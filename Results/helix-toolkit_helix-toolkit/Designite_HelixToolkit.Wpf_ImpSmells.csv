Implementation smell,Namespace,Class,File,Method,Description
Long Method,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The method has 113 lines of code.
Long Method,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,Read,The method has 138 lines of code.
Long Method,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddFace,The method has 102 lines of code.
Long Method,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The method has 118 lines of code.
Long Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The method has 101 lines of code.
Long Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The method has 168 lines of code.
Long Method,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,The method has 111 lines of code.
Complex Method,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,Rotate,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,Started,Cyclomatic complexity of the method is 16
Complex Method,HelixToolkit.Wpf,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomHandler.cs,ZoomByChangingCameraWidth,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,CategorizedColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\CategorizedColorAxis.cs,AddVisuals,Cyclomatic complexity of the method is 17
Complex Method,HelixToolkit.Wpf,RangeColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\RangeColorAxis.cs,AddVisuals,Cyclomatic complexity of the method is 14
Complex Method,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,OnApplyTemplate,Cyclomatic complexity of the method is 13
Complex Method,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,OnCameraChanged,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,OnItemsChanged,Cyclomatic complexity of the method is 13
Complex Method,HelixToolkit.Wpf,BitmapExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\BitmapExporter.cs,Export,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,Exporters,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\Exporters.cs,Create,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMesh,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,ToMeshGeometry3D,Cyclomatic complexity of the method is 14
Complex Method,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,Cyclomatic complexity of the method is 32
Complex Method,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,Cyclomatic complexity of the method is 32
Complex Method,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,Cyclomatic complexity of the method is 19
Complex Method,HelixToolkit.Wpf,DoubleKeyDictionary,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\DoubleKeyDictionary.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnManipulationDelta,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,Cyclomatic complexity of the method is 60
Complex Method,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMesh,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportLight,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMaterial,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,CohenSutherlandClipping,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\CohenSutherlandClipping.cs,ClipLine,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,Cyclomatic complexity of the method is 22
Complex Method,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,TextGroupVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextGroupVisual3D.cs,VisualChanged,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf,CuttingPlaneGroup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\CuttingPlaneGroup.cs,ApplyCuttingPlanesToModel,Cyclomatic complexity of the method is 20
Complex Method,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,FloorConstraint,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Physics\VerletIntegrator.cs,Satisfy,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,ModelImporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ModelImporter.cs,Load,Cyclomatic complexity of the method is 17
Complex Method,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,Read,Cyclomatic complexity of the method is 69
Complex Method,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddFace,Cyclomatic complexity of the method is 22
Complex Method,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,LoadMaterialLib,Cyclomatic complexity of the method is 59
Complex Method,HelixToolkit.Wpf,LwoReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\LwoReader.cs,Read,Cyclomatic complexity of the method is 23
Complex Method,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,TryReadAscii,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,TerrainModel,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\TerrainModel.cs,Load,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf,TerrainModel,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\TerrainModel.cs,ReadTerrainFile,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,GetCubefaceColor,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,StereoHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\StereoHelper.cs,CreateClone,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,Export,Cyclomatic complexity of the method is 25
Complex Method,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,ExportStereo,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,Read,Cyclomatic complexity of the method is 19
Complex Method,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadFaceSets,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadMaterial,Cyclomatic complexity of the method is 25
Complex Method,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,Cyclomatic complexity of the method is 22
Complex Method,HelixToolkit.Wpf,SortingVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\SortingVisual3D.cs,GetCameraDistance,Cyclomatic complexity of the method is 14
Complex Method,HelixToolkit.Wpf,SortingVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\SortingVisual3D.cs,SortChildren,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormalsAndTangents,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddLoftedGeometry,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,Cyclomatic complexity of the method is 27
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangles,Cyclomatic complexity of the method is 13
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,Cyclomatic complexity of the method is 14
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,Cyclomatic complexity of the method is 15
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Append,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ToMesh,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Simplify,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,Cyclomatic complexity of the method is 13
Complex Method,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,Cyclomatic complexity of the method is 17
Complex Method,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,CalculateDiagonals,Cyclomatic complexity of the method is 25
Complex Method,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourFacet,Cyclomatic complexity of the method is 30
Long Parameter List,HelixToolkit.Wpf,DrawingContextExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\DrawingContextExtensions.cs,DrawArc,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf,DrawingContextExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\DrawingContextExtensions.cs,DrawArc,The method has 9 parameters.
Long Parameter List,HelixToolkit.Wpf,DrawingContextExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\DrawingContextExtensions.cs,DrawArc,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf,Exporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\Exporter.cs,RenderBrush,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,Segment,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf,Billboard,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\Billboard.cs,Billboard,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteAshikhminMaterial,The method has 12 parameters.
Long Parameter List,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteDielectricMaterial,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteWhittedMaterial,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToString,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ConvertToString,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,RectangleAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\RectangleAdorner.cs,RectangleAdorner,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf,RectangleAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\RectangleAdorner.cs,RectangleAdorner,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf,PerspectiveCameraExtension,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\MarkupExtensions\PerspectiveCameraExtension.cs,PerspectiveCameraExtension,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,TextGroupVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextGroupVisual3D.cs,CreateTextMaterial,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,AnimateTo,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,LookAt,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,FitView,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,FitView,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,ZoomExtents,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,FitView,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,AddEdge,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,MaterialHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\MaterialHelper.cs,CreateMaterial,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,MaterialHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\MaterialHelper.cs,CreateMaterial,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,StereoHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\StereoHelper.cs,CalculateStereoBase,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,StereoHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\StereoHelper.cs,UpdateStereoCameras,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabel3D,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,Copy,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,FindNearest,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,SaveBitmap,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,SaveStereoBitmap,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,SaveBitmap,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,ExportKerkythea,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineX,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineY,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,InsideTriangle,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Snip,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddArrow,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBox,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBox,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCone,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCone,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndices,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 10 parameters.
Long Parameter List,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourFacet,The method has 7 parameters.
Long Identifier,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The length of the parameter containsHomogeneousCoordinates is 30.
Long Identifier,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The length of the parameter nextLineContainsVertexDimension is 31.
Long Identifier,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The length of the parameter nextLineContainsNumberOfVertices is 32.
Long Statement,HelixToolkit.Wpf,StlExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\StlExporter.cs,Export,The length of the statement  "	viewport.Children.Traverse<GeometryModel3D> ((m' t) => triangleIndicesCount += ((MeshGeometry3D)m.Geometry).TriangleIndices.Count); " is 131.
Long Statement,HelixToolkit.Wpf,StlExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\StlExporter.cs,Export,The length of the statement  "	visual.Traverse<GeometryModel3D> ((m' t) => triangleIndicesCount += ((MeshGeometry3D)m.Geometry).TriangleIndices.Count); " is 120.
Long Statement,HelixToolkit.Wpf,LineSegment,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\LineSegment.cs,AreLineSegmentsIntersecting,The length of the statement  "	if ((((a2.X - a1.X) * (b1.Y - a1.Y)) - ((b1.X - a1.X) * (a2.Y - a1.Y))) * (((a2.X - a1.X) * (b2.Y - a1.Y)) - ((b2.X - a1.X) * (a2.Y - a1.Y))) > 0) { " is 148.
Long Statement,HelixToolkit.Wpf,LineSegment,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\LineSegment.cs,AreLineSegmentsIntersecting,The length of the statement  "	if ((((b2.X - b1.X) * (a1.Y - b1.Y)) - ((a1.X - b1.X) * (b2.Y - b1.Y))) * (((b2.X - b1.X) * (a2.Y - b1.Y)) - ((a2.X - b1.X) * (b2.Y - b1.Y))) > 0) { " is 148.
Long Statement,HelixToolkit.Wpf,Triangle,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Triangle.cs,IsRectCompletelyInside,The length of the statement  "	return this.IsPointInside (rect.TopLeft) && this.IsPointInside (rect.TopRight) && this.IsPointInside (rect.BottomLeft) && this.IsPointInside (rect.BottomRight); " is 160.
Long Statement,HelixToolkit.Wpf,Triangle,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Triangle.cs,IsPointInside,The length of the statement  "	var s = (this.p1.Y * this.p3.X) - (this.p1.X * this.p3.Y) + ((this.p3.Y - this.p1.Y) * p.X) + ((this.p1.X - this.p3.X) * p.Y); " is 126.
Long Statement,HelixToolkit.Wpf,Triangle,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Triangle.cs,IsPointInside,The length of the statement  "	var t = (this.p1.X * this.p2.Y) - (this.p1.Y * this.p2.X) + ((this.p1.Y - this.p2.Y) * p.X) + ((this.p2.X - this.p1.X) * p.Y); " is 126.
Long Statement,HelixToolkit.Wpf,Triangle,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Triangle.cs,IsPointInside,The length of the statement  "	var a = (-this.p2.Y * this.p3.X) + (this.p1.Y * (this.p3.X - this.p2.X)) + (this.p1.X * (this.p2.Y - this.p3.Y)) + (this.p2.X * this.p3.Y); " is 139.
Long Statement,HelixToolkit.Wpf,Triangle,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Triangle.cs,IntersectsWith,The length of the statement  "	return LineSegment.AreLineSegmentsIntersecting (this.p1' this.p2' rect.BottomLeft' rect.BottomRight) || LineSegment.AreLineSegmentsIntersecting (this.p1' this.p2' rect.BottomLeft' rect.TopLeft) || LineSegment.AreLineSegmentsIntersecting (this.p1' this.p2' rect.TopLeft' rect.TopRight) || LineSegment.AreLineSegmentsIntersecting (this.p1' this.p2' rect.TopRight' rect.BottomRight) || LineSegment.AreLineSegmentsIntersecting (this.p2' this.p3' rect.BottomLeft' rect.BottomRight) || LineSegment.AreLineSegmentsIntersecting (this.p2' this.p3' rect.BottomLeft' rect.TopLeft) || LineSegment.AreLineSegmentsIntersecting (this.p2' this.p3' rect.TopLeft' rect.TopRight) || LineSegment.AreLineSegmentsIntersecting (this.p2' this.p3' rect.TopRight' rect.BottomRight) || LineSegment.AreLineSegmentsIntersecting (this.p3' this.p1' rect.BottomLeft' rect.BottomRight) || LineSegment.AreLineSegmentsIntersecting (this.p3' this.p1' rect.BottomLeft' rect.TopLeft) || LineSegment.AreLineSegmentsIntersecting (this.p3' this.p1' rect.TopLeft' rect.TopRight) || LineSegment.AreLineSegmentsIntersecting (this.p3' this.p1' rect.TopRight' rect.BottomRight); " is 1132.
Long Statement,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,OnInertiaStarting,The length of the statement  "	this.Controller.StartSpin (4 * delta * ((double)this.Controller.SpinReleaseTime / elapsedTime)' this.MouseDownPoint' this.rotationPoint3D); " is 139.
Long Statement,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,RotateAroundUpAndRight,The length of the statement  "	var delta2 = new Quaternion (Vector3D.CrossProduct (this.CameraUpDirection' this.CameraLookDirection)' dp.Y * this.RotationSensitivity); " is 136.
Long Statement,HelixToolkit.Wpf,CategorizedColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\CategorizedColorAxis.cs,AddVisuals,The length of the statement  "			p2 = new Point (this.ColorArea.Left - this.TickLength - this.TextMargin - tb.DesiredSize.Width' y1 - (tb.DesiredSize.Height / 2)); " is 130.
Long Statement,HelixToolkit.Wpf,ColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\ColorAxis.cs,AddVisuals,The length of the statement  "		this.ColorArea = new Rect (this.Padding.Left' this.Padding.Top' this.BarWidth' this.ActualHeight - this.Padding.Bottom - this.Padding.Top); " is 139.
Long Statement,HelixToolkit.Wpf,ColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\ColorAxis.cs,AddVisuals,The length of the statement  "		this.ColorArea = new Rect (this.ActualWidth - this.Padding.Right - this.BarWidth' this.Padding.Top' this.BarWidth' this.ActualHeight - this.Padding.Bottom - this.Padding.Top); " is 175.
Long Statement,HelixToolkit.Wpf,RangeColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\RangeColorAxis.cs,AddVisuals,The length of the statement  "			p2 = new Point (this.ColorArea.Left - this.TickLength - this.TextMargin - tb.DesiredSize.Width' y - (tb.DesiredSize.Height / 2)); " is 129.
Long Statement,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,UpdateCursorPosition,The length of the statement  "		this.CursorOnConstructionPlanePosition = this.ConstructionPlane.LineIntersection (this.CursorRay.Origin' this.CursorRay.Origin + this.CursorRay.Direction); " is 155.
Long Statement,HelixToolkit.Wpf,ColladaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ColladaExporter.cs,WriteColor,The length of the statement  "	writer.WriteElementString ("color"' string.Format (CultureInfo.InvariantCulture' "{0} {1} {2} {3}"' color.R / 255.0' color.G / 255.0' color.B / 255.0' color.A / 255.0)); " is 169.
Long Statement,HelixToolkit.Wpf,ColladaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ColladaExporter.cs,WriteMatrix,The length of the statement  "	string value = string.Format (CultureInfo.InvariantCulture' "{0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12} {13} {14} {15}"' m.M11' m.M12' m.M13' m.OffsetX' m.M21' m.M22' m.M23' m.OffsetY' m.M31' m.M32' m.M33' m.OffsetZ' 0' 0' 0' 1); " is 241.
Long Statement,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMesh,The length of the statement  "			writer.WriteLine (string.Format (CultureInfo.InvariantCulture' "v {0} {1} {2}"' p.X' this.SwitchYZ ? p.Z : p.Y' this.SwitchYZ ? -p.Y : p.Z)); " is 141.
Long Statement,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,The length of the statement  "		materialWriter.WriteLine (string.Format ("Ks {0}"' this.ToColorString (scb != null ? scb.Color : Color.FromScRgb (1.0f' 0.2f' 0.2f' 0.2f)))); " is 141.
Long Statement,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,The length of the statement  "		// "exponent" is the value for the specular exponent.  A high exponent results in a tight' concentrated highlight.  Ns values normally range from 0 to 1000. " is 156.
Long Statement,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ToColorString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "{0:F4} {1:F4} {2:F4}"' color.R / 255.0' color.G / 255.0' color.B / 255.0); " is 127.
Long Statement,HelixToolkit.Wpf,VrmlExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\VrmlExporter.cs,ExportModel,The length of the statement  "		writer.WriteLine (string.Format (CultureInfo.InvariantCulture' "{0} {1} {2}'"' mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2])); " is 166.
Long Statement,HelixToolkit.Wpf,PovRayExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\PovRayExporter.cs,ExportModel,The length of the statement  "		writer.WriteLine (string.Format (CultureInfo.InvariantCulture' "    {0} {1} {2}'"' mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2])); " is 170.
Long Statement,HelixToolkit.Wpf,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Polygon3D.cs,Flatten,The length of the statement  "	var right = Vector3D.CrossProduct (up' Math.Abs (up.X) > Math.Abs (up.Z) ? new Vector3D (0' 0' 1) : new Vector3D (1' 0' 0)); " is 124.
Long Statement,HelixToolkit.Wpf,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Polygon3D.cs,Flatten,The length of the statement  "	var m = new Matrix3D (backward.X' right.X' up.X' 0' backward.Y' right.Y' up.Y' 0' backward.Z' right.Z' up.Z' 0' 0' 0' 0' 1); " is 124.
Long Statement,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,FindMidpoint,The length of the statement  "	return new Point3D ((this.Vertices [v0].X + this.Vertices [v1].X) * 0.5' (this.Vertices [v0].Y + this.Vertices [v1].Y) * 0.5' (this.Vertices [v0].Z + this.Vertices [v1].Z) * 0.5); " is 179.
Long Statement,HelixToolkit.Wpf,BoundingSphere,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\BoundingSphere.cs,RayIntersection,The length of the statement  "	double c = (x1 * x1) + (y1 * y1) + (z1 * z1) + (cx * cx) + (cz * cz) + (cy * cy) - (2 * ((cy * y1) + (cz * z1) + (cx * x1))) - (r * r); " is 135.
Long Statement,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The length of the statement  "				Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance); " is 120.
Long Statement,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,Segment,The length of the statement  "		var pt = new Point3D (ax * t * t * t + bx * t * t + cx * t + dx' ay * t * t * t + by * t * t + cy * t + dy' az * t * t * t + bz * t * t + cz * t + dz); " is 151.
Long Statement,HelixToolkit.Wpf,DependencyPropertyEx,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\DependencyPropertyEx.cs,Register,The length of the statement  "	return DependencyProperty.Register (name' typeof(TProperty)' typeof(TOwner)' new FrameworkPropertyMetadata (defaultValue)); " is 123.
Long Statement,HelixToolkit.Wpf,DependencyPropertyEx,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\DependencyPropertyEx.cs,Register,The length of the statement  "	return DependencyProperty.Register (name' typeof(TProperty)' typeof(TOwner)' new FrameworkPropertyMetadata (defaultValue' (s' e) => callback ((TOwner)s' e))); " is 158.
Long Statement,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,GetPositions,The length of the statement  "			screenPoint = new Point4D (viewPoint.X' viewPoint.Y' viewPoint.Z + bb.WorldDepthOffset' viewPoint.W) * this.projectionToScreen; " is 127.
Long Statement,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,GetPositions,The length of the statement  "		var p = new Point4D (spx + ((bb.Left + offset.X) * spw)' spy + ((bb.Bottom + offset.Y) * spw)' spz' spw) * this.screenToVisual; " is 127.
Long Statement,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,GetPositions,The length of the statement  "		p = new Point4D (spx + ((bb.Right + offset.X) * spw)' spy + ((bb.Bottom + offset.Y) * spw)' spz' spw) * this.screenToVisual; " is 124.
Long Statement,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,GetPositions,The length of the statement  "		p = new Point4D (spx + ((bb.Right + offset.X) * spw)' spy + ((bb.Top + offset.Y) * spw)' spz' spw) * this.screenToVisual; " is 121.
Long Statement,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,GetPositions,The length of the statement  "		p = new Point4D (spx + ((bb.Left + offset.X) * spw)' spy + ((bb.Top + offset.Y) * spw)' spz' spw) * this.screenToVisual; " is 120.
Long Statement,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,GetPinPositions,The length of the statement  "			screenPoint = new Point4D (viewPoint.X' viewPoint.Y' viewPoint.Z + bb.WorldDepthOffset' viewPoint.W) * this.projectionToScreen; " is 127.
Long Statement,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The length of the statement  "					this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]); " is 165.
Long Statement,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnManipulationDelta,The length of the statement  "	//// System.Diagnostics.Debug.WriteLine("OnManipulationDelta: T={0}' S={1}' R={2}' O={3}"' e.DeltaManipulation.Translation' e.DeltaManipulation.Scale' e.DeltaManipulation.Rotation' e.ManipulationOrigin); " is 203.
Long Statement,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnManipulationDelta,The length of the statement  "	//// System.Diagnostics.Debug.WriteLine(n + " Delta:" + e.DeltaManipulation.Translation + " Origin:" + e.ManipulationOrigin + " pos:" + position); " is 146.
Long Statement,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnManipulationDelta,The length of the statement  "		var zoomAroundPoint = this.zoomHandler.UnProject (e.ManipulationOrigin' this.zoomHandler.Origin' this.CameraLookDirection); " is 123.
Long Statement,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnTimeStep,The length of the statement  "		this.rotateHandler.Rotate (this.spinningPosition' this.spinningPosition + (this.spinningSpeed * time)' this.spinningPoint3D); " is 125.
Long Statement,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnTimeStep,The length of the statement  "		this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + (this.rotationSpeed * time)' this.rotationPoint3D); " is 125.
Long Statement,HelixToolkit.Wpf,StereoControl,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\Stereo\StereoControl.cs,UpdateCameras,The length of the statement  "	StereoHelper.UpdateStereoCameras (this.Camera' this.LeftCamera' this.RightCamera' this.StereoBase' this.CrossViewing' this.CopyUpVector' this.CopyDirectionVector); " is 163.
Long Statement,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteThreadedRaytracer,The length of the statement  "	writer.WriteStartObject ("./Ray Tracers/Threaded Ray Tracer"' "Threaded Ray Tracer"' "Threaded Ray Tracer"' "Ray Tracer"); " is 122.
Long Statement,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportHeader,The length of the statement  "	writer.WriteStartObject ("./Image Handlers/Free Image Support"' "Free Image Support"' "Free Image Support"' "Image Handler"); " is 125.
Long Statement,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportHeader,The length of the statement  "	writer.WriteStartObject ("./Direct Light Estimators/Refraction Enhanced"' "Refraction Enhanced"' "Refraction Enhanced"' "Direct Light Estimator"); " is 146.
Long Statement,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportHeader,The length of the statement  "	writer.WriteStartObject ("./Environments/Octree Environment"' "Octree Environment"' "Octree Environment"' "Environment"); " is 121.
Long Statement,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ToKerkytheaString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "{0:0.######} {1:0.######} {2:0.######}"' ValueOrDefault (point.X' 1)' ValueOrDefault (point.Y' 0)' ValueOrDefault (point.Z' 0)); " is 181.
Long Statement,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ToKerkytheaString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "{0:0.######} {1:0.######} {2:0.######}"' ValueOrDefault (vector.X' 1)' ValueOrDefault (vector.Y' 0)' ValueOrDefault (vector.Z' 0)); " is 184.
Long Statement,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ToKerkytheaString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "{0:0.######} {1:0.######} {2:0.######}"' c.R / 255.0' c.G / 255.0' c.B / 255.0); " is 133.
Long Statement,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMaterial,The length of the statement  "		// color = Color.FromArgb((byte)(color.A * factor)' (byte)(color.R * factor)' (byte)(color.G * factor)' (byte)(color.B * factor)); " is 130.
Long Statement,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMaterial,The length of the statement  "		this.WriteWhittedMaterial (writer' string.Format ("#{0}"' weights.Count)' null' null' color' null' s.SpecularPower * 0.5); " is 122.
Long Statement,HelixToolkit.Wpf,Ray3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Ray3D.cs,GetNearest,The length of the statement  "	return this.origin + (Vector3D.DotProduct (p3 - this.origin' this.direction) / this.direction.LengthSquared * this.direction); " is 126.
Long Statement,HelixToolkit.Wpf,RectangleAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\RectangleAdorner.cs,OnRender,The length of the statement  "	var rect = new Rect ((int)this.Rectangle.Left + halfPenWidth' (int)this.Rectangle.Top + halfPenWidth' (int)this.Rectangle.Width' (int)this.Rectangle.Height); " is 157.
Long Statement,HelixToolkit.Wpf,RectangleSelectionCommand,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\SelectionCommands\RectangleSelectionCommand.cs,Completed,The length of the statement  "	var selectedModels = this.Viewport.FindHits (this.selectionRect' this.SelectionHitMode).Select (hit => hit.Model).ToList (); " is 124.
Long Statement,HelixToolkit.Wpf,RectangleSelectionCommand,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\SelectionCommands\RectangleSelectionCommand.cs,ShowRectangle,The length of the statement  "	this.rectangleAdorner = new RectangleAdorner (this.Viewport' this.selectionRect' Colors.LightGray' Colors.Black' 1' 1' 0' DashStyles.Dash); " is 139.
Long Statement,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The length of the statement  "		var a = accelerationSpreading > 0 ? CreateRandomVector (accelerationDirection' accelerationSpreading) : accelerationDirection; " is 126.
Long Statement,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The length of the statement  "	var sortedParticles = this.particles.OrderBy (p => -Vector3D.DotProduct (p.Position - cameraPosition' this.camera.LookDirection)); " is 130.
Long Statement,HelixToolkit.Wpf,Manipulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Manipulators\Manipulator.cs,PositionChanged,The length of the statement  "	this.Transform = new TranslateTransform3D (this.Position.X + this.Offset.X' this.Position.Y + this.Offset.Y' this.Position.Z + this.Offset.Z); " is 142.
Long Statement,HelixToolkit.Wpf,Teapot,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\TestModels\Teapot.cs,Tessellate,The length of the statement  "	var rd = Application.LoadComponent (new Uri ("HelixToolkit.Wpf;component/Resources/TeapotGeometry.xaml"' UriKind.Relative)) as ResourceDictionary; " is 146.
Long Statement,HelixToolkit.Wpf,Teapot,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\TestModels\Teapot.cs,OnTransformChanged,The length of the statement  "	this.Transform = new MatrixTransform3D (new Matrix3D (right.X' right.Y' right.Z' 0' up.X' up.Y' up.Z' 0' back.X' back.Y' back.Z' 0' this.Position.X' this.Position.Y' this.Position.Z' 1)); " is 187.
Long Statement,HelixToolkit.Wpf,BillboardVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\ScreenSpaceVisuals\BillboardVisual3D.cs,UpdateGeometry,The length of the statement  "	var bb = new Billboard (this.Position' this.Width' this.Height' this.HorizontalAlignment' this.VerticalAlignment' this.DepthOffset); " is 132.
Long Statement,HelixToolkit.Wpf,BillboardTextGroupVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\BillboardTextGroupVisual3D.cs,VisualChanged,The length of the statement  "		var material = TextGroupVisual3D.CreateTextMaterial (items' this.CreateElement' this.Background' out elementMap' out elementPositions); " is 135.
Long Statement,HelixToolkit.Wpf,BillboardTextGroupVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\BillboardTextGroupVisual3D.cs,VisualChanged,The length of the statement  "			billboards.Add (new Billboard (item.Position' element.ActualWidth' element.ActualHeight' item.HorizontalAlignment' item.VerticalAlignment' item.DepthOffset' item.WorldDepthOffset)); " is 181.
Long Statement,HelixToolkit.Wpf,BillboardTextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\BillboardTextVisual3D.cs,VisualChanged,The length of the statement  "	var rtb = new RenderTargetBitmap ((int)element.ActualWidth + 1' (int)element.ActualHeight + 1' 96' 96' PixelFormats.Pbgra32); " is 125.
Long Statement,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,AnimateTo,The length of the statement  "		var a2 = new Vector3DAnimation (fromDirection' newDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) { " is 120.
Long Statement,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,AnimateTo,The length of the statement  "		var a3 = new Vector3DAnimation (fromUpDirection' newUpDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) { " is 124.
Long Statement,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,GetInfo,The length of the statement  "		sb.AppendLine (string.Format (CultureInfo.InvariantCulture' "LookDirection:\t{0:0.000}'{1:0.000}'{2:0.000}"' projectionCamera.LookDirection.X' projectionCamera.LookDirection.Y' projectionCamera.LookDirection.Z)); " is 212.
Long Statement,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,GetInfo,The length of the statement  "		sb.AppendLine (string.Format (CultureInfo.InvariantCulture' "UpDirection:\t{0:0.000}'{1:0.000}'{2:0.000}"' projectionCamera.UpDirection.X' projectionCamera.UpDirection.Y' projectionCamera.UpDirection.Z)); " is 204.
Long Statement,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,GetInfo,The length of the statement  "		sb.AppendLine (string.Format (CultureInfo.InvariantCulture' "Position:\t\t{0:0.000}'{1:0.000}'{2:0.000}"' projectionCamera.Position.X' projectionCamera.Position.Y' projectionCamera.Position.Z)); " is 194.
Long Statement,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,GetInfo,The length of the statement  "		sb.AppendLine (string.Format (CultureInfo.InvariantCulture' "Target:\t\t{0:0.000}'{1:0.000}'{2:0.000}"' target.X' target.Y' target.Z)); " is 135.
Long Statement,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,GetInfo,The length of the statement  "		sb.AppendLine (string.Format (CultureInfo.InvariantCulture' "NearPlaneDist:\t{0}"' projectionCamera.NearPlaneDistance)); " is 120.
Long Statement,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,GetViewMatrix,The length of the statement  "		return new Matrix3D (xaxis.X' yaxis.X' zaxis.X' 0' xaxis.Y' yaxis.Y' zaxis.Y' 0' xaxis.Z' yaxis.Z' zaxis.Z' 0' -Vector3D.DotProduct (xaxis' pos)' -Vector3D.DotProduct (yaxis' pos)' -Vector3D.DotProduct (zaxis' pos)' 1); " is 219.
Long Statement,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,ZoomExtents,The length of the statement  "		FitView (camera' viewport' center' radius' perspectiveCamera.LookDirection' perspectiveCamera.UpDirection' animationTime); " is 122.
Long Statement,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,ZoomToRectangle,The length of the statement  "	var centerRay = Viewport3DHelper.Point2DtoRay3D (viewport' new Point ((zoomRectangle.Left + zoomRectangle.Right) * 0.5' (zoomRectangle.Top + zoomRectangle.Bottom) * 0.5)); " is 171.
Long Statement,HelixToolkit.Wpf,VerletIntegrator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Physics\VerletIntegrator.cs,Integrate,The length of the statement  "			this.Positions [i] += (this.Positions [i] - this.Positions0 [i]) * dt / this.dtprev * this.Damping + this.Accelerations [i] * dt * dt; " is 134.
Long Statement,HelixToolkit.Wpf,XamlHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\XamlHelper.cs,GetXaml,The length of the statement  "		xaml = xaml.Replace (string.Format ("<Viewport3D Height=\"{0}\" Width=\"{1}\" "' view.ActualHeight' view.ActualWidth)' "<Viewport3D "); " is 135.
Long Statement,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,SetSmoothingGroup,The length of the statement  "			throw new FileFormatException (string.Format ("Invalid smoothing group ({0}) at line {1}."' values' this.currentLineNo)); " is 121.
Long Statement,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddFace,The length of the statement  "			throw new FileFormatException (string.Format ("Invalid texture coordinate index ({0}) on line {1}."' vti' this.currentLineNo)); " is 127.
Long Statement,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,TryReadAscii,The length of the statement  "		if (line.Length == 0 || line.StartsWith ("\0") || line.StartsWith ("#") || line.StartsWith ("!") || line.StartsWith ("$")) { " is 124.
Long Statement,HelixToolkit.Wpf,TerrainVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\TerrainVisual3D.cs,UpdateModel,The length of the statement  "	// r.Texture = new MapTexture(@"D:\tmp\CraterLake.png") { Left = r.Left' Right = r.Right' Top = r.Top' Bottom = r.Bottom }; " is 123.
Long Statement,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The length of the statement  "		var rtb = new RenderTargetBitmap ((int)element.ActualWidth + 1' (int)element.ActualHeight + 1' 96' 96' PixelFormats.Pbgra32); " is 125.
Long Statement,HelixToolkit.Wpf,ElementSortingHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ElementSortingHelper.cs,AlphaSort,The length of the statement  "	var sortedList = models.OrderBy (model => Point3D.Subtract (cameraPosition' worldTransform.Transform (model.Bounds.Location)).Length); " is 134.
Long Statement,HelixToolkit.Wpf,TargetSymbolAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\TargetSymbolAdorner.cs,OnRender,The length of the statement  "	dc.DrawLine (lightPen' new Point (this.Position.X' this.Position.Y - r2)' new Point (this.Position.X' this.Position.Y - r3)); " is 125.
Long Statement,HelixToolkit.Wpf,TargetSymbolAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\TargetSymbolAdorner.cs,OnRender,The length of the statement  "	dc.DrawLine (lightPen' new Point (this.Position.X' this.Position.Y + r2)' new Point (this.Position.X' this.Position.Y + r3)); " is 125.
Long Statement,HelixToolkit.Wpf,TargetSymbolAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\TargetSymbolAdorner.cs,OnRender,The length of the statement  "	dc.DrawLine (lightPen' new Point (this.Position.X - r2' this.Position.Y)' new Point (this.Position.X - r3' this.Position.Y)); " is 125.
Long Statement,HelixToolkit.Wpf,TargetSymbolAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\TargetSymbolAdorner.cs,OnRender,The length of the statement  "	dc.DrawLine (lightPen' new Point (this.Position.X + r2' this.Position.Y)' new Point (this.Position.X + r3' this.Position.Y)); " is 125.
Long Statement,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,FindHits,The length of the statement  "			var triangle = new Triangle (point2Ds [geometry.TriangleIndices [i * 3]]' point2Ds [geometry.TriangleIndices [(i * 3) + 1]]' point2Ds [geometry.TriangleIndices [(i * 3) + 2]]); " is 176.
Long Statement,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,FindHits,The length of the statement  "				status = status || triangle.IsCompletelyInside (rectangle) || triangle.IntersectsWith (rectangle) || triangle.IsRectCompletelyInside (rectangle); " is 145.
Long Statement,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetCameraTransform,The length of the statement  "	return viewport3DVisual.Camera.GetTotalTransform (viewport3DVisual.Viewport.Size.Width / viewport3DVisual.Viewport.Size.Height); " is 128.
Long Statement,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetViewportTransform,The length of the statement  "	return new Matrix3D (viewport3DVisual.Viewport.Width / 2' 0' 0' 0' 0' -viewport3DVisual.Viewport.Height / 2' 0' 0' 0' 0' 1' 0' viewport3DVisual.Viewport.X + (viewport3DVisual.Viewport.Width / 2)' viewport3DVisual.Viewport.Y + (viewport3DVisual.Viewport.Height / 2)' 0' 1); " is 272.
Long Statement,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetViewportTransform,The length of the statement  "	return new Matrix3D (viewport.ActualWidth / 2' 0' 0' 0' 0' -viewport.ActualHeight / 2' 0' 0' 0' 0' 1' 0' viewport.ActualWidth / 2' viewport.ActualHeight / 2' 0' 1); " is 164.
Long Statement,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The length of the statement  "	var target = new WriteableBitmap ((int)view.ActualWidth * m' (int)view.ActualHeight * m' 96' 96' PixelFormats.Pbgra32' null); " is 125.
Long Statement,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The length of the statement  "			var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32); " is 121.
Long Statement,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetNormalHit,The length of the statement  "	return (rayHit.MeshHit.Normals [rayHit.VertexIndex1] * rayHit.VertexWeight1) + (rayHit.MeshHit.Normals [rayHit.VertexIndex2] * rayHit.VertexWeight2) + (rayHit.MeshHit.Normals [rayHit.VertexIndex3] * rayHit.VertexWeight3); " is 221.
Long Statement,HelixToolkit.Wpf,VectorFieldVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\VectorFieldVisual3D.cs,CreateBodyTransform,The length of the statement  "	var mat = new Matrix3D (x.X' x.Y' x.Z' 0' y.X' y.Y' y.Z' 0' z.X * length' z.Y * length' z.Z * length' 0' p.X' p.Y' p.Z' 1); " is 123.
Long Statement,HelixToolkit.Wpf,SortingVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\SortingVisual3D.cs,GetCameraDistance,The length of the statement  "		d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X + bounds.SizeX' bounds.Y + bounds.SizeY' bounds.Z + bounds.SizeZ))); " is 129.
Long Statement,HelixToolkit.Wpf,SortingVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\SortingVisual3D.cs,SortChildren,The length of the statement  "	var sortedTransparentChildren = transparentChildren.OrderBy (item => -this.GetCameraDistance (item' cameraPos' transform)).ToList (); " is 133.
Long Statement,HelixToolkit.Wpf,QuadVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\QuadVisual3D.cs,Tessellate,The length of the statement  "	builder.AddQuad (this.Point1' this.Point2' this.Point3' this.Point4' new Point (0' 1)' new Point (1' 1)' new Point (1' 0)' new Point (0' 0)); " is 141.
Long Statement,HelixToolkit.Wpf,ExtrudedVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ExtrudedVisual3D.cs,Tessellate,The length of the statement  "	builder.AddTube (this.Path' this.Angles' this.TextureCoordinates' this.Diameters' this.Section' sectionXAxis' this.IsPathClosed' this.IsSectionClosed); " is 151.
Long Statement,HelixToolkit.Wpf,TubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\TubeVisual3D.cs,Tessellate,The length of the statement  "	builder.AddTube (this.Path' this.Angles' this.TextureCoordinates' this.Diameters' this.Section' sectionXAxis' this.IsPathClosed' this.IsSectionClosed' this.AddCaps' this.AddCaps); " is 179.
Long Statement,HelixToolkit.Wpf,CubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\CubeVisual3D.cs,Tessellate,The length of the statement  "	b.AddCubeFace (this.Center' new Vector3D (-1' 0' 0)' new Vector3D (0' 0' 1)' this.SideLength' this.SideLength' this.SideLength); " is 128.
Long Statement,HelixToolkit.Wpf,CubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\CubeVisual3D.cs,Tessellate,The length of the statement  "	b.AddCubeFace (this.Center' new Vector3D (1' 0' 0)' new Vector3D (0' 0' -1)' this.SideLength' this.SideLength' this.SideLength); " is 128.
Long Statement,HelixToolkit.Wpf,CubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\CubeVisual3D.cs,Tessellate,The length of the statement  "	b.AddCubeFace (this.Center' new Vector3D (0' -1' 0)' new Vector3D (0' 0' 1)' this.SideLength' this.SideLength' this.SideLength); " is 128.
Long Statement,HelixToolkit.Wpf,CubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\CubeVisual3D.cs,Tessellate,The length of the statement  "	b.AddCubeFace (this.Center' new Vector3D (0' 1' 0)' new Vector3D (0' 0' -1)' this.SideLength' this.SideLength' this.SideLength); " is 128.
Long Statement,HelixToolkit.Wpf,CubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\CubeVisual3D.cs,Tessellate,The length of the statement  "	b.AddCubeFace (this.Center' new Vector3D (0' 0' 1)' new Vector3D (0' -1' 0)' this.SideLength' this.SideLength' this.SideLength); " is 128.
Long Statement,HelixToolkit.Wpf,CubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\CubeVisual3D.cs,Tessellate,The length of the statement  "	b.AddCubeFace (this.Center' new Vector3D (0' 0' -1)' new Vector3D (0' 1' 0)' this.SideLength' this.SideLength' this.SideLength); " is 128.
Long Statement,HelixToolkit.Wpf,MeshElement3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\MeshElement3D.cs,OnGeometryChanged,The length of the statement  "		// flag the geometry as changed' the geometry will be updated when the <see cref="M:System.ComponentModel.IEditableObject.EndEdit"/> is called. " is 143.
Long Statement,HelixToolkit.Wpf,TruncatedConeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\TruncatedConeVisual3D.cs,Tessellate,The length of the statement  "	builder.AddCone (this.Origin' this.Normal' this.BaseRadius' this.TopRadius' this.Height' this.BaseCap' this.TopCap' this.ThetaDiv); " is 131.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,GetCircle,The length of the statement  "	if ((!closed && !CircleCache.Value.TryGetValue (thetaDiv' out circle)) || (closed && !ClosedCircleCache.Value.TryGetValue (thetaDiv' out circle))) { " is 148.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The length of the statement  "	ComputeTangents (meshGeometry.Positions' meshGeometry.Normals' meshGeometry.TextureCoordinates' meshGeometry.TriangleIndices' out t1' out t2); " is 142.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "	var p1 = new Point3D ((DoubleOrSingle)boundingBox.X' (DoubleOrSingle)boundingBox.Y + (DoubleOrSingle)boundingBox.SizeY' (DoubleOrSingle)boundingBox.Z); " is 151.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "	var p2 = new Point3D ((DoubleOrSingle)boundingBox.X + (DoubleOrSingle)boundingBox.SizeX' (DoubleOrSingle)boundingBox.Y + (DoubleOrSingle)boundingBox.SizeY' (DoubleOrSingle)boundingBox.Z); " is 187.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "	var p3 = new Point3D ((DoubleOrSingle)boundingBox.X + (DoubleOrSingle)boundingBox.SizeX' (DoubleOrSingle)boundingBox.Y' (DoubleOrSingle)boundingBox.Z); " is 151.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "	var p4 = new Point3D ((DoubleOrSingle)boundingBox.X' (DoubleOrSingle)boundingBox.Y' (DoubleOrSingle)boundingBox.Z + (DoubleOrSingle)boundingBox.SizeZ); " is 151.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "	var p5 = new Point3D ((DoubleOrSingle)boundingBox.X' (DoubleOrSingle)boundingBox.Y + (DoubleOrSingle)boundingBox.SizeY' (DoubleOrSingle)boundingBox.Z + (DoubleOrSingle)boundingBox.SizeZ); " is 187.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "	var p6 = new Point3D ((DoubleOrSingle)boundingBox.X + (DoubleOrSingle)boundingBox.SizeX' (DoubleOrSingle)boundingBox.Y + (DoubleOrSingle)boundingBox.SizeY' (DoubleOrSingle)boundingBox.Z + (DoubleOrSingle)boundingBox.SizeZ); " is 223.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "	var p7 = new Point3D ((DoubleOrSingle)boundingBox.X + (DoubleOrSingle)boundingBox.SizeX' (DoubleOrSingle)boundingBox.Y' (DoubleOrSingle)boundingBox.Z + (DoubleOrSingle)boundingBox.SizeZ); " is 187.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBox,The length of the statement  "	this.AddBox (new Point3D ((DoubleOrSingle)(rectangle.X + (rectangle.SizeX * 0.5f))' (DoubleOrSingle)(rectangle.Y + (rectangle.SizeY * 0.5f))' (DoubleOrSingle)(rectangle.Z + (rectangle.SizeZ * 0.5f)))' (DoubleOrSingle)rectangle.SizeX' (DoubleOrSingle)rectangle.SizeY' (DoubleOrSingle)rectangle.SizeZ' faces); " is 307.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "	var radiusSphere = 0.25f * (DoubleOrSingle)Math.Sqrt (3) * (1 + (DoubleOrSingle)Math.Sqrt (5)) * (DoubleOrSingle)sideLength; " is 124.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "	var radiusFace = 0.1f * (DoubleOrSingle)Math.Sqrt (50 + 10 * (DoubleOrSingle)Math.Sqrt (5)) * (DoubleOrSingle)sideLength; " is 121.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "		var newPoint = new Point3D (radiusSphere * (DoubleOrSingle)Math.Cos (gamma)' 0' radiusSphere * (DoubleOrSingle)Math.Sin (gamma)); " is 129.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "		var newPoint = new Point3D (radiusSphere * (DoubleOrSingle)Math.Cos (gamma)' 0' radiusSphere * (DoubleOrSingle)Math.Sin (gamma)); " is 129.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "			var u = (DoubleOrSingle)Math.Atan2 (SharedFunctions.DotProduct (ref planeCTP' ref forward)' SharedFunctions.DotProduct (ref planeCTP' ref right)); " is 146.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The length of the statement  "			var p = new Point3D (center.X + (DoubleOrSingle)(radiusx * x)' center.Y + (DoubleOrSingle)(radiusy * y)' center.Z + (DoubleOrSingle)(radiusz * z)); " is 147.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshNormals,The length of the statement  "			var u = Point3D.Subtract (this.positions [index0 + (i1 * columns) + j0]' this.positions [index0 + (i0 * columns) + j0]); " is 120.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshNormals,The length of the statement  "			var v = Point3D.Subtract (this.positions [index0 + (i0 * columns) + j1]' this.positions [index0 + (i0 * columns) + j0]); " is 120.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The length of the statement  "			this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius)); " is 272.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The length of the statement  "				this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues [j])); " is 166.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The length of the statement  "				this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues [j + 1])); " is 176.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The length of the statement  "				this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues [j])); " is 166.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "			var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25)))); " is 133.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "		crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList (); " is 191.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList (); " is 251.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "				var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList (); " is 251.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "				var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0); " is 180.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The length of the statement  "				this.textureCoordinates.Add (values != null ? new Point ((DoubleOrSingle)values [i % valuesCount]' (DoubleOrSingle)j / (sectionLength - 1)) : new Point ()); " is 156.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The length of the statement  "				this.textureCoordinates.Add (values != null ? new Point ((DoubleOrSingle)values [i % valuesCount]' (DoubleOrSingle)j / (sectionLength - 1)) : new Point ()); " is 156.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Append,The length of the statement  "	this.Append (mesh.Positions' mesh.TriangleIndices' this.normals != null ? mesh.Normals : null' this.textureCoordinates != null ? mesh.TextureCoordinates : null); " is 161.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Scale,The length of the statement  "		this.Positions [i] = new Point3D (this.Positions [i].X * (DoubleOrSingle)scaleX' this.Positions [i].Y * (DoubleOrSingle)scaleY' this.Positions [i].Z * (DoubleOrSingle)scaleZ); " is 175.
Long Statement,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Scale,The length of the statement  "			this.Normals [i] = new Vector3D (this.Normals [i].X * (DoubleOrSingle)scaleX' this.Normals [i].Y * (DoubleOrSingle)scaleY' this.Normals [i].Z * (DoubleOrSingle)scaleZ); " is 168.
Long Statement,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The length of the statement  "	            return new MeshGeometry3D { Positions = p' TriangleIndices = new SharpDX.Core.IntCollection(ti)' Normals = n' TextureCoordinates = tc };" is 136.
Long Statement,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The length of the statement  "	if (mesh.TextureCoordinates != null && mesh.TextureCoordinates.Count != 0 && mesh.TextureCoordinates.Count != mesh.Positions.Count) { " is 133.
Long Statement,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The length of the statement  "		contourHelper.ContourFacet (index0' index1' index2' out positions' out normals' out textureCoordinates' out triangleIndices); " is 125.
Long Statement,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The length of the statement  "		contourHelper.ContourFacet (mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2]' out positions' out normals' out textureCoordinates' out triangleIndices); " is 187.
Long Statement,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,The length of the statement  "	RemoveIsolatedVertices (mesh.Positions' mesh.TriangleIndices' mesh.TextureCoordinates' mesh.Normals' out vertNew' out triNew' out textureNew' out normalNew); " is 157.
Long Statement,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,The length of the statement  "		//if (!(leftChain.Contains(top) && leftChain.Contains(newPoint) || rightChain.Contains(top) && rightChain.Contains(newPoint))) " is 126.
Long Statement,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,SplitIntoPolygons,The length of the statement  "	foreach (var edge in poly.Points.Select (p => p.EdgeTwo).Union (diagonals.Select (d => new PolygonEdge (poly.Points [d.Item1]' poly.Points [d.Item2]))).Union (diagonals.Select (d => new PolygonEdge (poly.Points [d.Item2]' poly.Points [d.Item1])))) { " is 249.
Long Statement,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,CreateNewPosition,The length of the statement  "	return new Point3D (CalculatePoint (firstPoint.X' secondPoint.X' firstSide' secondSide)' CalculatePoint (firstPoint.Y' secondPoint.Y' firstSide' secondSide)' CalculatePoint (firstPoint.Z' secondPoint.Z' firstSide' secondSide)); " is 227.
Long Statement,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,CreateNewNormal,The length of the statement  "	return new Vector3D (CalculatePoint (firstPoint.X' secondPoint.X' firstSide' secondSide)' CalculatePoint (firstPoint.Y' secondPoint.Y' firstSide' secondSide)' CalculatePoint (firstPoint.Z' secondPoint.Z' firstSide' secondSide)); " is 228.
Long Statement,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,CreateNewTexture,The length of the statement  "	return new Point (CalculatePoint (firstTexture.X' secondTexture.X' firstSide' secondSide)' CalculatePoint (firstTexture.Y' secondTexture.Y' firstSide' secondSide)); " is 164.
Complex Conditional,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The conditional expression  "(v < vTmp && this.GetEdgeVertice (v' vTmp' 0) != 0) || (v > vTmp && this.GetEdgeVertice (vTmp' v' 0) != 0)"  is complex.
Complex Conditional,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The conditional expression  "(vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)"  is complex.
Complex Conditional,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,TryReadAscii,The conditional expression  "line.Length == 0 || line.StartsWith ("\0") || line.StartsWith ("#") || line.StartsWith ("!") || line.StartsWith ("$")"  is complex.
Complex Conditional,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,GetCircle,The conditional expression  "(!closed && !CircleCache.Value.TryGetValue (thetaDiv' out circle)) || (closed && !ClosedCircleCache.Value.TryGetValue (thetaDiv' out circle))"  is complex.
Complex Conditional,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The conditional expression  "selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1))"  is complex.
Virtual Method Call from Constructor,HelixToolkit.Wpf,CoordinateSystemVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\CoordinateSystemVisual3D.cs,CoordinateSystemVisual3D,The constructor "CoordinateSystemVisual3D" calls a virtual method "OnGeometryChanged".
Empty Catch Block,HelixToolkit.Wpf,EnumToBooleanConverter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Converters\EnumToBooleanConverter.cs,ConvertBack,The method has an empty catch block.
Empty Catch Block,HelixToolkit.Wpf,EnumToBooleanConverter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Converters\EnumToBooleanConverter.cs,ConvertBack,The method has an empty catch block.
Magic Number,HelixToolkit.Wpf,InterlacedView3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\Stereo\InterlacedView3D.xaml.cs,UpdateEvenLeft,The following statement contains a magic number: if (this.IsLoaded && this.IsVisible) {  	int y = (int)this.PointToScreen (default(Point)).Y;  	this.EvenLeft = y % 2 == 0;  }  
Magic Number,HelixToolkit.Wpf,InterlacedView3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\Stereo\InterlacedView3D.xaml.cs,UpdateEvenLeft,The following statement contains a magic number: this.EvenLeft = y % 2 == 0;  
Magic Number,HelixToolkit.Wpf,StlExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\StlExporter.cs,Export,The following statement contains a magic number: ExportHeader (writer' triangleIndicesCount / 3);  
Magic Number,HelixToolkit.Wpf,StlExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\StlExporter.cs,Export,The following statement contains a magic number: ExportHeader (writer' triangleIndicesCount / 3);  
Magic Number,HelixToolkit.Wpf,StlExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\StlExporter.cs,Export,The following statement contains a magic number: ExportHeader (writer' triangleIndicesCount / 3);  
Magic Number,HelixToolkit.Wpf,StlExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\StlExporter.cs,ExportHeader,The following statement contains a magic number: writer.Write (new byte[80]);  
Magic Number,HelixToolkit.Wpf,StlExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\StlExporter.cs,ExportModel,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	int i0 = mesh.TriangleIndices [i + 0];  	int i1 = mesh.TriangleIndices [i + 1];  	int i2 = mesh.TriangleIndices [i + 2];  	// Normal  	var faceNormal = normalTransform.Transform (normals [i0] + normals [i1] + normals [i2]);  	faceNormal.Normalize ();  	WriteVector (writer' faceNormal);  	// Vertices  	WriteVertex (writer' t.Transform (mesh.Positions [i0]));  	WriteVertex (writer' t.Transform (mesh.Positions [i1]));  	WriteVertex (writer' t.Transform (mesh.Positions [i2]));  	// Attributes  	const ushort attribute = 0;  	writer.Write (attribute);  }  
Magic Number,HelixToolkit.Wpf,StlExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\StlExporter.cs,ExportModel,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	int i0 = mesh.TriangleIndices [i + 0];  	int i1 = mesh.TriangleIndices [i + 1];  	int i2 = mesh.TriangleIndices [i + 2];  	// Normal  	var faceNormal = normalTransform.Transform (normals [i0] + normals [i1] + normals [i2]);  	faceNormal.Normalize ();  	WriteVector (writer' faceNormal);  	// Vertices  	WriteVertex (writer' t.Transform (mesh.Positions [i0]));  	WriteVertex (writer' t.Transform (mesh.Positions [i1]));  	WriteVertex (writer' t.Transform (mesh.Positions [i2]));  	// Attributes  	const ushort attribute = 0;  	writer.Write (attribute);  }  
Magic Number,HelixToolkit.Wpf,StlExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\StlExporter.cs,ExportModel,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,Rotate,The following statement contains a magic number: if (Math.Abs (this.Controller.CameraUpDirection.Length - 1) > 1e-8) {  	this.Controller.CameraUpDirection.Normalize ();  }  
Magic Number,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,RotateTurnball,The following statement contains a magic number: if (this.CameraMode != CameraMode.Inspect) {  	d = 0.2;  }  
Magic Number,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,RotateTurnball,The following statement contains a magic number: d = 0.2;  
Magic Number,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,RotateTurnball,The following statement contains a magic number: if ((newUpDirection - modUpDir).Length > 1e-8) {  	newUpDirection = modUpDir;  }  
Magic Number,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,RotateTurntable,The following statement contains a magic number: if (this.CameraMode != CameraMode.Inspect) {  	d *= -0.2;  }  
Magic Number,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,RotateTurntable,The following statement contains a magic number: d *= -0.2;  
Magic Number,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,Started,The following statement contains a magic number: this.rotationPoint = new Point (this.Controller.Viewport.ActualWidth / 2' this.Controller.Viewport.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,Started,The following statement contains a magic number: this.rotationPoint = new Point (this.Controller.Viewport.ActualWidth / 2' this.Controller.Viewport.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,OnInertiaStarting,The following statement contains a magic number: this.Controller.StartSpin (4 * delta * ((double)this.Controller.SpinReleaseTime / elapsedTime)' this.MouseDownPoint' this.rotationPoint3D);  
Magic Number,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,InitTurnballRotationAxes,The following statement contains a magic number: if (fy > 0.8 || fy < 0.2) {  	// delta.Y = 0;  }  
Magic Number,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,InitTurnballRotationAxes,The following statement contains a magic number: if (fy > 0.8 || fy < 0.2) {  	// delta.Y = 0;  }  
Magic Number,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,InitTurnballRotationAxes,The following statement contains a magic number: if (fx > 0.8) {  	// delta.X = 0;  	this.rotationAxisY = dir;  }  
Magic Number,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,InitTurnballRotationAxes,The following statement contains a magic number: if (fx < 0.2) {  	// delta.X = 0;  	this.rotationAxisY = -dir;  }  
Magic Number,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,RotateTrackball,The following statement contains a magic number: if (axis.LengthSquared < 1e-8) {  	return;  }  
Magic Number,HelixToolkit.Wpf,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomHandler.cs,ZoomByChangingCameraPosition,The following statement contains a magic number: if (delta < -0.5) {  	delta = -0.5;  }  
Magic Number,HelixToolkit.Wpf,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomHandler.cs,ZoomByChangingCameraPosition,The following statement contains a magic number: if (delta < -0.5) {  	delta = -0.5;  }  
Magic Number,HelixToolkit.Wpf,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomHandler.cs,ZoomByChangingCameraPosition,The following statement contains a magic number: delta = -0.5;  
Magic Number,HelixToolkit.Wpf,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomHandler.cs,ZoomByChangingCameraWidth,The following statement contains a magic number: if (delta < -0.5) {  	delta = -0.5;  }  
Magic Number,HelixToolkit.Wpf,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomHandler.cs,ZoomByChangingCameraWidth,The following statement contains a magic number: if (delta < -0.5) {  	delta = -0.5;  }  
Magic Number,HelixToolkit.Wpf,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomHandler.cs,ZoomByChangingCameraWidth,The following statement contains a magic number: delta = -0.5;  
Magic Number,HelixToolkit.Wpf,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomHandler.cs,ZoomByChangingFieldOfView,The following statement contains a magic number: fov *= 1 + (delta * 0.5);  
Magic Number,HelixToolkit.Wpf,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomHandler.cs,Delta,The following statement contains a magic number: this.Zoom (delta.Y * 0.01' this.zoomPoint3D);  
Magic Number,HelixToolkit.Wpf,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomHandler.cs,Started,The following statement contains a magic number: this.zoomPoint = new Point (this.Controller.Viewport.ActualWidth / 2' this.Controller.Viewport.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomHandler.cs,Started,The following statement contains a magic number: this.zoomPoint = new Point (this.Controller.Viewport.ActualWidth / 2' this.Controller.Viewport.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf,ZoomRectangleHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomRectangleHandler.cs,ZoomRectangle,The following statement contains a magic number: if (rectangle.Width < 10 || rectangle.Height < 10) {  	return;  }  
Magic Number,HelixToolkit.Wpf,ZoomRectangleHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomRectangleHandler.cs,ZoomRectangle,The following statement contains a magic number: if (rectangle.Width < 10 || rectangle.Height < 10) {  	return;  }  
Magic Number,HelixToolkit.Wpf,CategorizedColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\CategorizedColorAxis.cs,AddVisuals,The following statement contains a magic number: for (int i = 0; i < this.Categories.Count; i++) {  	var text = this.Categories [i];  	var tb = new TextBlock (new Run (text)) {  		Foreground = this.Foreground  	};  	tb.Measure (new Size (this.ActualWidth' this.ActualHeight));  	double y = this.ColorArea.Top + (((double)i / this.Categories.Count) * this.ColorArea.Height);  	double y1 = this.ColorArea.Top + (((i + 0.5) / this.Categories.Count) * this.ColorArea.Height);  	double y2 = this.ColorArea.Top + (((i + 1.0) / this.Categories.Count) * this.ColorArea.Height);  	Point p0' p1' p2' p3' p4;  	switch (this.Position) {  	case ColorAxisPosition.Right:  		p0 = new Point (this.ColorArea.Right' y);  		p1 = new Point (this.ColorArea.Left - this.TickLength' y);  		p2 = new Point (this.ColorArea.Left - this.TickLength - this.TextMargin - tb.DesiredSize.Width' y1 - (tb.DesiredSize.Height / 2));  		p3 = new Point (this.ColorArea.Right' y2);  		p4 = new Point (this.ColorArea.Left - this.TickLength' y2);  		break;  	default:  		p0 = new Point (this.ColorArea.Left' y);  		p1 = new Point (this.ColorArea.Right + this.TickLength' y);  		p2 = new Point (this.ColorArea.Right + this.TickLength + this.TextMargin' y1 - (tb.DesiredSize.Height / 2));  		p3 = new Point (this.ColorArea.Left' y2);  		p4 = new Point (this.ColorArea.Right + this.TickLength' y2);  		break;  	}  	var l = new System.Windows.Shapes.Line {  		X1 = p0.X'  		X2 = p1.X'  		Y1 = p0.Y'  		Y2 = p1.Y'  		Stroke = this.Foreground'  		StrokeThickness = 1'  		SnapsToDevicePixels = true  	};  	this.Canvas.Children.Add (l);  	if (i == this.Categories.Count - 1) {  		var l2 = new System.Windows.Shapes.Line {  			X1 = p3.X'  			X2 = p4.X'  			Y1 = p3.Y'  			Y2 = p4.Y'  			Stroke = this.BorderBrush'  			StrokeThickness = 1'  			SnapsToDevicePixels = true  		};  		this.Canvas.Children.Add (l2);  	}  	Canvas.SetLeft (tb' p2.X);  	Canvas.SetTop (tb' p2.Y);  	this.Canvas.Children.Add (tb);  }  
Magic Number,HelixToolkit.Wpf,CategorizedColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\CategorizedColorAxis.cs,AddVisuals,The following statement contains a magic number: for (int i = 0; i < this.Categories.Count; i++) {  	var text = this.Categories [i];  	var tb = new TextBlock (new Run (text)) {  		Foreground = this.Foreground  	};  	tb.Measure (new Size (this.ActualWidth' this.ActualHeight));  	double y = this.ColorArea.Top + (((double)i / this.Categories.Count) * this.ColorArea.Height);  	double y1 = this.ColorArea.Top + (((i + 0.5) / this.Categories.Count) * this.ColorArea.Height);  	double y2 = this.ColorArea.Top + (((i + 1.0) / this.Categories.Count) * this.ColorArea.Height);  	Point p0' p1' p2' p3' p4;  	switch (this.Position) {  	case ColorAxisPosition.Right:  		p0 = new Point (this.ColorArea.Right' y);  		p1 = new Point (this.ColorArea.Left - this.TickLength' y);  		p2 = new Point (this.ColorArea.Left - this.TickLength - this.TextMargin - tb.DesiredSize.Width' y1 - (tb.DesiredSize.Height / 2));  		p3 = new Point (this.ColorArea.Right' y2);  		p4 = new Point (this.ColorArea.Left - this.TickLength' y2);  		break;  	default:  		p0 = new Point (this.ColorArea.Left' y);  		p1 = new Point (this.ColorArea.Right + this.TickLength' y);  		p2 = new Point (this.ColorArea.Right + this.TickLength + this.TextMargin' y1 - (tb.DesiredSize.Height / 2));  		p3 = new Point (this.ColorArea.Left' y2);  		p4 = new Point (this.ColorArea.Right + this.TickLength' y2);  		break;  	}  	var l = new System.Windows.Shapes.Line {  		X1 = p0.X'  		X2 = p1.X'  		Y1 = p0.Y'  		Y2 = p1.Y'  		Stroke = this.Foreground'  		StrokeThickness = 1'  		SnapsToDevicePixels = true  	};  	this.Canvas.Children.Add (l);  	if (i == this.Categories.Count - 1) {  		var l2 = new System.Windows.Shapes.Line {  			X1 = p3.X'  			X2 = p4.X'  			Y1 = p3.Y'  			Y2 = p4.Y'  			Stroke = this.BorderBrush'  			StrokeThickness = 1'  			SnapsToDevicePixels = true  		};  		this.Canvas.Children.Add (l2);  	}  	Canvas.SetLeft (tb' p2.X);  	Canvas.SetTop (tb' p2.Y);  	this.Canvas.Children.Add (tb);  }  
Magic Number,HelixToolkit.Wpf,CategorizedColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\CategorizedColorAxis.cs,AddVisuals,The following statement contains a magic number: for (int i = 0; i < this.Categories.Count; i++) {  	var text = this.Categories [i];  	var tb = new TextBlock (new Run (text)) {  		Foreground = this.Foreground  	};  	tb.Measure (new Size (this.ActualWidth' this.ActualHeight));  	double y = this.ColorArea.Top + (((double)i / this.Categories.Count) * this.ColorArea.Height);  	double y1 = this.ColorArea.Top + (((i + 0.5) / this.Categories.Count) * this.ColorArea.Height);  	double y2 = this.ColorArea.Top + (((i + 1.0) / this.Categories.Count) * this.ColorArea.Height);  	Point p0' p1' p2' p3' p4;  	switch (this.Position) {  	case ColorAxisPosition.Right:  		p0 = new Point (this.ColorArea.Right' y);  		p1 = new Point (this.ColorArea.Left - this.TickLength' y);  		p2 = new Point (this.ColorArea.Left - this.TickLength - this.TextMargin - tb.DesiredSize.Width' y1 - (tb.DesiredSize.Height / 2));  		p3 = new Point (this.ColorArea.Right' y2);  		p4 = new Point (this.ColorArea.Left - this.TickLength' y2);  		break;  	default:  		p0 = new Point (this.ColorArea.Left' y);  		p1 = new Point (this.ColorArea.Right + this.TickLength' y);  		p2 = new Point (this.ColorArea.Right + this.TickLength + this.TextMargin' y1 - (tb.DesiredSize.Height / 2));  		p3 = new Point (this.ColorArea.Left' y2);  		p4 = new Point (this.ColorArea.Right + this.TickLength' y2);  		break;  	}  	var l = new System.Windows.Shapes.Line {  		X1 = p0.X'  		X2 = p1.X'  		Y1 = p0.Y'  		Y2 = p1.Y'  		Stroke = this.Foreground'  		StrokeThickness = 1'  		SnapsToDevicePixels = true  	};  	this.Canvas.Children.Add (l);  	if (i == this.Categories.Count - 1) {  		var l2 = new System.Windows.Shapes.Line {  			X1 = p3.X'  			X2 = p4.X'  			Y1 = p3.Y'  			Y2 = p4.Y'  			Stroke = this.BorderBrush'  			StrokeThickness = 1'  			SnapsToDevicePixels = true  		};  		this.Canvas.Children.Add (l2);  	}  	Canvas.SetLeft (tb' p2.X);  	Canvas.SetTop (tb' p2.Y);  	this.Canvas.Children.Add (tb);  }  
Magic Number,HelixToolkit.Wpf,CategorizedColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\CategorizedColorAxis.cs,AddVisuals,The following statement contains a magic number: switch (this.Position) {  case ColorAxisPosition.Right:  	p0 = new Point (this.ColorArea.Right' y);  	p1 = new Point (this.ColorArea.Left - this.TickLength' y);  	p2 = new Point (this.ColorArea.Left - this.TickLength - this.TextMargin - tb.DesiredSize.Width' y1 - (tb.DesiredSize.Height / 2));  	p3 = new Point (this.ColorArea.Right' y2);  	p4 = new Point (this.ColorArea.Left - this.TickLength' y2);  	break;  default:  	p0 = new Point (this.ColorArea.Left' y);  	p1 = new Point (this.ColorArea.Right + this.TickLength' y);  	p2 = new Point (this.ColorArea.Right + this.TickLength + this.TextMargin' y1 - (tb.DesiredSize.Height / 2));  	p3 = new Point (this.ColorArea.Left' y2);  	p4 = new Point (this.ColorArea.Right + this.TickLength' y2);  	break;  }  
Magic Number,HelixToolkit.Wpf,CategorizedColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\CategorizedColorAxis.cs,AddVisuals,The following statement contains a magic number: switch (this.Position) {  case ColorAxisPosition.Right:  	p0 = new Point (this.ColorArea.Right' y);  	p1 = new Point (this.ColorArea.Left - this.TickLength' y);  	p2 = new Point (this.ColorArea.Left - this.TickLength - this.TextMargin - tb.DesiredSize.Width' y1 - (tb.DesiredSize.Height / 2));  	p3 = new Point (this.ColorArea.Right' y2);  	p4 = new Point (this.ColorArea.Left - this.TickLength' y2);  	break;  default:  	p0 = new Point (this.ColorArea.Left' y);  	p1 = new Point (this.ColorArea.Right + this.TickLength' y);  	p2 = new Point (this.ColorArea.Right + this.TickLength + this.TextMargin' y1 - (tb.DesiredSize.Height / 2));  	p3 = new Point (this.ColorArea.Left' y2);  	p4 = new Point (this.ColorArea.Right + this.TickLength' y2);  	break;  }  
Magic Number,HelixToolkit.Wpf,CategorizedColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\CategorizedColorAxis.cs,AddVisuals,The following statement contains a magic number: p2 = new Point (this.ColorArea.Left - this.TickLength - this.TextMargin - tb.DesiredSize.Width' y1 - (tb.DesiredSize.Height / 2));  
Magic Number,HelixToolkit.Wpf,CategorizedColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\CategorizedColorAxis.cs,AddVisuals,The following statement contains a magic number: p2 = new Point (this.ColorArea.Right + this.TickLength + this.TextMargin' y1 - (tb.DesiredSize.Height / 2));  
Magic Number,HelixToolkit.Wpf,ColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\ColorAxis.cs,AddVisuals,The following statement contains a magic number: if (this.FlipColorScheme) {  	r.LayoutTransform = new RotateTransform (180);  }  
Magic Number,HelixToolkit.Wpf,ColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\ColorAxis.cs,AddVisuals,The following statement contains a magic number: r.LayoutTransform = new RotateTransform (180);  
Magic Number,HelixToolkit.Wpf,RangeColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\RangeColorAxis.cs,AddVisuals,The following statement contains a magic number: foreach (var v in this.GetTickValues ()) {  	var text = v.ToString (this.FormatString' this.FormatProvider);  	var tb = new TextBlock (new Run (text)) {  		Foreground = this.Foreground  	};  	tb.Measure (new Size (this.ActualWidth' this.ActualHeight));  	double y = transform (v);  	Point p0' p1' p2;  	switch (this.Position) {  	case ColorAxisPosition.Right:  		p0 = new Point (this.ColorArea.Right' y);  		p1 = new Point (this.ColorArea.Left - this.TickLength' y);  		p2 = new Point (this.ColorArea.Left - this.TickLength - this.TextMargin - tb.DesiredSize.Width' y - (tb.DesiredSize.Height / 2));  		break;  	default:  		p0 = new Point (this.ColorArea.Left' y);  		p1 = new Point (this.ColorArea.Right + this.TickLength' y);  		p2 = new Point (this.ColorArea.Right + this.TickLength + this.TextMargin' y - (tb.DesiredSize.Height / 2));  		break;  	}  	var l = new System.Windows.Shapes.Line {  		X1 = p0.X'  		X2 = p1.X'  		Y1 = p0.Y'  		Y2 = p1.Y'  		Stroke = this.Foreground'  		StrokeThickness = 1'  		SnapsToDevicePixels = true  	};  	this.Canvas.Children.Add (l);  	double h = tb.DesiredSize.Height * 0.7;  	if (v < this.Maximum && Math.Abs (y - ymax) < h) {  		continue;  	}  	if (Math.Abs (y - p) < h) {  		continue;  	}  	Canvas.SetLeft (tb' p2.X);  	Canvas.SetTop (tb' p2.Y);  	this.Canvas.Children.Add (tb);  	p = y;  }  
Magic Number,HelixToolkit.Wpf,RangeColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\RangeColorAxis.cs,AddVisuals,The following statement contains a magic number: foreach (var v in this.GetTickValues ()) {  	var text = v.ToString (this.FormatString' this.FormatProvider);  	var tb = new TextBlock (new Run (text)) {  		Foreground = this.Foreground  	};  	tb.Measure (new Size (this.ActualWidth' this.ActualHeight));  	double y = transform (v);  	Point p0' p1' p2;  	switch (this.Position) {  	case ColorAxisPosition.Right:  		p0 = new Point (this.ColorArea.Right' y);  		p1 = new Point (this.ColorArea.Left - this.TickLength' y);  		p2 = new Point (this.ColorArea.Left - this.TickLength - this.TextMargin - tb.DesiredSize.Width' y - (tb.DesiredSize.Height / 2));  		break;  	default:  		p0 = new Point (this.ColorArea.Left' y);  		p1 = new Point (this.ColorArea.Right + this.TickLength' y);  		p2 = new Point (this.ColorArea.Right + this.TickLength + this.TextMargin' y - (tb.DesiredSize.Height / 2));  		break;  	}  	var l = new System.Windows.Shapes.Line {  		X1 = p0.X'  		X2 = p1.X'  		Y1 = p0.Y'  		Y2 = p1.Y'  		Stroke = this.Foreground'  		StrokeThickness = 1'  		SnapsToDevicePixels = true  	};  	this.Canvas.Children.Add (l);  	double h = tb.DesiredSize.Height * 0.7;  	if (v < this.Maximum && Math.Abs (y - ymax) < h) {  		continue;  	}  	if (Math.Abs (y - p) < h) {  		continue;  	}  	Canvas.SetLeft (tb' p2.X);  	Canvas.SetTop (tb' p2.Y);  	this.Canvas.Children.Add (tb);  	p = y;  }  
Magic Number,HelixToolkit.Wpf,RangeColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\RangeColorAxis.cs,AddVisuals,The following statement contains a magic number: foreach (var v in this.GetTickValues ()) {  	var text = v.ToString (this.FormatString' this.FormatProvider);  	var tb = new TextBlock (new Run (text)) {  		Foreground = this.Foreground  	};  	tb.Measure (new Size (this.ActualWidth' this.ActualHeight));  	double y = transform (v);  	Point p0' p1' p2;  	switch (this.Position) {  	case ColorAxisPosition.Right:  		p0 = new Point (this.ColorArea.Right' y);  		p1 = new Point (this.ColorArea.Left - this.TickLength' y);  		p2 = new Point (this.ColorArea.Left - this.TickLength - this.TextMargin - tb.DesiredSize.Width' y - (tb.DesiredSize.Height / 2));  		break;  	default:  		p0 = new Point (this.ColorArea.Left' y);  		p1 = new Point (this.ColorArea.Right + this.TickLength' y);  		p2 = new Point (this.ColorArea.Right + this.TickLength + this.TextMargin' y - (tb.DesiredSize.Height / 2));  		break;  	}  	var l = new System.Windows.Shapes.Line {  		X1 = p0.X'  		X2 = p1.X'  		Y1 = p0.Y'  		Y2 = p1.Y'  		Stroke = this.Foreground'  		StrokeThickness = 1'  		SnapsToDevicePixels = true  	};  	this.Canvas.Children.Add (l);  	double h = tb.DesiredSize.Height * 0.7;  	if (v < this.Maximum && Math.Abs (y - ymax) < h) {  		continue;  	}  	if (Math.Abs (y - p) < h) {  		continue;  	}  	Canvas.SetLeft (tb' p2.X);  	Canvas.SetTop (tb' p2.Y);  	this.Canvas.Children.Add (tb);  	p = y;  }  
Magic Number,HelixToolkit.Wpf,RangeColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\RangeColorAxis.cs,AddVisuals,The following statement contains a magic number: switch (this.Position) {  case ColorAxisPosition.Right:  	p0 = new Point (this.ColorArea.Right' y);  	p1 = new Point (this.ColorArea.Left - this.TickLength' y);  	p2 = new Point (this.ColorArea.Left - this.TickLength - this.TextMargin - tb.DesiredSize.Width' y - (tb.DesiredSize.Height / 2));  	break;  default:  	p0 = new Point (this.ColorArea.Left' y);  	p1 = new Point (this.ColorArea.Right + this.TickLength' y);  	p2 = new Point (this.ColorArea.Right + this.TickLength + this.TextMargin' y - (tb.DesiredSize.Height / 2));  	break;  }  
Magic Number,HelixToolkit.Wpf,RangeColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\RangeColorAxis.cs,AddVisuals,The following statement contains a magic number: switch (this.Position) {  case ColorAxisPosition.Right:  	p0 = new Point (this.ColorArea.Right' y);  	p1 = new Point (this.ColorArea.Left - this.TickLength' y);  	p2 = new Point (this.ColorArea.Left - this.TickLength - this.TextMargin - tb.DesiredSize.Width' y - (tb.DesiredSize.Height / 2));  	break;  default:  	p0 = new Point (this.ColorArea.Left' y);  	p1 = new Point (this.ColorArea.Right + this.TickLength' y);  	p2 = new Point (this.ColorArea.Right + this.TickLength + this.TextMargin' y - (tb.DesiredSize.Height / 2));  	break;  }  
Magic Number,HelixToolkit.Wpf,RangeColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\RangeColorAxis.cs,AddVisuals,The following statement contains a magic number: p2 = new Point (this.ColorArea.Left - this.TickLength - this.TextMargin - tb.DesiredSize.Width' y - (tb.DesiredSize.Height / 2));  
Magic Number,HelixToolkit.Wpf,RangeColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\RangeColorAxis.cs,AddVisuals,The following statement contains a magic number: p2 = new Point (this.ColorArea.Right + this.TickLength + this.TextMargin' y - (tb.DesiredSize.Height / 2));  
Magic Number,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,Copy,The following statement contains a magic number: this.Viewport.Copy (this.Viewport.ActualWidth * 2' this.Viewport.ActualHeight * 2' Brushes.White' 2);  
Magic Number,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,Copy,The following statement contains a magic number: this.Viewport.Copy (this.Viewport.ActualWidth * 2' this.Viewport.ActualHeight * 2' Brushes.White' 2);  
Magic Number,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,Copy,The following statement contains a magic number: this.Viewport.Copy (this.Viewport.ActualWidth * 2' this.Viewport.ActualHeight * 2' Brushes.White' 2);  
Magic Number,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,OnCameraChanged,The following statement contains a magic number: if (this.coordinateView != null) {  	this.Camera.CopyDirectionOnly (this.coordinateView.Camera as PerspectiveCamera' 30);  }  
Magic Number,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,OnCameraChanged,The following statement contains a magic number: this.Camera.CopyDirectionOnly (this.coordinateView.Camera as PerspectiveCamera' 30);  
Magic Number,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,OnCameraChanged,The following statement contains a magic number: if (this.viewCubeViewport != null) {  	this.Camera.CopyDirectionOnly (this.viewCubeViewport.Camera as PerspectiveCamera' 20);  }  
Magic Number,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,OnCameraChanged,The following statement contains a magic number: this.Camera.CopyDirectionOnly (this.viewCubeViewport.Camera as PerspectiveCamera' 20);  
Magic Number,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,CompositionTargetRendering,The following statement contains a magic number: if (this.ShowFrameRate && this.fpsWatch.ElapsedMilliseconds > 500) {  	this.FrameRate = (int)(this.frameCounter / (0.001 * this.fpsWatch.ElapsedMilliseconds));  	this.FrameRateText = this.FrameRate + " FPS";  	this.frameCounter = 0;  	this.fpsWatch.Reset ();  	this.fpsWatch.Start ();  }  
Magic Number,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,CompositionTargetRendering,The following statement contains a magic number: if (this.ShowFrameRate && this.fpsWatch.ElapsedMilliseconds > 500) {  	this.FrameRate = (int)(this.frameCounter / (0.001 * this.fpsWatch.ElapsedMilliseconds));  	this.FrameRateText = this.FrameRate + " FPS";  	this.frameCounter = 0;  	this.fpsWatch.Reset ();  	this.fpsWatch.Start ();  }  
Magic Number,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,CompositionTargetRendering,The following statement contains a magic number: this.FrameRate = (int)(this.frameCounter / (0.001 * this.fpsWatch.ElapsedMilliseconds));  
Magic Number,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,CompositionTargetRendering,The following statement contains a magic number: if (this.ShowTriangleCountInfo && this.infoFrameCounter > 100) {  	var count = this.viewport.GetTotalNumberOfTriangles ();  	this.TriangleCountInfo = string.Format ("Triangles: {0}"' count);  	this.infoFrameCounter = 0;  }  
Magic Number,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,ViewCubeViewportMouseEnter,The following statement contains a magic number: this.viewCubeViewport.AnimateOpacity (1.0' 200);  
Magic Number,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,ViewCubeViewportMouseLeave,The following statement contains a magic number: this.viewCubeViewport.AnimateOpacity (this.ViewCubeOpacity' 200);  
Magic Number,HelixToolkit.Wpf,BitmapExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\BitmapExporter.cs,BitmapExporter,The following statement contains a magic number: this.OversamplingMultiplier = 2;  
Magic Number,HelixToolkit.Wpf,ColladaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ColladaExporter.cs,ExportGeometry,The following statement contains a magic number: writer.WriteAttributeString ("count"' (mg.Positions.Count * 3).ToString (CultureInfo.InvariantCulture));  
Magic Number,HelixToolkit.Wpf,ColladaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ColladaExporter.cs,WriteColor,The following statement contains a magic number: writer.WriteElementString ("color"' string.Format (CultureInfo.InvariantCulture' "{0} {1} {2} {3}"' color.R / 255.0' color.G / 255.0' color.B / 255.0' color.A / 255.0));  
Magic Number,HelixToolkit.Wpf,ColladaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ColladaExporter.cs,WriteColor,The following statement contains a magic number: writer.WriteElementString ("color"' string.Format (CultureInfo.InvariantCulture' "{0} {1} {2} {3}"' color.R / 255.0' color.G / 255.0' color.B / 255.0' color.A / 255.0));  
Magic Number,HelixToolkit.Wpf,ColladaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ColladaExporter.cs,WriteColor,The following statement contains a magic number: writer.WriteElementString ("color"' string.Format (CultureInfo.InvariantCulture' "{0} {1} {2} {3}"' color.R / 255.0' color.G / 255.0' color.B / 255.0' color.A / 255.0));  
Magic Number,HelixToolkit.Wpf,ColladaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ColladaExporter.cs,WriteColor,The following statement contains a magic number: writer.WriteElementString ("color"' string.Format (CultureInfo.InvariantCulture' "{0} {1} {2} {3}"' color.R / 255.0' color.G / 255.0' color.B / 255.0' color.A / 255.0));  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ObjExporter,The following statement contains a magic number: this.TextureSize = 1024;  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ObjExporter,The following statement contains a magic number: this.TextureQualityLevel = 90;  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMesh,The following statement contains a magic number: if (m.TriangleIndices != null) {  	for (int i = 0; i < m.TriangleIndices.Count; i += 3) {  		int i0 = m.TriangleIndices [i];  		int i1 = m.TriangleIndices [i + 1];  		int i2 = m.TriangleIndices [i + 2];  		writer.WriteLine ("f {0} {1} {2}"' formatIndices (i0)' formatIndices (i1)' formatIndices (i2));  	}  	writer.WriteLine (string.Format ("# {0} faces"' m.TriangleIndices.Count / 3));  }  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMesh,The following statement contains a magic number: if (m.TriangleIndices != null) {  	for (int i = 0; i < m.TriangleIndices.Count; i += 3) {  		int i0 = m.TriangleIndices [i];  		int i1 = m.TriangleIndices [i + 1];  		int i2 = m.TriangleIndices [i + 2];  		writer.WriteLine ("f {0} {1} {2}"' formatIndices (i0)' formatIndices (i1)' formatIndices (i2));  	}  	writer.WriteLine (string.Format ("# {0} faces"' m.TriangleIndices.Count / 3));  }  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMesh,The following statement contains a magic number: if (m.TriangleIndices != null) {  	for (int i = 0; i < m.TriangleIndices.Count; i += 3) {  		int i0 = m.TriangleIndices [i];  		int i1 = m.TriangleIndices [i + 1];  		int i2 = m.TriangleIndices [i + 2];  		writer.WriteLine ("f {0} {1} {2}"' formatIndices (i0)' formatIndices (i1)' formatIndices (i2));  	}  	writer.WriteLine (string.Format ("# {0} faces"' m.TriangleIndices.Count / 3));  }  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMesh,The following statement contains a magic number: for (int i = 0; i < m.TriangleIndices.Count; i += 3) {  	int i0 = m.TriangleIndices [i];  	int i1 = m.TriangleIndices [i + 1];  	int i2 = m.TriangleIndices [i + 2];  	writer.WriteLine ("f {0} {1} {2}"' formatIndices (i0)' formatIndices (i1)' formatIndices (i2));  }  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMesh,The following statement contains a magic number: for (int i = 0; i < m.TriangleIndices.Count; i += 3) {  	int i0 = m.TriangleIndices [i];  	int i1 = m.TriangleIndices [i + 1];  	int i2 = m.TriangleIndices [i + 2];  	writer.WriteLine ("f {0} {1} {2}"' formatIndices (i0)' formatIndices (i1)' formatIndices (i2));  }  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMesh,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMesh,The following statement contains a magic number: writer.WriteLine (string.Format ("# {0} faces"' m.TriangleIndices.Count / 3));  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,The following statement contains a magic number: if (dm != null) {  	var adjustedAmbientColor = dm.AmbientColor.ChangeIntensity (0.2);  	// materialWriter.WriteLine(string.Format("Ka {0}"' this.ToColorString(adjustedAmbientColor)));  	var scb = dm.Brush as SolidColorBrush;  	if (scb != null) {  		materialWriter.WriteLine (string.Format ("Kd {0}"' this.ToColorString (scb.Color)));  		if (this.UseDissolveForTransparency) {  			// Dissolve factor  			materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "d {0:F4}"' scb.Color.A / 255.0));  		} else {  			// Transparency  			materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "Tr {0:F4}"' scb.Color.A / 255.0));  		}  	} else {  		var textureFilename = matName + this.TextureExtension;  		var texturePath = Path.Combine (this.TextureFolder' textureFilename);  		using (var s = this.FileCreator (texturePath)) {  			// create bitmap file for the brush  			if (this.TextureExtension == ".jpg") {  				this.RenderBrush (s' dm.Brush' this.TextureSize' this.TextureSize' this.TextureQualityLevel);  			} else {  				this.RenderBrush (s' dm.Brush' this.TextureSize' this.TextureSize);  			}  		}  		materialWriter.WriteLine (string.Format ("map_Kd {0}"' textureFilename));  	}  }  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,The following statement contains a magic number: if (dm != null) {  	var adjustedAmbientColor = dm.AmbientColor.ChangeIntensity (0.2);  	// materialWriter.WriteLine(string.Format("Ka {0}"' this.ToColorString(adjustedAmbientColor)));  	var scb = dm.Brush as SolidColorBrush;  	if (scb != null) {  		materialWriter.WriteLine (string.Format ("Kd {0}"' this.ToColorString (scb.Color)));  		if (this.UseDissolveForTransparency) {  			// Dissolve factor  			materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "d {0:F4}"' scb.Color.A / 255.0));  		} else {  			// Transparency  			materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "Tr {0:F4}"' scb.Color.A / 255.0));  		}  	} else {  		var textureFilename = matName + this.TextureExtension;  		var texturePath = Path.Combine (this.TextureFolder' textureFilename);  		using (var s = this.FileCreator (texturePath)) {  			// create bitmap file for the brush  			if (this.TextureExtension == ".jpg") {  				this.RenderBrush (s' dm.Brush' this.TextureSize' this.TextureSize' this.TextureQualityLevel);  			} else {  				this.RenderBrush (s' dm.Brush' this.TextureSize' this.TextureSize);  			}  		}  		materialWriter.WriteLine (string.Format ("map_Kd {0}"' textureFilename));  	}  }  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,The following statement contains a magic number: if (dm != null) {  	var adjustedAmbientColor = dm.AmbientColor.ChangeIntensity (0.2);  	// materialWriter.WriteLine(string.Format("Ka {0}"' this.ToColorString(adjustedAmbientColor)));  	var scb = dm.Brush as SolidColorBrush;  	if (scb != null) {  		materialWriter.WriteLine (string.Format ("Kd {0}"' this.ToColorString (scb.Color)));  		if (this.UseDissolveForTransparency) {  			// Dissolve factor  			materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "d {0:F4}"' scb.Color.A / 255.0));  		} else {  			// Transparency  			materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "Tr {0:F4}"' scb.Color.A / 255.0));  		}  	} else {  		var textureFilename = matName + this.TextureExtension;  		var texturePath = Path.Combine (this.TextureFolder' textureFilename);  		using (var s = this.FileCreator (texturePath)) {  			// create bitmap file for the brush  			if (this.TextureExtension == ".jpg") {  				this.RenderBrush (s' dm.Brush' this.TextureSize' this.TextureSize' this.TextureQualityLevel);  			} else {  				this.RenderBrush (s' dm.Brush' this.TextureSize' this.TextureSize);  			}  		}  		materialWriter.WriteLine (string.Format ("map_Kd {0}"' textureFilename));  	}  }  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,The following statement contains a magic number: if (scb != null) {  	materialWriter.WriteLine (string.Format ("Kd {0}"' this.ToColorString (scb.Color)));  	if (this.UseDissolveForTransparency) {  		// Dissolve factor  		materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "d {0:F4}"' scb.Color.A / 255.0));  	} else {  		// Transparency  		materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "Tr {0:F4}"' scb.Color.A / 255.0));  	}  } else {  	var textureFilename = matName + this.TextureExtension;  	var texturePath = Path.Combine (this.TextureFolder' textureFilename);  	using (var s = this.FileCreator (texturePath)) {  		// create bitmap file for the brush  		if (this.TextureExtension == ".jpg") {  			this.RenderBrush (s' dm.Brush' this.TextureSize' this.TextureSize' this.TextureQualityLevel);  		} else {  			this.RenderBrush (s' dm.Brush' this.TextureSize' this.TextureSize);  		}  	}  	materialWriter.WriteLine (string.Format ("map_Kd {0}"' textureFilename));  }  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,The following statement contains a magic number: if (scb != null) {  	materialWriter.WriteLine (string.Format ("Kd {0}"' this.ToColorString (scb.Color)));  	if (this.UseDissolveForTransparency) {  		// Dissolve factor  		materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "d {0:F4}"' scb.Color.A / 255.0));  	} else {  		// Transparency  		materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "Tr {0:F4}"' scb.Color.A / 255.0));  	}  } else {  	var textureFilename = matName + this.TextureExtension;  	var texturePath = Path.Combine (this.TextureFolder' textureFilename);  	using (var s = this.FileCreator (texturePath)) {  		// create bitmap file for the brush  		if (this.TextureExtension == ".jpg") {  			this.RenderBrush (s' dm.Brush' this.TextureSize' this.TextureSize' this.TextureQualityLevel);  		} else {  			this.RenderBrush (s' dm.Brush' this.TextureSize' this.TextureSize);  		}  	}  	materialWriter.WriteLine (string.Format ("map_Kd {0}"' textureFilename));  }  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,The following statement contains a magic number: if (this.UseDissolveForTransparency) {  	// Dissolve factor  	materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "d {0:F4}"' scb.Color.A / 255.0));  } else {  	// Transparency  	materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "Tr {0:F4}"' scb.Color.A / 255.0));  }  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,The following statement contains a magic number: if (this.UseDissolveForTransparency) {  	// Dissolve factor  	materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "d {0:F4}"' scb.Color.A / 255.0));  } else {  	// Transparency  	materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "Tr {0:F4}"' scb.Color.A / 255.0));  }  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,The following statement contains a magic number: materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "d {0:F4}"' scb.Color.A / 255.0));  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,The following statement contains a magic number: materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "Tr {0:F4}"' scb.Color.A / 255.0));  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,The following statement contains a magic number: if (sm != null) {  	var scb = sm.Brush as SolidColorBrush;  	materialWriter.WriteLine (string.Format ("Ks {0}"' this.ToColorString (scb != null ? scb.Color : Color.FromScRgb (1.0f' 0.2f' 0.2f' 0.2f))));  	// Illumination model 2  	// This is a diffuse and specular illumination model using Lambertian  	// shading and Blinn's interpretation of Phong's specular illumination  	// model (BLIN77).  The color includes an ambient constant term' and a  	// diffuse and specular shading term for each light source.  The formula  	// is: color = KaIa + Kd { SUM j=1..ls' (N*Lj)Ij } + Ks { SUM j=1..ls' ((H*Hj)^Ns)Ij }  	illum = 2;  	// Specifies the specular exponent for the current material.  This defines the focus of the specular highlight.  	// "exponent" is the value for the specular exponent.  A high exponent results in a tight' concentrated highlight.  Ns values normally range from 0 to 1000.  	materialWriter.WriteLine (string.Format (CultureInfo.InvariantCulture' "Ns {0:F4}"' sm.SpecularPower));  }  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,The following statement contains a magic number: illum = 2;  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ExportMaterial,The following statement contains a magic number: materialWriter.WriteLine (string.Format ("Ns {0}"' 2));  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ToColorString,The following statement contains a magic number: return string.Format (CultureInfo.InvariantCulture' "{0:F4} {1:F4} {2:F4}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ToColorString,The following statement contains a magic number: return string.Format (CultureInfo.InvariantCulture' "{0:F4} {1:F4} {2:F4}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);  
Magic Number,HelixToolkit.Wpf,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\ObjExporter.cs,ToColorString,The following statement contains a magic number: return string.Format (CultureInfo.InvariantCulture' "{0:F4} {1:F4} {2:F4}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);  
Magic Number,HelixToolkit.Wpf,VrmlExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\VrmlExporter.cs,ExportModel,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	writer.WriteLine (string.Format (CultureInfo.InvariantCulture' "{0} {1} {2}'"' mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2]));  }  
Magic Number,HelixToolkit.Wpf,VrmlExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\VrmlExporter.cs,ExportModel,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	writer.WriteLine (string.Format (CultureInfo.InvariantCulture' "{0} {1} {2}'"' mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2]));  }  
Magic Number,HelixToolkit.Wpf,VrmlExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\VrmlExporter.cs,ExportModel,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,VrmlExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\VrmlExporter.cs,ExportModel,The following statement contains a magic number: writer.WriteLine (string.Format (CultureInfo.InvariantCulture' "{0} {1} {2}'"' mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2]));  
Magic Number,HelixToolkit.Wpf,PovRayExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\PovRayExporter.cs,ExportModel,The following statement contains a magic number: writer.WriteLine ("    " + (mesh.TriangleIndices.Count / 3) + "'");  
Magic Number,HelixToolkit.Wpf,PovRayExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\PovRayExporter.cs,ExportModel,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	writer.WriteLine (string.Format (CultureInfo.InvariantCulture' "    {0} {1} {2}'"' mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2]));  }  
Magic Number,HelixToolkit.Wpf,PovRayExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\PovRayExporter.cs,ExportModel,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	writer.WriteLine (string.Format (CultureInfo.InvariantCulture' "    {0} {1} {2}'"' mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2]));  }  
Magic Number,HelixToolkit.Wpf,PovRayExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\PovRayExporter.cs,ExportModel,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,PovRayExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\PovRayExporter.cs,ExportModel,The following statement contains a magic number: writer.WriteLine (string.Format (CultureInfo.InvariantCulture' "    {0} {1} {2}'"' mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2]));  
Magic Number,HelixToolkit.Wpf,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: if (this.Points.Count < 3) {  	throw new InvalidOperationException ("At least three points required in the polygon to find a normal.");  }  
Magic Number,HelixToolkit.Wpf,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++) {  	var n = Vector3D.CrossProduct (v1' this.Points [i] - this.Points [0]);  	if (n.LengthSquared > 1e-10) {  		n.Normalize ();  		return n;  	}  }  
Magic Number,HelixToolkit.Wpf,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++) {  	var n = Vector3D.CrossProduct (v1' this.Points [i] - this.Points [0]);  	if (n.LengthSquared > 1e-10) {  		n.Normalize ();  		return n;  	}  }  
Magic Number,HelixToolkit.Wpf,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: if (n.LengthSquared > 1e-10) {  	n.Normalize ();  	return n;  }  
Magic Number,HelixToolkit.Wpf,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Polygon3D.cs,IsPlanar,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++) {  	var n = Vector3D.CrossProduct (v1' this.Points [i] - this.Points [0]);  	n.Normalize ();  	if (i == 2) {  		normal = n;  	} else if (Math.Abs (Vector3D.DotProduct (n' normal) - 1) > 1e-8) {  		return false;  	}  }  
Magic Number,HelixToolkit.Wpf,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Polygon3D.cs,IsPlanar,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++) {  	var n = Vector3D.CrossProduct (v1' this.Points [i] - this.Points [0]);  	n.Normalize ();  	if (i == 2) {  		normal = n;  	} else if (Math.Abs (Vector3D.DotProduct (n' normal) - 1) > 1e-8) {  		return false;  	}  }  
Magic Number,HelixToolkit.Wpf,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Polygon3D.cs,IsPlanar,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++) {  	var n = Vector3D.CrossProduct (v1' this.Points [i] - this.Points [0]);  	n.Normalize ();  	if (i == 2) {  		normal = n;  	} else if (Math.Abs (Vector3D.DotProduct (n' normal) - 1) > 1e-8) {  		return false;  	}  }  
Magic Number,HelixToolkit.Wpf,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Polygon3D.cs,IsPlanar,The following statement contains a magic number: if (i == 2) {  	normal = n;  } else if (Math.Abs (Vector3D.DotProduct (n' normal) - 1) > 1e-8) {  	return false;  }  
Magic Number,HelixToolkit.Wpf,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Polygon3D.cs,IsPlanar,The following statement contains a magic number: if (i == 2) {  	normal = n;  } else if (Math.Abs (Vector3D.DotProduct (n' normal) - 1) > 1e-8) {  	return false;  }  
Magic Number,HelixToolkit.Wpf,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Polygon3D.cs,IsPlanar,The following statement contains a magic number: if (Math.Abs (Vector3D.DotProduct (n' normal) - 1) > 1e-8) {  	return false;  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Mesh3D,The following statement contains a magic number: foreach (var index in triangleIndices) {  	tri [i++] = index;  	if (i == 3) {  		this.AddFace (tri);  		i = 0;  		tri = new int[3];  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Mesh3D,The following statement contains a magic number: foreach (var index in triangleIndices) {  	tri [i++] = index;  	if (i == 3) {  		this.AddFace (tri);  		i = 0;  		tri = new int[3];  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Mesh3D,The following statement contains a magic number: if (i == 3) {  	this.AddFace (tri);  	i = 0;  	tri = new int[3];  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Mesh3D,The following statement contains a magic number: if (i == 3) {  	this.AddFace (tri);  	i = 0;  	tri = new int[3];  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Mesh3D,The following statement contains a magic number: tri = new int[3];  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,GetFaceNormal,The following statement contains a magic number: for (int i = 0; i + 2 < m; i++) {  	var v0 = this.Vertices [this.Faces [faceIndex] [i]];  	var v1 = this.Vertices [this.Faces [faceIndex] [(i + 1) % m]];  	var v2 = this.Vertices [this.Faces [faceIndex] [(i + 2) % m]];  	var n = Vector3D.CrossProduct (v1 - v0' v2 - v0);  	x += n.X;  	y += n.Y;  	z += n.Z;  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,GetFaceNormal,The following statement contains a magic number: for (int i = 0; i + 2 < m; i++) {  	var v0 = this.Vertices [this.Faces [faceIndex] [i]];  	var v1 = this.Vertices [this.Faces [faceIndex] [(i + 1) % m]];  	var v2 = this.Vertices [this.Faces [faceIndex] [(i + 2) % m]];  	var n = Vector3D.CrossProduct (v1 - v0' v2 - v0);  	x += n.X;  	y += n.Y;  	z += n.Z;  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,IsQuadrilateralMesh,The following statement contains a magic number: foreach (var f in this.Faces) {  	if (f.Length != 4) {  		return false;  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,IsQuadrilateralMesh,The following statement contains a magic number: if (f.Length != 4) {  	return false;  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,IsTriangularMesh,The following statement contains a magic number: foreach (var f in this.Faces) {  	if (f.Length != 3) {  		return false;  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,IsTriangularMesh,The following statement contains a magic number: if (f.Length != 3) {  	return false;  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Quadrangulate,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	if (this.Faces [i].Length == 4) {  		continue;  	}  	var c = this.FindCentroid (i);  	int ci = this.Vertices.Count;  	this.Vertices.Add (c);  	int m = this.Faces [i].Length;  	for (int j = 0; j < m; j++) {  		var mp = this.FindMidpoint (this.Faces [i] [j]' this.Faces [i] [(j + 1) % m]);  		this.Vertices.Add (mp);  	}  	for (int j = 0; j < m; j++) {  		var quad = new int[4];  		quad [0] = ci + 1 + j;  		quad [1] = this.Faces [i] [(j + 1) % m];  		quad [2] = ci + 1 + ((j + 1) % m);  		quad [3] = ci;  		if (j == m - 1) {  			this.Faces [i] = quad;  		} else {  			this.Faces.Add (quad);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Quadrangulate,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	if (this.Faces [i].Length == 4) {  		continue;  	}  	var c = this.FindCentroid (i);  	int ci = this.Vertices.Count;  	this.Vertices.Add (c);  	int m = this.Faces [i].Length;  	for (int j = 0; j < m; j++) {  		var mp = this.FindMidpoint (this.Faces [i] [j]' this.Faces [i] [(j + 1) % m]);  		this.Vertices.Add (mp);  	}  	for (int j = 0; j < m; j++) {  		var quad = new int[4];  		quad [0] = ci + 1 + j;  		quad [1] = this.Faces [i] [(j + 1) % m];  		quad [2] = ci + 1 + ((j + 1) % m);  		quad [3] = ci;  		if (j == m - 1) {  			this.Faces [i] = quad;  		} else {  			this.Faces.Add (quad);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Quadrangulate,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	if (this.Faces [i].Length == 4) {  		continue;  	}  	var c = this.FindCentroid (i);  	int ci = this.Vertices.Count;  	this.Vertices.Add (c);  	int m = this.Faces [i].Length;  	for (int j = 0; j < m; j++) {  		var mp = this.FindMidpoint (this.Faces [i] [j]' this.Faces [i] [(j + 1) % m]);  		this.Vertices.Add (mp);  	}  	for (int j = 0; j < m; j++) {  		var quad = new int[4];  		quad [0] = ci + 1 + j;  		quad [1] = this.Faces [i] [(j + 1) % m];  		quad [2] = ci + 1 + ((j + 1) % m);  		quad [3] = ci;  		if (j == m - 1) {  			this.Faces [i] = quad;  		} else {  			this.Faces.Add (quad);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Quadrangulate,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	if (this.Faces [i].Length == 4) {  		continue;  	}  	var c = this.FindCentroid (i);  	int ci = this.Vertices.Count;  	this.Vertices.Add (c);  	int m = this.Faces [i].Length;  	for (int j = 0; j < m; j++) {  		var mp = this.FindMidpoint (this.Faces [i] [j]' this.Faces [i] [(j + 1) % m]);  		this.Vertices.Add (mp);  	}  	for (int j = 0; j < m; j++) {  		var quad = new int[4];  		quad [0] = ci + 1 + j;  		quad [1] = this.Faces [i] [(j + 1) % m];  		quad [2] = ci + 1 + ((j + 1) % m);  		quad [3] = ci;  		if (j == m - 1) {  			this.Faces [i] = quad;  		} else {  			this.Faces.Add (quad);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Quadrangulate,The following statement contains a magic number: if (this.Faces [i].Length == 4) {  	continue;  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Quadrangulate,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	var quad = new int[4];  	quad [0] = ci + 1 + j;  	quad [1] = this.Faces [i] [(j + 1) % m];  	quad [2] = ci + 1 + ((j + 1) % m);  	quad [3] = ci;  	if (j == m - 1) {  		this.Faces [i] = quad;  	} else {  		this.Faces.Add (quad);  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Quadrangulate,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	var quad = new int[4];  	quad [0] = ci + 1 + j;  	quad [1] = this.Faces [i] [(j + 1) % m];  	quad [2] = ci + 1 + ((j + 1) % m);  	quad [3] = ci;  	if (j == m - 1) {  		this.Faces [i] = quad;  	} else {  		this.Faces.Add (quad);  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Quadrangulate,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	var quad = new int[4];  	quad [0] = ci + 1 + j;  	quad [1] = this.Faces [i] [(j + 1) % m];  	quad [2] = ci + 1 + ((j + 1) % m);  	quad [3] = ci;  	if (j == m - 1) {  		this.Faces [i] = quad;  	} else {  		this.Faces.Add (quad);  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Quadrangulate,The following statement contains a magic number: quad [2] = ci + 1 + ((j + 1) % m);  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Quadrangulate,The following statement contains a magic number: quad [3] = ci;  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,ToMeshGeometry3D,The following statement contains a magic number: if (!sharedVertices || shrink) {  	// not shared vertices - flat shading  	var tm = new MeshBuilder (false' this.TextureCoordinates != null);  	int faceIndex = 0;  	foreach (var face in this.Faces) {  		var vertices = new int[face.Length];  		int j = 0;  		var centroid = this.FindCentroid (faceIndex);  		// var n = GetFaceNormal(faceIndex);  		// for (int i = 0; i < face.Length; i++)  		// tm.Normals.Add(n);  		foreach (int v in face) {  			vertices [j++] = tm.Positions.Count;  			var vertex = this.Vertices [v];  			if (shrink) {  				vertex = vertex + (shrinkFactor * (centroid - vertex));  			}  			tm.Positions.Add (vertex);  			if (tm.CreateTextureCoordinates) {  				tm.TextureCoordinates.Add (this.TextureCoordinates [v]);  			}  		}  		tm.AddTriangleFan (vertices);  		if (faceIndices != null) {  			int numberOfTriangles = vertices.Length - 2;  			for (int i = 0; i < numberOfTriangles; i++) {  				faceIndices.Add (faceIndex);  			}  		}  		faceIndex++;  	}  	return tm.ToMesh ();  } else {  	// shared vertices - smooth shading  	var tm = new MeshBuilder (false' this.TextureCoordinates != null);  	foreach (var v in this.Vertices) {  		tm.Positions.Add (v);  	}  	if (this.TextureCoordinates != null) {  		foreach (var uv in this.TextureCoordinates) {  			tm.TextureCoordinates.Add (uv);  		}  	}  	int faceIndex = 0;  	foreach (var face in this.Faces) {  		tm.AddTriangleFan (face);  		if (faceIndices != null) {  			int numberOfTriangles = face.Length - 2;  			for (int i = 0; i < numberOfTriangles; i++) {  				faceIndices.Add (faceIndex);  			}  		}  		faceIndex++;  	}  	return tm.ToMesh ();  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,ToMeshGeometry3D,The following statement contains a magic number: if (!sharedVertices || shrink) {  	// not shared vertices - flat shading  	var tm = new MeshBuilder (false' this.TextureCoordinates != null);  	int faceIndex = 0;  	foreach (var face in this.Faces) {  		var vertices = new int[face.Length];  		int j = 0;  		var centroid = this.FindCentroid (faceIndex);  		// var n = GetFaceNormal(faceIndex);  		// for (int i = 0; i < face.Length; i++)  		// tm.Normals.Add(n);  		foreach (int v in face) {  			vertices [j++] = tm.Positions.Count;  			var vertex = this.Vertices [v];  			if (shrink) {  				vertex = vertex + (shrinkFactor * (centroid - vertex));  			}  			tm.Positions.Add (vertex);  			if (tm.CreateTextureCoordinates) {  				tm.TextureCoordinates.Add (this.TextureCoordinates [v]);  			}  		}  		tm.AddTriangleFan (vertices);  		if (faceIndices != null) {  			int numberOfTriangles = vertices.Length - 2;  			for (int i = 0; i < numberOfTriangles; i++) {  				faceIndices.Add (faceIndex);  			}  		}  		faceIndex++;  	}  	return tm.ToMesh ();  } else {  	// shared vertices - smooth shading  	var tm = new MeshBuilder (false' this.TextureCoordinates != null);  	foreach (var v in this.Vertices) {  		tm.Positions.Add (v);  	}  	if (this.TextureCoordinates != null) {  		foreach (var uv in this.TextureCoordinates) {  			tm.TextureCoordinates.Add (uv);  		}  	}  	int faceIndex = 0;  	foreach (var face in this.Faces) {  		tm.AddTriangleFan (face);  		if (faceIndices != null) {  			int numberOfTriangles = face.Length - 2;  			for (int i = 0; i < numberOfTriangles; i++) {  				faceIndices.Add (faceIndex);  			}  		}  		faceIndex++;  	}  	return tm.ToMesh ();  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,ToMeshGeometry3D,The following statement contains a magic number: foreach (var face in this.Faces) {  	var vertices = new int[face.Length];  	int j = 0;  	var centroid = this.FindCentroid (faceIndex);  	// var n = GetFaceNormal(faceIndex);  	// for (int i = 0; i < face.Length; i++)  	// tm.Normals.Add(n);  	foreach (int v in face) {  		vertices [j++] = tm.Positions.Count;  		var vertex = this.Vertices [v];  		if (shrink) {  			vertex = vertex + (shrinkFactor * (centroid - vertex));  		}  		tm.Positions.Add (vertex);  		if (tm.CreateTextureCoordinates) {  			tm.TextureCoordinates.Add (this.TextureCoordinates [v]);  		}  	}  	tm.AddTriangleFan (vertices);  	if (faceIndices != null) {  		int numberOfTriangles = vertices.Length - 2;  		for (int i = 0; i < numberOfTriangles; i++) {  			faceIndices.Add (faceIndex);  		}  	}  	faceIndex++;  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,ToMeshGeometry3D,The following statement contains a magic number: if (faceIndices != null) {  	int numberOfTriangles = vertices.Length - 2;  	for (int i = 0; i < numberOfTriangles; i++) {  		faceIndices.Add (faceIndex);  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,ToMeshGeometry3D,The following statement contains a magic number: foreach (var face in this.Faces) {  	tm.AddTriangleFan (face);  	if (faceIndices != null) {  		int numberOfTriangles = face.Length - 2;  		for (int i = 0; i < numberOfTriangles; i++) {  			faceIndices.Add (faceIndex);  		}  	}  	faceIndex++;  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,ToMeshGeometry3D,The following statement contains a magic number: if (faceIndices != null) {  	int numberOfTriangles = face.Length - 2;  	for (int i = 0; i < numberOfTriangles; i++) {  		faceIndices.Add (faceIndex);  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	if (this.Faces [i].Length == 3) {  		continue;  	}  	if (barycentric) {  		var c = this.FindCentroid (i);  		int ci = this.Vertices.Count;  		this.Vertices.Add (c);  		int m = this.Faces [i].Length;  		for (int j = 0; j < m; j++) {  			var tri = new int[3];  			tri [0] = this.Faces [i] [j];  			tri [1] = this.Faces [i] [(j + 1) % m];  			tri [2] = ci;  			if (j == m - 1) {  				this.Faces [i] = tri;  			} else {  				this.Faces.Add (tri);  			}  		}  	} else {  		int m = this.Faces [i].Length;  		for (int j = 1; j + 1 < m; j++) {  			var tri = new int[3];  			tri [0] = this.Faces [i] [0];  			tri [1] = this.Faces [i] [j % m];  			tri [2] = this.Faces [i] [(j + 1) % m];  			if (j + 1 == m - 1) {  				this.Faces [i] = tri;  			} else {  				this.Faces.Add (tri);  			}  		}  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	if (this.Faces [i].Length == 3) {  		continue;  	}  	if (barycentric) {  		var c = this.FindCentroid (i);  		int ci = this.Vertices.Count;  		this.Vertices.Add (c);  		int m = this.Faces [i].Length;  		for (int j = 0; j < m; j++) {  			var tri = new int[3];  			tri [0] = this.Faces [i] [j];  			tri [1] = this.Faces [i] [(j + 1) % m];  			tri [2] = ci;  			if (j == m - 1) {  				this.Faces [i] = tri;  			} else {  				this.Faces.Add (tri);  			}  		}  	} else {  		int m = this.Faces [i].Length;  		for (int j = 1; j + 1 < m; j++) {  			var tri = new int[3];  			tri [0] = this.Faces [i] [0];  			tri [1] = this.Faces [i] [j % m];  			tri [2] = this.Faces [i] [(j + 1) % m];  			if (j + 1 == m - 1) {  				this.Faces [i] = tri;  			} else {  				this.Faces.Add (tri);  			}  		}  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	if (this.Faces [i].Length == 3) {  		continue;  	}  	if (barycentric) {  		var c = this.FindCentroid (i);  		int ci = this.Vertices.Count;  		this.Vertices.Add (c);  		int m = this.Faces [i].Length;  		for (int j = 0; j < m; j++) {  			var tri = new int[3];  			tri [0] = this.Faces [i] [j];  			tri [1] = this.Faces [i] [(j + 1) % m];  			tri [2] = ci;  			if (j == m - 1) {  				this.Faces [i] = tri;  			} else {  				this.Faces.Add (tri);  			}  		}  	} else {  		int m = this.Faces [i].Length;  		for (int j = 1; j + 1 < m; j++) {  			var tri = new int[3];  			tri [0] = this.Faces [i] [0];  			tri [1] = this.Faces [i] [j % m];  			tri [2] = this.Faces [i] [(j + 1) % m];  			if (j + 1 == m - 1) {  				this.Faces [i] = tri;  			} else {  				this.Faces.Add (tri);  			}  		}  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	if (this.Faces [i].Length == 3) {  		continue;  	}  	if (barycentric) {  		var c = this.FindCentroid (i);  		int ci = this.Vertices.Count;  		this.Vertices.Add (c);  		int m = this.Faces [i].Length;  		for (int j = 0; j < m; j++) {  			var tri = new int[3];  			tri [0] = this.Faces [i] [j];  			tri [1] = this.Faces [i] [(j + 1) % m];  			tri [2] = ci;  			if (j == m - 1) {  				this.Faces [i] = tri;  			} else {  				this.Faces.Add (tri);  			}  		}  	} else {  		int m = this.Faces [i].Length;  		for (int j = 1; j + 1 < m; j++) {  			var tri = new int[3];  			tri [0] = this.Faces [i] [0];  			tri [1] = this.Faces [i] [j % m];  			tri [2] = this.Faces [i] [(j + 1) % m];  			if (j + 1 == m - 1) {  				this.Faces [i] = tri;  			} else {  				this.Faces.Add (tri);  			}  		}  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	if (this.Faces [i].Length == 3) {  		continue;  	}  	if (barycentric) {  		var c = this.FindCentroid (i);  		int ci = this.Vertices.Count;  		this.Vertices.Add (c);  		int m = this.Faces [i].Length;  		for (int j = 0; j < m; j++) {  			var tri = new int[3];  			tri [0] = this.Faces [i] [j];  			tri [1] = this.Faces [i] [(j + 1) % m];  			tri [2] = ci;  			if (j == m - 1) {  				this.Faces [i] = tri;  			} else {  				this.Faces.Add (tri);  			}  		}  	} else {  		int m = this.Faces [i].Length;  		for (int j = 1; j + 1 < m; j++) {  			var tri = new int[3];  			tri [0] = this.Faces [i] [0];  			tri [1] = this.Faces [i] [j % m];  			tri [2] = this.Faces [i] [(j + 1) % m];  			if (j + 1 == m - 1) {  				this.Faces [i] = tri;  			} else {  				this.Faces.Add (tri);  			}  		}  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: if (this.Faces [i].Length == 3) {  	continue;  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: if (barycentric) {  	var c = this.FindCentroid (i);  	int ci = this.Vertices.Count;  	this.Vertices.Add (c);  	int m = this.Faces [i].Length;  	for (int j = 0; j < m; j++) {  		var tri = new int[3];  		tri [0] = this.Faces [i] [j];  		tri [1] = this.Faces [i] [(j + 1) % m];  		tri [2] = ci;  		if (j == m - 1) {  			this.Faces [i] = tri;  		} else {  			this.Faces.Add (tri);  		}  	}  } else {  	int m = this.Faces [i].Length;  	for (int j = 1; j + 1 < m; j++) {  		var tri = new int[3];  		tri [0] = this.Faces [i] [0];  		tri [1] = this.Faces [i] [j % m];  		tri [2] = this.Faces [i] [(j + 1) % m];  		if (j + 1 == m - 1) {  			this.Faces [i] = tri;  		} else {  			this.Faces.Add (tri);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: if (barycentric) {  	var c = this.FindCentroid (i);  	int ci = this.Vertices.Count;  	this.Vertices.Add (c);  	int m = this.Faces [i].Length;  	for (int j = 0; j < m; j++) {  		var tri = new int[3];  		tri [0] = this.Faces [i] [j];  		tri [1] = this.Faces [i] [(j + 1) % m];  		tri [2] = ci;  		if (j == m - 1) {  			this.Faces [i] = tri;  		} else {  			this.Faces.Add (tri);  		}  	}  } else {  	int m = this.Faces [i].Length;  	for (int j = 1; j + 1 < m; j++) {  		var tri = new int[3];  		tri [0] = this.Faces [i] [0];  		tri [1] = this.Faces [i] [j % m];  		tri [2] = this.Faces [i] [(j + 1) % m];  		if (j + 1 == m - 1) {  			this.Faces [i] = tri;  		} else {  			this.Faces.Add (tri);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: if (barycentric) {  	var c = this.FindCentroid (i);  	int ci = this.Vertices.Count;  	this.Vertices.Add (c);  	int m = this.Faces [i].Length;  	for (int j = 0; j < m; j++) {  		var tri = new int[3];  		tri [0] = this.Faces [i] [j];  		tri [1] = this.Faces [i] [(j + 1) % m];  		tri [2] = ci;  		if (j == m - 1) {  			this.Faces [i] = tri;  		} else {  			this.Faces.Add (tri);  		}  	}  } else {  	int m = this.Faces [i].Length;  	for (int j = 1; j + 1 < m; j++) {  		var tri = new int[3];  		tri [0] = this.Faces [i] [0];  		tri [1] = this.Faces [i] [j % m];  		tri [2] = this.Faces [i] [(j + 1) % m];  		if (j + 1 == m - 1) {  			this.Faces [i] = tri;  		} else {  			this.Faces.Add (tri);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: if (barycentric) {  	var c = this.FindCentroid (i);  	int ci = this.Vertices.Count;  	this.Vertices.Add (c);  	int m = this.Faces [i].Length;  	for (int j = 0; j < m; j++) {  		var tri = new int[3];  		tri [0] = this.Faces [i] [j];  		tri [1] = this.Faces [i] [(j + 1) % m];  		tri [2] = ci;  		if (j == m - 1) {  			this.Faces [i] = tri;  		} else {  			this.Faces.Add (tri);  		}  	}  } else {  	int m = this.Faces [i].Length;  	for (int j = 1; j + 1 < m; j++) {  		var tri = new int[3];  		tri [0] = this.Faces [i] [0];  		tri [1] = this.Faces [i] [j % m];  		tri [2] = this.Faces [i] [(j + 1) % m];  		if (j + 1 == m - 1) {  			this.Faces [i] = tri;  		} else {  			this.Faces.Add (tri);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	var tri = new int[3];  	tri [0] = this.Faces [i] [j];  	tri [1] = this.Faces [i] [(j + 1) % m];  	tri [2] = ci;  	if (j == m - 1) {  		this.Faces [i] = tri;  	} else {  		this.Faces.Add (tri);  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	var tri = new int[3];  	tri [0] = this.Faces [i] [j];  	tri [1] = this.Faces [i] [(j + 1) % m];  	tri [2] = ci;  	if (j == m - 1) {  		this.Faces [i] = tri;  	} else {  		this.Faces.Add (tri);  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: tri [2] = ci;  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: for (int j = 1; j + 1 < m; j++) {  	var tri = new int[3];  	tri [0] = this.Faces [i] [0];  	tri [1] = this.Faces [i] [j % m];  	tri [2] = this.Faces [i] [(j + 1) % m];  	if (j + 1 == m - 1) {  		this.Faces [i] = tri;  	} else {  		this.Faces.Add (tri);  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: for (int j = 1; j + 1 < m; j++) {  	var tri = new int[3];  	tri [0] = this.Faces [i] [0];  	tri [1] = this.Faces [i] [j % m];  	tri [2] = this.Faces [i] [(j + 1) % m];  	if (j + 1 == m - 1) {  		this.Faces [i] = tri;  	} else {  		this.Faces.Add (tri);  	}  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,Triangulate,The following statement contains a magic number: tri [2] = this.Faces [i] [(j + 1) % m];  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,UpdateEdges,The following statement contains a magic number: foreach (var v in this.Vertices) {  	edges.Add (new List<int> (5));  }  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,UpdateEdges,The following statement contains a magic number: edges.Add (new List<int> (5));  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,FindMidpoint,The following statement contains a magic number: return new Point3D ((this.Vertices [v0].X + this.Vertices [v1].X) * 0.5' (this.Vertices [v0].Y + this.Vertices [v1].Y) * 0.5' (this.Vertices [v0].Z + this.Vertices [v1].Z) * 0.5);  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,FindMidpoint,The following statement contains a magic number: return new Point3D ((this.Vertices [v0].X + this.Vertices [v1].X) * 0.5' (this.Vertices [v0].Y + this.Vertices [v1].Y) * 0.5' (this.Vertices [v0].Z + this.Vertices [v1].Z) * 0.5);  
Magic Number,HelixToolkit.Wpf,Mesh3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\Mesh3D.cs,FindMidpoint,The following statement contains a magic number: return new Point3D ((this.Vertices [v0].X + this.Vertices [v1].X) * 0.5' (this.Vertices [v0].Y + this.Vertices [v1].Y) * 0.5' (this.Vertices [v0].Z + this.Vertices [v1].Z) * 0.5);  
Magic Number,HelixToolkit.Wpf,BoundingSphere,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\BoundingSphere.cs,BoundingSphere,The following statement contains a magic number: this.radius = diameter / 2;  
Magic Number,HelixToolkit.Wpf,BoundingSphere,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\BoundingSphere.cs,CreateFromRect3D,The following statement contains a magic number: return new BoundingSphere {  	Center = new Point3D (rect.X + (rect.SizeX * 0.5)' rect.Y + (rect.SizeY * 0.5)' rect.Z + (rect.SizeZ * 0.5))'  	Radius = 0.5 * Math.Sqrt ((rect.SizeX * rect.SizeX) + (rect.SizeY * rect.SizeY) + (rect.SizeZ * rect.SizeZ))  };  
Magic Number,HelixToolkit.Wpf,BoundingSphere,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\BoundingSphere.cs,CreateFromRect3D,The following statement contains a magic number: return new BoundingSphere {  	Center = new Point3D (rect.X + (rect.SizeX * 0.5)' rect.Y + (rect.SizeY * 0.5)' rect.Z + (rect.SizeZ * 0.5))'  	Radius = 0.5 * Math.Sqrt ((rect.SizeX * rect.SizeX) + (rect.SizeY * rect.SizeY) + (rect.SizeZ * rect.SizeZ))  };  
Magic Number,HelixToolkit.Wpf,BoundingSphere,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\BoundingSphere.cs,CreateFromRect3D,The following statement contains a magic number: return new BoundingSphere {  	Center = new Point3D (rect.X + (rect.SizeX * 0.5)' rect.Y + (rect.SizeY * 0.5)' rect.Z + (rect.SizeZ * 0.5))'  	Radius = 0.5 * Math.Sqrt ((rect.SizeX * rect.SizeX) + (rect.SizeY * rect.SizeY) + (rect.SizeZ * rect.SizeZ))  };  
Magic Number,HelixToolkit.Wpf,BoundingSphere,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\BoundingSphere.cs,CreateFromRect3D,The following statement contains a magic number: return new BoundingSphere {  	Center = new Point3D (rect.X + (rect.SizeX * 0.5)' rect.Y + (rect.SizeY * 0.5)' rect.Z + (rect.SizeZ * 0.5))'  	Radius = 0.5 * Math.Sqrt ((rect.SizeX * rect.SizeX) + (rect.SizeY * rect.SizeY) + (rect.SizeZ * rect.SizeZ))  };  
Magic Number,HelixToolkit.Wpf,BoundingSphere,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\BoundingSphere.cs,Intersects,The following statement contains a magic number: return (this.radius * this.radius) + (2.0 * this.radius * sphere.radius) + (sphere.radius * sphere.radius) > d2;  
Magic Number,HelixToolkit.Wpf,BoundingSphere,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\BoundingSphere.cs,RayIntersection,The following statement contains a magic number: if (q >= 0) {  	double q2 = Math.Sqrt ((b * b) - (4 * a * c));  	// First root  	double t1 = (-b + q2) / (2 * a);  	// Second root  	double t2 = (-b - q2) / (2 * a);  	if (t1 >= 0 && t2 >= 0 && !t1.Equals (t2)) {  		var i1 = new Point3D (x1 + (dx * t1)' y1 + (dy * t1)' z1 + (dz * t1));  		var i2 = new Point3D (x1 + (dx * t2)' y1 + (dy * t2)' z1 + (dz * t2));  		result = t1 < t2 ? new[] {  			i1'  			i2  		} : new[] {  			i2'  			i1  		};  		return true;  	}  	if (t1 >= 0) {  		var i1 = new Point3D (x1 + (dx * t1)' y1 + (dy * t1)' z1 + (dz * t1));  		result = new[] {  			i1  		};  		return true;  	}  	if (t2 >= 0) {  		var i2 = new Point3D (x1 + (dx * t2)' y1 + (dy * t2)' z1 + (dz * t2));  		result = new[] {  			i2  		};  		return true;  	}  }  
Magic Number,HelixToolkit.Wpf,BoundingSphere,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\BoundingSphere.cs,RayIntersection,The following statement contains a magic number: if (q >= 0) {  	double q2 = Math.Sqrt ((b * b) - (4 * a * c));  	// First root  	double t1 = (-b + q2) / (2 * a);  	// Second root  	double t2 = (-b - q2) / (2 * a);  	if (t1 >= 0 && t2 >= 0 && !t1.Equals (t2)) {  		var i1 = new Point3D (x1 + (dx * t1)' y1 + (dy * t1)' z1 + (dz * t1));  		var i2 = new Point3D (x1 + (dx * t2)' y1 + (dy * t2)' z1 + (dz * t2));  		result = t1 < t2 ? new[] {  			i1'  			i2  		} : new[] {  			i2'  			i1  		};  		return true;  	}  	if (t1 >= 0) {  		var i1 = new Point3D (x1 + (dx * t1)' y1 + (dy * t1)' z1 + (dz * t1));  		result = new[] {  			i1  		};  		return true;  	}  	if (t2 >= 0) {  		var i2 = new Point3D (x1 + (dx * t2)' y1 + (dy * t2)' z1 + (dz * t2));  		result = new[] {  			i2  		};  		return true;  	}  }  
Magic Number,HelixToolkit.Wpf,BoundingSphere,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Geometry\BoundingSphere.cs,RayIntersection,The following statement contains a magic number: if (q >= 0) {  	double q2 = Math.Sqrt ((b * b) - (4 * a * c));  	// First root  	double t1 = (-b + q2) / (2 * a);  	// Second root  	double t2 = (-b - q2) / (2 * a);  	if (t1 >= 0 && t2 >= 0 && !t1.Equals (t2)) {  		var i1 = new Point3D (x1 + (dx * t1)' y1 + (dy * t1)' z1 + (dz * t1));  		var i2 = new Point3D (x1 + (dx * t2)' y1 + (dy * t2)' z1 + (dz * t2));  		result = t1 < t2 ? new[] {  			i1'  			i2  		} : new[] {  			i2'  			i1  		};  		return true;  	}  	if (t1 >= 0) {  		var i1 = new Point3D (x1 + (dx * t1)' y1 + (dy * t1)' z1 + (dz * t1));  		result = new[] {  			i1  		};  		return true;  	}  	if (t2 >= 0) {  		var i2 = new Point3D (x1 + (dx * t2)' y1 + (dy * t2)' z1 + (dz * t2));  		result = new[] {  			i2  		};  		return true;  	}  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n < 2) {  	result.AddRange (points);  	return result;  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n == 2) {  	if (!isClosed) {  		Segment (result' points [0]' points [0]' points [1]' points [1]' tension' tension' tolerance);  	} else {  		Segment (result' points [1]' points [0]' points [1]' points [0]' tension' tension' tolerance);  		Segment (result' points [0]' points [1]' points [0]' points [1]' tension' tension' tolerance);  	}  } else {  	bool useTensionCollection = tensions != null && tensions.Count > 0;  	for (int i = 0; i < n; i++) {  		double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  		double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  		if (i == 0) {  			Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  		} else if (i == n - 2) {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  		} else if (i == n - 1) {  			if (isClosed) {  				Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  			}  		} else {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n == 2) {  	if (!isClosed) {  		Segment (result' points [0]' points [0]' points [1]' points [1]' tension' tension' tolerance);  	} else {  		Segment (result' points [1]' points [0]' points [1]' points [0]' tension' tension' tolerance);  		Segment (result' points [0]' points [1]' points [0]' points [1]' tension' tension' tolerance);  	}  } else {  	bool useTensionCollection = tensions != null && tensions.Count > 0;  	for (int i = 0; i < n; i++) {  		double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  		double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  		if (i == 0) {  			Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  		} else if (i == n - 2) {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  		} else if (i == n - 1) {  			if (isClosed) {  				Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  			}  		} else {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n == 2) {  	if (!isClosed) {  		Segment (result' points [0]' points [0]' points [1]' points [1]' tension' tension' tolerance);  	} else {  		Segment (result' points [1]' points [0]' points [1]' points [0]' tension' tension' tolerance);  		Segment (result' points [0]' points [1]' points [0]' points [1]' tension' tension' tolerance);  	}  } else {  	bool useTensionCollection = tensions != null && tensions.Count > 0;  	for (int i = 0; i < n; i++) {  		double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  		double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  		if (i == 0) {  			Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  		} else if (i == n - 2) {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  		} else if (i == n - 1) {  			if (isClosed) {  				Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  			}  		} else {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (n == 2) {  	if (!isClosed) {  		Segment (result' points [0]' points [0]' points [1]' points [1]' tension' tension' tolerance);  	} else {  		Segment (result' points [1]' points [0]' points [1]' points [0]' tension' tension' tolerance);  		Segment (result' points [0]' points [1]' points [0]' points [1]' tension' tension' tolerance);  	}  } else {  	bool useTensionCollection = tensions != null && tensions.Count > 0;  	for (int i = 0; i < n; i++) {  		double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  		double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  		if (i == 0) {  			Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  		} else if (i == n - 2) {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  		} else if (i == n - 1) {  			if (isClosed) {  				Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  			}  		} else {  			Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  	double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  	if (i == 0) {  		Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  	} else if (i == n - 2) {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  	} else if (i == n - 1) {  		if (isClosed) {  			Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  		}  	} else {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  	}  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  	double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  	if (i == 0) {  		Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  	} else if (i == n - 2) {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  	} else if (i == n - 1) {  		if (isClosed) {  			Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  		}  	} else {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  	}  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	double t1 = useTensionCollection ? tensions [i % tensions.Count] : tension;  	double t2 = useTensionCollection ? tensions [(i + 1) % tensions.Count] : tension;  	if (i == 0) {  		Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  	} else if (i == n - 2) {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  	} else if (i == n - 1) {  		if (isClosed) {  			Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  		}  	} else {  		Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  	}  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == 0) {  	Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  } else if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  } else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  } else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == 0) {  	Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  } else if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  } else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  } else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == 0) {  	Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  } else if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  } else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  } else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: Segment (result' isClosed ? points [n - 1] : points [0]' points [0]' points [1]' points [2]' t1' t2' tolerance);  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  } else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  } else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == n - 2) {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' isClosed ? points [0] : points [i + 1]' t1' t2' tolerance);  } else if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  } else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: if (i == n - 1) {  	if (isClosed) {  		Segment (result' points [i - 1]' points [i]' points [0]' points [1]' t1' t2' tolerance);  	}  } else {  	Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  }  
Magic Number,HelixToolkit.Wpf,CanonicalSplineHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CanonicalSplineHelper.cs,CreateSpline,The following statement contains a magic number: Segment (result' points [i - 1]' points [i]' points [i + 1]' points [i + 2]' t1' t2' tolerance);  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ChangeIntensity,The following statement contains a magic number: hsv [2] *= factor;  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ChangeIntensity,The following statement contains a magic number: if (hsv [2] > 1.0) {  	hsv [2] = 1.0;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ChangeIntensity,The following statement contains a magic number: if (hsv [2] > 1.0) {  	hsv [2] = 1.0;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ChangeIntensity,The following statement contains a magic number: hsv [2] = 1.0;  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: if (s == 0) {  	h = 0.0;  } else {  	if (r == v) {  		h = (g - b) / delta;  	} else if (g == v) {  		h = 2 + (b - r) / delta;  	} else if (b == v) {  		h = 4 + (r - g) / delta;  	}  	h *= 60;  	if (h < 0.0) {  		h = h + 360;  	}  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: if (s == 0) {  	h = 0.0;  } else {  	if (r == v) {  		h = (g - b) / delta;  	} else if (g == v) {  		h = 2 + (b - r) / delta;  	} else if (b == v) {  		h = 4 + (r - g) / delta;  	}  	h *= 60;  	if (h < 0.0) {  		h = h + 360;  	}  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: if (s == 0) {  	h = 0.0;  } else {  	if (r == v) {  		h = (g - b) / delta;  	} else if (g == v) {  		h = 2 + (b - r) / delta;  	} else if (b == v) {  		h = 4 + (r - g) / delta;  	}  	h *= 60;  	if (h < 0.0) {  		h = h + 360;  	}  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: if (s == 0) {  	h = 0.0;  } else {  	if (r == v) {  		h = (g - b) / delta;  	} else if (g == v) {  		h = 2 + (b - r) / delta;  	} else if (b == v) {  		h = 4 + (r - g) / delta;  	}  	h *= 60;  	if (h < 0.0) {  		h = h + 360;  	}  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: if (r == v) {  	h = (g - b) / delta;  } else if (g == v) {  	h = 2 + (b - r) / delta;  } else if (b == v) {  	h = 4 + (r - g) / delta;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: if (r == v) {  	h = (g - b) / delta;  } else if (g == v) {  	h = 2 + (b - r) / delta;  } else if (b == v) {  	h = 4 + (r - g) / delta;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: if (g == v) {  	h = 2 + (b - r) / delta;  } else if (b == v) {  	h = 4 + (r - g) / delta;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: if (g == v) {  	h = 2 + (b - r) / delta;  } else if (b == v) {  	h = 4 + (r - g) / delta;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: h = 2 + (b - r) / delta;  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: if (b == v) {  	h = 4 + (r - g) / delta;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: h = 4 + (r - g) / delta;  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: h *= 60;  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: if (h < 0.0) {  	h = h + 360;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: h = h + 360;  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: hsv [0] = h / 360.0;  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: hsv [2] = v / 255.0;  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsv,The following statement contains a magic number: hsv [2] = v / 255.0;  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsvBytes,The following statement contains a magic number: hsv2 [0] = (byte)(hsv1 [0] * 255);  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsvBytes,The following statement contains a magic number: hsv2 [1] = (byte)(hsv1 [1] * 255);  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsvBytes,The following statement contains a magic number: hsv2 [2] = (byte)(hsv1 [2] * 255);  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsvBytes,The following statement contains a magic number: hsv2 [2] = (byte)(hsv1 [2] * 255);  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToHsvBytes,The following statement contains a magic number: hsv2 [2] = (byte)(hsv1 [2] * 255);  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToUint,The following statement contains a magic number: u += (UInt32)c.R << 16;  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,ColorToUint,The following statement contains a magic number: u += (UInt32)c.G << 8;  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,Complementary,The following statement contains a magic number: return HsvToColor (newHue' hsv [1]' hsv [2]);  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HexToColor,The following statement contains a magic number: if (value.Length <= 6) {  	value = "FF" + value.PadLeft (6' '0');  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HexToColor,The following statement contains a magic number: if (value.Length <= 6) {  	value = "FF" + value.PadLeft (6' '0');  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HexToColor,The following statement contains a magic number: value = "FF" + value.PadLeft (6' '0');  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: if (s == 0) {  	r = v;  	g = v;  	b = v;  } else {  	int i;  	double f' p' q' t;  	if (h == 360) {  		h = 0;  	} else {  		h = h / 60;  	}  	i = (int)Math.Truncate (h);  	f = h - i;  	p = v * (1.0 - s);  	q = v * (1.0 - (s * f));  	t = v * (1.0 - (s * (1.0 - f)));  	switch (i) {  	case 0:  		r = v;  		g = t;  		b = p;  		break;  	case 1:  		r = q;  		g = v;  		b = p;  		break;  	case 2:  		r = p;  		g = v;  		b = t;  		break;  	case 3:  		r = p;  		g = q;  		b = v;  		break;  	case 4:  		r = t;  		g = p;  		b = v;  		break;  	default:  		r = v;  		g = p;  		b = q;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: if (s == 0) {  	r = v;  	g = v;  	b = v;  } else {  	int i;  	double f' p' q' t;  	if (h == 360) {  		h = 0;  	} else {  		h = h / 60;  	}  	i = (int)Math.Truncate (h);  	f = h - i;  	p = v * (1.0 - s);  	q = v * (1.0 - (s * f));  	t = v * (1.0 - (s * (1.0 - f)));  	switch (i) {  	case 0:  		r = v;  		g = t;  		b = p;  		break;  	case 1:  		r = q;  		g = v;  		b = p;  		break;  	case 2:  		r = p;  		g = v;  		b = t;  		break;  	case 3:  		r = p;  		g = q;  		b = v;  		break;  	case 4:  		r = t;  		g = p;  		b = v;  		break;  	default:  		r = v;  		g = p;  		b = q;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: if (s == 0) {  	r = v;  	g = v;  	b = v;  } else {  	int i;  	double f' p' q' t;  	if (h == 360) {  		h = 0;  	} else {  		h = h / 60;  	}  	i = (int)Math.Truncate (h);  	f = h - i;  	p = v * (1.0 - s);  	q = v * (1.0 - (s * f));  	t = v * (1.0 - (s * (1.0 - f)));  	switch (i) {  	case 0:  		r = v;  		g = t;  		b = p;  		break;  	case 1:  		r = q;  		g = v;  		b = p;  		break;  	case 2:  		r = p;  		g = v;  		b = t;  		break;  	case 3:  		r = p;  		g = q;  		b = v;  		break;  	case 4:  		r = t;  		g = p;  		b = v;  		break;  	default:  		r = v;  		g = p;  		b = q;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: if (s == 0) {  	r = v;  	g = v;  	b = v;  } else {  	int i;  	double f' p' q' t;  	if (h == 360) {  		h = 0;  	} else {  		h = h / 60;  	}  	i = (int)Math.Truncate (h);  	f = h - i;  	p = v * (1.0 - s);  	q = v * (1.0 - (s * f));  	t = v * (1.0 - (s * (1.0 - f)));  	switch (i) {  	case 0:  		r = v;  		g = t;  		b = p;  		break;  	case 1:  		r = q;  		g = v;  		b = p;  		break;  	case 2:  		r = p;  		g = v;  		b = t;  		break;  	case 3:  		r = p;  		g = q;  		b = v;  		break;  	case 4:  		r = t;  		g = p;  		b = v;  		break;  	default:  		r = v;  		g = p;  		b = q;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: if (s == 0) {  	r = v;  	g = v;  	b = v;  } else {  	int i;  	double f' p' q' t;  	if (h == 360) {  		h = 0;  	} else {  		h = h / 60;  	}  	i = (int)Math.Truncate (h);  	f = h - i;  	p = v * (1.0 - s);  	q = v * (1.0 - (s * f));  	t = v * (1.0 - (s * (1.0 - f)));  	switch (i) {  	case 0:  		r = v;  		g = t;  		b = p;  		break;  	case 1:  		r = q;  		g = v;  		b = p;  		break;  	case 2:  		r = p;  		g = v;  		b = t;  		break;  	case 3:  		r = p;  		g = q;  		b = v;  		break;  	case 4:  		r = t;  		g = p;  		b = v;  		break;  	default:  		r = v;  		g = p;  		b = q;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: if (h == 360) {  	h = 0;  } else {  	h = h / 60;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: if (h == 360) {  	h = 0;  } else {  	h = h / 60;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: h = h / 60;  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: switch (i) {  case 0:  	r = v;  	g = t;  	b = p;  	break;  case 1:  	r = q;  	g = v;  	b = p;  	break;  case 2:  	r = p;  	g = v;  	b = t;  	break;  case 3:  	r = p;  	g = q;  	b = v;  	break;  case 4:  	r = t;  	g = p;  	b = v;  	break;  default:  	r = v;  	g = p;  	b = q;  	break;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: switch (i) {  case 0:  	r = v;  	g = t;  	b = p;  	break;  case 1:  	r = q;  	g = v;  	b = p;  	break;  case 2:  	r = p;  	g = v;  	b = t;  	break;  case 3:  	r = p;  	g = q;  	b = v;  	break;  case 4:  	r = t;  	g = p;  	b = v;  	break;  default:  	r = v;  	g = p;  	b = q;  	break;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: switch (i) {  case 0:  	r = v;  	g = t;  	b = p;  	break;  case 1:  	r = q;  	g = v;  	b = p;  	break;  case 2:  	r = p;  	g = v;  	b = t;  	break;  case 3:  	r = p;  	g = q;  	b = v;  	break;  case 4:  	r = t;  	g = p;  	b = v;  	break;  default:  	r = v;  	g = p;  	b = q;  	break;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: return Color.FromArgb (255' (byte)(r * 255)' (byte)(g * 255)' (byte)(b * 255));  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: return Color.FromArgb (255' (byte)(r * 255)' (byte)(g * 255)' (byte)(b * 255));  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: return Color.FromArgb (255' (byte)(r * 255)' (byte)(g * 255)' (byte)(b * 255));  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: return Color.FromArgb (255' (byte)(r * 255)' (byte)(g * 255)' (byte)(b * 255));  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: if (hsv.Length != 3) {  	throw new InvalidOperationException ("Wrong length of hsv array.");  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: return HsvToColor (hsv [0]' hsv [1]' hsv [2]);  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: if (sat == 0) {  	// Gray scale  	r = g = b = val;  } else {  	if (hue == 1.0) {  		hue = 0;  	}  	hue *= 6.0;  	i = (int)Math.Floor (hue);  	f = hue - i;  	aa = val * (1 - sat);  	bb = val * (1 - (sat * f));  	cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: if (sat == 0) {  	// Gray scale  	r = g = b = val;  } else {  	if (hue == 1.0) {  		hue = 0;  	}  	hue *= 6.0;  	i = (int)Math.Floor (hue);  	f = hue - i;  	aa = val * (1 - sat);  	bb = val * (1 - (sat * f));  	cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: if (sat == 0) {  	// Gray scale  	r = g = b = val;  } else {  	if (hue == 1.0) {  		hue = 0;  	}  	hue *= 6.0;  	i = (int)Math.Floor (hue);  	f = hue - i;  	aa = val * (1 - sat);  	bb = val * (1 - (sat * f));  	cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: if (sat == 0) {  	// Gray scale  	r = g = b = val;  } else {  	if (hue == 1.0) {  		hue = 0;  	}  	hue *= 6.0;  	i = (int)Math.Floor (hue);  	f = hue - i;  	aa = val * (1 - sat);  	bb = val * (1 - (sat * f));  	cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: if (sat == 0) {  	// Gray scale  	r = g = b = val;  } else {  	if (hue == 1.0) {  		hue = 0;  	}  	hue *= 6.0;  	i = (int)Math.Floor (hue);  	f = hue - i;  	aa = val * (1 - sat);  	bb = val * (1 - (sat * f));  	cc = val * (1 - (sat * (1 - f)));  	switch (i) {  	case 0:  		r = val;  		g = cc;  		b = aa;  		break;  	case 1:  		r = bb;  		g = val;  		b = aa;  		break;  	case 2:  		r = aa;  		g = val;  		b = cc;  		break;  	case 3:  		r = aa;  		g = bb;  		b = val;  		break;  	case 4:  		r = cc;  		g = aa;  		b = val;  		break;  	case 5:  		r = val;  		g = aa;  		b = bb;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: hue *= 6.0;  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: return Color.FromRgb ((byte)(r * 255)' (byte)(g * 255)' (byte)(b * 255));  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: return Color.FromRgb ((byte)(r * 255)' (byte)(g * 255)' (byte)(b * 255));  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following statement contains a magic number: return Color.FromRgb ((byte)(r * 255)' (byte)(g * 255)' (byte)(b * 255));  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HueDifference,The following statement contains a magic number: if (dh > 0.5) {  	dh -= 1.0;  }  
Magic Number,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HueDifference,The following statement contains a magic number: if (dh < -0.5) {  	dh += 1.0;  }  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	// bottom right triangle  	indices.Add ((i * 4) + 0);  	indices.Add ((i * 4) + 1);  	indices.Add ((i * 4) + 2);  	// top left triangle  	indices.Add ((i * 4) + 2);  	indices.Add ((i * 4) + 3);  	indices.Add ((i * 4) + 0);  }  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	// bottom right triangle  	indices.Add ((i * 4) + 0);  	indices.Add ((i * 4) + 1);  	indices.Add ((i * 4) + 2);  	// top left triangle  	indices.Add ((i * 4) + 2);  	indices.Add ((i * 4) + 3);  	indices.Add ((i * 4) + 0);  }  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	// bottom right triangle  	indices.Add ((i * 4) + 0);  	indices.Add ((i * 4) + 1);  	indices.Add ((i * 4) + 2);  	// top left triangle  	indices.Add ((i * 4) + 2);  	indices.Add ((i * 4) + 3);  	indices.Add ((i * 4) + 0);  }  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	// bottom right triangle  	indices.Add ((i * 4) + 0);  	indices.Add ((i * 4) + 1);  	indices.Add ((i * 4) + 2);  	// top left triangle  	indices.Add ((i * 4) + 2);  	indices.Add ((i * 4) + 3);  	indices.Add ((i * 4) + 0);  }  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	// bottom right triangle  	indices.Add ((i * 4) + 0);  	indices.Add ((i * 4) + 1);  	indices.Add ((i * 4) + 2);  	// top left triangle  	indices.Add ((i * 4) + 2);  	indices.Add ((i * 4) + 3);  	indices.Add ((i * 4) + 0);  }  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	// bottom right triangle  	indices.Add ((i * 4) + 0);  	indices.Add ((i * 4) + 1);  	indices.Add ((i * 4) + 2);  	// top left triangle  	indices.Add ((i * 4) + 2);  	indices.Add ((i * 4) + 3);  	indices.Add ((i * 4) + 0);  }  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	// bottom right triangle  	indices.Add ((i * 4) + 0);  	indices.Add ((i * 4) + 1);  	indices.Add ((i * 4) + 2);  	// top left triangle  	indices.Add ((i * 4) + 2);  	indices.Add ((i * 4) + 3);  	indices.Add ((i * 4) + 0);  }  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	// bottom right triangle  	indices.Add ((i * 4) + 0);  	indices.Add ((i * 4) + 1);  	indices.Add ((i * 4) + 2);  	// top left triangle  	indices.Add ((i * 4) + 2);  	indices.Add ((i * 4) + 3);  	indices.Add ((i * 4) + 0);  }  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	// bottom right triangle  	indices.Add ((i * 4) + 0);  	indices.Add ((i * 4) + 1);  	indices.Add ((i * 4) + 2);  	// top left triangle  	indices.Add ((i * 4) + 2);  	indices.Add ((i * 4) + 3);  	indices.Add ((i * 4) + 0);  }  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add ((i * 4) + 0);  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add ((i * 4) + 1);  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add ((i * 4) + 2);  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add ((i * 4) + 2);  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add ((i * 4) + 2);  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add ((i * 4) + 2);  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add ((i * 4) + 3);  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add ((i * 4) + 3);  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add ((i * 4) + 0);  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,GetPinPositions,The following statement contains a magic number: pinNormal *= pinWidth * 0.5;  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,GetPinPositions,The following statement contains a magic number: pinPoints [0] = new Point (0' 0) + (pinNormal * 0.5);  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,GetPinPositions,The following statement contains a magic number: pinPoints [1] = new Point (0' 0) - (pinNormal * 0.5);  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,GetPinPositions,The following statement contains a magic number: pinPoints [2] = pinEnd - pinNormal;  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,GetPinPositions,The following statement contains a magic number: pinPoints [3] = pinEnd + pinNormal;  
Magic Number,HelixToolkit.Wpf,BillboardGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\BillboardGeometryBuilder.cs,GetPinPositions,The following statement contains a magic number: foreach (var bb in billboards) {  	Point4D screenPoint;  	if (!bb.WorldDepthOffset.Equals (0)) {  		var viewPoint = (Point4D)bb.Position * this.visualToProjection;  		screenPoint = new Point4D (viewPoint.X' viewPoint.Y' viewPoint.Z + bb.WorldDepthOffset' viewPoint.W) * this.projectionToScreen;  	} else {  		screenPoint = (Point4D)bb.Position * this.visualToScreen;  	}  	double spw = screenPoint.W;  	double spx = screenPoint.X;  	double spy = screenPoint.Y;  	double spz = screenPoint.Z - ((bb.DepthOffset - 1e-5) * spw);  	foreach (var pinPoint in pinPoints) {  		var p = new Point4D (spx + (pinPoint.X * spw)' spy + (pinPoint.Y * spw)' spz' spw) * this.screenToVisual;  		double wi = 1 / p.W;  		positions.Add (new Point3D (p.X * wi' p.Y * wi' p.Z * wi));  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,SetEdgeVertice,The following statement contains a magic number: if (!this.edgeVertice [v0].ContainsKey (v1)) {  	this.edgeVertice [v0] [v1] = new int[3];  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,SetEdgeVertice,The following statement contains a magic number: this.edgeVertice [v0] [v1] = new int[3];  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int i = 0; i < nFaces; i++) {  	int vaIndex = this.triangleIndices [i * 3];  	int vbIndex = this.triangleIndices [i * 3 + 1];  	int vcIndex = this.triangleIndices [i * 3 + 2];  	int vpIndex = this.AddEdgeVertice (vaIndex' vbIndex' vcIndex);  	int vqIndex = this.AddEdgeVertice (vbIndex' vcIndex' vaIndex);  	int vrIndex = this.AddEdgeVertice (vaIndex' vcIndex' vbIndex);  	this.Add (vaIndex' vpIndex' vrIndex);  	this.Add (vpIndex' vbIndex' vqIndex);  	this.Add (vrIndex' vqIndex' vcIndex);  	this.Add (vrIndex' vpIndex' vqIndex);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int i = 0; i < nFaces; i++) {  	int vaIndex = this.triangleIndices [i * 3];  	int vbIndex = this.triangleIndices [i * 3 + 1];  	int vcIndex = this.triangleIndices [i * 3 + 2];  	int vpIndex = this.AddEdgeVertice (vaIndex' vbIndex' vcIndex);  	int vqIndex = this.AddEdgeVertice (vbIndex' vcIndex' vaIndex);  	int vrIndex = this.AddEdgeVertice (vaIndex' vcIndex' vbIndex);  	this.Add (vaIndex' vpIndex' vrIndex);  	this.Add (vpIndex' vbIndex' vqIndex);  	this.Add (vrIndex' vqIndex' vcIndex);  	this.Add (vrIndex' vpIndex' vqIndex);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int i = 0; i < nFaces; i++) {  	int vaIndex = this.triangleIndices [i * 3];  	int vbIndex = this.triangleIndices [i * 3 + 1];  	int vcIndex = this.triangleIndices [i * 3 + 2];  	int vpIndex = this.AddEdgeVertice (vaIndex' vbIndex' vcIndex);  	int vqIndex = this.AddEdgeVertice (vbIndex' vcIndex' vaIndex);  	int vrIndex = this.AddEdgeVertice (vaIndex' vcIndex' vbIndex);  	this.Add (vaIndex' vpIndex' vrIndex);  	this.Add (vpIndex' vbIndex' vqIndex);  	this.Add (vrIndex' vqIndex' vcIndex);  	this.Add (vrIndex' vpIndex' vqIndex);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int i = 0; i < nFaces; i++) {  	int vaIndex = this.triangleIndices [i * 3];  	int vbIndex = this.triangleIndices [i * 3 + 1];  	int vcIndex = this.triangleIndices [i * 3 + 2];  	int vpIndex = this.AddEdgeVertice (vaIndex' vbIndex' vcIndex);  	int vqIndex = this.AddEdgeVertice (vbIndex' vcIndex' vaIndex);  	int vrIndex = this.AddEdgeVertice (vaIndex' vcIndex' vbIndex);  	this.Add (vaIndex' vpIndex' vrIndex);  	this.Add (vpIndex' vbIndex' vqIndex);  	this.Add (vrIndex' vqIndex' vcIndex);  	this.Add (vrIndex' vpIndex' vqIndex);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v1 = 0; v1 < nVertices - 1; v1++) {  	for (int v2 = v1; v2 < nVertices; v2++) {  		int vNIndex = this.GetEdgeVertice (v1' v2' 0);  		if (vNIndex != 0) {  			int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  			int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  			if (vNOpposite2Index == 0) {  				// boundary case  				this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  			} else {  				this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  			}  		}  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v1 = 0; v1 < nVertices - 1; v1++) {  	for (int v2 = v1; v2 < nVertices; v2++) {  		int vNIndex = this.GetEdgeVertice (v1' v2' 0);  		if (vNIndex != 0) {  			int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  			int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  			if (vNOpposite2Index == 0) {  				// boundary case  				this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  			} else {  				this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  			}  		}  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v1 = 0; v1 < nVertices - 1; v1++) {  	for (int v2 = v1; v2 < nVertices; v2++) {  		int vNIndex = this.GetEdgeVertice (v1' v2' 0);  		if (vNIndex != 0) {  			int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  			int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  			if (vNOpposite2Index == 0) {  				// boundary case  				this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  			} else {  				this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  			}  		}  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v1 = 0; v1 < nVertices - 1; v1++) {  	for (int v2 = v1; v2 < nVertices; v2++) {  		int vNIndex = this.GetEdgeVertice (v1' v2' 0);  		if (vNIndex != 0) {  			int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  			int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  			if (vNOpposite2Index == 0) {  				// boundary case  				this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  			} else {  				this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  			}  		}  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v1 = 0; v1 < nVertices - 1; v1++) {  	for (int v2 = v1; v2 < nVertices; v2++) {  		int vNIndex = this.GetEdgeVertice (v1' v2' 0);  		if (vNIndex != 0) {  			int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  			int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  			if (vNOpposite2Index == 0) {  				// boundary case  				this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  			} else {  				this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  			}  		}  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v2 = v1; v2 < nVertices; v2++) {  	int vNIndex = this.GetEdgeVertice (v1' v2' 0);  	if (vNIndex != 0) {  		int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  		int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  		if (vNOpposite2Index == 0) {  			// boundary case  			this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  		} else {  			this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v2 = v1; v2 < nVertices; v2++) {  	int vNIndex = this.GetEdgeVertice (v1' v2' 0);  	if (vNIndex != 0) {  		int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  		int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  		if (vNOpposite2Index == 0) {  			// boundary case  			this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  		} else {  			this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v2 = v1; v2 < nVertices; v2++) {  	int vNIndex = this.GetEdgeVertice (v1' v2' 0);  	if (vNIndex != 0) {  		int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  		int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  		if (vNOpposite2Index == 0) {  			// boundary case  			this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  		} else {  			this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v2 = v1; v2 < nVertices; v2++) {  	int vNIndex = this.GetEdgeVertice (v1' v2' 0);  	if (vNIndex != 0) {  		int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  		int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  		if (vNOpposite2Index == 0) {  			// boundary case  			this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  		} else {  			this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v2 = v1; v2 < nVertices; v2++) {  	int vNIndex = this.GetEdgeVertice (v1' v2' 0);  	if (vNIndex != 0) {  		int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  		int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  		if (vNOpposite2Index == 0) {  			// boundary case  			this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  		} else {  			this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (vNIndex != 0) {  	int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  	int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  	if (vNOpposite2Index == 0) {  		// boundary case  		this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  	} else {  		this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (vNIndex != 0) {  	int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  	int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  	if (vNOpposite2Index == 0) {  		// boundary case  		this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  	} else {  		this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (vNIndex != 0) {  	int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  	int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  	if (vNOpposite2Index == 0) {  		// boundary case  		this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  	} else {  		this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (vNIndex != 0) {  	int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  	int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  	if (vNOpposite2Index == 0) {  		// boundary case  		this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  	} else {  		this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (vNIndex != 0) {  	int vNOpposite1Index = this.GetEdgeVertice (v1' v2' 1);  	int vNOpposite2Index = this.GetEdgeVertice (v1' v2' 2);  	if (vNOpposite2Index == 0) {  		// boundary case  		this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  	} else {  		this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (vNOpposite2Index == 0) {  	// boundary case  	this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  } else {  	this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (vNOpposite2Index == 0) {  	// boundary case  	this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  } else {  	this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (vNOpposite2Index == 0) {  	// boundary case  	this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  } else {  	this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (vNOpposite2Index == 0) {  	// boundary case  	this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  } else {  	this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: this.newVertices [vNIndex] = 0.5 * (this.vertices [v1] + this.vertices [v2]);  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: this.newVertices [vNIndex] = 3.0 / 8 * (this.vertices [v1] + this.vertices [v2]) + (1.0 / 8) * (this.vertices [vNOpposite1Index] + this.vertices [vNOpposite2Index]);  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int v = 0; v < nVertices; v++) {  	int k = adjVertice [v].Count;  	var adjBoundaryVertices = new List<int> ();  	for (int i = 0; i < k; i++) {  		int vi = adjVertice [v] [i];  		if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  			adjBoundaryVertices.Add (vi);  		}  	}  	if (adjBoundaryVertices.Count == 2) {  		// boundary case  		this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  	} else {  		double beta;  		switch (this.Scheme) {  		case SubdivisionScheme.Warren:  			beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  			break;  		default:  			beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  			break;  		}  		this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int i = 0; i < k; i++) {  	int vi = adjVertice [v] [i];  	if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  		adjBoundaryVertices.Add (vi);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: for (int i = 0; i < k; i++) {  	int vi = adjVertice [v] [i];  	if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  		adjBoundaryVertices.Add (vi);  	}  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  	adjBoundaryVertices.Add (vi);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if ((vi > v) && (this.GetEdgeVertice (v' vi' 2) == 0) || (vi < v) && (this.GetEdgeVertice (vi' v' 2) == 0)) {  	adjBoundaryVertices.Add (vi);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: if (adjBoundaryVertices.Count == 2) {  	// boundary case  	this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  } else {  	double beta;  	switch (this.Scheme) {  	case SubdivisionScheme.Warren:  		beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  		break;  	default:  		beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  		break;  	}  	this.newVertices [v] = (1 - k * beta) * this.vertices [v] + beta * this.Sum (adjVertice [v]);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: this.newVertices [v] = 6.0 / 8 * this.vertices [v] + 1.0 / 8 * this.Sum (adjBoundaryVertices);  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: switch (this.Scheme) {  case SubdivisionScheme.Warren:  	beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  	break;  default:  	beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  	break;  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: switch (this.Scheme) {  case SubdivisionScheme.Warren:  	beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  	break;  default:  	beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  	break;  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: switch (this.Scheme) {  case SubdivisionScheme.Warren:  	beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  	break;  default:  	beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  	break;  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: switch (this.Scheme) {  case SubdivisionScheme.Warren:  	beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  	break;  default:  	beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  	break;  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: switch (this.Scheme) {  case SubdivisionScheme.Warren:  	beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  	break;  default:  	beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  	break;  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: switch (this.Scheme) {  case SubdivisionScheme.Warren:  	beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  	break;  default:  	beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  	break;  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: switch (this.Scheme) {  case SubdivisionScheme.Warren:  	beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  	break;  default:  	beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  	break;  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: switch (this.Scheme) {  case SubdivisionScheme.Warren:  	beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  	break;  default:  	beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  	break;  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: switch (this.Scheme) {  case SubdivisionScheme.Warren:  	beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  	break;  default:  	beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  	break;  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: switch (this.Scheme) {  case SubdivisionScheme.Warren:  	beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  	break;  default:  	beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  	break;  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: switch (this.Scheme) {  case SubdivisionScheme.Warren:  	beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  	break;  default:  	beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  	break;  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: beta = k > 3 ? 3.0 / 8 / k : 3.0 / 16;  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,Subdivide,The following statement contains a magic number: beta = 1.0 / k * (5.0 / 8 - this.Sqr (3.0 / 8 + 1 / 4 * Math.Cos (2 * Math.PI / k)));  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,AddEdgeVertice,The following statement contains a magic number: if (this.GetEdgeVertice (v1Index' v2Index' 0) == 0) {  	this.SetEdgeVertice (v1Index' v2Index' 0' this.newVertices.Count);  	this.SetEdgeVertice (v1Index' v2Index' 1' v3Index);  	this.newVertices.Add (new Vector3D ());  } else {  	this.SetEdgeVertice (v1Index' v2Index' 2' v3Index);  }  
Magic Number,HelixToolkit.Wpf,LoopSubdivision,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\LoopSubdivision.cs,AddEdgeVertice,The following statement contains a magic number: this.SetEdgeVertice (v1Index' v2Index' 2' v3Index);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddMoveForce,The following statement contains a magic number: this.moveSpeed += delta * 40;  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddPanForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.panSpeed += pan * 40;  } else {  	this.panHandler.Pan (pan);  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddPanForce,The following statement contains a magic number: this.panSpeed += pan * 40;  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.rotationPoint3D = this.CameraTarget;  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotationSpeed.X += dx * 40;  	this.rotationSpeed.Y += dy * 40;  } else {  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + new Vector (dx' dy)' this.CameraTarget);  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.rotationPoint3D = this.CameraTarget;  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotationSpeed.X += dx * 40;  	this.rotationSpeed.Y += dy * 40;  } else {  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + new Vector (dx' dy)' this.CameraTarget);  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.rotationPoint3D = this.CameraTarget;  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotationSpeed.X += dx * 40;  	this.rotationSpeed.Y += dy * 40;  } else {  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + new Vector (dx' dy)' this.CameraTarget);  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.rotationPoint3D = this.CameraTarget;  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotationSpeed.X += dx * 40;  	this.rotationSpeed.Y += dy * 40;  } else {  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + new Vector (dx' dy)' this.CameraTarget);  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.rotationPoint3D = this.CameraTarget;  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotationSpeed.X += dx * 40;  	this.rotationSpeed.Y += dy * 40;  } else {  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + new Vector (dx' dy)' this.CameraTarget);  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.rotationPoint3D = this.CameraTarget;  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotationSpeed.X += dx * 40;  	this.rotationSpeed.Y += dy * 40;  } else {  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + new Vector (dx' dy)' this.CameraTarget);  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationSpeed.X += dx * 40;  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationSpeed.Y += dy * 40;  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddZoomForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.zoomPoint3D = zoomOrigin;  	this.zoomSpeed += delta * 8;  } else {  	this.zoomHandler.Zoom (delta' zoomOrigin);  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,AddZoomForce,The following statement contains a magic number: this.zoomSpeed += delta * 8;  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,PushCameraSetting,The following statement contains a magic number: if (this.cameraHistory.Count > 100) {  	this.cameraHistory.RemoveFirst ();  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,ShowRectangle,The following statement contains a magic number: this.rectangleAdorner = new RectangleAdorner (this.Viewport' rect' color1' color2' 3' 1' 10' DashStyles.Solid);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,ShowRectangle,The following statement contains a magic number: this.rectangleAdorner = new RectangleAdorner (this.Viewport' rect' color1' color2' 3' 1' 10' DashStyles.Solid);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnManipulationCompleted,The following statement contains a magic number: if (this.manipulatorCount == 2) {  	this.panHandler.Completed (new ManipulationEventArgs (p));  	this.zoomHandler.Completed (new ManipulationEventArgs (p));  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (this.manipulatorCount != n) {  	// the number of manipulators has changed  	if (this.manipulatorCount == 1) {  		this.rotateHandler.Completed (new ManipulationEventArgs (position));  	}  	if (this.manipulatorCount == 2) {  		this.panHandler.Completed (new ManipulationEventArgs (position));  		this.zoomHandler.Completed (new ManipulationEventArgs (position));  	}  	if (n == 2) {  		this.panHandler.Started (new ManipulationEventArgs (position));  		this.zoomHandler.Started (new ManipulationEventArgs (e.ManipulationOrigin));  	} else {  		this.rotateHandler.Started (new ManipulationEventArgs (position));  	}  	// skip this event' the origin may have changed  	this.manipulatorCount = n;  	e.Handled = true;  	return;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (this.manipulatorCount != n) {  	// the number of manipulators has changed  	if (this.manipulatorCount == 1) {  		this.rotateHandler.Completed (new ManipulationEventArgs (position));  	}  	if (this.manipulatorCount == 2) {  		this.panHandler.Completed (new ManipulationEventArgs (position));  		this.zoomHandler.Completed (new ManipulationEventArgs (position));  	}  	if (n == 2) {  		this.panHandler.Started (new ManipulationEventArgs (position));  		this.zoomHandler.Started (new ManipulationEventArgs (e.ManipulationOrigin));  	} else {  		this.rotateHandler.Started (new ManipulationEventArgs (position));  	}  	// skip this event' the origin may have changed  	this.manipulatorCount = n;  	e.Handled = true;  	return;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (this.manipulatorCount == 2) {  	this.panHandler.Completed (new ManipulationEventArgs (position));  	this.zoomHandler.Completed (new ManipulationEventArgs (position));  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (n == 2) {  	this.panHandler.Started (new ManipulationEventArgs (position));  	this.zoomHandler.Started (new ManipulationEventArgs (e.ManipulationOrigin));  } else {  	this.rotateHandler.Started (new ManipulationEventArgs (position));  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (n == 2) {  	// two fingers pans  	this.panHandler.Delta (new ManipulationEventArgs (position));  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (this.IsTouchZoomEnabled && n == 2) {  	var zoomAroundPoint = this.zoomHandler.UnProject (e.ManipulationOrigin' this.zoomHandler.Origin' this.CameraLookDirection);  	if (zoomAroundPoint != null) {  		this.zoomHandler.Zoom (1 - (e.DeltaManipulation.Scale.Length / Math.Sqrt (2))' zoomAroundPoint.Value);  	}  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (this.IsTouchZoomEnabled && n == 2) {  	var zoomAroundPoint = this.zoomHandler.UnProject (e.ManipulationOrigin' this.zoomHandler.Origin' this.CameraLookDirection);  	if (zoomAroundPoint != null) {  		this.zoomHandler.Zoom (1 - (e.DeltaManipulation.Scale.Length / Math.Sqrt (2))' zoomAroundPoint.Value);  	}  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (zoomAroundPoint != null) {  	this.zoomHandler.Zoom (1 - (e.DeltaManipulation.Scale.Length / Math.Sqrt (2))' zoomAroundPoint.Value);  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: this.zoomHandler.Zoom (1 - (e.DeltaManipulation.Scale.Length / Math.Sqrt (2))' zoomAroundPoint.Value);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: if (!shift) {  	switch (e.Key) {  	case Key.Left:  		this.AddRotateForce (-1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddRotateForce (1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddRotateForce (0' -1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddRotateForce (0' 1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	}  } else {  	switch (e.Key) {  	case Key.Left:  		this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: if (!shift) {  	switch (e.Key) {  	case Key.Left:  		this.AddRotateForce (-1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddRotateForce (1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddRotateForce (0' -1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddRotateForce (0' 1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	}  } else {  	switch (e.Key) {  	case Key.Left:  		this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: if (!shift) {  	switch (e.Key) {  	case Key.Left:  		this.AddRotateForce (-1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddRotateForce (1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddRotateForce (0' -1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddRotateForce (0' 1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	}  } else {  	switch (e.Key) {  	case Key.Left:  		this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: if (!shift) {  	switch (e.Key) {  	case Key.Left:  		this.AddRotateForce (-1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddRotateForce (1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddRotateForce (0' -1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddRotateForce (0' 1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	}  } else {  	switch (e.Key) {  	case Key.Left:  		this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.Left:  	this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Right:  	this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Up:  	this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  case Key.Down:  	this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.Left:  	this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Right:  	this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Up:  	this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  case Key.Down:  	this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.Left:  	this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Right:  	this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Up:  	this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  case Key.Down:  	this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.Left:  	this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Right:  	this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Up:  	this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  case Key.Down:  	this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.PageUp:  	this.AddZoomForce (-0.1 * f * this.PageUpDownZoomSensitivity);  	e.Handled = true;  	break;  case Key.PageDown:  	this.AddZoomForce (0.1 * f * this.PageUpDownZoomSensitivity);  	e.Handled = true;  	break;  case Key.Back:  	if (this.RestoreCameraSetting ()) {  		e.Handled = true;  	}  	break;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.PageUp:  	this.AddZoomForce (-0.1 * f * this.PageUpDownZoomSensitivity);  	e.Handled = true;  	break;  case Key.PageDown:  	this.AddZoomForce (0.1 * f * this.PageUpDownZoomSensitivity);  	e.Handled = true;  	break;  case Key.Back:  	if (this.RestoreCameraSetting ()) {  		e.Handled = true;  	}  	break;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddZoomForce (-0.1 * f * this.PageUpDownZoomSensitivity);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddZoomForce (0.1 * f * this.PageUpDownZoomSensitivity);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.W:  	this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  	break;  case Key.A:  	this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.S:  	this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  	break;  case Key.D:  	this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.Z:  	this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  case Key.Q:  	this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.W:  	this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  	break;  case Key.A:  	this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.S:  	this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  	break;  case Key.D:  	this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.Z:  	this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  case Key.Q:  	this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.W:  	this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  	break;  case Key.A:  	this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.S:  	this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  	break;  case Key.D:  	this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.Z:  	this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  case Key.Q:  	this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.W:  	this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  	break;  case Key.A:  	this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.S:  	this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  	break;  case Key.D:  	this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.Z:  	this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  case Key.Q:  	this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.W:  	this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  	break;  case Key.A:  	this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.S:  	this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  	break;  case Key.D:  	this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.Z:  	this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  case Key.Q:  	this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.W:  	this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  	break;  case Key.A:  	this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.S:  	this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  	break;  case Key.D:  	this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.Z:  	this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  case Key.Q:  	this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnMouseWheel,The following statement contains a magic number: if (this.ZoomAroundMouseDownPoint) {  	var point = e.GetPosition (this);  	Point3D nearestPoint;  	Vector3D normal;  	DependencyObject visual;  	if (this.Viewport.FindNearest (point' out nearestPoint' out normal' out visual)) {  		this.AddZoomForce (-e.Delta * 0.001' nearestPoint);  		e.Handled = true;  		return;  	}  	var pos = this.Viewport.UnProject (point);  	if (pos.HasValue) {  		this.AddZoomForce (-e.Delta * 0.001' pos.Value);  		e.Handled = true;  		return;  	}  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnMouseWheel,The following statement contains a magic number: if (this.ZoomAroundMouseDownPoint) {  	var point = e.GetPosition (this);  	Point3D nearestPoint;  	Vector3D normal;  	DependencyObject visual;  	if (this.Viewport.FindNearest (point' out nearestPoint' out normal' out visual)) {  		this.AddZoomForce (-e.Delta * 0.001' nearestPoint);  		e.Handled = true;  		return;  	}  	var pos = this.Viewport.UnProject (point);  	if (pos.HasValue) {  		this.AddZoomForce (-e.Delta * 0.001' pos.Value);  		e.Handled = true;  		return;  	}  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnMouseWheel,The following statement contains a magic number: if (this.Viewport.FindNearest (point' out nearestPoint' out normal' out visual)) {  	this.AddZoomForce (-e.Delta * 0.001' nearestPoint);  	e.Handled = true;  	return;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnMouseWheel,The following statement contains a magic number: this.AddZoomForce (-e.Delta * 0.001' nearestPoint);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnMouseWheel,The following statement contains a magic number: if (pos.HasValue) {  	this.AddZoomForce (-e.Delta * 0.001' pos.Value);  	e.Handled = true;  	return;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnMouseWheel,The following statement contains a magic number: this.AddZoomForce (-e.Delta * 0.001' pos.Value);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnMouseWheel,The following statement contains a magic number: this.AddZoomForce (-e.Delta * 0.001);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnTimeStep,The following statement contains a magic number: factor = this.Clamp (factor' 0.2' 1);  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnTimeStep,The following statement contains a magic number: if (this.rotationSpeed.LengthSquared > 0.1) {  	this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + (this.rotationSpeed * time)' this.rotationPoint3D);  	this.rotationSpeed *= factor;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnTimeStep,The following statement contains a magic number: if (Math.Abs (this.panSpeed.LengthSquared) > 0.0001) {  	this.panHandler.Pan (this.panSpeed * time);  	this.panSpeed *= factor;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnTimeStep,The following statement contains a magic number: if (Math.Abs (this.moveSpeed.LengthSquared) > 0.0001) {  	this.zoomHandler.MoveCameraPosition (this.moveSpeed * time);  	this.moveSpeed *= factor;  }  
Magic Number,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnTimeStep,The following statement contains a magic number: if (Math.Abs (this.zoomSpeed) > 0.1) {  	this.zoomHandler.Zoom (this.zoomSpeed * time' this.zoomPoint3D);  	this.zoomSpeed *= factor;  }  
Magic Number,HelixToolkit.Wpf,WiggleView3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\Stereo\WiggleView3D.xaml.cs,OnCompositionTargetRendering,The following statement contains a magic number: if (this.watch.ElapsedMilliseconds > 1000 / this.WiggleRate) {  	this.watch.Reset ();  	this.watch.Start ();  	this.Wiggle ();  }  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,KerkytheaExporter,The following statement contains a magic number: this.LightMultiplier = 3.0;  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,KerkytheaExporter,The following statement contains a magic number: this.Threads = 2;  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,KerkytheaExporter,The following statement contains a magic number: this.ShadowColor = Color.FromArgb (255' 100' 100' 100);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,KerkytheaExporter,The following statement contains a magic number: this.ShadowColor = Color.FromArgb (255' 100' 100' 100);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,KerkytheaExporter,The following statement contains a magic number: this.ShadowColor = Color.FromArgb (255' 100' 100' 100);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,KerkytheaExporter,The following statement contains a magic number: this.ShadowColor = Color.FromArgb (255' 100' 100' 100);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,KerkytheaExporter,The following statement contains a magic number: this.LensSamples = 3;  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,KerkytheaExporter,The following statement contains a magic number: this.Width = 500;  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,KerkytheaExporter,The following statement contains a magic number: this.Height = 500;  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,KerkytheaExporter,The following statement contains a magic number: this.TextureWidth = 1024;  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,KerkytheaExporter,The following statement contains a magic number: this.TextureHeight = 1024;  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMesh,The following statement contains a magic number: for (int a = 0; a < triangles; a++) {  	int a3 = a * 3;  	int i = m.TriangleIndices [a3];  	int j = m.TriangleIndices [a3 + 1];  	int k = m.TriangleIndices [a3 + 2];  	writer.WriteStartElement ("F");  	writer.WriteAttributeString ("ijk"' string.Format ("{0} {1} {2}"' i' j' k));  	writer.WriteEndElement ();  }  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMesh,The following statement contains a magic number: for (int a = 0; a < triangles; a++) {  	int a3 = a * 3;  	int i = m.TriangleIndices [a3];  	int j = m.TriangleIndices [a3 + 1];  	int k = m.TriangleIndices [a3 + 2];  	writer.WriteStartElement ("F");  	writer.WriteAttributeString ("ijk"' string.Format ("{0} {1} {2}"' i' j' k));  	writer.WriteEndElement ();  }  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMesh,The following statement contains a magic number: writer.WriteParameter ("AA Tolerance"' 15.0);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteMetropolisLightTransport,The following statement contains a magic number: writer.WriteParameter ("Max Ray Tracing Depth"' 100);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteMetropolisLightTransport,The following statement contains a magic number: writer.WriteParameter ("Max Iterations"' 10000);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteMetropolisLightTransport,The following statement contains a magic number: writer.WriteParameter ("Seed Paths"' 50000);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteMetropolisLightTransport,The following statement contains a magic number: writer.WriteParameter ("Large Step Probability"' 0.2);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteMetropolisLightTransport,The following statement contains a magic number: writer.WriteParameter ("Max Mutation Distance"' 0.02);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteMetropolisLightTransport,The following statement contains a magic number: writer.WriteParameter ("Live Probability"' 0.7);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteMetropolisLightTransport,The following statement contains a magic number: writer.WriteParameter ("Max Consecutive Rejections"' 200);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteStandardRayTracer,The following statement contains a magic number: writer.WriteParameter ("Antialiasing Threshold"' 0.3);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteStandardRayTracer,The following statement contains a magic number: writer.WriteParameter ("Brightness Threshold"' 0.002);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteStandardRayTracer,The following statement contains a magic number: writer.WriteParameter ("Max Ray Tracing Depth"' 5);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteStandardRayTracer,The following statement contains a magic number: writer.WriteParameter ("Max Scatter Bounces"' 5);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteStandardRayTracer,The following statement contains a magic number: writer.WriteParameter ("Max Dirac Bounces"' 5);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteStandardRayTracer,The following statement contains a magic number: writer.WriteParameter ("Irradiance Precomputation"' 4);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteStandardRayTracer,The following statement contains a magic number: writer.WriteParameter ("Max Iterations"' 5);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteStandardRayTracer,The following statement contains a magic number: writer.WriteParameter ("./Sampling Criteria/Diffuse Samples"' 1024);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteStandardRayTracer,The following statement contains a magic number: writer.WriteParameter ("./Sampling Criteria/Specular Samples"' 32);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteThreadedRaytracer,The following statement contains a magic number: writer.WriteParameter ("Listening Port"' 6200);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportCamera,The following statement contains a magic number: writer.WriteParameter ("Blades"' 6);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportHeader,The following statement contains a magic number: writer.WriteParameter ("Max Objects per Cell"' 20);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportHeader,The following statement contains a magic number: writer.WriteParameter ("Instancing Switch"' 1000000);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportHeader,The following statement contains a magic number: writer.WriteParameter ("Caching Switch"' 6000000);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportHeader,The following statement contains a magic number: writer.WriteParameter ("Reverse Gamma"' 2.2);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportLight,The following statement contains a magic number: if (d != null) {  	writer.WriteParameter ("Width"' 2.0);  	writer.WriteParameter ("Height"' 2.0);  }  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportLight,The following statement contains a magic number: if (d != null) {  	writer.WriteParameter ("Width"' 2.0);  	writer.WriteParameter ("Height"' 2.0);  }  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportLight,The following statement contains a magic number: writer.WriteParameter ("Width"' 2.0);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportLight,The following statement contains a magic number: writer.WriteParameter ("Height"' 2.0);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportLight,The following statement contains a magic number: if (d != null) {  	var origin = new Point3D (-1000 * d.Direction.X' -1000 * d.Direction.Y' -1000 * d.Direction.Z);  	transform = CreateTransform (origin' d.Direction' upVector);  	writer.WriteTransform ("Frame"' transform);  }  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportLight,The following statement contains a magic number: if (d != null) {  	var origin = new Point3D (-1000 * d.Direction.X' -1000 * d.Direction.Y' -1000 * d.Direction.Z);  	transform = CreateTransform (origin' d.Direction' upVector);  	writer.WriteTransform ("Frame"' transform);  }  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportLight,The following statement contains a magic number: if (d != null) {  	var origin = new Point3D (-1000 * d.Direction.X' -1000 * d.Direction.Y' -1000 * d.Direction.Z);  	transform = CreateTransform (origin' d.Direction' upVector);  	writer.WriteTransform ("Frame"' transform);  }  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportLight,The following statement contains a magic number: writer.WriteParameter ("Focus Distance"' 4.0);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportLight,The following statement contains a magic number: writer.WriteParameter ("Radius"' 0.2);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportViewport,The following statement contains a magic number: writer.WriteParameter ("Sky Turbidity"' 2.0);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportViewport,The following statement contains a magic number: writer.WriteParameter ("Sky Luminance Gamma"' 1.2);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportViewport,The following statement contains a magic number: writer.WriteParameter ("Sky Chromaticity Gamma"' 1.8);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportViewport,The following statement contains a magic number: writer.WriteParameter ("Scatter Density"' 0.1);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ToKerkytheaString,The following statement contains a magic number: return string.Format (CultureInfo.InvariantCulture' "{0:0.######} {1:0.######} {2:0.######}"' c.R / 255.0' c.G / 255.0' c.B / 255.0);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ToKerkytheaString,The following statement contains a magic number: return string.Format (CultureInfo.InvariantCulture' "{0:0.######} {1:0.######} {2:0.######}"' c.R / 255.0' c.G / 255.0' c.B / 255.0);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ToKerkytheaString,The following statement contains a magic number: return string.Format (CultureInfo.InvariantCulture' "{0:0.######} {1:0.######} {2:0.######}"' c.R / 255.0' c.G / 255.0' c.B / 255.0);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMaterial,The following statement contains a magic number: if (d != null) {  	string texture = null;  	Color? color = null;  	double alpha = 1.0;  	if (d.Brush is SolidColorBrush) {  		color = this.GetSolidColor (d.Brush' d.Color);  		alpha = color.Value.A / 255.0;  	} else {  		texture = this.GetTexture (writer' d.Brush' name);  	}  	if (alpha > 0) {  		this.WriteWhittedMaterial (writer' string.Format ("#{0}"' weights.Count)' texture' color' null' null);  		weights.Add (alpha);  	}  	// The refractive part  	if (alpha < 1) {  		this.WriteWhittedMaterial (writer' string.Format ("#{0}"' weights.Count)' null' null' null' Colors.White);  		weights.Add (1 - alpha);  	}  }  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMaterial,The following statement contains a magic number: if (d.Brush is SolidColorBrush) {  	color = this.GetSolidColor (d.Brush' d.Color);  	alpha = color.Value.A / 255.0;  } else {  	texture = this.GetTexture (writer' d.Brush' name);  }  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMaterial,The following statement contains a magic number: alpha = color.Value.A / 255.0;  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMaterial,The following statement contains a magic number: if (s != null) {  	var color = this.GetSolidColor (s.Brush' s.Color);  	// color = Color.FromArgb((byte)(color.A * factor)' (byte)(color.R * factor)' (byte)(color.G * factor)' (byte)(color.B * factor));  	this.WriteWhittedMaterial (writer' string.Format ("#{0}"' weights.Count)' null' null' color' null' s.SpecularPower * 0.5);  	double weight = color.A / 255.0;  	weight *= 0.01;  	weights.Add (weight);  }  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMaterial,The following statement contains a magic number: if (s != null) {  	var color = this.GetSolidColor (s.Brush' s.Color);  	// color = Color.FromArgb((byte)(color.A * factor)' (byte)(color.R * factor)' (byte)(color.G * factor)' (byte)(color.B * factor));  	this.WriteWhittedMaterial (writer' string.Format ("#{0}"' weights.Count)' null' null' color' null' s.SpecularPower * 0.5);  	double weight = color.A / 255.0;  	weight *= 0.01;  	weights.Add (weight);  }  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMaterial,The following statement contains a magic number: if (s != null) {  	var color = this.GetSolidColor (s.Brush' s.Color);  	// color = Color.FromArgb((byte)(color.A * factor)' (byte)(color.R * factor)' (byte)(color.G * factor)' (byte)(color.B * factor));  	this.WriteWhittedMaterial (writer' string.Format ("#{0}"' weights.Count)' null' null' color' null' s.SpecularPower * 0.5);  	double weight = color.A / 255.0;  	weight *= 0.01;  	weights.Add (weight);  }  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMaterial,The following statement contains a magic number: this.WriteWhittedMaterial (writer' string.Format ("#{0}"' weights.Count)' null' null' color' null' s.SpecularPower * 0.5);  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,ExportMaterial,The following statement contains a magic number: weight *= 0.01;  
Magic Number,HelixToolkit.Wpf,KerkytheaExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Exporters\KerkytheaExporter.cs,WriteWhittedMaterial,The following statement contains a magic number: writer.WriteParameter ("Transmitted Shininess"' 128.0);  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [0' 2] = matrix.M13;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [0' 3] = matrix.M14;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [1' 2] = matrix.M23;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [1' 3] = matrix.M24;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [2' 0] = matrix.M31;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [2' 1] = matrix.M32;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [2' 2] = matrix.M33;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [2' 2] = matrix.M33;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [2' 3] = matrix.M34;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [2' 3] = matrix.M34;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [3' 0] = matrix.OffsetX;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [3' 1] = matrix.OffsetY;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [3' 2] = matrix.OffsetZ;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [3' 2] = matrix.OffsetZ;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [3' 3] = matrix.M44;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToArray,The following statement contains a magic number: m [3' 3] = matrix.M44;  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ToString,The following statement contains a magic number: return matrix.ConvertToString ("N" + columnWidth' 20);  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ConvertToString,The following statement contains a magic number: for (int i = 0; i < m.GetLength (0); i++) {  	for (int j = 0; j < m.GetLength (1); j++) {  		string s = string.Format (provider' formatString' m [i' j]).PadLeft (columnWidth);  		sb.Append (s);  		if (j < 3) {  			sb.Append (columnSeparator);  		}  	}  	if (i < 3) {  		sb.Append (lineSeparator);  	}  }  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ConvertToString,The following statement contains a magic number: for (int i = 0; i < m.GetLength (0); i++) {  	for (int j = 0; j < m.GetLength (1); j++) {  		string s = string.Format (provider' formatString' m [i' j]).PadLeft (columnWidth);  		sb.Append (s);  		if (j < 3) {  			sb.Append (columnSeparator);  		}  	}  	if (i < 3) {  		sb.Append (lineSeparator);  	}  }  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ConvertToString,The following statement contains a magic number: for (int j = 0; j < m.GetLength (1); j++) {  	string s = string.Format (provider' formatString' m [i' j]).PadLeft (columnWidth);  	sb.Append (s);  	if (j < 3) {  		sb.Append (columnSeparator);  	}  }  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ConvertToString,The following statement contains a magic number: if (j < 3) {  	sb.Append (columnSeparator);  }  
Magic Number,HelixToolkit.Wpf,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Matrix3DExtensions.cs,ConvertToString,The following statement contains a magic number: if (i < 3) {  	sb.Append (lineSeparator);  }  
Magic Number,HelixToolkit.Wpf,Vector3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\ExtensionMethods\Vector3DExtensions.cs,FindAnyPerpendicular,The following statement contains a magic number: if (u.LengthSquared < 1e-3) {  	u = Vector3D.CrossProduct (new Vector3D (1' 0' 0)' n);  }  
Magic Number,HelixToolkit.Wpf,LineGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\LineGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n / 2; i++) {  	var i4 = i * 4;  	indices.Add (i4 + 2);  	indices.Add (i4 + 1);  	indices.Add (i4 + 0);  	indices.Add (i4 + 2);  	indices.Add (i4 + 3);  	indices.Add (i4 + 1);  }  
Magic Number,HelixToolkit.Wpf,LineGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\LineGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n / 2; i++) {  	var i4 = i * 4;  	indices.Add (i4 + 2);  	indices.Add (i4 + 1);  	indices.Add (i4 + 0);  	indices.Add (i4 + 2);  	indices.Add (i4 + 3);  	indices.Add (i4 + 1);  }  
Magic Number,HelixToolkit.Wpf,LineGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\LineGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n / 2; i++) {  	var i4 = i * 4;  	indices.Add (i4 + 2);  	indices.Add (i4 + 1);  	indices.Add (i4 + 0);  	indices.Add (i4 + 2);  	indices.Add (i4 + 3);  	indices.Add (i4 + 1);  }  
Magic Number,HelixToolkit.Wpf,LineGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\LineGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n / 2; i++) {  	var i4 = i * 4;  	indices.Add (i4 + 2);  	indices.Add (i4 + 1);  	indices.Add (i4 + 0);  	indices.Add (i4 + 2);  	indices.Add (i4 + 3);  	indices.Add (i4 + 1);  }  
Magic Number,HelixToolkit.Wpf,LineGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\LineGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n / 2; i++) {  	var i4 = i * 4;  	indices.Add (i4 + 2);  	indices.Add (i4 + 1);  	indices.Add (i4 + 0);  	indices.Add (i4 + 2);  	indices.Add (i4 + 3);  	indices.Add (i4 + 1);  }  
Magic Number,HelixToolkit.Wpf,LineGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\LineGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add (i4 + 2);  
Magic Number,HelixToolkit.Wpf,LineGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\LineGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add (i4 + 2);  
Magic Number,HelixToolkit.Wpf,LineGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\LineGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add (i4 + 3);  
Magic Number,HelixToolkit.Wpf,LineGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\LineGeometryBuilder.cs,CreatePositions,The following statement contains a magic number: for (int i = 0; i < segmentCount; i++) {  	int startIndex = i * 2;  	var startPoint = points [startIndex];  	var endPoint = points [startIndex + 1];  	// Transform the start and end points to screen space  	var s0 = (Point4D)startPoint * this.visualToScreen;  	var s1 = (Point4D)endPoint * this.visualToScreen;  	if (clipping != null) {  		// Apply a clipping rectangle  		var x0 = s0.X / s0.W;  		var y0 = s0.Y / s0.W;  		var x1 = s1.X / s1.W;  		var y1 = s1.Y / s1.W;  		if (!clipping.ClipLine (ref x0' ref y0' ref x1' ref y1)) {  			continue;  		}  		s0.X = x0 * s0.W;  		s0.Y = y0 * s0.W;  		s1.X = x1 * s1.W;  		s1.Y = y1 * s1.W;  	}  	var lx = (s1.X / s1.W) - (s0.X / s0.W);  	var ly = (s1.Y / s1.W) - (s0.Y / s0.W);  	var l2 = (lx * lx) + (ly * ly);  	var p00 = s0;  	var p01 = s0;  	var p10 = s1;  	var p11 = s1;  	if (l2.Equals (0)) {  		// coinciding points (in world space or screen space)  		var dz = halfThickness;  		// TODO: make a square with the thickness as side length  		p00.X -= dz * p00.W;  		p00.Y -= dz * p00.W;  		p01.X -= dz * p01.W;  		p01.Y += dz * p01.W;  		p10.X += dz * p10.W;  		p10.Y -= dz * p10.W;  		p11.X += dz * p11.W;  		p11.Y += dz * p11.W;  	} else {  		var m = halfThickness / Math.Sqrt (l2);  		// the normal (dx'dy)  		var dx = -ly * m;  		var dy = lx * m;  		// segment start points  		p00.X += dx * p00.W;  		p00.Y += dy * p00.W;  		p01.X -= dx * p01.W;  		p01.Y -= dy * p01.W;  		// segment end points  		p10.X += dx * p10.W;  		p10.Y += dy * p10.W;  		p11.X -= dx * p11.W;  		p11.Y -= dy * p11.W;  	}  	if (!depthOffset.Equals (0)) {  		// Adjust the z-coordinate by the depth offset  		p00.Z -= depthOffset;  		p01.Z -= depthOffset;  		p10.Z -= depthOffset;  		p11.Z -= depthOffset;  		// Transform from screen space to world space  		p00 *= this.screenToVisual;  		p01 *= this.screenToVisual;  		p10 *= this.screenToVisual;  		p11 *= this.screenToVisual;  		positions.Add (new Point3D (p00.X / p00.W' p00.Y / p00.W' p00.Z / p00.W));  		positions.Add (new Point3D (p01.X / p00.W' p01.Y / p01.W' p01.Z / p01.W));  		positions.Add (new Point3D (p10.X / p00.W' p10.Y / p10.W' p10.Z / p10.W));  		positions.Add (new Point3D (p11.X / p00.W' p11.Y / p11.W' p11.Z / p11.W));  	} else {  		// Transform from screen space to world space  		p00 *= this.screenToVisual;  		p01 *= this.screenToVisual;  		p10 *= this.screenToVisual;  		p11 *= this.screenToVisual;  		positions.Add (new Point3D (p00.X' p00.Y' p00.Z));  		positions.Add (new Point3D (p01.X' p01.Y' p01.Z));  		positions.Add (new Point3D (p10.X' p10.Y' p10.Z));  		positions.Add (new Point3D (p11.X' p11.Y' p11.Z));  	}  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: using (var reader = new StreamReader (s)) {  	bool containsNormals = false;  	bool containsTextureCoordinates = false;  	bool containsColors = false;  	bool containsHomogeneousCoordinates = false;  	int vertexDimension = 3;  	bool nextLineContainsVertexDimension = false;  	bool nextLineContainsNumberOfVertices = false;  	int numberOfVertices = 0;  	int numberOfFaces = 0;  	while (!reader.EndOfStream) {  		var line = reader.ReadLine ();  		if (line == null) {  			break;  		}  		line = line.Trim ();  		if (line.StartsWith ("#") || line.Length == 0) {  			continue;  		}  		if (nextLineContainsVertexDimension) {  			var values = GetIntValues (line);  			vertexDimension = values [0];  			nextLineContainsVertexDimension = false;  			continue;  		}  		if (line.Contains ("OFF")) {  			containsNormals = line.Contains ("N");  			containsColors = line.Contains ("C");  			containsTextureCoordinates = line.Contains ("ST");  			if (line.Contains ("4")) {  				containsHomogeneousCoordinates = true;  			}  			if (line.Contains ("n")) {  				nextLineContainsVertexDimension = true;  			}  			nextLineContainsNumberOfVertices = true;  			continue;  		}  		if (nextLineContainsNumberOfVertices) {  			var values = GetIntValues (line);  			numberOfVertices = values [0];  			numberOfFaces = values [1];  			/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  			continue;  		}  		if (this.Vertices.Count < numberOfVertices) {  			var x = new double[vertexDimension];  			var values = GetValues (line);  			int i = 0;  			for (int j = 0; j < vertexDimension; j++) {  				x [j] = values [i++];  			}  			var n = new double[vertexDimension];  			var uv = new double[2];  			#pragma  			double w = 0;  			if (containsHomogeneousCoordinates) {  				// ReSharper disable once RedundantAssignment  				w = values [i++];  			}  			#pragma  			if (containsNormals) {  				for (int j = 0; j < vertexDimension; j++) {  					n [j] = values [i++];  				}  			}  			if (containsColors) {  				// read color  			}  			if (containsTextureCoordinates) {  				for (int j = 0; j < 2; j++) {  					uv [j] = values [i++];  				}  			}  			this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  			continue;  		}  		if (this.Faces.Count < numberOfFaces) {  			var values = GetIntValues (line);  			int nv = values [0];  			var vertices = new int[nv];  			for (int i = 0; i < nv; i++) {  				vertices [i] = values [i + 1];  			}  			if (containsColors) {  				// read colorspec  			}  			this.Faces.Add (vertices);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: using (var reader = new StreamReader (s)) {  	bool containsNormals = false;  	bool containsTextureCoordinates = false;  	bool containsColors = false;  	bool containsHomogeneousCoordinates = false;  	int vertexDimension = 3;  	bool nextLineContainsVertexDimension = false;  	bool nextLineContainsNumberOfVertices = false;  	int numberOfVertices = 0;  	int numberOfFaces = 0;  	while (!reader.EndOfStream) {  		var line = reader.ReadLine ();  		if (line == null) {  			break;  		}  		line = line.Trim ();  		if (line.StartsWith ("#") || line.Length == 0) {  			continue;  		}  		if (nextLineContainsVertexDimension) {  			var values = GetIntValues (line);  			vertexDimension = values [0];  			nextLineContainsVertexDimension = false;  			continue;  		}  		if (line.Contains ("OFF")) {  			containsNormals = line.Contains ("N");  			containsColors = line.Contains ("C");  			containsTextureCoordinates = line.Contains ("ST");  			if (line.Contains ("4")) {  				containsHomogeneousCoordinates = true;  			}  			if (line.Contains ("n")) {  				nextLineContainsVertexDimension = true;  			}  			nextLineContainsNumberOfVertices = true;  			continue;  		}  		if (nextLineContainsNumberOfVertices) {  			var values = GetIntValues (line);  			numberOfVertices = values [0];  			numberOfFaces = values [1];  			/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  			continue;  		}  		if (this.Vertices.Count < numberOfVertices) {  			var x = new double[vertexDimension];  			var values = GetValues (line);  			int i = 0;  			for (int j = 0; j < vertexDimension; j++) {  				x [j] = values [i++];  			}  			var n = new double[vertexDimension];  			var uv = new double[2];  			#pragma  			double w = 0;  			if (containsHomogeneousCoordinates) {  				// ReSharper disable once RedundantAssignment  				w = values [i++];  			}  			#pragma  			if (containsNormals) {  				for (int j = 0; j < vertexDimension; j++) {  					n [j] = values [i++];  				}  			}  			if (containsColors) {  				// read color  			}  			if (containsTextureCoordinates) {  				for (int j = 0; j < 2; j++) {  					uv [j] = values [i++];  				}  			}  			this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  			continue;  		}  		if (this.Faces.Count < numberOfFaces) {  			var values = GetIntValues (line);  			int nv = values [0];  			var vertices = new int[nv];  			for (int i = 0; i < nv; i++) {  				vertices [i] = values [i + 1];  			}  			if (containsColors) {  				// read colorspec  			}  			this.Faces.Add (vertices);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: using (var reader = new StreamReader (s)) {  	bool containsNormals = false;  	bool containsTextureCoordinates = false;  	bool containsColors = false;  	bool containsHomogeneousCoordinates = false;  	int vertexDimension = 3;  	bool nextLineContainsVertexDimension = false;  	bool nextLineContainsNumberOfVertices = false;  	int numberOfVertices = 0;  	int numberOfFaces = 0;  	while (!reader.EndOfStream) {  		var line = reader.ReadLine ();  		if (line == null) {  			break;  		}  		line = line.Trim ();  		if (line.StartsWith ("#") || line.Length == 0) {  			continue;  		}  		if (nextLineContainsVertexDimension) {  			var values = GetIntValues (line);  			vertexDimension = values [0];  			nextLineContainsVertexDimension = false;  			continue;  		}  		if (line.Contains ("OFF")) {  			containsNormals = line.Contains ("N");  			containsColors = line.Contains ("C");  			containsTextureCoordinates = line.Contains ("ST");  			if (line.Contains ("4")) {  				containsHomogeneousCoordinates = true;  			}  			if (line.Contains ("n")) {  				nextLineContainsVertexDimension = true;  			}  			nextLineContainsNumberOfVertices = true;  			continue;  		}  		if (nextLineContainsNumberOfVertices) {  			var values = GetIntValues (line);  			numberOfVertices = values [0];  			numberOfFaces = values [1];  			/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  			continue;  		}  		if (this.Vertices.Count < numberOfVertices) {  			var x = new double[vertexDimension];  			var values = GetValues (line);  			int i = 0;  			for (int j = 0; j < vertexDimension; j++) {  				x [j] = values [i++];  			}  			var n = new double[vertexDimension];  			var uv = new double[2];  			#pragma  			double w = 0;  			if (containsHomogeneousCoordinates) {  				// ReSharper disable once RedundantAssignment  				w = values [i++];  			}  			#pragma  			if (containsNormals) {  				for (int j = 0; j < vertexDimension; j++) {  					n [j] = values [i++];  				}  			}  			if (containsColors) {  				// read color  			}  			if (containsTextureCoordinates) {  				for (int j = 0; j < 2; j++) {  					uv [j] = values [i++];  				}  			}  			this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  			continue;  		}  		if (this.Faces.Count < numberOfFaces) {  			var values = GetIntValues (line);  			int nv = values [0];  			var vertices = new int[nv];  			for (int i = 0; i < nv; i++) {  				vertices [i] = values [i + 1];  			}  			if (containsColors) {  				// read colorspec  			}  			this.Faces.Add (vertices);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: using (var reader = new StreamReader (s)) {  	bool containsNormals = false;  	bool containsTextureCoordinates = false;  	bool containsColors = false;  	bool containsHomogeneousCoordinates = false;  	int vertexDimension = 3;  	bool nextLineContainsVertexDimension = false;  	bool nextLineContainsNumberOfVertices = false;  	int numberOfVertices = 0;  	int numberOfFaces = 0;  	while (!reader.EndOfStream) {  		var line = reader.ReadLine ();  		if (line == null) {  			break;  		}  		line = line.Trim ();  		if (line.StartsWith ("#") || line.Length == 0) {  			continue;  		}  		if (nextLineContainsVertexDimension) {  			var values = GetIntValues (line);  			vertexDimension = values [0];  			nextLineContainsVertexDimension = false;  			continue;  		}  		if (line.Contains ("OFF")) {  			containsNormals = line.Contains ("N");  			containsColors = line.Contains ("C");  			containsTextureCoordinates = line.Contains ("ST");  			if (line.Contains ("4")) {  				containsHomogeneousCoordinates = true;  			}  			if (line.Contains ("n")) {  				nextLineContainsVertexDimension = true;  			}  			nextLineContainsNumberOfVertices = true;  			continue;  		}  		if (nextLineContainsNumberOfVertices) {  			var values = GetIntValues (line);  			numberOfVertices = values [0];  			numberOfFaces = values [1];  			/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  			continue;  		}  		if (this.Vertices.Count < numberOfVertices) {  			var x = new double[vertexDimension];  			var values = GetValues (line);  			int i = 0;  			for (int j = 0; j < vertexDimension; j++) {  				x [j] = values [i++];  			}  			var n = new double[vertexDimension];  			var uv = new double[2];  			#pragma  			double w = 0;  			if (containsHomogeneousCoordinates) {  				// ReSharper disable once RedundantAssignment  				w = values [i++];  			}  			#pragma  			if (containsNormals) {  				for (int j = 0; j < vertexDimension; j++) {  					n [j] = values [i++];  				}  			}  			if (containsColors) {  				// read color  			}  			if (containsTextureCoordinates) {  				for (int j = 0; j < 2; j++) {  					uv [j] = values [i++];  				}  			}  			this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  			continue;  		}  		if (this.Faces.Count < numberOfFaces) {  			var values = GetIntValues (line);  			int nv = values [0];  			var vertices = new int[nv];  			for (int i = 0; i < nv; i++) {  				vertices [i] = values [i + 1];  			}  			if (containsColors) {  				// read colorspec  			}  			this.Faces.Add (vertices);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: using (var reader = new StreamReader (s)) {  	bool containsNormals = false;  	bool containsTextureCoordinates = false;  	bool containsColors = false;  	bool containsHomogeneousCoordinates = false;  	int vertexDimension = 3;  	bool nextLineContainsVertexDimension = false;  	bool nextLineContainsNumberOfVertices = false;  	int numberOfVertices = 0;  	int numberOfFaces = 0;  	while (!reader.EndOfStream) {  		var line = reader.ReadLine ();  		if (line == null) {  			break;  		}  		line = line.Trim ();  		if (line.StartsWith ("#") || line.Length == 0) {  			continue;  		}  		if (nextLineContainsVertexDimension) {  			var values = GetIntValues (line);  			vertexDimension = values [0];  			nextLineContainsVertexDimension = false;  			continue;  		}  		if (line.Contains ("OFF")) {  			containsNormals = line.Contains ("N");  			containsColors = line.Contains ("C");  			containsTextureCoordinates = line.Contains ("ST");  			if (line.Contains ("4")) {  				containsHomogeneousCoordinates = true;  			}  			if (line.Contains ("n")) {  				nextLineContainsVertexDimension = true;  			}  			nextLineContainsNumberOfVertices = true;  			continue;  		}  		if (nextLineContainsNumberOfVertices) {  			var values = GetIntValues (line);  			numberOfVertices = values [0];  			numberOfFaces = values [1];  			/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  			continue;  		}  		if (this.Vertices.Count < numberOfVertices) {  			var x = new double[vertexDimension];  			var values = GetValues (line);  			int i = 0;  			for (int j = 0; j < vertexDimension; j++) {  				x [j] = values [i++];  			}  			var n = new double[vertexDimension];  			var uv = new double[2];  			#pragma  			double w = 0;  			if (containsHomogeneousCoordinates) {  				// ReSharper disable once RedundantAssignment  				w = values [i++];  			}  			#pragma  			if (containsNormals) {  				for (int j = 0; j < vertexDimension; j++) {  					n [j] = values [i++];  				}  			}  			if (containsColors) {  				// read color  			}  			if (containsTextureCoordinates) {  				for (int j = 0; j < 2; j++) {  					uv [j] = values [i++];  				}  			}  			this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  			continue;  		}  		if (this.Faces.Count < numberOfFaces) {  			var values = GetIntValues (line);  			int nv = values [0];  			var vertices = new int[nv];  			for (int i = 0; i < nv; i++) {  				vertices [i] = values [i + 1];  			}  			if (containsColors) {  				// read colorspec  			}  			this.Faces.Add (vertices);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: using (var reader = new StreamReader (s)) {  	bool containsNormals = false;  	bool containsTextureCoordinates = false;  	bool containsColors = false;  	bool containsHomogeneousCoordinates = false;  	int vertexDimension = 3;  	bool nextLineContainsVertexDimension = false;  	bool nextLineContainsNumberOfVertices = false;  	int numberOfVertices = 0;  	int numberOfFaces = 0;  	while (!reader.EndOfStream) {  		var line = reader.ReadLine ();  		if (line == null) {  			break;  		}  		line = line.Trim ();  		if (line.StartsWith ("#") || line.Length == 0) {  			continue;  		}  		if (nextLineContainsVertexDimension) {  			var values = GetIntValues (line);  			vertexDimension = values [0];  			nextLineContainsVertexDimension = false;  			continue;  		}  		if (line.Contains ("OFF")) {  			containsNormals = line.Contains ("N");  			containsColors = line.Contains ("C");  			containsTextureCoordinates = line.Contains ("ST");  			if (line.Contains ("4")) {  				containsHomogeneousCoordinates = true;  			}  			if (line.Contains ("n")) {  				nextLineContainsVertexDimension = true;  			}  			nextLineContainsNumberOfVertices = true;  			continue;  		}  		if (nextLineContainsNumberOfVertices) {  			var values = GetIntValues (line);  			numberOfVertices = values [0];  			numberOfFaces = values [1];  			/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  			continue;  		}  		if (this.Vertices.Count < numberOfVertices) {  			var x = new double[vertexDimension];  			var values = GetValues (line);  			int i = 0;  			for (int j = 0; j < vertexDimension; j++) {  				x [j] = values [i++];  			}  			var n = new double[vertexDimension];  			var uv = new double[2];  			#pragma  			double w = 0;  			if (containsHomogeneousCoordinates) {  				// ReSharper disable once RedundantAssignment  				w = values [i++];  			}  			#pragma  			if (containsNormals) {  				for (int j = 0; j < vertexDimension; j++) {  					n [j] = values [i++];  				}  			}  			if (containsColors) {  				// read color  			}  			if (containsTextureCoordinates) {  				for (int j = 0; j < 2; j++) {  					uv [j] = values [i++];  				}  			}  			this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  			continue;  		}  		if (this.Faces.Count < numberOfFaces) {  			var values = GetIntValues (line);  			int nv = values [0];  			var vertices = new int[nv];  			for (int i = 0; i < nv; i++) {  				vertices [i] = values [i + 1];  			}  			if (containsColors) {  				// read colorspec  			}  			this.Faces.Add (vertices);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: while (!reader.EndOfStream) {  	var line = reader.ReadLine ();  	if (line == null) {  		break;  	}  	line = line.Trim ();  	if (line.StartsWith ("#") || line.Length == 0) {  		continue;  	}  	if (nextLineContainsVertexDimension) {  		var values = GetIntValues (line);  		vertexDimension = values [0];  		nextLineContainsVertexDimension = false;  		continue;  	}  	if (line.Contains ("OFF")) {  		containsNormals = line.Contains ("N");  		containsColors = line.Contains ("C");  		containsTextureCoordinates = line.Contains ("ST");  		if (line.Contains ("4")) {  			containsHomogeneousCoordinates = true;  		}  		if (line.Contains ("n")) {  			nextLineContainsVertexDimension = true;  		}  		nextLineContainsNumberOfVertices = true;  		continue;  	}  	if (nextLineContainsNumberOfVertices) {  		var values = GetIntValues (line);  		numberOfVertices = values [0];  		numberOfFaces = values [1];  		/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  		continue;  	}  	if (this.Vertices.Count < numberOfVertices) {  		var x = new double[vertexDimension];  		var values = GetValues (line);  		int i = 0;  		for (int j = 0; j < vertexDimension; j++) {  			x [j] = values [i++];  		}  		var n = new double[vertexDimension];  		var uv = new double[2];  		#pragma  		double w = 0;  		if (containsHomogeneousCoordinates) {  			// ReSharper disable once RedundantAssignment  			w = values [i++];  		}  		#pragma  		if (containsNormals) {  			for (int j = 0; j < vertexDimension; j++) {  				n [j] = values [i++];  			}  		}  		if (containsColors) {  			// read color  		}  		if (containsTextureCoordinates) {  			for (int j = 0; j < 2; j++) {  				uv [j] = values [i++];  			}  		}  		this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  		continue;  	}  	if (this.Faces.Count < numberOfFaces) {  		var values = GetIntValues (line);  		int nv = values [0];  		var vertices = new int[nv];  		for (int i = 0; i < nv; i++) {  			vertices [i] = values [i + 1];  		}  		if (containsColors) {  			// read colorspec  		}  		this.Faces.Add (vertices);  	}  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: while (!reader.EndOfStream) {  	var line = reader.ReadLine ();  	if (line == null) {  		break;  	}  	line = line.Trim ();  	if (line.StartsWith ("#") || line.Length == 0) {  		continue;  	}  	if (nextLineContainsVertexDimension) {  		var values = GetIntValues (line);  		vertexDimension = values [0];  		nextLineContainsVertexDimension = false;  		continue;  	}  	if (line.Contains ("OFF")) {  		containsNormals = line.Contains ("N");  		containsColors = line.Contains ("C");  		containsTextureCoordinates = line.Contains ("ST");  		if (line.Contains ("4")) {  			containsHomogeneousCoordinates = true;  		}  		if (line.Contains ("n")) {  			nextLineContainsVertexDimension = true;  		}  		nextLineContainsNumberOfVertices = true;  		continue;  	}  	if (nextLineContainsNumberOfVertices) {  		var values = GetIntValues (line);  		numberOfVertices = values [0];  		numberOfFaces = values [1];  		/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  		continue;  	}  	if (this.Vertices.Count < numberOfVertices) {  		var x = new double[vertexDimension];  		var values = GetValues (line);  		int i = 0;  		for (int j = 0; j < vertexDimension; j++) {  			x [j] = values [i++];  		}  		var n = new double[vertexDimension];  		var uv = new double[2];  		#pragma  		double w = 0;  		if (containsHomogeneousCoordinates) {  			// ReSharper disable once RedundantAssignment  			w = values [i++];  		}  		#pragma  		if (containsNormals) {  			for (int j = 0; j < vertexDimension; j++) {  				n [j] = values [i++];  			}  		}  		if (containsColors) {  			// read color  		}  		if (containsTextureCoordinates) {  			for (int j = 0; j < 2; j++) {  				uv [j] = values [i++];  			}  		}  		this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  		continue;  	}  	if (this.Faces.Count < numberOfFaces) {  		var values = GetIntValues (line);  		int nv = values [0];  		var vertices = new int[nv];  		for (int i = 0; i < nv; i++) {  			vertices [i] = values [i + 1];  		}  		if (containsColors) {  			// read colorspec  		}  		this.Faces.Add (vertices);  	}  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: while (!reader.EndOfStream) {  	var line = reader.ReadLine ();  	if (line == null) {  		break;  	}  	line = line.Trim ();  	if (line.StartsWith ("#") || line.Length == 0) {  		continue;  	}  	if (nextLineContainsVertexDimension) {  		var values = GetIntValues (line);  		vertexDimension = values [0];  		nextLineContainsVertexDimension = false;  		continue;  	}  	if (line.Contains ("OFF")) {  		containsNormals = line.Contains ("N");  		containsColors = line.Contains ("C");  		containsTextureCoordinates = line.Contains ("ST");  		if (line.Contains ("4")) {  			containsHomogeneousCoordinates = true;  		}  		if (line.Contains ("n")) {  			nextLineContainsVertexDimension = true;  		}  		nextLineContainsNumberOfVertices = true;  		continue;  	}  	if (nextLineContainsNumberOfVertices) {  		var values = GetIntValues (line);  		numberOfVertices = values [0];  		numberOfFaces = values [1];  		/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  		continue;  	}  	if (this.Vertices.Count < numberOfVertices) {  		var x = new double[vertexDimension];  		var values = GetValues (line);  		int i = 0;  		for (int j = 0; j < vertexDimension; j++) {  			x [j] = values [i++];  		}  		var n = new double[vertexDimension];  		var uv = new double[2];  		#pragma  		double w = 0;  		if (containsHomogeneousCoordinates) {  			// ReSharper disable once RedundantAssignment  			w = values [i++];  		}  		#pragma  		if (containsNormals) {  			for (int j = 0; j < vertexDimension; j++) {  				n [j] = values [i++];  			}  		}  		if (containsColors) {  			// read color  		}  		if (containsTextureCoordinates) {  			for (int j = 0; j < 2; j++) {  				uv [j] = values [i++];  			}  		}  		this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  		continue;  	}  	if (this.Faces.Count < numberOfFaces) {  		var values = GetIntValues (line);  		int nv = values [0];  		var vertices = new int[nv];  		for (int i = 0; i < nv; i++) {  			vertices [i] = values [i + 1];  		}  		if (containsColors) {  			// read colorspec  		}  		this.Faces.Add (vertices);  	}  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: while (!reader.EndOfStream) {  	var line = reader.ReadLine ();  	if (line == null) {  		break;  	}  	line = line.Trim ();  	if (line.StartsWith ("#") || line.Length == 0) {  		continue;  	}  	if (nextLineContainsVertexDimension) {  		var values = GetIntValues (line);  		vertexDimension = values [0];  		nextLineContainsVertexDimension = false;  		continue;  	}  	if (line.Contains ("OFF")) {  		containsNormals = line.Contains ("N");  		containsColors = line.Contains ("C");  		containsTextureCoordinates = line.Contains ("ST");  		if (line.Contains ("4")) {  			containsHomogeneousCoordinates = true;  		}  		if (line.Contains ("n")) {  			nextLineContainsVertexDimension = true;  		}  		nextLineContainsNumberOfVertices = true;  		continue;  	}  	if (nextLineContainsNumberOfVertices) {  		var values = GetIntValues (line);  		numberOfVertices = values [0];  		numberOfFaces = values [1];  		/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  		continue;  	}  	if (this.Vertices.Count < numberOfVertices) {  		var x = new double[vertexDimension];  		var values = GetValues (line);  		int i = 0;  		for (int j = 0; j < vertexDimension; j++) {  			x [j] = values [i++];  		}  		var n = new double[vertexDimension];  		var uv = new double[2];  		#pragma  		double w = 0;  		if (containsHomogeneousCoordinates) {  			// ReSharper disable once RedundantAssignment  			w = values [i++];  		}  		#pragma  		if (containsNormals) {  			for (int j = 0; j < vertexDimension; j++) {  				n [j] = values [i++];  			}  		}  		if (containsColors) {  			// read color  		}  		if (containsTextureCoordinates) {  			for (int j = 0; j < 2; j++) {  				uv [j] = values [i++];  			}  		}  		this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  		continue;  	}  	if (this.Faces.Count < numberOfFaces) {  		var values = GetIntValues (line);  		int nv = values [0];  		var vertices = new int[nv];  		for (int i = 0; i < nv; i++) {  			vertices [i] = values [i + 1];  		}  		if (containsColors) {  			// read colorspec  		}  		this.Faces.Add (vertices);  	}  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: while (!reader.EndOfStream) {  	var line = reader.ReadLine ();  	if (line == null) {  		break;  	}  	line = line.Trim ();  	if (line.StartsWith ("#") || line.Length == 0) {  		continue;  	}  	if (nextLineContainsVertexDimension) {  		var values = GetIntValues (line);  		vertexDimension = values [0];  		nextLineContainsVertexDimension = false;  		continue;  	}  	if (line.Contains ("OFF")) {  		containsNormals = line.Contains ("N");  		containsColors = line.Contains ("C");  		containsTextureCoordinates = line.Contains ("ST");  		if (line.Contains ("4")) {  			containsHomogeneousCoordinates = true;  		}  		if (line.Contains ("n")) {  			nextLineContainsVertexDimension = true;  		}  		nextLineContainsNumberOfVertices = true;  		continue;  	}  	if (nextLineContainsNumberOfVertices) {  		var values = GetIntValues (line);  		numberOfVertices = values [0];  		numberOfFaces = values [1];  		/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  		continue;  	}  	if (this.Vertices.Count < numberOfVertices) {  		var x = new double[vertexDimension];  		var values = GetValues (line);  		int i = 0;  		for (int j = 0; j < vertexDimension; j++) {  			x [j] = values [i++];  		}  		var n = new double[vertexDimension];  		var uv = new double[2];  		#pragma  		double w = 0;  		if (containsHomogeneousCoordinates) {  			// ReSharper disable once RedundantAssignment  			w = values [i++];  		}  		#pragma  		if (containsNormals) {  			for (int j = 0; j < vertexDimension; j++) {  				n [j] = values [i++];  			}  		}  		if (containsColors) {  			// read color  		}  		if (containsTextureCoordinates) {  			for (int j = 0; j < 2; j++) {  				uv [j] = values [i++];  			}  		}  		this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  		continue;  	}  	if (this.Faces.Count < numberOfFaces) {  		var values = GetIntValues (line);  		int nv = values [0];  		var vertices = new int[nv];  		for (int i = 0; i < nv; i++) {  			vertices [i] = values [i + 1];  		}  		if (containsColors) {  			// read colorspec  		}  		this.Faces.Add (vertices);  	}  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: if (this.Vertices.Count < numberOfVertices) {  	var x = new double[vertexDimension];  	var values = GetValues (line);  	int i = 0;  	for (int j = 0; j < vertexDimension; j++) {  		x [j] = values [i++];  	}  	var n = new double[vertexDimension];  	var uv = new double[2];  	#pragma  	double w = 0;  	if (containsHomogeneousCoordinates) {  		// ReSharper disable once RedundantAssignment  		w = values [i++];  	}  	#pragma  	if (containsNormals) {  		for (int j = 0; j < vertexDimension; j++) {  			n [j] = values [i++];  		}  	}  	if (containsColors) {  		// read color  	}  	if (containsTextureCoordinates) {  		for (int j = 0; j < 2; j++) {  			uv [j] = values [i++];  		}  	}  	this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  	continue;  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: if (this.Vertices.Count < numberOfVertices) {  	var x = new double[vertexDimension];  	var values = GetValues (line);  	int i = 0;  	for (int j = 0; j < vertexDimension; j++) {  		x [j] = values [i++];  	}  	var n = new double[vertexDimension];  	var uv = new double[2];  	#pragma  	double w = 0;  	if (containsHomogeneousCoordinates) {  		// ReSharper disable once RedundantAssignment  		w = values [i++];  	}  	#pragma  	if (containsNormals) {  		for (int j = 0; j < vertexDimension; j++) {  			n [j] = values [i++];  		}  	}  	if (containsColors) {  		// read color  	}  	if (containsTextureCoordinates) {  		for (int j = 0; j < 2; j++) {  			uv [j] = values [i++];  		}  	}  	this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  	continue;  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: if (this.Vertices.Count < numberOfVertices) {  	var x = new double[vertexDimension];  	var values = GetValues (line);  	int i = 0;  	for (int j = 0; j < vertexDimension; j++) {  		x [j] = values [i++];  	}  	var n = new double[vertexDimension];  	var uv = new double[2];  	#pragma  	double w = 0;  	if (containsHomogeneousCoordinates) {  		// ReSharper disable once RedundantAssignment  		w = values [i++];  	}  	#pragma  	if (containsNormals) {  		for (int j = 0; j < vertexDimension; j++) {  			n [j] = values [i++];  		}  	}  	if (containsColors) {  		// read color  	}  	if (containsTextureCoordinates) {  		for (int j = 0; j < 2; j++) {  			uv [j] = values [i++];  		}  	}  	this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  	continue;  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: if (this.Vertices.Count < numberOfVertices) {  	var x = new double[vertexDimension];  	var values = GetValues (line);  	int i = 0;  	for (int j = 0; j < vertexDimension; j++) {  		x [j] = values [i++];  	}  	var n = new double[vertexDimension];  	var uv = new double[2];  	#pragma  	double w = 0;  	if (containsHomogeneousCoordinates) {  		// ReSharper disable once RedundantAssignment  		w = values [i++];  	}  	#pragma  	if (containsNormals) {  		for (int j = 0; j < vertexDimension; j++) {  			n [j] = values [i++];  		}  	}  	if (containsColors) {  		// read color  	}  	if (containsTextureCoordinates) {  		for (int j = 0; j < 2; j++) {  			uv [j] = values [i++];  		}  	}  	this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  	continue;  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: if (this.Vertices.Count < numberOfVertices) {  	var x = new double[vertexDimension];  	var values = GetValues (line);  	int i = 0;  	for (int j = 0; j < vertexDimension; j++) {  		x [j] = values [i++];  	}  	var n = new double[vertexDimension];  	var uv = new double[2];  	#pragma  	double w = 0;  	if (containsHomogeneousCoordinates) {  		// ReSharper disable once RedundantAssignment  		w = values [i++];  	}  	#pragma  	if (containsNormals) {  		for (int j = 0; j < vertexDimension; j++) {  			n [j] = values [i++];  		}  	}  	if (containsColors) {  		// read color  	}  	if (containsTextureCoordinates) {  		for (int j = 0; j < 2; j++) {  			uv [j] = values [i++];  		}  	}  	this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  	continue;  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: if (containsTextureCoordinates) {  	for (int j = 0; j < 2; j++) {  		uv [j] = values [i++];  	}  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: for (int j = 0; j < 2; j++) {  	uv [j] = values [i++];  }  
Magic Number,HelixToolkit.Wpf,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\OffReader.cs,Load,The following statement contains a magic number: this.Vertices.Add (new Point3D (x [0]' x [1]' x [2]));  
Magic Number,HelixToolkit.Wpf,PerspectiveCameraExtension,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\MarkupExtensions\PerspectiveCameraExtension.cs,PerspectiveCameraExtension,The following statement contains a magic number: this.FieldOfView = 60;  
Magic Number,HelixToolkit.Wpf,GenericHeadLight,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\GenericHeadLight.cs,Update,The following statement contains a magic number: if (!double.IsNaN (this.Brightness)) {  	var a = (byte)(this.Brightness * 255);  	this.light.Color = Color.FromArgb (255' a' a' a);  } else {  	this.light.Color = this.Color;  }  
Magic Number,HelixToolkit.Wpf,GenericHeadLight,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\GenericHeadLight.cs,Update,The following statement contains a magic number: if (!double.IsNaN (this.Brightness)) {  	var a = (byte)(this.Brightness * 255);  	this.light.Color = Color.FromArgb (255' a' a' a);  } else {  	this.light.Color = this.Color;  }  
Magic Number,HelixToolkit.Wpf,GenericHeadLight,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\GenericHeadLight.cs,Update,The following statement contains a magic number: this.light.Color = Color.FromArgb (255' a' a' a);  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions == null) {  	positions = new Point3DCollection (alive * 4);  	textureCoordinates = new PointCollection (alive * 4);  	triangleIndices = new Int32Collection (alive * 6);  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions == null) {  	positions = new Point3DCollection (alive * 4);  	textureCoordinates = new PointCollection (alive * 4);  	triangleIndices = new Int32Collection (alive * 6);  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions == null) {  	positions = new Point3DCollection (alive * 4);  	textureCoordinates = new PointCollection (alive * 4);  	triangleIndices = new Int32Collection (alive * 6);  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: positions = new Point3DCollection (alive * 4);  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: textureCoordinates = new PointCollection (alive * 4);  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: triangleIndices = new Int32Collection (alive * 6);  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions.Count != alive * 4) {  	int previousAliveParticles = positions.Count / 4;  	// allocate positions' texture coordinates and triangle indices (to make the updating code simpler)  	AdjustListLength (positions' alive * 4);  	AdjustListLength (textureCoordinates' alive * 4);  	AdjustListLength (triangleIndices' alive * 6);  	for (int i = previousAliveParticles; i < alive; i++) {  		var i4 = i * 4;  		var i6 = i * 6;  		triangleIndices [i6] = i4;  		triangleIndices [i6 + 1] = i4 + 1;  		triangleIndices [i6 + 2] = i4 + 2;  		triangleIndices [i6 + 3] = i4 + 2;  		triangleIndices [i6 + 4] = i4 + 3;  		triangleIndices [i6 + 5] = i4;  	}  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions.Count != alive * 4) {  	int previousAliveParticles = positions.Count / 4;  	// allocate positions' texture coordinates and triangle indices (to make the updating code simpler)  	AdjustListLength (positions' alive * 4);  	AdjustListLength (textureCoordinates' alive * 4);  	AdjustListLength (triangleIndices' alive * 6);  	for (int i = previousAliveParticles; i < alive; i++) {  		var i4 = i * 4;  		var i6 = i * 6;  		triangleIndices [i6] = i4;  		triangleIndices [i6 + 1] = i4 + 1;  		triangleIndices [i6 + 2] = i4 + 2;  		triangleIndices [i6 + 3] = i4 + 2;  		triangleIndices [i6 + 4] = i4 + 3;  		triangleIndices [i6 + 5] = i4;  	}  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions.Count != alive * 4) {  	int previousAliveParticles = positions.Count / 4;  	// allocate positions' texture coordinates and triangle indices (to make the updating code simpler)  	AdjustListLength (positions' alive * 4);  	AdjustListLength (textureCoordinates' alive * 4);  	AdjustListLength (triangleIndices' alive * 6);  	for (int i = previousAliveParticles; i < alive; i++) {  		var i4 = i * 4;  		var i6 = i * 6;  		triangleIndices [i6] = i4;  		triangleIndices [i6 + 1] = i4 + 1;  		triangleIndices [i6 + 2] = i4 + 2;  		triangleIndices [i6 + 3] = i4 + 2;  		triangleIndices [i6 + 4] = i4 + 3;  		triangleIndices [i6 + 5] = i4;  	}  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions.Count != alive * 4) {  	int previousAliveParticles = positions.Count / 4;  	// allocate positions' texture coordinates and triangle indices (to make the updating code simpler)  	AdjustListLength (positions' alive * 4);  	AdjustListLength (textureCoordinates' alive * 4);  	AdjustListLength (triangleIndices' alive * 6);  	for (int i = previousAliveParticles; i < alive; i++) {  		var i4 = i * 4;  		var i6 = i * 6;  		triangleIndices [i6] = i4;  		triangleIndices [i6 + 1] = i4 + 1;  		triangleIndices [i6 + 2] = i4 + 2;  		triangleIndices [i6 + 3] = i4 + 2;  		triangleIndices [i6 + 4] = i4 + 3;  		triangleIndices [i6 + 5] = i4;  	}  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions.Count != alive * 4) {  	int previousAliveParticles = positions.Count / 4;  	// allocate positions' texture coordinates and triangle indices (to make the updating code simpler)  	AdjustListLength (positions' alive * 4);  	AdjustListLength (textureCoordinates' alive * 4);  	AdjustListLength (triangleIndices' alive * 6);  	for (int i = previousAliveParticles; i < alive; i++) {  		var i4 = i * 4;  		var i6 = i * 6;  		triangleIndices [i6] = i4;  		triangleIndices [i6 + 1] = i4 + 1;  		triangleIndices [i6 + 2] = i4 + 2;  		triangleIndices [i6 + 3] = i4 + 2;  		triangleIndices [i6 + 4] = i4 + 3;  		triangleIndices [i6 + 5] = i4;  	}  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions.Count != alive * 4) {  	int previousAliveParticles = positions.Count / 4;  	// allocate positions' texture coordinates and triangle indices (to make the updating code simpler)  	AdjustListLength (positions' alive * 4);  	AdjustListLength (textureCoordinates' alive * 4);  	AdjustListLength (triangleIndices' alive * 6);  	for (int i = previousAliveParticles; i < alive; i++) {  		var i4 = i * 4;  		var i6 = i * 6;  		triangleIndices [i6] = i4;  		triangleIndices [i6 + 1] = i4 + 1;  		triangleIndices [i6 + 2] = i4 + 2;  		triangleIndices [i6 + 3] = i4 + 2;  		triangleIndices [i6 + 4] = i4 + 3;  		triangleIndices [i6 + 5] = i4;  	}  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions.Count != alive * 4) {  	int previousAliveParticles = positions.Count / 4;  	// allocate positions' texture coordinates and triangle indices (to make the updating code simpler)  	AdjustListLength (positions' alive * 4);  	AdjustListLength (textureCoordinates' alive * 4);  	AdjustListLength (triangleIndices' alive * 6);  	for (int i = previousAliveParticles; i < alive; i++) {  		var i4 = i * 4;  		var i6 = i * 6;  		triangleIndices [i6] = i4;  		triangleIndices [i6 + 1] = i4 + 1;  		triangleIndices [i6 + 2] = i4 + 2;  		triangleIndices [i6 + 3] = i4 + 2;  		triangleIndices [i6 + 4] = i4 + 3;  		triangleIndices [i6 + 5] = i4;  	}  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions.Count != alive * 4) {  	int previousAliveParticles = positions.Count / 4;  	// allocate positions' texture coordinates and triangle indices (to make the updating code simpler)  	AdjustListLength (positions' alive * 4);  	AdjustListLength (textureCoordinates' alive * 4);  	AdjustListLength (triangleIndices' alive * 6);  	for (int i = previousAliveParticles; i < alive; i++) {  		var i4 = i * 4;  		var i6 = i * 6;  		triangleIndices [i6] = i4;  		triangleIndices [i6 + 1] = i4 + 1;  		triangleIndices [i6 + 2] = i4 + 2;  		triangleIndices [i6 + 3] = i4 + 2;  		triangleIndices [i6 + 4] = i4 + 3;  		triangleIndices [i6 + 5] = i4;  	}  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions.Count != alive * 4) {  	int previousAliveParticles = positions.Count / 4;  	// allocate positions' texture coordinates and triangle indices (to make the updating code simpler)  	AdjustListLength (positions' alive * 4);  	AdjustListLength (textureCoordinates' alive * 4);  	AdjustListLength (triangleIndices' alive * 6);  	for (int i = previousAliveParticles; i < alive; i++) {  		var i4 = i * 4;  		var i6 = i * 6;  		triangleIndices [i6] = i4;  		triangleIndices [i6 + 1] = i4 + 1;  		triangleIndices [i6 + 2] = i4 + 2;  		triangleIndices [i6 + 3] = i4 + 2;  		triangleIndices [i6 + 4] = i4 + 3;  		triangleIndices [i6 + 5] = i4;  	}  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions.Count != alive * 4) {  	int previousAliveParticles = positions.Count / 4;  	// allocate positions' texture coordinates and triangle indices (to make the updating code simpler)  	AdjustListLength (positions' alive * 4);  	AdjustListLength (textureCoordinates' alive * 4);  	AdjustListLength (triangleIndices' alive * 6);  	for (int i = previousAliveParticles; i < alive; i++) {  		var i4 = i * 4;  		var i6 = i * 6;  		triangleIndices [i6] = i4;  		triangleIndices [i6 + 1] = i4 + 1;  		triangleIndices [i6 + 2] = i4 + 2;  		triangleIndices [i6 + 3] = i4 + 2;  		triangleIndices [i6 + 4] = i4 + 3;  		triangleIndices [i6 + 5] = i4;  	}  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions.Count != alive * 4) {  	int previousAliveParticles = positions.Count / 4;  	// allocate positions' texture coordinates and triangle indices (to make the updating code simpler)  	AdjustListLength (positions' alive * 4);  	AdjustListLength (textureCoordinates' alive * 4);  	AdjustListLength (triangleIndices' alive * 6);  	for (int i = previousAliveParticles; i < alive; i++) {  		var i4 = i * 4;  		var i6 = i * 6;  		triangleIndices [i6] = i4;  		triangleIndices [i6 + 1] = i4 + 1;  		triangleIndices [i6 + 2] = i4 + 2;  		triangleIndices [i6 + 3] = i4 + 2;  		triangleIndices [i6 + 4] = i4 + 3;  		triangleIndices [i6 + 5] = i4;  	}  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions.Count != alive * 4) {  	int previousAliveParticles = positions.Count / 4;  	// allocate positions' texture coordinates and triangle indices (to make the updating code simpler)  	AdjustListLength (positions' alive * 4);  	AdjustListLength (textureCoordinates' alive * 4);  	AdjustListLength (triangleIndices' alive * 6);  	for (int i = previousAliveParticles; i < alive; i++) {  		var i4 = i * 4;  		var i6 = i * 6;  		triangleIndices [i6] = i4;  		triangleIndices [i6 + 1] = i4 + 1;  		triangleIndices [i6 + 2] = i4 + 2;  		triangleIndices [i6 + 3] = i4 + 2;  		triangleIndices [i6 + 4] = i4 + 3;  		triangleIndices [i6 + 5] = i4;  	}  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions.Count != alive * 4) {  	int previousAliveParticles = positions.Count / 4;  	// allocate positions' texture coordinates and triangle indices (to make the updating code simpler)  	AdjustListLength (positions' alive * 4);  	AdjustListLength (textureCoordinates' alive * 4);  	AdjustListLength (triangleIndices' alive * 6);  	for (int i = previousAliveParticles; i < alive; i++) {  		var i4 = i * 4;  		var i6 = i * 6;  		triangleIndices [i6] = i4;  		triangleIndices [i6 + 1] = i4 + 1;  		triangleIndices [i6 + 2] = i4 + 2;  		triangleIndices [i6 + 3] = i4 + 2;  		triangleIndices [i6 + 4] = i4 + 3;  		triangleIndices [i6 + 5] = i4;  	}  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: if (positions.Count != alive * 4) {  	int previousAliveParticles = positions.Count / 4;  	// allocate positions' texture coordinates and triangle indices (to make the updating code simpler)  	AdjustListLength (positions' alive * 4);  	AdjustListLength (textureCoordinates' alive * 4);  	AdjustListLength (triangleIndices' alive * 6);  	for (int i = previousAliveParticles; i < alive; i++) {  		var i4 = i * 4;  		var i6 = i * 6;  		triangleIndices [i6] = i4;  		triangleIndices [i6 + 1] = i4 + 1;  		triangleIndices [i6 + 2] = i4 + 2;  		triangleIndices [i6 + 3] = i4 + 2;  		triangleIndices [i6 + 4] = i4 + 3;  		triangleIndices [i6 + 5] = i4;  	}  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: AdjustListLength (positions' alive * 4);  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: AdjustListLength (textureCoordinates' alive * 4);  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: AdjustListLength (triangleIndices' alive * 6);  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: for (int i = previousAliveParticles; i < alive; i++) {  	var i4 = i * 4;  	var i6 = i * 6;  	triangleIndices [i6] = i4;  	triangleIndices [i6 + 1] = i4 + 1;  	triangleIndices [i6 + 2] = i4 + 2;  	triangleIndices [i6 + 3] = i4 + 2;  	triangleIndices [i6 + 4] = i4 + 3;  	triangleIndices [i6 + 5] = i4;  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: for (int i = previousAliveParticles; i < alive; i++) {  	var i4 = i * 4;  	var i6 = i * 6;  	triangleIndices [i6] = i4;  	triangleIndices [i6 + 1] = i4 + 1;  	triangleIndices [i6 + 2] = i4 + 2;  	triangleIndices [i6 + 3] = i4 + 2;  	triangleIndices [i6 + 4] = i4 + 3;  	triangleIndices [i6 + 5] = i4;  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: for (int i = previousAliveParticles; i < alive; i++) {  	var i4 = i * 4;  	var i6 = i * 6;  	triangleIndices [i6] = i4;  	triangleIndices [i6 + 1] = i4 + 1;  	triangleIndices [i6 + 2] = i4 + 2;  	triangleIndices [i6 + 3] = i4 + 2;  	triangleIndices [i6 + 4] = i4 + 3;  	triangleIndices [i6 + 5] = i4;  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: for (int i = previousAliveParticles; i < alive; i++) {  	var i4 = i * 4;  	var i6 = i * 6;  	triangleIndices [i6] = i4;  	triangleIndices [i6 + 1] = i4 + 1;  	triangleIndices [i6 + 2] = i4 + 2;  	triangleIndices [i6 + 3] = i4 + 2;  	triangleIndices [i6 + 4] = i4 + 3;  	triangleIndices [i6 + 5] = i4;  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: for (int i = previousAliveParticles; i < alive; i++) {  	var i4 = i * 4;  	var i6 = i * 6;  	triangleIndices [i6] = i4;  	triangleIndices [i6 + 1] = i4 + 1;  	triangleIndices [i6 + 2] = i4 + 2;  	triangleIndices [i6 + 3] = i4 + 2;  	triangleIndices [i6 + 4] = i4 + 3;  	triangleIndices [i6 + 5] = i4;  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: for (int i = previousAliveParticles; i < alive; i++) {  	var i4 = i * 4;  	var i6 = i * 6;  	triangleIndices [i6] = i4;  	triangleIndices [i6 + 1] = i4 + 1;  	triangleIndices [i6 + 2] = i4 + 2;  	triangleIndices [i6 + 3] = i4 + 2;  	triangleIndices [i6 + 4] = i4 + 3;  	triangleIndices [i6 + 5] = i4;  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: for (int i = previousAliveParticles; i < alive; i++) {  	var i4 = i * 4;  	var i6 = i * 6;  	triangleIndices [i6] = i4;  	triangleIndices [i6 + 1] = i4 + 1;  	triangleIndices [i6 + 2] = i4 + 2;  	triangleIndices [i6 + 3] = i4 + 2;  	triangleIndices [i6 + 4] = i4 + 3;  	triangleIndices [i6 + 5] = i4;  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: for (int i = previousAliveParticles; i < alive; i++) {  	var i4 = i * 4;  	var i6 = i * 6;  	triangleIndices [i6] = i4;  	triangleIndices [i6 + 1] = i4 + 1;  	triangleIndices [i6 + 2] = i4 + 2;  	triangleIndices [i6 + 3] = i4 + 2;  	triangleIndices [i6 + 4] = i4 + 3;  	triangleIndices [i6 + 5] = i4;  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: for (int i = previousAliveParticles; i < alive; i++) {  	var i4 = i * 4;  	var i6 = i * 6;  	triangleIndices [i6] = i4;  	triangleIndices [i6 + 1] = i4 + 1;  	triangleIndices [i6 + 2] = i4 + 2;  	triangleIndices [i6 + 3] = i4 + 2;  	triangleIndices [i6 + 4] = i4 + 3;  	triangleIndices [i6 + 5] = i4;  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: triangleIndices [i6 + 2] = i4 + 2;  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: triangleIndices [i6 + 2] = i4 + 2;  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: triangleIndices [i6 + 3] = i4 + 2;  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: triangleIndices [i6 + 3] = i4 + 2;  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: triangleIndices [i6 + 4] = i4 + 3;  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: triangleIndices [i6 + 4] = i4 + 3;  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: triangleIndices [i6 + 5] = i4;  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: foreach (var p in sortedParticles) {  	var halfSize = p.Size * 0.5;  	var j4 = j * 4;  	j++;  	var cos = Math.Cos (p.Rotation);  	var sin = Math.Sin (p.Rotation);  	var p0 = new Point (halfSize * (cos + sin)' halfSize * (sin - cos));  	var p1 = new Point (halfSize * (cos - sin)' halfSize * (cos + sin));  	var p2 = new Point (-halfSize * (cos + sin)' halfSize * (cos - sin));  	var p3 = new Point (halfSize * (sin - cos)' -halfSize * (cos + sin));  	var pos = p.Position;  	positions [j4] = pos + (x * p0.X) + (y * p0.Y);  	positions [j4 + 1] = pos + (x * p1.X) + (y * p1.Y);  	positions [j4 + 2] = pos + (x * p2.X) + (y * p2.Y);  	positions [j4 + 3] = pos + (x * p3.X) + (y * p3.Y);  	var opacity = 1d;  	if (fadeOutTime < 1 && p.Age > lifeTime * fadeOutTime) {  		opacity = 1 - (((p.Age / lifeTime) - fadeOutTime) / (1 - fadeOutTime));  	}  	// update the texture coordinates with the current opacity of the particle  	int transparency = (int)((1 - opacity) * this.opacityLevels);  	var u0 = (double)transparency / this.opacityLevels;  	var u1 = (transparency + 1d) / this.opacityLevels;  	textureCoordinates [j4] = new Point (u1' 1);  	textureCoordinates [j4 + 1] = new Point (u1' 0);  	textureCoordinates [j4 + 2] = new Point (u0' 0);  	textureCoordinates [j4 + 3] = new Point (u0' 1);  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: foreach (var p in sortedParticles) {  	var halfSize = p.Size * 0.5;  	var j4 = j * 4;  	j++;  	var cos = Math.Cos (p.Rotation);  	var sin = Math.Sin (p.Rotation);  	var p0 = new Point (halfSize * (cos + sin)' halfSize * (sin - cos));  	var p1 = new Point (halfSize * (cos - sin)' halfSize * (cos + sin));  	var p2 = new Point (-halfSize * (cos + sin)' halfSize * (cos - sin));  	var p3 = new Point (halfSize * (sin - cos)' -halfSize * (cos + sin));  	var pos = p.Position;  	positions [j4] = pos + (x * p0.X) + (y * p0.Y);  	positions [j4 + 1] = pos + (x * p1.X) + (y * p1.Y);  	positions [j4 + 2] = pos + (x * p2.X) + (y * p2.Y);  	positions [j4 + 3] = pos + (x * p3.X) + (y * p3.Y);  	var opacity = 1d;  	if (fadeOutTime < 1 && p.Age > lifeTime * fadeOutTime) {  		opacity = 1 - (((p.Age / lifeTime) - fadeOutTime) / (1 - fadeOutTime));  	}  	// update the texture coordinates with the current opacity of the particle  	int transparency = (int)((1 - opacity) * this.opacityLevels);  	var u0 = (double)transparency / this.opacityLevels;  	var u1 = (transparency + 1d) / this.opacityLevels;  	textureCoordinates [j4] = new Point (u1' 1);  	textureCoordinates [j4 + 1] = new Point (u1' 0);  	textureCoordinates [j4 + 2] = new Point (u0' 0);  	textureCoordinates [j4 + 3] = new Point (u0' 1);  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: foreach (var p in sortedParticles) {  	var halfSize = p.Size * 0.5;  	var j4 = j * 4;  	j++;  	var cos = Math.Cos (p.Rotation);  	var sin = Math.Sin (p.Rotation);  	var p0 = new Point (halfSize * (cos + sin)' halfSize * (sin - cos));  	var p1 = new Point (halfSize * (cos - sin)' halfSize * (cos + sin));  	var p2 = new Point (-halfSize * (cos + sin)' halfSize * (cos - sin));  	var p3 = new Point (halfSize * (sin - cos)' -halfSize * (cos + sin));  	var pos = p.Position;  	positions [j4] = pos + (x * p0.X) + (y * p0.Y);  	positions [j4 + 1] = pos + (x * p1.X) + (y * p1.Y);  	positions [j4 + 2] = pos + (x * p2.X) + (y * p2.Y);  	positions [j4 + 3] = pos + (x * p3.X) + (y * p3.Y);  	var opacity = 1d;  	if (fadeOutTime < 1 && p.Age > lifeTime * fadeOutTime) {  		opacity = 1 - (((p.Age / lifeTime) - fadeOutTime) / (1 - fadeOutTime));  	}  	// update the texture coordinates with the current opacity of the particle  	int transparency = (int)((1 - opacity) * this.opacityLevels);  	var u0 = (double)transparency / this.opacityLevels;  	var u1 = (transparency + 1d) / this.opacityLevels;  	textureCoordinates [j4] = new Point (u1' 1);  	textureCoordinates [j4 + 1] = new Point (u1' 0);  	textureCoordinates [j4 + 2] = new Point (u0' 0);  	textureCoordinates [j4 + 3] = new Point (u0' 1);  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: foreach (var p in sortedParticles) {  	var halfSize = p.Size * 0.5;  	var j4 = j * 4;  	j++;  	var cos = Math.Cos (p.Rotation);  	var sin = Math.Sin (p.Rotation);  	var p0 = new Point (halfSize * (cos + sin)' halfSize * (sin - cos));  	var p1 = new Point (halfSize * (cos - sin)' halfSize * (cos + sin));  	var p2 = new Point (-halfSize * (cos + sin)' halfSize * (cos - sin));  	var p3 = new Point (halfSize * (sin - cos)' -halfSize * (cos + sin));  	var pos = p.Position;  	positions [j4] = pos + (x * p0.X) + (y * p0.Y);  	positions [j4 + 1] = pos + (x * p1.X) + (y * p1.Y);  	positions [j4 + 2] = pos + (x * p2.X) + (y * p2.Y);  	positions [j4 + 3] = pos + (x * p3.X) + (y * p3.Y);  	var opacity = 1d;  	if (fadeOutTime < 1 && p.Age > lifeTime * fadeOutTime) {  		opacity = 1 - (((p.Age / lifeTime) - fadeOutTime) / (1 - fadeOutTime));  	}  	// update the texture coordinates with the current opacity of the particle  	int transparency = (int)((1 - opacity) * this.opacityLevels);  	var u0 = (double)transparency / this.opacityLevels;  	var u1 = (transparency + 1d) / this.opacityLevels;  	textureCoordinates [j4] = new Point (u1' 1);  	textureCoordinates [j4 + 1] = new Point (u1' 0);  	textureCoordinates [j4 + 2] = new Point (u0' 0);  	textureCoordinates [j4 + 3] = new Point (u0' 1);  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: foreach (var p in sortedParticles) {  	var halfSize = p.Size * 0.5;  	var j4 = j * 4;  	j++;  	var cos = Math.Cos (p.Rotation);  	var sin = Math.Sin (p.Rotation);  	var p0 = new Point (halfSize * (cos + sin)' halfSize * (sin - cos));  	var p1 = new Point (halfSize * (cos - sin)' halfSize * (cos + sin));  	var p2 = new Point (-halfSize * (cos + sin)' halfSize * (cos - sin));  	var p3 = new Point (halfSize * (sin - cos)' -halfSize * (cos + sin));  	var pos = p.Position;  	positions [j4] = pos + (x * p0.X) + (y * p0.Y);  	positions [j4 + 1] = pos + (x * p1.X) + (y * p1.Y);  	positions [j4 + 2] = pos + (x * p2.X) + (y * p2.Y);  	positions [j4 + 3] = pos + (x * p3.X) + (y * p3.Y);  	var opacity = 1d;  	if (fadeOutTime < 1 && p.Age > lifeTime * fadeOutTime) {  		opacity = 1 - (((p.Age / lifeTime) - fadeOutTime) / (1 - fadeOutTime));  	}  	// update the texture coordinates with the current opacity of the particle  	int transparency = (int)((1 - opacity) * this.opacityLevels);  	var u0 = (double)transparency / this.opacityLevels;  	var u1 = (transparency + 1d) / this.opacityLevels;  	textureCoordinates [j4] = new Point (u1' 1);  	textureCoordinates [j4 + 1] = new Point (u1' 0);  	textureCoordinates [j4 + 2] = new Point (u0' 0);  	textureCoordinates [j4 + 3] = new Point (u0' 1);  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: foreach (var p in sortedParticles) {  	var halfSize = p.Size * 0.5;  	var j4 = j * 4;  	j++;  	var cos = Math.Cos (p.Rotation);  	var sin = Math.Sin (p.Rotation);  	var p0 = new Point (halfSize * (cos + sin)' halfSize * (sin - cos));  	var p1 = new Point (halfSize * (cos - sin)' halfSize * (cos + sin));  	var p2 = new Point (-halfSize * (cos + sin)' halfSize * (cos - sin));  	var p3 = new Point (halfSize * (sin - cos)' -halfSize * (cos + sin));  	var pos = p.Position;  	positions [j4] = pos + (x * p0.X) + (y * p0.Y);  	positions [j4 + 1] = pos + (x * p1.X) + (y * p1.Y);  	positions [j4 + 2] = pos + (x * p2.X) + (y * p2.Y);  	positions [j4 + 3] = pos + (x * p3.X) + (y * p3.Y);  	var opacity = 1d;  	if (fadeOutTime < 1 && p.Age > lifeTime * fadeOutTime) {  		opacity = 1 - (((p.Age / lifeTime) - fadeOutTime) / (1 - fadeOutTime));  	}  	// update the texture coordinates with the current opacity of the particle  	int transparency = (int)((1 - opacity) * this.opacityLevels);  	var u0 = (double)transparency / this.opacityLevels;  	var u1 = (transparency + 1d) / this.opacityLevels;  	textureCoordinates [j4] = new Point (u1' 1);  	textureCoordinates [j4 + 1] = new Point (u1' 0);  	textureCoordinates [j4 + 2] = new Point (u0' 0);  	textureCoordinates [j4 + 3] = new Point (u0' 1);  }  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: positions [j4 + 2] = pos + (x * p2.X) + (y * p2.Y);  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: positions [j4 + 3] = pos + (x * p3.X) + (y * p3.Y);  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: textureCoordinates [j4 + 2] = new Point (u0' 0);  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,Update,The following statement contains a magic number: textureCoordinates [j4 + 3] = new Point (u0' 1);  
Magic Number,HelixToolkit.Wpf,ParticleSystem,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ParticleSystem.cs,OnCompositionTargetRendering,The following statement contains a magic number: this.Update (this.watch.ElapsedMilliseconds * 0.001);  
Magic Number,HelixToolkit.Wpf,TextGroupVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextGroupVisual3D.cs,CreateTextMaterial,The following statement contains a magic number: foreach (var item in items) {  	if (elementMap.ContainsKey (item.Text)) {  		continue;  	}  	var e = createElement (item.Text);  	e.Measure (new Size (2048' 2048));  	maxWidth = Math.Max (maxWidth' e.DesiredSize.Width);  	elementMap [item.Text] = e;  	panel.Children.Add (e);  }  
Magic Number,HelixToolkit.Wpf,TextGroupVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextGroupVisual3D.cs,CreateTextMaterial,The following statement contains a magic number: foreach (var item in items) {  	if (elementMap.ContainsKey (item.Text)) {  		continue;  	}  	var e = createElement (item.Text);  	e.Measure (new Size (2048' 2048));  	maxWidth = Math.Max (maxWidth' e.DesiredSize.Width);  	elementMap [item.Text] = e;  	panel.Children.Add (e);  }  
Magic Number,HelixToolkit.Wpf,TextGroupVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextGroupVisual3D.cs,CreateTextMaterial,The following statement contains a magic number: e.Measure (new Size (2048' 2048));  
Magic Number,HelixToolkit.Wpf,TextGroupVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextGroupVisual3D.cs,CreateTextMaterial,The following statement contains a magic number: e.Measure (new Size (2048' 2048));  
Magic Number,HelixToolkit.Wpf,TextGroupVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextGroupVisual3D.cs,OptimizeSize,The following statement contains a magic number: for (width = minWidth; width < maxWidth; width += 50) {  	panel.Measure (new Size (width' width + 1));  	if (panel.DesiredSize.Height <= width) {  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,TextGroupVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextGroupVisual3D.cs,OptimizeSize,The following statement contains a magic number: width += 50
Magic Number,HelixToolkit.Wpf,TextGroupVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextGroupVisual3D.cs,VisualChanged,The following statement contains a magic number: while (items.Count > 0) {  	Dictionary<string' FrameworkElement> elementMap;  	Dictionary<FrameworkElement' Rect> elementPositions;  	var material = CreateTextMaterial (items' this.CreateElement' this.Background' out elementMap' out elementPositions);  	var builder = new MeshBuilder (false' true);  	var addedChildren = new List<SpatialTextItem> ();  	foreach (var item in items) {  		var element = elementMap [item.Text];  		var r = elementPositions [element];  		double u0 = r.Left;  		double v0 = r.Top;  		double u1 = r.Right;  		double v1 = r.Bottom;  		if (v1 > 1) {  			break;  		}  		if (this.IsFlipped) {  			var tmp = u0;  			u0 = u1;  			u1 = tmp;  		}  		// Set horizontal alignment factor  		var xa = -0.5;  		if (item.HorizontalAlignment == HorizontalAlignment.Left) {  			xa = 0;  		}  		if (item.HorizontalAlignment == HorizontalAlignment.Right) {  			xa = -1;  		}  		// Set vertical alignment factor  		var ya = -0.5;  		if (item.VerticalAlignment == VerticalAlignment.Top) {  			ya = -1;  		}  		if (item.VerticalAlignment == VerticalAlignment.Bottom) {  			ya = 0;  		}  		var position = item.Position;  		var textDirection = item.TextDirection;  		var upDirection = item.UpDirection;  		var height = this.Height;  		var width = this.Height / element.ActualHeight * element.ActualWidth;  		var p0 = position + ((xa * width) * textDirection) + ((ya * height) * upDirection);  		var p1 = p0 + (textDirection * width);  		var p2 = p0 + (upDirection * height) + (textDirection * width);  		var p3 = p0 + (upDirection * height);  		builder.AddQuad (p0' p1' p2' p3' new Point (u0' v1)' new Point (u1' v1)' new Point (u1' v0)' new Point (u0' v0));  		if (this.IsDoubleSided) {  			builder.AddQuad (p1' p0' p3' p2' new Point (u0' v1)' new Point (u1' v1)' new Point (u1' v0)' new Point (u0' v0));  		}  		addedChildren.Add (item);  	}  	var mg = builder.ToMesh ();  	group.Children.Add (new GeometryModel3D (mg' material));  	foreach (var c in addedChildren) {  		items.Remove (c);  	}  }  
Magic Number,HelixToolkit.Wpf,TextGroupVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextGroupVisual3D.cs,VisualChanged,The following statement contains a magic number: while (items.Count > 0) {  	Dictionary<string' FrameworkElement> elementMap;  	Dictionary<FrameworkElement' Rect> elementPositions;  	var material = CreateTextMaterial (items' this.CreateElement' this.Background' out elementMap' out elementPositions);  	var builder = new MeshBuilder (false' true);  	var addedChildren = new List<SpatialTextItem> ();  	foreach (var item in items) {  		var element = elementMap [item.Text];  		var r = elementPositions [element];  		double u0 = r.Left;  		double v0 = r.Top;  		double u1 = r.Right;  		double v1 = r.Bottom;  		if (v1 > 1) {  			break;  		}  		if (this.IsFlipped) {  			var tmp = u0;  			u0 = u1;  			u1 = tmp;  		}  		// Set horizontal alignment factor  		var xa = -0.5;  		if (item.HorizontalAlignment == HorizontalAlignment.Left) {  			xa = 0;  		}  		if (item.HorizontalAlignment == HorizontalAlignment.Right) {  			xa = -1;  		}  		// Set vertical alignment factor  		var ya = -0.5;  		if (item.VerticalAlignment == VerticalAlignment.Top) {  			ya = -1;  		}  		if (item.VerticalAlignment == VerticalAlignment.Bottom) {  			ya = 0;  		}  		var position = item.Position;  		var textDirection = item.TextDirection;  		var upDirection = item.UpDirection;  		var height = this.Height;  		var width = this.Height / element.ActualHeight * element.ActualWidth;  		var p0 = position + ((xa * width) * textDirection) + ((ya * height) * upDirection);  		var p1 = p0 + (textDirection * width);  		var p2 = p0 + (upDirection * height) + (textDirection * width);  		var p3 = p0 + (upDirection * height);  		builder.AddQuad (p0' p1' p2' p3' new Point (u0' v1)' new Point (u1' v1)' new Point (u1' v0)' new Point (u0' v0));  		if (this.IsDoubleSided) {  			builder.AddQuad (p1' p0' p3' p2' new Point (u0' v1)' new Point (u1' v1)' new Point (u1' v0)' new Point (u0' v0));  		}  		addedChildren.Add (item);  	}  	var mg = builder.ToMesh ();  	group.Children.Add (new GeometryModel3D (mg' material));  	foreach (var c in addedChildren) {  		items.Remove (c);  	}  }  
Magic Number,HelixToolkit.Wpf,TextGroupVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextGroupVisual3D.cs,VisualChanged,The following statement contains a magic number: foreach (var item in items) {  	var element = elementMap [item.Text];  	var r = elementPositions [element];  	double u0 = r.Left;  	double v0 = r.Top;  	double u1 = r.Right;  	double v1 = r.Bottom;  	if (v1 > 1) {  		break;  	}  	if (this.IsFlipped) {  		var tmp = u0;  		u0 = u1;  		u1 = tmp;  	}  	// Set horizontal alignment factor  	var xa = -0.5;  	if (item.HorizontalAlignment == HorizontalAlignment.Left) {  		xa = 0;  	}  	if (item.HorizontalAlignment == HorizontalAlignment.Right) {  		xa = -1;  	}  	// Set vertical alignment factor  	var ya = -0.5;  	if (item.VerticalAlignment == VerticalAlignment.Top) {  		ya = -1;  	}  	if (item.VerticalAlignment == VerticalAlignment.Bottom) {  		ya = 0;  	}  	var position = item.Position;  	var textDirection = item.TextDirection;  	var upDirection = item.UpDirection;  	var height = this.Height;  	var width = this.Height / element.ActualHeight * element.ActualWidth;  	var p0 = position + ((xa * width) * textDirection) + ((ya * height) * upDirection);  	var p1 = p0 + (textDirection * width);  	var p2 = p0 + (upDirection * height) + (textDirection * width);  	var p3 = p0 + (upDirection * height);  	builder.AddQuad (p0' p1' p2' p3' new Point (u0' v1)' new Point (u1' v1)' new Point (u1' v0)' new Point (u0' v0));  	if (this.IsDoubleSided) {  		builder.AddQuad (p1' p0' p3' p2' new Point (u0' v1)' new Point (u1' v1)' new Point (u1' v0)' new Point (u0' v0));  	}  	addedChildren.Add (item);  }  
Magic Number,HelixToolkit.Wpf,TextGroupVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextGroupVisual3D.cs,VisualChanged,The following statement contains a magic number: foreach (var item in items) {  	var element = elementMap [item.Text];  	var r = elementPositions [element];  	double u0 = r.Left;  	double v0 = r.Top;  	double u1 = r.Right;  	double v1 = r.Bottom;  	if (v1 > 1) {  		break;  	}  	if (this.IsFlipped) {  		var tmp = u0;  		u0 = u1;  		u1 = tmp;  	}  	// Set horizontal alignment factor  	var xa = -0.5;  	if (item.HorizontalAlignment == HorizontalAlignment.Left) {  		xa = 0;  	}  	if (item.HorizontalAlignment == HorizontalAlignment.Right) {  		xa = -1;  	}  	// Set vertical alignment factor  	var ya = -0.5;  	if (item.VerticalAlignment == VerticalAlignment.Top) {  		ya = -1;  	}  	if (item.VerticalAlignment == VerticalAlignment.Bottom) {  		ya = 0;  	}  	var position = item.Position;  	var textDirection = item.TextDirection;  	var upDirection = item.UpDirection;  	var height = this.Height;  	var width = this.Height / element.ActualHeight * element.ActualWidth;  	var p0 = position + ((xa * width) * textDirection) + ((ya * height) * upDirection);  	var p1 = p0 + (textDirection * width);  	var p2 = p0 + (upDirection * height) + (textDirection * width);  	var p3 = p0 + (upDirection * height);  	builder.AddQuad (p0' p1' p2' p3' new Point (u0' v1)' new Point (u1' v1)' new Point (u1' v0)' new Point (u0' v0));  	if (this.IsDoubleSided) {  		builder.AddQuad (p1' p0' p3' p2' new Point (u0' v1)' new Point (u1' v1)' new Point (u1' v0)' new Point (u0' v0));  	}  	addedChildren.Add (item);  }  
Magic Number,HelixToolkit.Wpf,MeshVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\MeshVisual3D.cs,UpdateVisuals,The following statement contains a magic number: if (this.EdgeDiameter > 0) {  	var em = new MeshBuilder (false' false);  	//// int fi = 0;  	foreach (var p in this.Mesh.Faces) {  		//// var n = this.Mesh.GetFaceNormal(fi++);  		for (int i = 0; i < p.Length; i += 1) {  			var p0 = this.Mesh.Vertices [p [i]];  			var p1 = this.Mesh.Vertices [p [(i + 1) % p.Length]];  			em.AddCylinder (p0' p1' this.EdgeDiameter' 4);  		}  	}  	m.Children.Add (new GeometryModel3D (em.ToMesh ()' this.EdgeMaterial));  }  
Magic Number,HelixToolkit.Wpf,MeshVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\MeshVisual3D.cs,UpdateVisuals,The following statement contains a magic number: foreach (var p in this.Mesh.Faces) {  	//// var n = this.Mesh.GetFaceNormal(fi++);  	for (int i = 0; i < p.Length; i += 1) {  		var p0 = this.Mesh.Vertices [p [i]];  		var p1 = this.Mesh.Vertices [p [(i + 1) % p.Length]];  		em.AddCylinder (p0' p1' this.EdgeDiameter' 4);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\MeshVisual3D.cs,UpdateVisuals,The following statement contains a magic number: for (int i = 0; i < p.Length; i += 1) {  	var p0 = this.Mesh.Vertices [p [i]];  	var p1 = this.Mesh.Vertices [p [(i + 1) % p.Length]];  	em.AddCylinder (p0' p1' this.EdgeDiameter' 4);  }  
Magic Number,HelixToolkit.Wpf,MeshVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\MeshVisual3D.cs,UpdateVisuals,The following statement contains a magic number: em.AddCylinder (p0' p1' this.EdgeDiameter' 4);  
Magic Number,HelixToolkit.Wpf,LightSetup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\LightSetup.cs,OnShowLightsChanged,The following statement contains a magic number: if (this.ShowLights) {  	foreach (var light in this.lightGroup.Children) {  		var pl = light as PointLight;  		if (pl != null) {  			var sphere = new SphereVisual3D ();  			sphere.BeginEdit ();  			sphere.Center = pl.Position;  			sphere.Radius = 1.0;  			sphere.Fill = new SolidColorBrush (pl.Color);  			sphere.EndEdit ();  			this.lightsVisual.Children.Add (sphere);  		}  		var dl = light as DirectionalLight;  		if (dl != null) {  			var dir = dl.Direction;  			dir.Normalize ();  			var target = new Point3D (0' 0' 0);  			var source = target - (dir * 20);  			var p2 = source + (dir * 10);  			var sphere = new SphereVisual3D ();  			sphere.BeginEdit ();  			sphere.Center = source;  			sphere.Radius = 1.0;  			sphere.Fill = new SolidColorBrush (dl.Color);  			sphere.EndEdit ();  			this.lightsVisual.Children.Add (sphere);  			var arrow = new ArrowVisual3D ();  			arrow.BeginEdit ();  			arrow.Point1 = source;  			arrow.Point2 = p2;  			arrow.Diameter = 0.5;  			arrow.Fill = new SolidColorBrush (dl.Color);  			arrow.EndEdit ();  			this.lightsVisual.Children.Add (arrow);  		}  		var al = light as AmbientLight;  		if (al != null) {  			var pos = new Point3D (0' 0' 20);  			this.lightsVisual.Children.Add (new CubeVisual3D {  				Center = pos'  				SideLength = 1.0'  				Fill = new SolidColorBrush (al.Color)  			});  		}  	}  }  
Magic Number,HelixToolkit.Wpf,LightSetup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\LightSetup.cs,OnShowLightsChanged,The following statement contains a magic number: if (this.ShowLights) {  	foreach (var light in this.lightGroup.Children) {  		var pl = light as PointLight;  		if (pl != null) {  			var sphere = new SphereVisual3D ();  			sphere.BeginEdit ();  			sphere.Center = pl.Position;  			sphere.Radius = 1.0;  			sphere.Fill = new SolidColorBrush (pl.Color);  			sphere.EndEdit ();  			this.lightsVisual.Children.Add (sphere);  		}  		var dl = light as DirectionalLight;  		if (dl != null) {  			var dir = dl.Direction;  			dir.Normalize ();  			var target = new Point3D (0' 0' 0);  			var source = target - (dir * 20);  			var p2 = source + (dir * 10);  			var sphere = new SphereVisual3D ();  			sphere.BeginEdit ();  			sphere.Center = source;  			sphere.Radius = 1.0;  			sphere.Fill = new SolidColorBrush (dl.Color);  			sphere.EndEdit ();  			this.lightsVisual.Children.Add (sphere);  			var arrow = new ArrowVisual3D ();  			arrow.BeginEdit ();  			arrow.Point1 = source;  			arrow.Point2 = p2;  			arrow.Diameter = 0.5;  			arrow.Fill = new SolidColorBrush (dl.Color);  			arrow.EndEdit ();  			this.lightsVisual.Children.Add (arrow);  		}  		var al = light as AmbientLight;  		if (al != null) {  			var pos = new Point3D (0' 0' 20);  			this.lightsVisual.Children.Add (new CubeVisual3D {  				Center = pos'  				SideLength = 1.0'  				Fill = new SolidColorBrush (al.Color)  			});  		}  	}  }  
Magic Number,HelixToolkit.Wpf,LightSetup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\LightSetup.cs,OnShowLightsChanged,The following statement contains a magic number: if (this.ShowLights) {  	foreach (var light in this.lightGroup.Children) {  		var pl = light as PointLight;  		if (pl != null) {  			var sphere = new SphereVisual3D ();  			sphere.BeginEdit ();  			sphere.Center = pl.Position;  			sphere.Radius = 1.0;  			sphere.Fill = new SolidColorBrush (pl.Color);  			sphere.EndEdit ();  			this.lightsVisual.Children.Add (sphere);  		}  		var dl = light as DirectionalLight;  		if (dl != null) {  			var dir = dl.Direction;  			dir.Normalize ();  			var target = new Point3D (0' 0' 0);  			var source = target - (dir * 20);  			var p2 = source + (dir * 10);  			var sphere = new SphereVisual3D ();  			sphere.BeginEdit ();  			sphere.Center = source;  			sphere.Radius = 1.0;  			sphere.Fill = new SolidColorBrush (dl.Color);  			sphere.EndEdit ();  			this.lightsVisual.Children.Add (sphere);  			var arrow = new ArrowVisual3D ();  			arrow.BeginEdit ();  			arrow.Point1 = source;  			arrow.Point2 = p2;  			arrow.Diameter = 0.5;  			arrow.Fill = new SolidColorBrush (dl.Color);  			arrow.EndEdit ();  			this.lightsVisual.Children.Add (arrow);  		}  		var al = light as AmbientLight;  		if (al != null) {  			var pos = new Point3D (0' 0' 20);  			this.lightsVisual.Children.Add (new CubeVisual3D {  				Center = pos'  				SideLength = 1.0'  				Fill = new SolidColorBrush (al.Color)  			});  		}  	}  }  
Magic Number,HelixToolkit.Wpf,LightSetup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\LightSetup.cs,OnShowLightsChanged,The following statement contains a magic number: if (this.ShowLights) {  	foreach (var light in this.lightGroup.Children) {  		var pl = light as PointLight;  		if (pl != null) {  			var sphere = new SphereVisual3D ();  			sphere.BeginEdit ();  			sphere.Center = pl.Position;  			sphere.Radius = 1.0;  			sphere.Fill = new SolidColorBrush (pl.Color);  			sphere.EndEdit ();  			this.lightsVisual.Children.Add (sphere);  		}  		var dl = light as DirectionalLight;  		if (dl != null) {  			var dir = dl.Direction;  			dir.Normalize ();  			var target = new Point3D (0' 0' 0);  			var source = target - (dir * 20);  			var p2 = source + (dir * 10);  			var sphere = new SphereVisual3D ();  			sphere.BeginEdit ();  			sphere.Center = source;  			sphere.Radius = 1.0;  			sphere.Fill = new SolidColorBrush (dl.Color);  			sphere.EndEdit ();  			this.lightsVisual.Children.Add (sphere);  			var arrow = new ArrowVisual3D ();  			arrow.BeginEdit ();  			arrow.Point1 = source;  			arrow.Point2 = p2;  			arrow.Diameter = 0.5;  			arrow.Fill = new SolidColorBrush (dl.Color);  			arrow.EndEdit ();  			this.lightsVisual.Children.Add (arrow);  		}  		var al = light as AmbientLight;  		if (al != null) {  			var pos = new Point3D (0' 0' 20);  			this.lightsVisual.Children.Add (new CubeVisual3D {  				Center = pos'  				SideLength = 1.0'  				Fill = new SolidColorBrush (al.Color)  			});  		}  	}  }  
Magic Number,HelixToolkit.Wpf,LightSetup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\LightSetup.cs,OnShowLightsChanged,The following statement contains a magic number: foreach (var light in this.lightGroup.Children) {  	var pl = light as PointLight;  	if (pl != null) {  		var sphere = new SphereVisual3D ();  		sphere.BeginEdit ();  		sphere.Center = pl.Position;  		sphere.Radius = 1.0;  		sphere.Fill = new SolidColorBrush (pl.Color);  		sphere.EndEdit ();  		this.lightsVisual.Children.Add (sphere);  	}  	var dl = light as DirectionalLight;  	if (dl != null) {  		var dir = dl.Direction;  		dir.Normalize ();  		var target = new Point3D (0' 0' 0);  		var source = target - (dir * 20);  		var p2 = source + (dir * 10);  		var sphere = new SphereVisual3D ();  		sphere.BeginEdit ();  		sphere.Center = source;  		sphere.Radius = 1.0;  		sphere.Fill = new SolidColorBrush (dl.Color);  		sphere.EndEdit ();  		this.lightsVisual.Children.Add (sphere);  		var arrow = new ArrowVisual3D ();  		arrow.BeginEdit ();  		arrow.Point1 = source;  		arrow.Point2 = p2;  		arrow.Diameter = 0.5;  		arrow.Fill = new SolidColorBrush (dl.Color);  		arrow.EndEdit ();  		this.lightsVisual.Children.Add (arrow);  	}  	var al = light as AmbientLight;  	if (al != null) {  		var pos = new Point3D (0' 0' 20);  		this.lightsVisual.Children.Add (new CubeVisual3D {  			Center = pos'  			SideLength = 1.0'  			Fill = new SolidColorBrush (al.Color)  		});  	}  }  
Magic Number,HelixToolkit.Wpf,LightSetup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\LightSetup.cs,OnShowLightsChanged,The following statement contains a magic number: foreach (var light in this.lightGroup.Children) {  	var pl = light as PointLight;  	if (pl != null) {  		var sphere = new SphereVisual3D ();  		sphere.BeginEdit ();  		sphere.Center = pl.Position;  		sphere.Radius = 1.0;  		sphere.Fill = new SolidColorBrush (pl.Color);  		sphere.EndEdit ();  		this.lightsVisual.Children.Add (sphere);  	}  	var dl = light as DirectionalLight;  	if (dl != null) {  		var dir = dl.Direction;  		dir.Normalize ();  		var target = new Point3D (0' 0' 0);  		var source = target - (dir * 20);  		var p2 = source + (dir * 10);  		var sphere = new SphereVisual3D ();  		sphere.BeginEdit ();  		sphere.Center = source;  		sphere.Radius = 1.0;  		sphere.Fill = new SolidColorBrush (dl.Color);  		sphere.EndEdit ();  		this.lightsVisual.Children.Add (sphere);  		var arrow = new ArrowVisual3D ();  		arrow.BeginEdit ();  		arrow.Point1 = source;  		arrow.Point2 = p2;  		arrow.Diameter = 0.5;  		arrow.Fill = new SolidColorBrush (dl.Color);  		arrow.EndEdit ();  		this.lightsVisual.Children.Add (arrow);  	}  	var al = light as AmbientLight;  	if (al != null) {  		var pos = new Point3D (0' 0' 20);  		this.lightsVisual.Children.Add (new CubeVisual3D {  			Center = pos'  			SideLength = 1.0'  			Fill = new SolidColorBrush (al.Color)  		});  	}  }  
Magic Number,HelixToolkit.Wpf,LightSetup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\LightSetup.cs,OnShowLightsChanged,The following statement contains a magic number: foreach (var light in this.lightGroup.Children) {  	var pl = light as PointLight;  	if (pl != null) {  		var sphere = new SphereVisual3D ();  		sphere.BeginEdit ();  		sphere.Center = pl.Position;  		sphere.Radius = 1.0;  		sphere.Fill = new SolidColorBrush (pl.Color);  		sphere.EndEdit ();  		this.lightsVisual.Children.Add (sphere);  	}  	var dl = light as DirectionalLight;  	if (dl != null) {  		var dir = dl.Direction;  		dir.Normalize ();  		var target = new Point3D (0' 0' 0);  		var source = target - (dir * 20);  		var p2 = source + (dir * 10);  		var sphere = new SphereVisual3D ();  		sphere.BeginEdit ();  		sphere.Center = source;  		sphere.Radius = 1.0;  		sphere.Fill = new SolidColorBrush (dl.Color);  		sphere.EndEdit ();  		this.lightsVisual.Children.Add (sphere);  		var arrow = new ArrowVisual3D ();  		arrow.BeginEdit ();  		arrow.Point1 = source;  		arrow.Point2 = p2;  		arrow.Diameter = 0.5;  		arrow.Fill = new SolidColorBrush (dl.Color);  		arrow.EndEdit ();  		this.lightsVisual.Children.Add (arrow);  	}  	var al = light as AmbientLight;  	if (al != null) {  		var pos = new Point3D (0' 0' 20);  		this.lightsVisual.Children.Add (new CubeVisual3D {  			Center = pos'  			SideLength = 1.0'  			Fill = new SolidColorBrush (al.Color)  		});  	}  }  
Magic Number,HelixToolkit.Wpf,LightSetup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\LightSetup.cs,OnShowLightsChanged,The following statement contains a magic number: foreach (var light in this.lightGroup.Children) {  	var pl = light as PointLight;  	if (pl != null) {  		var sphere = new SphereVisual3D ();  		sphere.BeginEdit ();  		sphere.Center = pl.Position;  		sphere.Radius = 1.0;  		sphere.Fill = new SolidColorBrush (pl.Color);  		sphere.EndEdit ();  		this.lightsVisual.Children.Add (sphere);  	}  	var dl = light as DirectionalLight;  	if (dl != null) {  		var dir = dl.Direction;  		dir.Normalize ();  		var target = new Point3D (0' 0' 0);  		var source = target - (dir * 20);  		var p2 = source + (dir * 10);  		var sphere = new SphereVisual3D ();  		sphere.BeginEdit ();  		sphere.Center = source;  		sphere.Radius = 1.0;  		sphere.Fill = new SolidColorBrush (dl.Color);  		sphere.EndEdit ();  		this.lightsVisual.Children.Add (sphere);  		var arrow = new ArrowVisual3D ();  		arrow.BeginEdit ();  		arrow.Point1 = source;  		arrow.Point2 = p2;  		arrow.Diameter = 0.5;  		arrow.Fill = new SolidColorBrush (dl.Color);  		arrow.EndEdit ();  		this.lightsVisual.Children.Add (arrow);  	}  	var al = light as AmbientLight;  	if (al != null) {  		var pos = new Point3D (0' 0' 20);  		this.lightsVisual.Children.Add (new CubeVisual3D {  			Center = pos'  			SideLength = 1.0'  			Fill = new SolidColorBrush (al.Color)  		});  	}  }  
Magic Number,HelixToolkit.Wpf,LightSetup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\LightSetup.cs,OnShowLightsChanged,The following statement contains a magic number: if (dl != null) {  	var dir = dl.Direction;  	dir.Normalize ();  	var target = new Point3D (0' 0' 0);  	var source = target - (dir * 20);  	var p2 = source + (dir * 10);  	var sphere = new SphereVisual3D ();  	sphere.BeginEdit ();  	sphere.Center = source;  	sphere.Radius = 1.0;  	sphere.Fill = new SolidColorBrush (dl.Color);  	sphere.EndEdit ();  	this.lightsVisual.Children.Add (sphere);  	var arrow = new ArrowVisual3D ();  	arrow.BeginEdit ();  	arrow.Point1 = source;  	arrow.Point2 = p2;  	arrow.Diameter = 0.5;  	arrow.Fill = new SolidColorBrush (dl.Color);  	arrow.EndEdit ();  	this.lightsVisual.Children.Add (arrow);  }  
Magic Number,HelixToolkit.Wpf,LightSetup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\LightSetup.cs,OnShowLightsChanged,The following statement contains a magic number: if (dl != null) {  	var dir = dl.Direction;  	dir.Normalize ();  	var target = new Point3D (0' 0' 0);  	var source = target - (dir * 20);  	var p2 = source + (dir * 10);  	var sphere = new SphereVisual3D ();  	sphere.BeginEdit ();  	sphere.Center = source;  	sphere.Radius = 1.0;  	sphere.Fill = new SolidColorBrush (dl.Color);  	sphere.EndEdit ();  	this.lightsVisual.Children.Add (sphere);  	var arrow = new ArrowVisual3D ();  	arrow.BeginEdit ();  	arrow.Point1 = source;  	arrow.Point2 = p2;  	arrow.Diameter = 0.5;  	arrow.Fill = new SolidColorBrush (dl.Color);  	arrow.EndEdit ();  	this.lightsVisual.Children.Add (arrow);  }  
Magic Number,HelixToolkit.Wpf,LightSetup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\LightSetup.cs,OnShowLightsChanged,The following statement contains a magic number: if (dl != null) {  	var dir = dl.Direction;  	dir.Normalize ();  	var target = new Point3D (0' 0' 0);  	var source = target - (dir * 20);  	var p2 = source + (dir * 10);  	var sphere = new SphereVisual3D ();  	sphere.BeginEdit ();  	sphere.Center = source;  	sphere.Radius = 1.0;  	sphere.Fill = new SolidColorBrush (dl.Color);  	sphere.EndEdit ();  	this.lightsVisual.Children.Add (sphere);  	var arrow = new ArrowVisual3D ();  	arrow.BeginEdit ();  	arrow.Point1 = source;  	arrow.Point2 = p2;  	arrow.Diameter = 0.5;  	arrow.Fill = new SolidColorBrush (dl.Color);  	arrow.EndEdit ();  	this.lightsVisual.Children.Add (arrow);  }  
Magic Number,HelixToolkit.Wpf,LightSetup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\LightSetup.cs,OnShowLightsChanged,The following statement contains a magic number: arrow.Diameter = 0.5;  
Magic Number,HelixToolkit.Wpf,LightSetup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\LightSetup.cs,OnShowLightsChanged,The following statement contains a magic number: if (al != null) {  	var pos = new Point3D (0' 0' 20);  	this.lightsVisual.Children.Add (new CubeVisual3D {  		Center = pos'  		SideLength = 1.0'  		Fill = new SolidColorBrush (al.Color)  	});  }  
Magic Number,HelixToolkit.Wpf,BindableRotateManipulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Manipulators\BindableRotateManipulator.cs,UpdateGeometry,The following statement contains a magic number: mb.AddPipe (p1' p2' this.InnerDiameter' this.Diameter' 60);  
Magic Number,HelixToolkit.Wpf,BindableRotateManipulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Manipulators\BindableRotateManipulator.cs,OnMouseMove,The following statement contains a magic number: if (this.IsMouseCaptured) {  	var hitPlaneOrigin = this.ToWorld (this.Position);  	var hitPlaneNormal = this.ToWorld (this.Axis);  	var position = e.GetPosition (this.ParentViewport);  	var hitPoint = this.GetHitPlanePoint (position' hitPlaneOrigin' hitPlaneNormal);  	if (hitPoint == null) {  		return;  	}  	var currentPoint = this.ToLocal (hitPoint.Value);  	var v = this.lastPoint - this.Position;  	var u = currentPoint - this.Position;  	v.Normalize ();  	u.Normalize ();  	var currentAxis = Vector3D.CrossProduct (u' v);  	double sign = -Vector3D.DotProduct (this.Axis' currentAxis);  	double theta = Math.Sign (sign) * Math.Asin (currentAxis.Length) / Math.PI * 180;  	this.Value += theta;  	hitPoint = this.GetHitPlanePoint (position' hitPlaneOrigin' hitPlaneNormal);  	if (hitPoint != null) {  		this.lastPoint = this.ToLocal (hitPoint.Value);  	}  }  
Magic Number,HelixToolkit.Wpf,RotateManipulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Manipulators\RotateManipulator.cs,UpdateGeometry,The following statement contains a magic number: mb.AddPipe (p1' p2' this.InnerDiameter' this.Diameter' 60);  
Magic Number,HelixToolkit.Wpf,RotateManipulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Manipulators\RotateManipulator.cs,OnMouseMove,The following statement contains a magic number: if (this.IsMouseCaptured) {  	var hitPlaneOrigin = this.ToWorld (this.Position);  	var hitPlaneNormal = this.ToWorld (this.Axis);  	var position = e.GetPosition (this.ParentViewport);  	var hitPoint = this.GetHitPlanePoint (position' hitPlaneOrigin' hitPlaneNormal);  	if (hitPoint == null) {  		return;  	}  	var currentPoint = this.ToLocal (hitPoint.Value);  	var v = this.lastPoint - this.Position;  	var u = currentPoint - this.Position;  	v.Normalize ();  	u.Normalize ();  	var currentAxis = Vector3D.CrossProduct (u' v);  	double sign = -Vector3D.DotProduct (this.Axis' currentAxis);  	double theta = Math.Sign (sign) * Math.Asin (currentAxis.Length) / Math.PI * 180;  	this.Value += theta;  	if (this.TargetTransform != null) {  		var rotateTransform = new RotateTransform3D (new AxisAngleRotation3D (this.Axis' theta)' this.Pivot);  		this.TargetTransform = Transform3DHelper.CombineTransform (rotateTransform' this.TargetTransform);  	}  	hitPoint = this.GetHitPlanePoint (position' hitPlaneOrigin' hitPlaneNormal);  	if (hitPoint != null) {  		this.lastPoint = this.ToLocal (hitPoint.Value);  	}  }  
Magic Number,HelixToolkit.Wpf,HelixVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\HelixVisual3D.cs,Evaluate,The following statement contains a magic number: v *= 2 * Math.PI;  
Magic Number,HelixToolkit.Wpf,BillboardTextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\BillboardTextVisual3D.cs,VisualChanged,The following statement contains a magic number: element.Measure (new Size (1000' 1000));  
Magic Number,HelixToolkit.Wpf,BillboardTextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\BillboardTextVisual3D.cs,VisualChanged,The following statement contains a magic number: element.Measure (new Size (1000' 1000));  
Magic Number,HelixToolkit.Wpf,LinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\ScreenSpaceVisuals\LinesVisual3D.cs,UpdateGeometry,The following statement contains a magic number: if (n > 0) {  	if (this.Mesh.TriangleIndices.Count != n * 3) {  		this.Mesh.TriangleIndices = this.builder.CreateIndices (n);  	}  	this.Mesh.Positions = this.builder.CreatePositions (this.Points' this.Thickness' this.DepthOffset);  } else {  	this.Mesh.Positions = null;  }  
Magic Number,HelixToolkit.Wpf,LinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\ScreenSpaceVisuals\LinesVisual3D.cs,UpdateGeometry,The following statement contains a magic number: if (this.Mesh.TriangleIndices.Count != n * 3) {  	this.Mesh.TriangleIndices = this.builder.CreateIndices (n);  }  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 1);  	indices.Add (i * 4 + 0);  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 3);  	indices.Add (i * 4 + 1);  }  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 1);  	indices.Add (i * 4 + 0);  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 3);  	indices.Add (i * 4 + 1);  }  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 1);  	indices.Add (i * 4 + 0);  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 3);  	indices.Add (i * 4 + 1);  }  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 1);  	indices.Add (i * 4 + 0);  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 3);  	indices.Add (i * 4 + 1);  }  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 1);  	indices.Add (i * 4 + 0);  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 3);  	indices.Add (i * 4 + 1);  }  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 1);  	indices.Add (i * 4 + 0);  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 3);  	indices.Add (i * 4 + 1);  }  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 1);  	indices.Add (i * 4 + 0);  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 3);  	indices.Add (i * 4 + 1);  }  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 1);  	indices.Add (i * 4 + 0);  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 3);  	indices.Add (i * 4 + 1);  }  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 1);  	indices.Add (i * 4 + 0);  	indices.Add (i * 4 + 2);  	indices.Add (i * 4 + 3);  	indices.Add (i * 4 + 1);  }  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add (i * 4 + 2);  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add (i * 4 + 2);  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add (i * 4 + 1);  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add (i * 4 + 0);  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add (i * 4 + 2);  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add (i * 4 + 2);  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add (i * 4 + 3);  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add (i * 4 + 3);  
Magic Number,HelixToolkit.Wpf,PointGeometryBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ScreenSpace\PointGeometryBuilder.cs,CreateIndices,The following statement contains a magic number: indices.Add (i * 4 + 1);  
Magic Number,HelixToolkit.Wpf,PointsVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\ScreenSpaceVisuals\PointsVisual3D.cs,UpdateGeometry,The following statement contains a magic number: if (n > 0) {  	if (this.Mesh.TriangleIndices.Count != n * 6) {  		this.Mesh.TriangleIndices = this.builder.CreateIndices (n);  	}  	this.Mesh.Positions = this.builder.CreatePositions (this.Points' this.Size' this.DepthOffset);  }  
Magic Number,HelixToolkit.Wpf,PointsVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\ScreenSpaceVisuals\PointsVisual3D.cs,UpdateGeometry,The following statement contains a magic number: if (this.Mesh.TriangleIndices.Count != n * 6) {  	this.Mesh.TriangleIndices = this.builder.CreateIndices (n);  }  
Magic Number,HelixToolkit.Wpf,ScreenSpaceVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\ScreenSpaceVisuals\ScreenSpaceVisual3D.cs,UpdateClipping,The following statement contains a magic number: this.Clipping = new CohenSutherlandClipping (10' vp.ActualWidth - 20' 10' vp.ActualHeight - 20);  
Magic Number,HelixToolkit.Wpf,ScreenSpaceVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\ScreenSpaceVisuals\ScreenSpaceVisual3D.cs,UpdateClipping,The following statement contains a magic number: this.Clipping = new CohenSutherlandClipping (10' vp.ActualWidth - 20' 10' vp.ActualHeight - 20);  
Magic Number,HelixToolkit.Wpf,ScreenSpaceVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\ScreenSpaceVisuals\ScreenSpaceVisual3D.cs,UpdateClipping,The following statement contains a magic number: this.Clipping = new CohenSutherlandClipping (10' vp.ActualWidth - 20' 10' vp.ActualHeight - 20);  
Magic Number,HelixToolkit.Wpf,ScreenSpaceVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\ScreenSpaceVisuals\ScreenSpaceVisual3D.cs,UpdateClipping,The following statement contains a magic number: this.Clipping = new CohenSutherlandClipping (10' vp.ActualWidth - 20' 10' vp.ActualHeight - 20);  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new Point3DAnimation (fromPosition' newPosition' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a1.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.PositionProperty' null);  	camera.BeginAnimation (ProjectionCamera.PositionProperty' a1);  	var a2 = new Vector3DAnimation (fromDirection' newDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a2.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' null);  	camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' a2);  	var a3 = new Vector3DAnimation (fromUpDirection' newUpDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a3.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' null);  	camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' a3);  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new Point3DAnimation (fromPosition' newPosition' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a1.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.PositionProperty' null);  	camera.BeginAnimation (ProjectionCamera.PositionProperty' a1);  	var a2 = new Vector3DAnimation (fromDirection' newDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a2.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' null);  	camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' a2);  	var a3 = new Vector3DAnimation (fromUpDirection' newUpDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a3.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' null);  	camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' a3);  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new Point3DAnimation (fromPosition' newPosition' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a1.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.PositionProperty' null);  	camera.BeginAnimation (ProjectionCamera.PositionProperty' a1);  	var a2 = new Vector3DAnimation (fromDirection' newDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a2.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' null);  	camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' a2);  	var a3 = new Vector3DAnimation (fromUpDirection' newUpDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a3.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' null);  	camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' a3);  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new Point3DAnimation (fromPosition' newPosition' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a1.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.PositionProperty' null);  	camera.BeginAnimation (ProjectionCamera.PositionProperty' a1);  	var a2 = new Vector3DAnimation (fromDirection' newDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a2.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' null);  	camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' a2);  	var a3 = new Vector3DAnimation (fromUpDirection' newUpDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a3.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' null);  	camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' a3);  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new Point3DAnimation (fromPosition' newPosition' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a1.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.PositionProperty' null);  	camera.BeginAnimation (ProjectionCamera.PositionProperty' a1);  	var a2 = new Vector3DAnimation (fromDirection' newDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a2.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' null);  	camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' a2);  	var a3 = new Vector3DAnimation (fromUpDirection' newUpDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a3.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' null);  	camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' a3);  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new Point3DAnimation (fromPosition' newPosition' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a1.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.PositionProperty' null);  	camera.BeginAnimation (ProjectionCamera.PositionProperty' a1);  	var a2 = new Vector3DAnimation (fromDirection' newDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a2.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' null);  	camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' a2);  	var a3 = new Vector3DAnimation (fromUpDirection' newUpDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a3.Completed += (s' a) => camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' null);  	camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' a3);  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,AnimateWidth,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new DoubleAnimation (fromWidth' newWidth' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	camera.BeginAnimation (OrthographicCamera.WidthProperty' a1);  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,AnimateWidth,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new DoubleAnimation (fromWidth' newWidth' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	camera.BeginAnimation (OrthographicCamera.WidthProperty' a1);  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: if (pdest != null) {  	double fov = 45;  	if (psrc != null) {  		fov = psrc.FieldOfView;  	}  	if (osrc != null) {  		double dist = source.LookDirection.Length;  		fov = Math.Atan (osrc.Width / 2 / dist) * 180 / Math.PI * 2;  	}  	pdest.FieldOfView = fov;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: if (pdest != null) {  	double fov = 45;  	if (psrc != null) {  		fov = psrc.FieldOfView;  	}  	if (osrc != null) {  		double dist = source.LookDirection.Length;  		fov = Math.Atan (osrc.Width / 2 / dist) * 180 / Math.PI * 2;  	}  	pdest.FieldOfView = fov;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: if (pdest != null) {  	double fov = 45;  	if (psrc != null) {  		fov = psrc.FieldOfView;  	}  	if (osrc != null) {  		double dist = source.LookDirection.Length;  		fov = Math.Atan (osrc.Width / 2 / dist) * 180 / Math.PI * 2;  	}  	pdest.FieldOfView = fov;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: if (pdest != null) {  	double fov = 45;  	if (psrc != null) {  		fov = psrc.FieldOfView;  	}  	if (osrc != null) {  		double dist = source.LookDirection.Length;  		fov = Math.Atan (osrc.Width / 2 / dist) * 180 / Math.PI * 2;  	}  	pdest.FieldOfView = fov;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: if (osrc != null) {  	double dist = source.LookDirection.Length;  	fov = Math.Atan (osrc.Width / 2 / dist) * 180 / Math.PI * 2;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: if (osrc != null) {  	double dist = source.LookDirection.Length;  	fov = Math.Atan (osrc.Width / 2 / dist) * 180 / Math.PI * 2;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: if (osrc != null) {  	double dist = source.LookDirection.Length;  	fov = Math.Atan (osrc.Width / 2 / dist) * 180 / Math.PI * 2;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: fov = Math.Atan (osrc.Width / 2 / dist) * 180 / Math.PI * 2;  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: fov = Math.Atan (osrc.Width / 2 / dist) * 180 / Math.PI * 2;  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: fov = Math.Atan (osrc.Width / 2 / dist) * 180 / Math.PI * 2;  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: if (odest != null) {  	double width = 100;  	if (psrc != null) {  		double dist = source.LookDirection.Length;  		width = Math.Tan (psrc.FieldOfView / 180 * Math.PI / 2) * dist * 2;  	}  	if (osrc != null) {  		width = osrc.Width;  	}  	odest.Width = width;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: if (odest != null) {  	double width = 100;  	if (psrc != null) {  		double dist = source.LookDirection.Length;  		width = Math.Tan (psrc.FieldOfView / 180 * Math.PI / 2) * dist * 2;  	}  	if (osrc != null) {  		width = osrc.Width;  	}  	odest.Width = width;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: if (odest != null) {  	double width = 100;  	if (psrc != null) {  		double dist = source.LookDirection.Length;  		width = Math.Tan (psrc.FieldOfView / 180 * Math.PI / 2) * dist * 2;  	}  	if (osrc != null) {  		width = osrc.Width;  	}  	odest.Width = width;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: if (odest != null) {  	double width = 100;  	if (psrc != null) {  		double dist = source.LookDirection.Length;  		width = Math.Tan (psrc.FieldOfView / 180 * Math.PI / 2) * dist * 2;  	}  	if (osrc != null) {  		width = osrc.Width;  	}  	odest.Width = width;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: if (psrc != null) {  	double dist = source.LookDirection.Length;  	width = Math.Tan (psrc.FieldOfView / 180 * Math.PI / 2) * dist * 2;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: if (psrc != null) {  	double dist = source.LookDirection.Length;  	width = Math.Tan (psrc.FieldOfView / 180 * Math.PI / 2) * dist * 2;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: if (psrc != null) {  	double dist = source.LookDirection.Length;  	width = Math.Tan (psrc.FieldOfView / 180 * Math.PI / 2) * dist * 2;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: width = Math.Tan (psrc.FieldOfView / 180 * Math.PI / 2) * dist * 2;  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: width = Math.Tan (psrc.FieldOfView / 180 * Math.PI / 2) * dist * 2;  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Copy,The following statement contains a magic number: width = Math.Tan (psrc.FieldOfView / 180 * Math.PI / 2) * dist * 2;  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D (2' 16' 20);  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D (2' 16' 20);  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D (2' 16' 20);  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D (-2' -16' -20);  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D (-2' -16' -20);  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D (-2' -16' -20);  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.FieldOfView = 45;  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.NearPlaneDistance = 0.1;  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D (2' 16' 20);  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D (2' 16' 20);  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D (2' 16' 20);  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D (-2' -16' -20);  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D (-2' -16' -20);  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D (-2' -16' -20);  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.Width = 40;  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,Reset,The following statement contains a magic number: camera.NearPlaneDistance = 0.1;  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,GetProjectionMatrix,The following statement contains a magic number: if (perspectiveCamera != null) {  	// The angle-to-radian formula is a little off because only  	// half the angle enters the calculation.  	double xscale = 1 / Math.Tan (Math.PI * perspectiveCamera.FieldOfView / 360);  	double yscale = xscale * aspectRatio;  	double znear = perspectiveCamera.NearPlaneDistance;  	double zfar = perspectiveCamera.FarPlaneDistance;  	double zscale = double.IsPositiveInfinity (zfar) ? -1 : (zfar / (znear - zfar));  	double zoffset = znear * zscale;  	return new Matrix3D (xscale' 0' 0' 0' 0' yscale' 0' 0' 0' 0' zscale' -1' 0' 0' zoffset' 0);  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,GetProjectionMatrix,The following statement contains a magic number: if (orthographicCamera != null) {  	double xscale = 2.0 / orthographicCamera.Width;  	double yscale = xscale * aspectRatio;  	double znear = orthographicCamera.NearPlaneDistance;  	double zfar = orthographicCamera.FarPlaneDistance;  	if (double.IsPositiveInfinity (zfar)) {  		zfar = znear * 1e5;  	}  	double dzinv = 1.0 / (znear - zfar);  	var m = new Matrix3D (xscale' 0' 0' 0' 0' yscale' 0' 0' 0' 0' dzinv' 0' 0' 0' znear * dzinv' 1);  	return m;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,GetProjectionMatrix,The following statement contains a magic number: if (orthographicCamera != null) {  	double xscale = 2.0 / orthographicCamera.Width;  	double yscale = xscale * aspectRatio;  	double znear = orthographicCamera.NearPlaneDistance;  	double zfar = orthographicCamera.FarPlaneDistance;  	if (double.IsPositiveInfinity (zfar)) {  		zfar = znear * 1e5;  	}  	double dzinv = 1.0 / (znear - zfar);  	var m = new Matrix3D (xscale' 0' 0' 0' 0' yscale' 0' 0' 0' 0' dzinv' 0' 0' 0' znear * dzinv' 1);  	return m;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,GetProjectionMatrix,The following statement contains a magic number: if (double.IsPositiveInfinity (zfar)) {  	zfar = znear * 1e5;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,GetProjectionMatrix,The following statement contains a magic number: zfar = znear * 1e5;  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,FitView,The following statement contains a magic number: if (perspectiveCamera != null) {  	var pcam = perspectiveCamera;  	double disth = radius / Math.Tan (0.5 * pcam.FieldOfView * Math.PI / 180);  	double vfov = pcam.FieldOfView;  	if (viewport.ActualWidth > 0 && viewport.ActualHeight > 0) {  		vfov *= viewport.ActualHeight / viewport.ActualWidth;  	}  	double distv = radius / Math.Tan (0.5 * vfov * Math.PI / 180);  	double dist = Math.Max (disth' distv);  	var dir = lookDirection;  	dir.Normalize ();  	LookAt (perspectiveCamera' center' dir * dist' upDirection' animationTime);  	return;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,FitView,The following statement contains a magic number: if (perspectiveCamera != null) {  	var pcam = perspectiveCamera;  	double disth = radius / Math.Tan (0.5 * pcam.FieldOfView * Math.PI / 180);  	double vfov = pcam.FieldOfView;  	if (viewport.ActualWidth > 0 && viewport.ActualHeight > 0) {  		vfov *= viewport.ActualHeight / viewport.ActualWidth;  	}  	double distv = radius / Math.Tan (0.5 * vfov * Math.PI / 180);  	double dist = Math.Max (disth' distv);  	var dir = lookDirection;  	dir.Normalize ();  	LookAt (perspectiveCamera' center' dir * dist' upDirection' animationTime);  	return;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,FitView,The following statement contains a magic number: if (perspectiveCamera != null) {  	var pcam = perspectiveCamera;  	double disth = radius / Math.Tan (0.5 * pcam.FieldOfView * Math.PI / 180);  	double vfov = pcam.FieldOfView;  	if (viewport.ActualWidth > 0 && viewport.ActualHeight > 0) {  		vfov *= viewport.ActualHeight / viewport.ActualWidth;  	}  	double distv = radius / Math.Tan (0.5 * vfov * Math.PI / 180);  	double dist = Math.Max (disth' distv);  	var dir = lookDirection;  	dir.Normalize ();  	LookAt (perspectiveCamera' center' dir * dist' upDirection' animationTime);  	return;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,FitView,The following statement contains a magic number: if (perspectiveCamera != null) {  	var pcam = perspectiveCamera;  	double disth = radius / Math.Tan (0.5 * pcam.FieldOfView * Math.PI / 180);  	double vfov = pcam.FieldOfView;  	if (viewport.ActualWidth > 0 && viewport.ActualHeight > 0) {  		vfov *= viewport.ActualHeight / viewport.ActualWidth;  	}  	double distv = radius / Math.Tan (0.5 * vfov * Math.PI / 180);  	double dist = Math.Max (disth' distv);  	var dir = lookDirection;  	dir.Normalize ();  	LookAt (perspectiveCamera' center' dir * dist' upDirection' animationTime);  	return;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,FitView,The following statement contains a magic number: if (orthographicCamera != null) {  	LookAt (orthographicCamera' center' lookDirection' upDirection' animationTime);  	double newWidth = radius * 2;  	if (viewport.ActualWidth > viewport.ActualHeight) {  		newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;  	}  	AnimateWidth (orthographicCamera' newWidth' animationTime);  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,FitView,The following statement contains a magic number: if (orthographicCamera != null) {  	LookAt (orthographicCamera' center' lookDirection' upDirection' animationTime);  	double newWidth = radius * 2;  	if (viewport.ActualWidth > viewport.ActualHeight) {  		newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;  	}  	AnimateWidth (orthographicCamera' newWidth' animationTime);  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,FitView,The following statement contains a magic number: if (viewport.ActualWidth > viewport.ActualHeight) {  	newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,FitView,The following statement contains a magic number: newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,ZoomToRectangle,The following statement contains a magic number: if (perspectiveCamera != null) {  	var distance = camera.LookDirection.Length;  	// option 1: change distance  	var newDistance = distance * zoomRectangle.Width / viewport.ActualWidth;  	var newLookDirection = newDistance * w;  	var newPosition = perspectiveCamera.Position + ((distance - newDistance) * w);  	var newTarget = newPosition + newLookDirection;  	LookAt (camera' newTarget' newLookDirection' 200);  	// option 2: change fov  	//    double newFieldOfView = Math.Acos(Vector3D.DotProduct(u' v));  	//    var newTarget = camera.Position + distance * w;  	//    pcamera.FieldOfView = newFieldOfView * 180 / Math.PI;  	//    LookAt(camera' newTarget' distance * w' 0);  }  
Magic Number,HelixToolkit.Wpf,CameraHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\CameraHelper.cs,ZoomToRectangle,The following statement contains a magic number: LookAt (camera' newTarget' newLookDirection' 200);  
Magic Number,HelixToolkit.Wpf,BrushHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\BrushHelper.cs,CreateGrayBrush,The following statement contains a magic number: return new SolidColorBrush (Color.FromArgb (255' b' b' b));  
Magic Number,HelixToolkit.Wpf,BrushHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\BrushHelper.cs,CreateHsvBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (a' 0xff' 0xff' 0x00)' 0.17));  
Magic Number,HelixToolkit.Wpf,BrushHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\BrushHelper.cs,CreateHsvBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (a' 0x00' 0xff' 0x00)' 0.33));  
Magic Number,HelixToolkit.Wpf,BrushHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\BrushHelper.cs,CreateHsvBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (a' 0x00' 0xff' 0xff)' 0.50));  
Magic Number,HelixToolkit.Wpf,BrushHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\BrushHelper.cs,CreateHsvBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (a' 0x00' 0x00' 0xff)' 0.67));  
Magic Number,HelixToolkit.Wpf,BrushHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\BrushHelper.cs,CreateHsvBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Color.FromArgb (a' 0xff' 0x00' 0xff)' 0.84));  
Magic Number,HelixToolkit.Wpf,BrushHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\BrushHelper.cs,CreateRainbowBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Colors.Orange' 0.17));  
Magic Number,HelixToolkit.Wpf,BrushHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\BrushHelper.cs,CreateRainbowBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Colors.Yellow' 0.33));  
Magic Number,HelixToolkit.Wpf,BrushHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\BrushHelper.cs,CreateRainbowBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Colors.Green' 0.50));  
Magic Number,HelixToolkit.Wpf,BrushHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\BrushHelper.cs,CreateRainbowBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Colors.Blue' 0.67));  
Magic Number,HelixToolkit.Wpf,BrushHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\BrushHelper.cs,CreateRainbowBrush,The following statement contains a magic number: brush.GradientStops.Add (new GradientStop (Colors.Indigo' 0.84));  
Magic Number,HelixToolkit.Wpf,VerletIntegrator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Physics\VerletIntegrator.cs,VerletIntegrator,The following statement contains a magic number: this.Iterations = 4;  
Magic Number,HelixToolkit.Wpf,VerletIntegrator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Physics\VerletIntegrator.cs,CreateConstraintsByMesh,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	int i0 = mesh.TriangleIndices [i];  	int i1 = mesh.TriangleIndices [i + 1];  	int i2 = mesh.TriangleIndices [i + 2];  	this.AddConstraint (i0' i1' relax);  	this.AddConstraint (i1' i2' relax);  	this.AddConstraint (i2' i0' relax);  }  
Magic Number,HelixToolkit.Wpf,VerletIntegrator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Physics\VerletIntegrator.cs,CreateConstraintsByMesh,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	int i0 = mesh.TriangleIndices [i];  	int i1 = mesh.TriangleIndices [i + 1];  	int i2 = mesh.TriangleIndices [i + 2];  	this.AddConstraint (i0' i1' relax);  	this.AddConstraint (i1' i2' relax);  	this.AddConstraint (i2' i0' relax);  }  
Magic Number,HelixToolkit.Wpf,VerletIntegrator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Physics\VerletIntegrator.cs,CreateConstraintsByMesh,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,SphereConstraint,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Physics\VerletIntegrator.cs,Satisfy,The following statement contains a magic number: if (vec.LengthSquared < this.RadiusSquared) {  	vec.Normalize ();  	vs.Positions [this.Index] = this.Center + vec * this.Radius * 1.1;  	vs.Positions0 [this.Index] = vs.Positions [this.Index];  }  
Magic Number,HelixToolkit.Wpf,SphereConstraint,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Physics\VerletIntegrator.cs,Satisfy,The following statement contains a magic number: vs.Positions [this.Index] = this.Center + vec * this.Radius * 1.1;  
Magic Number,HelixToolkit.Wpf,DistanceConstraint,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Physics\VerletIntegrator.cs,Satisfy,The following statement contains a magic number: if (this.Iterations > iteration) {  	Point3D x1 = vs.Positions [this.Index1];  	Point3D x2 = vs.Positions [this.Index2];  	Vector3D delta = x2 - x1;  	double deltalength = delta.Length;  	double diff = deltalength - this.Restlength;  	double div = deltalength * (vs.InverseMass [this.Index1] + vs.InverseMass [this.Index2]);  	if (Math.Abs (div) > 1e-8) {  		diff /= div;  		if (vs.InverseMass [this.Index1] != 0) {  			vs.Positions [this.Index1] += delta * diff * vs.InverseMass [this.Index1] * this.RelaxationFactor;  		}  		if (vs.InverseMass [this.Index2] != 0) {  			vs.Positions [this.Index2] -= delta * diff * vs.InverseMass [this.Index2] * this.RelaxationFactor;  		}  	}  }  
Magic Number,HelixToolkit.Wpf,DistanceConstraint,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Physics\VerletIntegrator.cs,Satisfy,The following statement contains a magic number: if (Math.Abs (div) > 1e-8) {  	diff /= div;  	if (vs.InverseMass [this.Index1] != 0) {  		vs.Positions [this.Index1] += delta * diff * vs.InverseMass [this.Index1] * this.RelaxationFactor;  	}  	if (vs.InverseMass [this.Index2] != 0) {  		vs.Positions [this.Index2] -= delta * diff * vs.InverseMass [this.Index2] * this.RelaxationFactor;  	}  }  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,ColorParse,The following statement contains a magic number: return Color.FromRgb ((byte)(fields [0] * 255)' (byte)(fields [1] * 255)' (byte)(fields [2] * 255));  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,ColorParse,The following statement contains a magic number: return Color.FromRgb ((byte)(fields [0] * 255)' (byte)(fields [1] * 255)' (byte)(fields [2] * 255));  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,ColorParse,The following statement contains a magic number: return Color.FromRgb ((byte)(fields [0] * 255)' (byte)(fields [1] * 255)' (byte)(fields [2] * 255));  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,ColorParse,The following statement contains a magic number: return Color.FromRgb ((byte)(fields [0] * 255)' (byte)(fields [1] * 255)' (byte)(fields [2] * 255));  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddFace,The following statement contains a magic number: foreach (var field in fields) {  	if (string.IsNullOrEmpty (field)) {  		continue;  	}  	var ff = field.Split ('/');  	int vi = int.Parse (ff [0]);  	int vti = ff.Length > 1 && ff [1].Length > 0 ? int.Parse (ff [1]) : int.MaxValue;  	int vni = ff.Length > 2 && ff [2].Length > 0 ? int.Parse (ff [2]) : int.MaxValue;  	// Handle relative indices (negative numbers)  	if (vi < 0) {  		vi = this.Points.Count + vi + 1;  	}  	if (vti < 0) {  		vti = this.TextureCoordinates.Count + vti + 1;  	}  	if (vni < 0) {  		vni = this.Normals.Count + vni + 1;  	}  	// Check if the indices are valid  	if (vi - 1 >= this.Points.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid vertex index ({0}) on line {1}."' vi' this.currentLineNo));  	}  	if (vti == int.MaxValue) {  		// turn off texture coordinates in the builder  		builder.CreateTextureCoordinates = false;  	}  	if (vni == int.MaxValue) {  		// turn off normals in the builder  		builder.CreateNormals = false;  	}  	// check if the texture coordinate index is valid  	if (builder.CreateTextureCoordinates && vti - 1 >= this.TextureCoordinates.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid texture coordinate index ({0}) on line {1}."' vti' this.currentLineNo));  	}  	// check if the normal index is valid  	if (builder.CreateNormals && vni - 1 >= this.Normals.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid normal index ({0}) on line {1}."' vni' this.currentLineNo));  	}  	bool addVertex = true;  	if (smoothingGroupMap != null) {  		var key = Tuple.Create (vi' vti' vni);  		int vix;  		if (smoothingGroupMap.TryGetValue (key' out vix)) {  			// use the index of a previously defined vertex  			addVertex = false;  		} else {  			// add a new vertex  			vix = positions.Count;  			smoothingGroupMap.Add (key' vix);  		}  		faceIndices.Add (vix);  	} else {  		// if smoothing is off' always add a new vertex  		faceIndices.Add (positions.Count);  	}  	if (addVertex) {  		// add vertex  		positions.Add (this.Points [vi - 1]);  		// add texture coordinate (if enabled)  		if (builder.CreateTextureCoordinates) {  			textureCoordinates.Add (this.TextureCoordinates [vti - 1]);  		}  		// add normal (if enabled)  		if (builder.CreateNormals) {  			normals.Add (this.Normals [vni - 1]);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddFace,The following statement contains a magic number: foreach (var field in fields) {  	if (string.IsNullOrEmpty (field)) {  		continue;  	}  	var ff = field.Split ('/');  	int vi = int.Parse (ff [0]);  	int vti = ff.Length > 1 && ff [1].Length > 0 ? int.Parse (ff [1]) : int.MaxValue;  	int vni = ff.Length > 2 && ff [2].Length > 0 ? int.Parse (ff [2]) : int.MaxValue;  	// Handle relative indices (negative numbers)  	if (vi < 0) {  		vi = this.Points.Count + vi + 1;  	}  	if (vti < 0) {  		vti = this.TextureCoordinates.Count + vti + 1;  	}  	if (vni < 0) {  		vni = this.Normals.Count + vni + 1;  	}  	// Check if the indices are valid  	if (vi - 1 >= this.Points.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid vertex index ({0}) on line {1}."' vi' this.currentLineNo));  	}  	if (vti == int.MaxValue) {  		// turn off texture coordinates in the builder  		builder.CreateTextureCoordinates = false;  	}  	if (vni == int.MaxValue) {  		// turn off normals in the builder  		builder.CreateNormals = false;  	}  	// check if the texture coordinate index is valid  	if (builder.CreateTextureCoordinates && vti - 1 >= this.TextureCoordinates.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid texture coordinate index ({0}) on line {1}."' vti' this.currentLineNo));  	}  	// check if the normal index is valid  	if (builder.CreateNormals && vni - 1 >= this.Normals.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid normal index ({0}) on line {1}."' vni' this.currentLineNo));  	}  	bool addVertex = true;  	if (smoothingGroupMap != null) {  		var key = Tuple.Create (vi' vti' vni);  		int vix;  		if (smoothingGroupMap.TryGetValue (key' out vix)) {  			// use the index of a previously defined vertex  			addVertex = false;  		} else {  			// add a new vertex  			vix = positions.Count;  			smoothingGroupMap.Add (key' vix);  		}  		faceIndices.Add (vix);  	} else {  		// if smoothing is off' always add a new vertex  		faceIndices.Add (positions.Count);  	}  	if (addVertex) {  		// add vertex  		positions.Add (this.Points [vi - 1]);  		// add texture coordinate (if enabled)  		if (builder.CreateTextureCoordinates) {  			textureCoordinates.Add (this.TextureCoordinates [vti - 1]);  		}  		// add normal (if enabled)  		if (builder.CreateNormals) {  			normals.Add (this.Normals [vni - 1]);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddFace,The following statement contains a magic number: foreach (var field in fields) {  	if (string.IsNullOrEmpty (field)) {  		continue;  	}  	var ff = field.Split ('/');  	int vi = int.Parse (ff [0]);  	int vti = ff.Length > 1 && ff [1].Length > 0 ? int.Parse (ff [1]) : int.MaxValue;  	int vni = ff.Length > 2 && ff [2].Length > 0 ? int.Parse (ff [2]) : int.MaxValue;  	// Handle relative indices (negative numbers)  	if (vi < 0) {  		vi = this.Points.Count + vi + 1;  	}  	if (vti < 0) {  		vti = this.TextureCoordinates.Count + vti + 1;  	}  	if (vni < 0) {  		vni = this.Normals.Count + vni + 1;  	}  	// Check if the indices are valid  	if (vi - 1 >= this.Points.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid vertex index ({0}) on line {1}."' vi' this.currentLineNo));  	}  	if (vti == int.MaxValue) {  		// turn off texture coordinates in the builder  		builder.CreateTextureCoordinates = false;  	}  	if (vni == int.MaxValue) {  		// turn off normals in the builder  		builder.CreateNormals = false;  	}  	// check if the texture coordinate index is valid  	if (builder.CreateTextureCoordinates && vti - 1 >= this.TextureCoordinates.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid texture coordinate index ({0}) on line {1}."' vti' this.currentLineNo));  	}  	// check if the normal index is valid  	if (builder.CreateNormals && vni - 1 >= this.Normals.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid normal index ({0}) on line {1}."' vni' this.currentLineNo));  	}  	bool addVertex = true;  	if (smoothingGroupMap != null) {  		var key = Tuple.Create (vi' vti' vni);  		int vix;  		if (smoothingGroupMap.TryGetValue (key' out vix)) {  			// use the index of a previously defined vertex  			addVertex = false;  		} else {  			// add a new vertex  			vix = positions.Count;  			smoothingGroupMap.Add (key' vix);  		}  		faceIndices.Add (vix);  	} else {  		// if smoothing is off' always add a new vertex  		faceIndices.Add (positions.Count);  	}  	if (addVertex) {  		// add vertex  		positions.Add (this.Points [vi - 1]);  		// add texture coordinate (if enabled)  		if (builder.CreateTextureCoordinates) {  			textureCoordinates.Add (this.TextureCoordinates [vti - 1]);  		}  		// add normal (if enabled)  		if (builder.CreateNormals) {  			normals.Add (this.Normals [vni - 1]);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddFace,The following statement contains a magic number: if (faceIndices.Count <= 4) {  	// add triangles or quads  	builder.AddPolygon (faceIndices);  } else {  	// add triangles by cutting ears algorithm  	// this algorithm is quite expensive...  	builder.AddPolygonByTriangulation (faceIndices);  }  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddNormal,The following statement contains a magic number: if (SwitchYZ) {  	this.Normals.Add (new Vector3D (fields [0]' -fields [2]' fields [1]));  } else {  	this.Normals.Add (new Vector3D (fields [0]' fields [1]' fields [2]));  }  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddNormal,The following statement contains a magic number: if (SwitchYZ) {  	this.Normals.Add (new Vector3D (fields [0]' -fields [2]' fields [1]));  } else {  	this.Normals.Add (new Vector3D (fields [0]' fields [1]' fields [2]));  }  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddNormal,The following statement contains a magic number: this.Normals.Add (new Vector3D (fields [0]' -fields [2]' fields [1]));  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddNormal,The following statement contains a magic number: this.Normals.Add (new Vector3D (fields [0]' fields [1]' fields [2]));  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddVertex,The following statement contains a magic number: if (SwitchYZ) {  	this.Points.Add (new Point3D (fields [0]' -fields [2]' fields [1]));  } else {  	this.Points.Add (new Point3D (fields [0]' fields [1]' fields [2]));  }  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddVertex,The following statement contains a magic number: if (SwitchYZ) {  	this.Points.Add (new Point3D (fields [0]' -fields [2]' fields [1]));  } else {  	this.Points.Add (new Point3D (fields [0]' fields [1]' fields [2]));  }  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddVertex,The following statement contains a magic number: this.Points.Add (new Point3D (fields [0]' -fields [2]' fields [1]));  
Magic Number,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,AddVertex,The following statement contains a magic number: this.Points.Add (new Point3D (fields [0]' fields [1]' fields [2]));  
Magic Number,HelixToolkit.Wpf,LwoReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\LwoReader.cs,Read,The following statement contains a magic number: using (var reader = new BinaryReader (s)) {  	long length = reader.BaseStream.Length;  	string headerId = this.ReadChunkId (reader);  	if (headerId != "FORM") {  		throw new FileFormatException ("Unknown file");  	}  	int headerSize = this.ReadChunkSize (reader);  	if (headerSize + 8 != length) {  		throw new FileFormatException ("Incomplete file (file length does not match header)");  	}  	string header2 = this.ReadChunkId (reader);  	switch (header2) {  	case "LWOB":  		break;  	case "LWO2":  		throw new FileFormatException ("LWO2 is not yet supported.");  	default:  		throw new FileFormatException ("Unknown file format (" + header2 + ").");  	}  	while (reader.BaseStream.Position < reader.BaseStream.Length) {  		string id = this.ReadChunkId (reader);  		int size = this.ReadChunkSize (reader);  		switch (id) {  		case "PNTS":  			this.ReadPoints (reader' size);  			break;  		case "SRFS":  			this.ReadSurface (reader' size);  			break;  		case "POLS":  			this.ReadPolygons (reader' size);  			break;  		// ReSharper disable RedundantCaseLabel  		case "SURF":  		// ReSharper restore RedundantCaseLabel  		default:  			// download the whole chunk  			// ReSharper disable UnusedVariable  			var data = this.ReadData (reader' size);  			// ReSharper restore UnusedVariable  			break;  		}  	}  	return this.BuildModel ();  }  
Magic Number,HelixToolkit.Wpf,LwoReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\LwoReader.cs,Read,The following statement contains a magic number: if (headerSize + 8 != length) {  	throw new FileFormatException ("Incomplete file (file length does not match header)");  }  
Magic Number,HelixToolkit.Wpf,LwoReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\LwoReader.cs,ReadFloat,The following statement contains a magic number: return BitConverter.ToSingle (new[] {  	bytes [3]'  	bytes [2]'  	bytes [1]'  	bytes [0]  }' 0);  
Magic Number,HelixToolkit.Wpf,LwoReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\LwoReader.cs,ReadFloat,The following statement contains a magic number: return BitConverter.ToSingle (new[] {  	bytes [3]'  	bytes [2]'  	bytes [1]'  	bytes [0]  }' 0);  
Magic Number,HelixToolkit.Wpf,LwoReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\LwoReader.cs,ReadInt,The following statement contains a magic number: return BitConverter.ToInt32 (new[] {  	bytes [3]'  	bytes [2]'  	bytes [1]'  	bytes [0]  }' 0);  
Magic Number,HelixToolkit.Wpf,LwoReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\LwoReader.cs,ReadInt,The following statement contains a magic number: return BitConverter.ToInt32 (new[] {  	bytes [3]'  	bytes [2]'  	bytes [1]'  	bytes [0]  }' 0);  
Magic Number,HelixToolkit.Wpf,LwoReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\LwoReader.cs,ReadPolygons,The following statement contains a magic number: while (size > 0) {  	short nverts = this.ReadShortInt (reader);  	if (nverts <= 0) {  		throw new NotSupportedException ("details are not supported");  	}  	var pts = new List<Point3D> (nverts);  	for (int i = 0; i < nverts; i++) {  		int vidx = this.ReadShortInt (reader);  		pts.Add (this.Points [vidx]);  	}  	short surfaceIndex = this.ReadShortInt (reader);  	size -= (2 + nverts) * 2;  	this.Meshes [surfaceIndex - 1].AddTriangleFan (pts);  }  
Magic Number,HelixToolkit.Wpf,LwoReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\LwoReader.cs,ReadPolygons,The following statement contains a magic number: while (size > 0) {  	short nverts = this.ReadShortInt (reader);  	if (nverts <= 0) {  		throw new NotSupportedException ("details are not supported");  	}  	var pts = new List<Point3D> (nverts);  	for (int i = 0; i < nverts; i++) {  		int vidx = this.ReadShortInt (reader);  		pts.Add (this.Points [vidx]);  	}  	short surfaceIndex = this.ReadShortInt (reader);  	size -= (2 + nverts) * 2;  	this.Meshes [surfaceIndex - 1].AddTriangleFan (pts);  }  
Magic Number,HelixToolkit.Wpf,LwoReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\LwoReader.cs,ReadPolygons,The following statement contains a magic number: size -= (2 + nverts) * 2;  
Magic Number,HelixToolkit.Wpf,LwoReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\LwoReader.cs,ReadPolygons,The following statement contains a magic number: size -= (2 + nverts) * 2;  
Magic Number,HelixToolkit.Wpf,LwoReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\LwoReader.cs,ReadSurface,The following statement contains a magic number: for (int i = 0; i < names.Length; i++) {  	string n = names [i];  	this.Surfaces.Add (n);  	this.Meshes.Add (new MeshBuilder (false' false));  	this.Materials.Add (this.DefaultMaterial);  	// If the length of the string (including the null) is odd' an extra null byte is added.  	// Then skip the next empty string.  	if ((n.Length + 1) % 2 == 1) {  		i++;  	}  }  
Magic Number,HelixToolkit.Wpf,LwoReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\LwoReader.cs,ReadSurface,The following statement contains a magic number: if ((n.Length + 1) % 2 == 1) {  	i++;  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: if (hasColor) {  	int blue = attrib [15].Equals ('1') ? 1 : 0;  	blue = attrib [14].Equals ('1') ? blue + 2 : blue;  	blue = attrib [13].Equals ('1') ? blue + 4 : blue;  	blue = attrib [12].Equals ('1') ? blue + 8 : blue;  	blue = attrib [11].Equals ('1') ? blue + 16 : blue;  	int b = blue * 8;  	int green = attrib [10].Equals ('1') ? 1 : 0;  	green = attrib [9].Equals ('1') ? green + 2 : green;  	green = attrib [8].Equals ('1') ? green + 4 : green;  	green = attrib [7].Equals ('1') ? green + 8 : green;  	green = attrib [6].Equals ('1') ? green + 16 : green;  	int g = green * 8;  	int red = attrib [5].Equals ('1') ? 1 : 0;  	red = attrib [4].Equals ('1') ? red + 2 : red;  	red = attrib [3].Equals ('1') ? red + 4 : red;  	red = attrib [2].Equals ('1') ? red + 8 : red;  	red = attrib [1].Equals ('1') ? red + 16 : red;  	int r = red * 8;  	var currentColor = Color.FromRgb (Convert.ToByte (r)' Convert.ToByte (g)' Convert.ToByte (b));  	if (!Color.Equals (this.lastColor' currentColor)) {  		this.lastColor = currentColor;  		this.index++;  	}  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (MaterialHelper.CreateMaterial (currentColor));  	}  } else {  	if (this.Materials.Count < this.index + 1) {  		this.Materials.Add (this.DefaultMaterial);  	}  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib [14].Equals ('1') ? blue + 2 : blue;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib [14].Equals ('1') ? blue + 2 : blue;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib [13].Equals ('1') ? blue + 4 : blue;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib [13].Equals ('1') ? blue + 4 : blue;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib [12].Equals ('1') ? blue + 8 : blue;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib [12].Equals ('1') ? blue + 8 : blue;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib [11].Equals ('1') ? blue + 16 : blue;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib [11].Equals ('1') ? blue + 16 : blue;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib [9].Equals ('1') ? green + 2 : green;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib [9].Equals ('1') ? green + 2 : green;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib [8].Equals ('1') ? green + 4 : green;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib [8].Equals ('1') ? green + 4 : green;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib [7].Equals ('1') ? green + 8 : green;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib [7].Equals ('1') ? green + 8 : green;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib [6].Equals ('1') ? green + 16 : green;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib [6].Equals ('1') ? green + 16 : green;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: red = attrib [4].Equals ('1') ? red + 2 : red;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: red = attrib [4].Equals ('1') ? red + 2 : red;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: red = attrib [3].Equals ('1') ? red + 4 : red;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: red = attrib [3].Equals ('1') ? red + 4 : red;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: red = attrib [2].Equals ('1') ? red + 8 : red;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: red = attrib [2].Equals ('1') ? red + 8 : red;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,ReadTriangle,The following statement contains a magic number: red = attrib [1].Equals ('1') ? red + 16 : red;  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,TryReadBinary,The following statement contains a magic number: if (length < 84) {  	throw new FileFormatException ("Incomplete file");  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,TryReadBinary,The following statement contains a magic number: this.Header = System.Text.Encoding.ASCII.GetString (reader.ReadBytes (80)).Trim ();  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,TryReadBinary,The following statement contains a magic number: if (length - 84 != numberTriangles * 50) {  	return false;  }  
Magic Number,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,TryReadBinary,The following statement contains a magic number: if (length - 84 != numberTriangles * 50) {  	return false;  }  
Magic Number,HelixToolkit.Wpf,MaterialExtension,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\MarkupExtensions\MaterialExtension.cs,MaterialExtension,The following statement contains a magic number: this.SpecularPower = 100;  
Magic Number,HelixToolkit.Wpf,PanoramaCube3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\PanoramaCube3D.cs,AddCubeSide,The following statement contains a magic number: mesh.TriangleIndices.Add (2);  
Magic Number,HelixToolkit.Wpf,PanoramaCube3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\PanoramaCube3D.cs,AddCubeSide,The following statement contains a magic number: mesh.TriangleIndices.Add (2);  
Magic Number,HelixToolkit.Wpf,PanoramaCube3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\PanoramaCube3D.cs,AddCubeSide,The following statement contains a magic number: mesh.TriangleIndices.Add (3);  
Magic Number,HelixToolkit.Wpf,SlopeDirectionTexture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\Textures\SlopeDirectionTexture.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < normals.Count; i++) {  	double slopedir = Math.Atan2 (normals [i].Y' normals [i].X) * 180 / Math.PI;  	if (slopedir < 0) {  		slopedir += 360;  	}  	double u = slopedir / 360;  	texcoords.Add (new Point (u' u));  }  
Magic Number,HelixToolkit.Wpf,SlopeDirectionTexture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\Textures\SlopeDirectionTexture.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < normals.Count; i++) {  	double slopedir = Math.Atan2 (normals [i].Y' normals [i].X) * 180 / Math.PI;  	if (slopedir < 0) {  		slopedir += 360;  	}  	double u = slopedir / 360;  	texcoords.Add (new Point (u' u));  }  
Magic Number,HelixToolkit.Wpf,SlopeDirectionTexture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\Textures\SlopeDirectionTexture.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < normals.Count; i++) {  	double slopedir = Math.Atan2 (normals [i].Y' normals [i].X) * 180 / Math.PI;  	if (slopedir < 0) {  		slopedir += 360;  	}  	double u = slopedir / 360;  	texcoords.Add (new Point (u' u));  }  
Magic Number,HelixToolkit.Wpf,SlopeDirectionTexture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\Textures\SlopeDirectionTexture.cs,Calculate,The following statement contains a magic number: if (slopedir < 0) {  	slopedir += 360;  }  
Magic Number,HelixToolkit.Wpf,SlopeDirectionTexture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\Textures\SlopeDirectionTexture.cs,Calculate,The following statement contains a magic number: slopedir += 360;  
Magic Number,HelixToolkit.Wpf,SlopeTexture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\Textures\SlopeTexture.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < normals.Count; i++) {  	double slope = Math.Acos (Vector3D.DotProduct (normals [i]' up)) * 180 / Math.PI;  	double u = slope / 40;  	if (u > 1) {  		u = 1;  	}  	if (u < 0) {  		u = 0;  	}  	texcoords.Add (new Point (u' u));  }  
Magic Number,HelixToolkit.Wpf,SlopeTexture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\Textures\SlopeTexture.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < normals.Count; i++) {  	double slope = Math.Acos (Vector3D.DotProduct (normals [i]' up)) * 180 / Math.PI;  	double u = slope / 40;  	if (u > 1) {  		u = 1;  	}  	if (u < 0) {  		u = 0;  	}  	texcoords.Add (new Point (u' u));  }  
Magic Number,HelixToolkit.Wpf,TerrainModel,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\TerrainModel.cs,ReadTerrainFile,The following statement contains a magic number: using (var reader = new BinaryReader (stream)) {  	var buffer = reader.ReadBytes (10);  	var enc = new ASCIIEncoding ();  	var marker = enc.GetString (buffer);  	if (!marker.StartsWith ("binterr")) {  		throw new FileFormatException ("Invalid marker.");  	}  	var version = marker.Substring (7);  	this.Width = reader.ReadInt32 ();  	this.Height = reader.ReadInt32 ();  	short dataSize = reader.ReadInt16 ();  	bool isFloatingPoint = reader.ReadInt16 () == 1;  	short horizontalUnits = reader.ReadInt16 ();  	short utmZone = reader.ReadInt16 ();  	short datum = reader.ReadInt16 ();  	this.Left = reader.ReadDouble ();  	this.Right = reader.ReadDouble ();  	this.Bottom = reader.ReadDouble ();  	this.Top = reader.ReadDouble ();  	short proj = reader.ReadInt16 ();  	float scale = reader.ReadSingle ();  	var padding = reader.ReadBytes (190);  	int index = 0;  	this.Data = new double[this.Width * this.Height];  	this.MinimumZ = double.MaxValue;  	this.MaximumZ = double.MinValue;  	for (int y = 0; y < this.Height; y++) {  		for (int x = 0; x < this.Width; x++) {  			double z;  			if (dataSize == 2) {  				z = reader.ReadUInt16 ();  			} else {  				z = isFloatingPoint ? reader.ReadSingle () : reader.ReadUInt32 ();  			}  			this.Data [index++] = z;  			if (z < this.MinimumZ) {  				this.MinimumZ = z;  			}  			if (z > this.MaximumZ) {  				this.MaximumZ = z;  			}  		}  	}  }  
Magic Number,HelixToolkit.Wpf,TerrainModel,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\TerrainModel.cs,ReadTerrainFile,The following statement contains a magic number: using (var reader = new BinaryReader (stream)) {  	var buffer = reader.ReadBytes (10);  	var enc = new ASCIIEncoding ();  	var marker = enc.GetString (buffer);  	if (!marker.StartsWith ("binterr")) {  		throw new FileFormatException ("Invalid marker.");  	}  	var version = marker.Substring (7);  	this.Width = reader.ReadInt32 ();  	this.Height = reader.ReadInt32 ();  	short dataSize = reader.ReadInt16 ();  	bool isFloatingPoint = reader.ReadInt16 () == 1;  	short horizontalUnits = reader.ReadInt16 ();  	short utmZone = reader.ReadInt16 ();  	short datum = reader.ReadInt16 ();  	this.Left = reader.ReadDouble ();  	this.Right = reader.ReadDouble ();  	this.Bottom = reader.ReadDouble ();  	this.Top = reader.ReadDouble ();  	short proj = reader.ReadInt16 ();  	float scale = reader.ReadSingle ();  	var padding = reader.ReadBytes (190);  	int index = 0;  	this.Data = new double[this.Width * this.Height];  	this.MinimumZ = double.MaxValue;  	this.MaximumZ = double.MinValue;  	for (int y = 0; y < this.Height; y++) {  		for (int x = 0; x < this.Width; x++) {  			double z;  			if (dataSize == 2) {  				z = reader.ReadUInt16 ();  			} else {  				z = isFloatingPoint ? reader.ReadSingle () : reader.ReadUInt32 ();  			}  			this.Data [index++] = z;  			if (z < this.MinimumZ) {  				this.MinimumZ = z;  			}  			if (z > this.MaximumZ) {  				this.MaximumZ = z;  			}  		}  	}  }  
Magic Number,HelixToolkit.Wpf,TerrainModel,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\TerrainModel.cs,ReadTerrainFile,The following statement contains a magic number: using (var reader = new BinaryReader (stream)) {  	var buffer = reader.ReadBytes (10);  	var enc = new ASCIIEncoding ();  	var marker = enc.GetString (buffer);  	if (!marker.StartsWith ("binterr")) {  		throw new FileFormatException ("Invalid marker.");  	}  	var version = marker.Substring (7);  	this.Width = reader.ReadInt32 ();  	this.Height = reader.ReadInt32 ();  	short dataSize = reader.ReadInt16 ();  	bool isFloatingPoint = reader.ReadInt16 () == 1;  	short horizontalUnits = reader.ReadInt16 ();  	short utmZone = reader.ReadInt16 ();  	short datum = reader.ReadInt16 ();  	this.Left = reader.ReadDouble ();  	this.Right = reader.ReadDouble ();  	this.Bottom = reader.ReadDouble ();  	this.Top = reader.ReadDouble ();  	short proj = reader.ReadInt16 ();  	float scale = reader.ReadSingle ();  	var padding = reader.ReadBytes (190);  	int index = 0;  	this.Data = new double[this.Width * this.Height];  	this.MinimumZ = double.MaxValue;  	this.MaximumZ = double.MinValue;  	for (int y = 0; y < this.Height; y++) {  		for (int x = 0; x < this.Width; x++) {  			double z;  			if (dataSize == 2) {  				z = reader.ReadUInt16 ();  			} else {  				z = isFloatingPoint ? reader.ReadSingle () : reader.ReadUInt32 ();  			}  			this.Data [index++] = z;  			if (z < this.MinimumZ) {  				this.MinimumZ = z;  			}  			if (z > this.MaximumZ) {  				this.MaximumZ = z;  			}  		}  	}  }  
Magic Number,HelixToolkit.Wpf,TerrainModel,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\TerrainModel.cs,ReadTerrainFile,The following statement contains a magic number: using (var reader = new BinaryReader (stream)) {  	var buffer = reader.ReadBytes (10);  	var enc = new ASCIIEncoding ();  	var marker = enc.GetString (buffer);  	if (!marker.StartsWith ("binterr")) {  		throw new FileFormatException ("Invalid marker.");  	}  	var version = marker.Substring (7);  	this.Width = reader.ReadInt32 ();  	this.Height = reader.ReadInt32 ();  	short dataSize = reader.ReadInt16 ();  	bool isFloatingPoint = reader.ReadInt16 () == 1;  	short horizontalUnits = reader.ReadInt16 ();  	short utmZone = reader.ReadInt16 ();  	short datum = reader.ReadInt16 ();  	this.Left = reader.ReadDouble ();  	this.Right = reader.ReadDouble ();  	this.Bottom = reader.ReadDouble ();  	this.Top = reader.ReadDouble ();  	short proj = reader.ReadInt16 ();  	float scale = reader.ReadSingle ();  	var padding = reader.ReadBytes (190);  	int index = 0;  	this.Data = new double[this.Width * this.Height];  	this.MinimumZ = double.MaxValue;  	this.MaximumZ = double.MinValue;  	for (int y = 0; y < this.Height; y++) {  		for (int x = 0; x < this.Width; x++) {  			double z;  			if (dataSize == 2) {  				z = reader.ReadUInt16 ();  			} else {  				z = isFloatingPoint ? reader.ReadSingle () : reader.ReadUInt32 ();  			}  			this.Data [index++] = z;  			if (z < this.MinimumZ) {  				this.MinimumZ = z;  			}  			if (z > this.MaximumZ) {  				this.MaximumZ = z;  			}  		}  	}  }  
Magic Number,HelixToolkit.Wpf,TerrainModel,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\TerrainModel.cs,ReadTerrainFile,The following statement contains a magic number: for (int y = 0; y < this.Height; y++) {  	for (int x = 0; x < this.Width; x++) {  		double z;  		if (dataSize == 2) {  			z = reader.ReadUInt16 ();  		} else {  			z = isFloatingPoint ? reader.ReadSingle () : reader.ReadUInt32 ();  		}  		this.Data [index++] = z;  		if (z < this.MinimumZ) {  			this.MinimumZ = z;  		}  		if (z > this.MaximumZ) {  			this.MaximumZ = z;  		}  	}  }  
Magic Number,HelixToolkit.Wpf,TerrainModel,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\TerrainModel.cs,ReadTerrainFile,The following statement contains a magic number: for (int x = 0; x < this.Width; x++) {  	double z;  	if (dataSize == 2) {  		z = reader.ReadUInt16 ();  	} else {  		z = isFloatingPoint ? reader.ReadSingle () : reader.ReadUInt32 ();  	}  	this.Data [index++] = z;  	if (z < this.MinimumZ) {  		this.MinimumZ = z;  	}  	if (z > this.MaximumZ) {  		this.MaximumZ = z;  	}  }  
Magic Number,HelixToolkit.Wpf,TerrainModel,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\TerrainModel.cs,ReadTerrainFile,The following statement contains a magic number: if (dataSize == 2) {  	z = reader.ReadUInt16 ();  } else {  	z = isFloatingPoint ? reader.ReadSingle () : reader.ReadUInt32 ();  }  
Magic Number,HelixToolkit.Wpf,TerrainVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\TerrainVisual3D.cs,UpdateModel,The following statement contains a magic number: r.Texture = new SlopeTexture (8);  
Magic Number,HelixToolkit.Wpf,TerrainVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\TerrainVisual3D.cs,UpdateModel,The following statement contains a magic number: this.visualChild.Content = r.CreateModel (2);  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: element.Measure (new Size (1000' 1000));  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: element.Measure (new Size (1000' 1000));  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: if (this.FontSize > 0) {  	var rtb = new RenderTargetBitmap ((int)element.ActualWidth + 1' (int)element.ActualHeight + 1' 96' 96' PixelFormats.Pbgra32);  	rtb.Render (element);  	rtb.Freeze ();  	material = new DiffuseMaterial (new ImageBrush (rtb));  } else {  	material = new DiffuseMaterial {  		Brush = new VisualBrush (element)  	};  }  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: if (this.FontSize > 0) {  	var rtb = new RenderTargetBitmap ((int)element.ActualWidth + 1' (int)element.ActualHeight + 1' 96' 96' PixelFormats.Pbgra32);  	rtb.Render (element);  	rtb.Freeze ();  	material = new DiffuseMaterial (new ImageBrush (rtb));  } else {  	material = new DiffuseMaterial {  		Brush = new VisualBrush (element)  	};  }  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: mg.TriangleIndices.Add (3);  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: mg.TriangleIndices.Add (2);  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: mg.TriangleIndices.Add (3);  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: if (isDoubleSided) {  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (5);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (6);  }  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: if (isDoubleSided) {  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (5);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (6);  }  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: if (isDoubleSided) {  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (5);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (6);  }  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: if (isDoubleSided) {  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (5);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (6);  }  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: if (isDoubleSided) {  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (5);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (6);  }  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: if (isDoubleSided) {  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (5);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (6);  }  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: mg.TriangleIndices.Add (4);  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: mg.TriangleIndices.Add (5);  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: mg.TriangleIndices.Add (7);  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: mg.TriangleIndices.Add (4);  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: mg.TriangleIndices.Add (7);  
Magic Number,HelixToolkit.Wpf,TextVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Text\TextVisual3D.cs,VisualChanged,The following statement contains a magic number: mg.TriangleIndices.Add (6);  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,UpdateVisuals,The following statement contains a magic number: CubeFaceModels.Add (this.AddCubeFace (vecLeft' vecUp' GetCubefaceColor (2)' this.LeftText));  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,UpdateVisuals,The following statement contains a magic number: CubeFaceModels.Add (this.AddCubeFace (-vecLeft' vecUp' GetCubefaceColor (3)' this.RightText));  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,UpdateVisuals,The following statement contains a magic number: CubeFaceModels.Add (this.AddCubeFace (vecUp' vecLeft' GetCubefaceColor (4)' this.TopText));  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,UpdateVisuals,The following statement contains a magic number: CubeFaceModels.Add (this.AddCubeFace (-vecUp' -vecLeft' GetCubefaceColor (5)' this.BottomText));  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,UpdateVisuals,The following statement contains a magic number: circle.Center = (this.ModelUpDirection * (-this.Size / 2)).ToPoint3D ();  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,UpdateVisuals,The following statement contains a magic number: circle.OuterRadius = this.Size * 1.3;  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,UpdateVisuals,The following statement contains a magic number: circle.EndAngle = 360;  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,GetCubefaceColor,The following statement contains a magic number: switch (index) {  case 0:  case 1:  	return Brushes.Red;  case 2:  case 3:  	if (ModelUpDirection.Z < 1) {  		return Brushes.Blue;  	} else {  		return Brushes.Green;  	}  case 4:  case 5:  	if (ModelUpDirection.Z < 1) {  		return Brushes.Green;  	} else {  		return Brushes.Blue;  	}  default:  	return Brushes.White;  }  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,GetCubefaceColor,The following statement contains a magic number: switch (index) {  case 0:  case 1:  	return Brushes.Red;  case 2:  case 3:  	if (ModelUpDirection.Z < 1) {  		return Brushes.Blue;  	} else {  		return Brushes.Green;  	}  case 4:  case 5:  	if (ModelUpDirection.Z < 1) {  		return Brushes.Green;  	} else {  		return Brushes.Blue;  	}  default:  	return Brushes.White;  }  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,GetCubefaceColor,The following statement contains a magic number: switch (index) {  case 0:  case 1:  	return Brushes.Red;  case 2:  case 3:  	if (ModelUpDirection.Z < 1) {  		return Brushes.Blue;  	} else {  		return Brushes.Green;  	}  case 4:  case 5:  	if (ModelUpDirection.Z < 1) {  		return Brushes.Green;  	} else {  		return Brushes.Blue;  	}  default:  	return Brushes.White;  }  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,GetCubefaceColor,The following statement contains a magic number: switch (index) {  case 0:  case 1:  	return Brushes.Red;  case 2:  case 3:  	if (ModelUpDirection.Z < 1) {  		return Brushes.Blue;  	} else {  		return Brushes.Green;  	}  case 4:  case 5:  	if (ModelUpDirection.Z < 1) {  		return Brushes.Green;  	} else {  		return Brushes.Blue;  	}  default:  	return Brushes.White;  }  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,AddEdges,The following statement contains a magic number: foreach (var p in xAligned) {  	Point3D center = p.Multiply (halfSize);  	AddEdge (center' 1.5 * halfSize' sideLength' sideLength' p.ToVector3D ());  }  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,AddEdges,The following statement contains a magic number: AddEdge (center' 1.5 * halfSize' sideLength' sideLength' p.ToVector3D ());  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,AddEdges,The following statement contains a magic number: foreach (var p in yAligned) {  	Point3D center = p.Multiply (halfSize);  	AddEdge (center' sideLength' 1.5 * halfSize' sideLength' p.ToVector3D ());  }  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,AddEdges,The following statement contains a magic number: AddEdge (center' sideLength' 1.5 * halfSize' sideLength' p.ToVector3D ());  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,AddEdges,The following statement contains a magic number: foreach (var p in zAligned) {  	Point3D center = p.Multiply (halfSize);  	AddEdge (center' sideLength' sideLength' 1.5 * halfSize' p.ToVector3D ());  }  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,AddEdges,The following statement contains a magic number: AddEdge (center' sideLength' sideLength' 1.5 * halfSize' p.ToVector3D ());  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,CreateTextMaterial,The following statement contains a magic number: grid.Children.Add (new TextBlock {  	Text = text'  	VerticalAlignment = VerticalAlignment.Center'  	HorizontalAlignment = HorizontalAlignment.Center'  	FontSize = 15'  	Foreground = Brushes.White  });  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,CreateTextMaterial,The following statement contains a magic number: grid.Arrange (new Rect (new Point (0' 0)' new Size (20' 20)));  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,CreateTextMaterial,The following statement contains a magic number: grid.Arrange (new Rect (new Point (0' 0)' new Size (20' 20)));  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,FaceMouseLeftButtonDown,The following statement contains a magic number: if (e.ClickCount == 2) {  	lookDirection *= -1;  	if (upDirection != this.ModelUpDirection) {  		upDirection *= -1;  	}  }  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,FaceMouseLeftButtonDown,The following statement contains a magic number: if (this.Viewport != null) {  	var camera = this.Viewport.Camera as ProjectionCamera;  	if (camera != null) {  		var target = camera.Position + camera.LookDirection;  		double distance = camera.LookDirection.Length;  		lookDirection *= distance;  		var newPosition = target - lookDirection;  		CameraHelper.AnimateTo (camera' newPosition' lookDirection' upDirection' 500);  	}  }  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,FaceMouseLeftButtonDown,The following statement contains a magic number: if (camera != null) {  	var target = camera.Position + camera.LookDirection;  	double distance = camera.LookDirection.Length;  	lookDirection *= distance;  	var newPosition = target - lookDirection;  	CameraHelper.AnimateTo (camera' newPosition' lookDirection' upDirection' 500);  }  
Magic Number,HelixToolkit.Wpf,ViewCubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\ViewCubeVisual3D.cs,FaceMouseLeftButtonDown,The following statement contains a magic number: CameraHelper.AnimateTo (camera' newPosition' lookDirection' upDirection' 500);  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (180' 180' 180)' new Vector3D (-1' -1' -1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (180' 180' 180)' new Vector3D (-1' -1' -1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (180' 180' 180)' new Vector3D (-1' -1' -1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (120' 120' 120)' new Vector3D (1' -1' -0.1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (120' 120' 120)' new Vector3D (1' -1' -0.1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (120' 120' 120)' new Vector3D (1' -1' -0.1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (120' 120' 120)' new Vector3D (1' -1' -0.1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (60' 60' 60)' new Vector3D (0.1' 1' -1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (60' 60' 60)' new Vector3D (0.1' 1' -1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (60' 60' 60)' new Vector3D (0.1' 1' -1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (60' 60' 60)' new Vector3D (0.1' 1' -1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (50' 50' 50)' new Vector3D (0.1' 0.1' 1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (50' 50' 50)' new Vector3D (0.1' 0.1' 1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (50' 50' 50)' new Vector3D (0.1' 0.1' 1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (50' 50' 50)' new Vector3D (0.1' 0.1' 1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new DirectionalLight (Color.FromRgb (50' 50' 50)' new Vector3D (0.1' 0.1' 1)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new AmbientLight (Color.FromRgb (30' 30' 30)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new AmbientLight (Color.FromRgb (30' 30' 30)));  
Magic Number,HelixToolkit.Wpf,DefaultLights,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\LightSetups\DefaultLights.cs,AddLights,The following statement contains a magic number: lightGroup.Children.Add (new AmbientLight (Color.FromRgb (30' 30' 30)));  
Magic Number,HelixToolkit.Wpf,MaterialHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\MaterialHelper.cs,CreateMaterial,The following statement contains a magic number: return CreateMaterial (Color.FromArgb ((byte)(opacity * 255)' color.R' color.G' color.B));  
Magic Number,HelixToolkit.Wpf,MaterialHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\MaterialHelper.cs,CreateMaterial,The following statement contains a magic number: if (specularPower > 0) {  	var b = (byte)(255 * specularBrightness);  	mg.Children.Add (new SpecularMaterial (new SolidColorBrush (Color.FromRgb (b' b' b))' specularPower));  }  
Magic Number,HelixToolkit.Wpf,ElementSortingHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ElementSortingHelper.cs,IsTransparent,The following statement contains a magic number: if (dm != null) {  	if (IsTransparent (dm.Brush)) {  		return true;  	}  	if (dm.Color.A < 255) {  		return true;  	}  }  
Magic Number,HelixToolkit.Wpf,ElementSortingHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ElementSortingHelper.cs,IsTransparent,The following statement contains a magic number: if (dm.Color.A < 255) {  	return true;  }  
Magic Number,HelixToolkit.Wpf,ElementSortingHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ElementSortingHelper.cs,IsTransparent,The following statement contains a magic number: if (scb != null) {  	return scb.Color.A < 255;  }  
Magic Number,HelixToolkit.Wpf,ElementSortingHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ElementSortingHelper.cs,IsTransparent,The following statement contains a magic number: return scb.Color.A < 255;  
Magic Number,HelixToolkit.Wpf,ElementSortingHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ElementSortingHelper.cs,IsTransparent,The following statement contains a magic number: if (gb != null) {  	return gb.GradientStops.Any (gs => gs.Color.A < 255);  }  
Magic Number,HelixToolkit.Wpf,ElementSortingHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ElementSortingHelper.cs,IsTransparent,The following statement contains a magic number: return gb.GradientStops.Any (gs => gs.Color.A < 255);  
Magic Number,HelixToolkit.Wpf,StereoHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\StereoHelper.cs,CalculateStereoBase,The following statement contains a magic number: return P * (L * N / (L - N)) * (1 / F - (L + N) / (2 * L * N));  
Magic Number,HelixToolkit.Wpf,StereoHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\StereoHelper.cs,FindFocalLength,The following statement contains a magic number: return format / 2 / Math.Tan (fov / 2 * Math.PI / 180);  
Magic Number,HelixToolkit.Wpf,StereoHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\StereoHelper.cs,FindFocalLength,The following statement contains a magic number: return format / 2 / Math.Tan (fov / 2 * Math.PI / 180);  
Magic Number,HelixToolkit.Wpf,StereoHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\StereoHelper.cs,FindFocalLength,The following statement contains a magic number: return format / 2 / Math.Tan (fov / 2 * Math.PI / 180);  
Magic Number,HelixToolkit.Wpf,StereoHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\StereoHelper.cs,UpdateStereoCameras,The following statement contains a magic number: leftCamera.Position = centerCamera.Position - (right * stereoBase / 2);  
Magic Number,HelixToolkit.Wpf,StereoHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\StereoHelper.cs,UpdateStereoCameras,The following statement contains a magic number: rightCamera.Position = centerCamera.Position + (right * stereoBase / 2);  
Magic Number,HelixToolkit.Wpf,TargetSymbolAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\TargetSymbolAdorner.cs,OnRender,The following statement contains a magic number: lightBrush.Opacity = 0.4;  
Magic Number,HelixToolkit.Wpf,TargetSymbolAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\TargetSymbolAdorner.cs,OnRender,The following statement contains a magic number: darkBrush.Opacity = 0.1;  
Magic Number,HelixToolkit.Wpf,TargetSymbolAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\TargetSymbolAdorner.cs,OnRender,The following statement contains a magic number: dc.DrawArc (null' lightPen' this.Position' 10' 80' r4' r4);  
Magic Number,HelixToolkit.Wpf,TargetSymbolAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\TargetSymbolAdorner.cs,OnRender,The following statement contains a magic number: dc.DrawArc (null' lightPen' this.Position' 10' 80' r4' r4);  
Magic Number,HelixToolkit.Wpf,TargetSymbolAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\TargetSymbolAdorner.cs,OnRender,The following statement contains a magic number: dc.DrawArc (null' lightPen' this.Position' 100' 170' r4' r4);  
Magic Number,HelixToolkit.Wpf,TargetSymbolAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\TargetSymbolAdorner.cs,OnRender,The following statement contains a magic number: dc.DrawArc (null' lightPen' this.Position' 100' 170' r4' r4);  
Magic Number,HelixToolkit.Wpf,TargetSymbolAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\TargetSymbolAdorner.cs,OnRender,The following statement contains a magic number: dc.DrawArc (null' lightPen' this.Position' 190' 260' r4' r4);  
Magic Number,HelixToolkit.Wpf,TargetSymbolAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\TargetSymbolAdorner.cs,OnRender,The following statement contains a magic number: dc.DrawArc (null' lightPen' this.Position' 190' 260' r4' r4);  
Magic Number,HelixToolkit.Wpf,TargetSymbolAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\TargetSymbolAdorner.cs,OnRender,The following statement contains a magic number: dc.DrawArc (null' lightPen' this.Position' 280' 350' r4' r4);  
Magic Number,HelixToolkit.Wpf,TargetSymbolAdorner,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Adorners\TargetSymbolAdorner.cs,OnRender,The following statement contains a magic number: dc.DrawArc (null' lightPen' this.Position' 280' 350' r4' r4);  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: mg.TriangleIndices.Add (3);  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: mg.TriangleIndices.Add (2);  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: mg.TriangleIndices.Add (3);  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: if (isDoubleSided) {  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (5);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (6);  }  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: if (isDoubleSided) {  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (5);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (6);  }  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: if (isDoubleSided) {  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (5);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (6);  }  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: if (isDoubleSided) {  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (5);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (6);  }  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: if (isDoubleSided) {  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (5);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (6);  }  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: if (isDoubleSided) {  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (5);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (4);  	mg.TriangleIndices.Add (7);  	mg.TriangleIndices.Add (6);  }  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: mg.TriangleIndices.Add (4);  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: mg.TriangleIndices.Add (5);  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: mg.TriangleIndices.Add (7);  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: mg.TriangleIndices.Add (4);  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: mg.TriangleIndices.Add (7);  
Magic Number,HelixToolkit.Wpf,TextCreator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\TextCreator.cs,CreateTextLabelModel3D,The following statement contains a magic number: mg.TriangleIndices.Add (6);  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,Export,The following statement contains a magic number: switch (ext) {  case ".jpg":  case ".png":  	SaveBitmap (viewport' fileName' background' 2);  	break;  case ".xaml":  	ExportXaml (viewport' fileName);  	break;  case ".xml":  	ExportKerkythea (viewport' fileName' background);  	break;  case ".obj":  	ExportObj (viewport' fileName);  	break;  case ".x3d":  	ExportX3D (viewport' fileName);  	break;  case ".dae":  	ExportCollada (viewport' fileName);  	break;  case ".stl":  	ExportStl (viewport' fileName);  	break;  default:  	throw new HelixToolkitException ("Not supported file format.");  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,Export,The following statement contains a magic number: SaveBitmap (viewport' fileName' background' 2);  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,ExportStereo,The following statement contains a magic number: switch (ext) {  case ".jpg":  case ".png":  	SaveStereoBitmap (viewport' fileName' stereoBase' background' 2);  	break;  case ".mpo":  	throw new HelixToolkitException ("MPO is not yet supported.");  default:  	throw new HelixToolkitException ("Not supported file format.");  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,ExportStereo,The following statement contains a magic number: SaveStereoBitmap (viewport' fileName' stereoBase' background' 2);  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,FindHits,The following statement contains a magic number: viewport.Children.Traverse<GeometryModel3D> ((model' transform) => {  	var geometry = model.Geometry as MeshGeometry3D;  	if (geometry == null || geometry.Positions == null || geometry.TriangleIndices == null) {  		return;  	}  	var status = mode == SelectionHitMode.Inside;  	// transform the positions of the mesh to screen coordinates  	var point2Ds = geometry.Positions.Select (transform.Transform).Select (viewport.Point3DtoPoint2D).ToArray ();  	// evaluate each triangle  	for (var i = 0; i < geometry.TriangleIndices.Count / 3; i++) {  		var triangle = new Triangle (point2Ds [geometry.TriangleIndices [i * 3]]' point2Ds [geometry.TriangleIndices [(i * 3) + 1]]' point2Ds [geometry.TriangleIndices [(i * 3) + 2]]);  		switch (mode) {  		case SelectionHitMode.Inside:  			status = status && triangle.IsCompletelyInside (rectangle);  			break;  		case SelectionHitMode.Touch:  			status = status || triangle.IsCompletelyInside (rectangle) || triangle.IntersectsWith (rectangle) || triangle.IsRectCompletelyInside (rectangle);  			break;  		}  		if (mode == SelectionHitMode.Touch && status) {  			break;  		}  	}  	if (status) {  		results.Add (new RectangleHitResult (model));  	}  });  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,FindHits,The following statement contains a magic number: viewport.Children.Traverse<GeometryModel3D> ((model' transform) => {  	var geometry = model.Geometry as MeshGeometry3D;  	if (geometry == null || geometry.Positions == null || geometry.TriangleIndices == null) {  		return;  	}  	var status = mode == SelectionHitMode.Inside;  	// transform the positions of the mesh to screen coordinates  	var point2Ds = geometry.Positions.Select (transform.Transform).Select (viewport.Point3DtoPoint2D).ToArray ();  	// evaluate each triangle  	for (var i = 0; i < geometry.TriangleIndices.Count / 3; i++) {  		var triangle = new Triangle (point2Ds [geometry.TriangleIndices [i * 3]]' point2Ds [geometry.TriangleIndices [(i * 3) + 1]]' point2Ds [geometry.TriangleIndices [(i * 3) + 2]]);  		switch (mode) {  		case SelectionHitMode.Inside:  			status = status && triangle.IsCompletelyInside (rectangle);  			break;  		case SelectionHitMode.Touch:  			status = status || triangle.IsCompletelyInside (rectangle) || triangle.IntersectsWith (rectangle) || triangle.IsRectCompletelyInside (rectangle);  			break;  		}  		if (mode == SelectionHitMode.Touch && status) {  			break;  		}  	}  	if (status) {  		results.Add (new RectangleHitResult (model));  	}  });  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,FindHits,The following statement contains a magic number: viewport.Children.Traverse<GeometryModel3D> ((model' transform) => {  	var geometry = model.Geometry as MeshGeometry3D;  	if (geometry == null || geometry.Positions == null || geometry.TriangleIndices == null) {  		return;  	}  	var status = mode == SelectionHitMode.Inside;  	// transform the positions of the mesh to screen coordinates  	var point2Ds = geometry.Positions.Select (transform.Transform).Select (viewport.Point3DtoPoint2D).ToArray ();  	// evaluate each triangle  	for (var i = 0; i < geometry.TriangleIndices.Count / 3; i++) {  		var triangle = new Triangle (point2Ds [geometry.TriangleIndices [i * 3]]' point2Ds [geometry.TriangleIndices [(i * 3) + 1]]' point2Ds [geometry.TriangleIndices [(i * 3) + 2]]);  		switch (mode) {  		case SelectionHitMode.Inside:  			status = status && triangle.IsCompletelyInside (rectangle);  			break;  		case SelectionHitMode.Touch:  			status = status || triangle.IsCompletelyInside (rectangle) || triangle.IntersectsWith (rectangle) || triangle.IsRectCompletelyInside (rectangle);  			break;  		}  		if (mode == SelectionHitMode.Touch && status) {  			break;  		}  	}  	if (status) {  		results.Add (new RectangleHitResult (model));  	}  });  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,FindHits,The following statement contains a magic number: viewport.Children.Traverse<GeometryModel3D> ((model' transform) => {  	var geometry = model.Geometry as MeshGeometry3D;  	if (geometry == null || geometry.Positions == null || geometry.TriangleIndices == null) {  		return;  	}  	var status = mode == SelectionHitMode.Inside;  	// transform the positions of the mesh to screen coordinates  	var point2Ds = geometry.Positions.Select (transform.Transform).Select (viewport.Point3DtoPoint2D).ToArray ();  	// evaluate each triangle  	for (var i = 0; i < geometry.TriangleIndices.Count / 3; i++) {  		var triangle = new Triangle (point2Ds [geometry.TriangleIndices [i * 3]]' point2Ds [geometry.TriangleIndices [(i * 3) + 1]]' point2Ds [geometry.TriangleIndices [(i * 3) + 2]]);  		switch (mode) {  		case SelectionHitMode.Inside:  			status = status && triangle.IsCompletelyInside (rectangle);  			break;  		case SelectionHitMode.Touch:  			status = status || triangle.IsCompletelyInside (rectangle) || triangle.IntersectsWith (rectangle) || triangle.IsRectCompletelyInside (rectangle);  			break;  		}  		if (mode == SelectionHitMode.Touch && status) {  			break;  		}  	}  	if (status) {  		results.Add (new RectangleHitResult (model));  	}  });  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,FindHits,The following statement contains a magic number: viewport.Children.Traverse<GeometryModel3D> ((model' transform) => {  	var geometry = model.Geometry as MeshGeometry3D;  	if (geometry == null || geometry.Positions == null || geometry.TriangleIndices == null) {  		return;  	}  	var status = mode == SelectionHitMode.Inside;  	// transform the positions of the mesh to screen coordinates  	var point2Ds = geometry.Positions.Select (transform.Transform).Select (viewport.Point3DtoPoint2D).ToArray ();  	// evaluate each triangle  	for (var i = 0; i < geometry.TriangleIndices.Count / 3; i++) {  		var triangle = new Triangle (point2Ds [geometry.TriangleIndices [i * 3]]' point2Ds [geometry.TriangleIndices [(i * 3) + 1]]' point2Ds [geometry.TriangleIndices [(i * 3) + 2]]);  		switch (mode) {  		case SelectionHitMode.Inside:  			status = status && triangle.IsCompletelyInside (rectangle);  			break;  		case SelectionHitMode.Touch:  			status = status || triangle.IsCompletelyInside (rectangle) || triangle.IntersectsWith (rectangle) || triangle.IsRectCompletelyInside (rectangle);  			break;  		}  		if (mode == SelectionHitMode.Touch && status) {  			break;  		}  	}  	if (status) {  		results.Add (new RectangleHitResult (model));  	}  });  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,FindHits,The following statement contains a magic number: for (var i = 0; i < geometry.TriangleIndices.Count / 3; i++) {  	var triangle = new Triangle (point2Ds [geometry.TriangleIndices [i * 3]]' point2Ds [geometry.TriangleIndices [(i * 3) + 1]]' point2Ds [geometry.TriangleIndices [(i * 3) + 2]]);  	switch (mode) {  	case SelectionHitMode.Inside:  		status = status && triangle.IsCompletelyInside (rectangle);  		break;  	case SelectionHitMode.Touch:  		status = status || triangle.IsCompletelyInside (rectangle) || triangle.IntersectsWith (rectangle) || triangle.IsRectCompletelyInside (rectangle);  		break;  	}  	if (mode == SelectionHitMode.Touch && status) {  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,FindHits,The following statement contains a magic number: for (var i = 0; i < geometry.TriangleIndices.Count / 3; i++) {  	var triangle = new Triangle (point2Ds [geometry.TriangleIndices [i * 3]]' point2Ds [geometry.TriangleIndices [(i * 3) + 1]]' point2Ds [geometry.TriangleIndices [(i * 3) + 2]]);  	switch (mode) {  	case SelectionHitMode.Inside:  		status = status && triangle.IsCompletelyInside (rectangle);  		break;  	case SelectionHitMode.Touch:  		status = status || triangle.IsCompletelyInside (rectangle) || triangle.IntersectsWith (rectangle) || triangle.IsRectCompletelyInside (rectangle);  		break;  	}  	if (mode == SelectionHitMode.Touch && status) {  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,FindHits,The following statement contains a magic number: for (var i = 0; i < geometry.TriangleIndices.Count / 3; i++) {  	var triangle = new Triangle (point2Ds [geometry.TriangleIndices [i * 3]]' point2Ds [geometry.TriangleIndices [(i * 3) + 1]]' point2Ds [geometry.TriangleIndices [(i * 3) + 2]]);  	switch (mode) {  	case SelectionHitMode.Inside:  		status = status && triangle.IsCompletelyInside (rectangle);  		break;  	case SelectionHitMode.Touch:  		status = status || triangle.IsCompletelyInside (rectangle) || triangle.IntersectsWith (rectangle) || triangle.IsRectCompletelyInside (rectangle);  		break;  	}  	if (mode == SelectionHitMode.Touch && status) {  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,FindHits,The following statement contains a magic number: for (var i = 0; i < geometry.TriangleIndices.Count / 3; i++) {  	var triangle = new Triangle (point2Ds [geometry.TriangleIndices [i * 3]]' point2Ds [geometry.TriangleIndices [(i * 3) + 1]]' point2Ds [geometry.TriangleIndices [(i * 3) + 2]]);  	switch (mode) {  	case SelectionHitMode.Inside:  		status = status && triangle.IsCompletelyInside (rectangle);  		break;  	case SelectionHitMode.Touch:  		status = status || triangle.IsCompletelyInside (rectangle) || triangle.IntersectsWith (rectangle) || triangle.IsRectCompletelyInside (rectangle);  		break;  	}  	if (mode == SelectionHitMode.Touch && status) {  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,FindHits,The following statement contains a magic number: for (var i = 0; i < geometry.TriangleIndices.Count / 3; i++) {  	var triangle = new Triangle (point2Ds [geometry.TriangleIndices [i * 3]]' point2Ds [geometry.TriangleIndices [(i * 3) + 1]]' point2Ds [geometry.TriangleIndices [(i * 3) + 2]]);  	switch (mode) {  	case SelectionHitMode.Inside:  		status = status && triangle.IsCompletelyInside (rectangle);  		break;  	case SelectionHitMode.Touch:  		status = status || triangle.IsCompletelyInside (rectangle) || triangle.IntersectsWith (rectangle) || triangle.IsRectCompletelyInside (rectangle);  		break;  	}  	if (mode == SelectionHitMode.Touch && status) {  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetViewportTransform,The following statement contains a magic number: return new Matrix3D (viewport3DVisual.Viewport.Width / 2' 0' 0' 0' 0' -viewport3DVisual.Viewport.Height / 2' 0' 0' 0' 0' 1' 0' viewport3DVisual.Viewport.X + (viewport3DVisual.Viewport.Width / 2)' viewport3DVisual.Viewport.Y + (viewport3DVisual.Viewport.Height / 2)' 0' 1);  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetViewportTransform,The following statement contains a magic number: return new Matrix3D (viewport3DVisual.Viewport.Width / 2' 0' 0' 0' 0' -viewport3DVisual.Viewport.Height / 2' 0' 0' 0' 0' 1' 0' viewport3DVisual.Viewport.X + (viewport3DVisual.Viewport.Width / 2)' viewport3DVisual.Viewport.Y + (viewport3DVisual.Viewport.Height / 2)' 0' 1);  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetViewportTransform,The following statement contains a magic number: return new Matrix3D (viewport3DVisual.Viewport.Width / 2' 0' 0' 0' 0' -viewport3DVisual.Viewport.Height / 2' 0' 0' 0' 0' 1' 0' viewport3DVisual.Viewport.X + (viewport3DVisual.Viewport.Width / 2)' viewport3DVisual.Viewport.Y + (viewport3DVisual.Viewport.Height / 2)' 0' 1);  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetViewportTransform,The following statement contains a magic number: return new Matrix3D (viewport3DVisual.Viewport.Width / 2' 0' 0' 0' 0' -viewport3DVisual.Viewport.Height / 2' 0' 0' 0' 0' 1' 0' viewport3DVisual.Viewport.X + (viewport3DVisual.Viewport.Width / 2)' viewport3DVisual.Viewport.Y + (viewport3DVisual.Viewport.Height / 2)' 0' 1);  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetViewportTransform,The following statement contains a magic number: return new Matrix3D (viewport.ActualWidth / 2' 0' 0' 0' 0' -viewport.ActualHeight / 2' 0' 0' 0' 0' 1' 0' viewport.ActualWidth / 2' viewport.ActualHeight / 2' 0' 1);  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetViewportTransform,The following statement contains a magic number: return new Matrix3D (viewport.ActualWidth / 2' 0' 0' 0' 0' -viewport.ActualHeight / 2' 0' 0' 0' 0' 1' 0' viewport.ActualWidth / 2' viewport.ActualHeight / 2' 0' 1);  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetViewportTransform,The following statement contains a magic number: return new Matrix3D (viewport.ActualWidth / 2' 0' 0' 0' 0' -viewport.ActualHeight / 2' 0' 0' 0' 0' 1' 0' viewport.ActualWidth / 2' viewport.ActualHeight / 2' 0' 1);  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetViewportTransform,The following statement contains a magic number: return new Matrix3D (viewport.ActualWidth / 2' 0' 0' 0' 0' -viewport.ActualHeight / 2' 0' 0' 0' 0' 1' 0' viewport.ActualWidth / 2' viewport.ActualHeight / 2' 0' 1);  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,Point2DtoPoint3D,The following statement contains a magic number: pointNormalized.Z = 0.01;  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,Point2DtoPoint3D,The following statement contains a magic number: pointNormalized.Z = 0.99;  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < m; j++) {  		// change the camera viewport and scaling  		var pm = originalCamera.GetProjectionMatrix (ar);  		if (originalCamera is OrthographicCamera) {  			pm.OffsetX = m - 1 - (i * 2);  			pm.OffsetY = -(m - 1 - (j * 2));  		}  		if (originalCamera is PerspectiveCamera) {  			pm.M31 = -(m - 1 - (i * 2));  			pm.M32 = m - 1 - (j * 2);  		}  		pm.M11 *= m;  		pm.M22 *= m;  		var mc = new MatrixCamera (vm' pm);  		view.Camera = mc;  		var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  		// render background  		var backgroundRectangle = new Rectangle {  			Width = partialBitmap.Width'  			Height = partialBitmap.Height'  			Fill = background  		};  		backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  		partialBitmap.Render (backgroundRectangle);  		// render 3d  		partialBitmap.Render (view);  		// copy to the target bitmap  		CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  	}  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < m; j++) {  		// change the camera viewport and scaling  		var pm = originalCamera.GetProjectionMatrix (ar);  		if (originalCamera is OrthographicCamera) {  			pm.OffsetX = m - 1 - (i * 2);  			pm.OffsetY = -(m - 1 - (j * 2));  		}  		if (originalCamera is PerspectiveCamera) {  			pm.M31 = -(m - 1 - (i * 2));  			pm.M32 = m - 1 - (j * 2);  		}  		pm.M11 *= m;  		pm.M22 *= m;  		var mc = new MatrixCamera (vm' pm);  		view.Camera = mc;  		var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  		// render background  		var backgroundRectangle = new Rectangle {  			Width = partialBitmap.Width'  			Height = partialBitmap.Height'  			Fill = background  		};  		backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  		partialBitmap.Render (backgroundRectangle);  		// render 3d  		partialBitmap.Render (view);  		// copy to the target bitmap  		CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  	}  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < m; j++) {  		// change the camera viewport and scaling  		var pm = originalCamera.GetProjectionMatrix (ar);  		if (originalCamera is OrthographicCamera) {  			pm.OffsetX = m - 1 - (i * 2);  			pm.OffsetY = -(m - 1 - (j * 2));  		}  		if (originalCamera is PerspectiveCamera) {  			pm.M31 = -(m - 1 - (i * 2));  			pm.M32 = m - 1 - (j * 2);  		}  		pm.M11 *= m;  		pm.M22 *= m;  		var mc = new MatrixCamera (vm' pm);  		view.Camera = mc;  		var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  		// render background  		var backgroundRectangle = new Rectangle {  			Width = partialBitmap.Width'  			Height = partialBitmap.Height'  			Fill = background  		};  		backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  		partialBitmap.Render (backgroundRectangle);  		// render 3d  		partialBitmap.Render (view);  		// copy to the target bitmap  		CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  	}  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < m; j++) {  		// change the camera viewport and scaling  		var pm = originalCamera.GetProjectionMatrix (ar);  		if (originalCamera is OrthographicCamera) {  			pm.OffsetX = m - 1 - (i * 2);  			pm.OffsetY = -(m - 1 - (j * 2));  		}  		if (originalCamera is PerspectiveCamera) {  			pm.M31 = -(m - 1 - (i * 2));  			pm.M32 = m - 1 - (j * 2);  		}  		pm.M11 *= m;  		pm.M22 *= m;  		var mc = new MatrixCamera (vm' pm);  		view.Camera = mc;  		var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  		// render background  		var backgroundRectangle = new Rectangle {  			Width = partialBitmap.Width'  			Height = partialBitmap.Height'  			Fill = background  		};  		backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  		partialBitmap.Render (backgroundRectangle);  		// render 3d  		partialBitmap.Render (view);  		// copy to the target bitmap  		CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  	}  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < m; j++) {  		// change the camera viewport and scaling  		var pm = originalCamera.GetProjectionMatrix (ar);  		if (originalCamera is OrthographicCamera) {  			pm.OffsetX = m - 1 - (i * 2);  			pm.OffsetY = -(m - 1 - (j * 2));  		}  		if (originalCamera is PerspectiveCamera) {  			pm.M31 = -(m - 1 - (i * 2));  			pm.M32 = m - 1 - (j * 2);  		}  		pm.M11 *= m;  		pm.M22 *= m;  		var mc = new MatrixCamera (vm' pm);  		view.Camera = mc;  		var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  		// render background  		var backgroundRectangle = new Rectangle {  			Width = partialBitmap.Width'  			Height = partialBitmap.Height'  			Fill = background  		};  		backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  		partialBitmap.Render (backgroundRectangle);  		// render 3d  		partialBitmap.Render (view);  		// copy to the target bitmap  		CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  	}  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < m; j++) {  		// change the camera viewport and scaling  		var pm = originalCamera.GetProjectionMatrix (ar);  		if (originalCamera is OrthographicCamera) {  			pm.OffsetX = m - 1 - (i * 2);  			pm.OffsetY = -(m - 1 - (j * 2));  		}  		if (originalCamera is PerspectiveCamera) {  			pm.M31 = -(m - 1 - (i * 2));  			pm.M32 = m - 1 - (j * 2);  		}  		pm.M11 *= m;  		pm.M22 *= m;  		var mc = new MatrixCamera (vm' pm);  		view.Camera = mc;  		var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  		// render background  		var backgroundRectangle = new Rectangle {  			Width = partialBitmap.Width'  			Height = partialBitmap.Height'  			Fill = background  		};  		backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  		partialBitmap.Render (backgroundRectangle);  		// render 3d  		partialBitmap.Render (view);  		// copy to the target bitmap  		CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  	}  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	// change the camera viewport and scaling  	var pm = originalCamera.GetProjectionMatrix (ar);  	if (originalCamera is OrthographicCamera) {  		pm.OffsetX = m - 1 - (i * 2);  		pm.OffsetY = -(m - 1 - (j * 2));  	}  	if (originalCamera is PerspectiveCamera) {  		pm.M31 = -(m - 1 - (i * 2));  		pm.M32 = m - 1 - (j * 2);  	}  	pm.M11 *= m;  	pm.M22 *= m;  	var mc = new MatrixCamera (vm' pm);  	view.Camera = mc;  	var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  	// render background  	var backgroundRectangle = new Rectangle {  		Width = partialBitmap.Width'  		Height = partialBitmap.Height'  		Fill = background  	};  	backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  	partialBitmap.Render (backgroundRectangle);  	// render 3d  	partialBitmap.Render (view);  	// copy to the target bitmap  	CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	// change the camera viewport and scaling  	var pm = originalCamera.GetProjectionMatrix (ar);  	if (originalCamera is OrthographicCamera) {  		pm.OffsetX = m - 1 - (i * 2);  		pm.OffsetY = -(m - 1 - (j * 2));  	}  	if (originalCamera is PerspectiveCamera) {  		pm.M31 = -(m - 1 - (i * 2));  		pm.M32 = m - 1 - (j * 2);  	}  	pm.M11 *= m;  	pm.M22 *= m;  	var mc = new MatrixCamera (vm' pm);  	view.Camera = mc;  	var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  	// render background  	var backgroundRectangle = new Rectangle {  		Width = partialBitmap.Width'  		Height = partialBitmap.Height'  		Fill = background  	};  	backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  	partialBitmap.Render (backgroundRectangle);  	// render 3d  	partialBitmap.Render (view);  	// copy to the target bitmap  	CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	// change the camera viewport and scaling  	var pm = originalCamera.GetProjectionMatrix (ar);  	if (originalCamera is OrthographicCamera) {  		pm.OffsetX = m - 1 - (i * 2);  		pm.OffsetY = -(m - 1 - (j * 2));  	}  	if (originalCamera is PerspectiveCamera) {  		pm.M31 = -(m - 1 - (i * 2));  		pm.M32 = m - 1 - (j * 2);  	}  	pm.M11 *= m;  	pm.M22 *= m;  	var mc = new MatrixCamera (vm' pm);  	view.Camera = mc;  	var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  	// render background  	var backgroundRectangle = new Rectangle {  		Width = partialBitmap.Width'  		Height = partialBitmap.Height'  		Fill = background  	};  	backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  	partialBitmap.Render (backgroundRectangle);  	// render 3d  	partialBitmap.Render (view);  	// copy to the target bitmap  	CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	// change the camera viewport and scaling  	var pm = originalCamera.GetProjectionMatrix (ar);  	if (originalCamera is OrthographicCamera) {  		pm.OffsetX = m - 1 - (i * 2);  		pm.OffsetY = -(m - 1 - (j * 2));  	}  	if (originalCamera is PerspectiveCamera) {  		pm.M31 = -(m - 1 - (i * 2));  		pm.M32 = m - 1 - (j * 2);  	}  	pm.M11 *= m;  	pm.M22 *= m;  	var mc = new MatrixCamera (vm' pm);  	view.Camera = mc;  	var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  	// render background  	var backgroundRectangle = new Rectangle {  		Width = partialBitmap.Width'  		Height = partialBitmap.Height'  		Fill = background  	};  	backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  	partialBitmap.Render (backgroundRectangle);  	// render 3d  	partialBitmap.Render (view);  	// copy to the target bitmap  	CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	// change the camera viewport and scaling  	var pm = originalCamera.GetProjectionMatrix (ar);  	if (originalCamera is OrthographicCamera) {  		pm.OffsetX = m - 1 - (i * 2);  		pm.OffsetY = -(m - 1 - (j * 2));  	}  	if (originalCamera is PerspectiveCamera) {  		pm.M31 = -(m - 1 - (i * 2));  		pm.M32 = m - 1 - (j * 2);  	}  	pm.M11 *= m;  	pm.M22 *= m;  	var mc = new MatrixCamera (vm' pm);  	view.Camera = mc;  	var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  	// render background  	var backgroundRectangle = new Rectangle {  		Width = partialBitmap.Width'  		Height = partialBitmap.Height'  		Fill = background  	};  	backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  	partialBitmap.Render (backgroundRectangle);  	// render 3d  	partialBitmap.Render (view);  	// copy to the target bitmap  	CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	// change the camera viewport and scaling  	var pm = originalCamera.GetProjectionMatrix (ar);  	if (originalCamera is OrthographicCamera) {  		pm.OffsetX = m - 1 - (i * 2);  		pm.OffsetY = -(m - 1 - (j * 2));  	}  	if (originalCamera is PerspectiveCamera) {  		pm.M31 = -(m - 1 - (i * 2));  		pm.M32 = m - 1 - (j * 2);  	}  	pm.M11 *= m;  	pm.M22 *= m;  	var mc = new MatrixCamera (vm' pm);  	view.Camera = mc;  	var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  	// render background  	var backgroundRectangle = new Rectangle {  		Width = partialBitmap.Width'  		Height = partialBitmap.Height'  		Fill = background  	};  	backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  	partialBitmap.Render (backgroundRectangle);  	// render 3d  	partialBitmap.Render (view);  	// copy to the target bitmap  	CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: if (originalCamera is OrthographicCamera) {  	pm.OffsetX = m - 1 - (i * 2);  	pm.OffsetY = -(m - 1 - (j * 2));  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: if (originalCamera is OrthographicCamera) {  	pm.OffsetX = m - 1 - (i * 2);  	pm.OffsetY = -(m - 1 - (j * 2));  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: pm.OffsetX = m - 1 - (i * 2);  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: pm.OffsetY = -(m - 1 - (j * 2));  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: if (originalCamera is PerspectiveCamera) {  	pm.M31 = -(m - 1 - (i * 2));  	pm.M32 = m - 1 - (j * 2);  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: if (originalCamera is PerspectiveCamera) {  	pm.M31 = -(m - 1 - (i * 2));  	pm.M32 = m - 1 - (j * 2);  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: pm.M31 = -(m - 1 - (i * 2));  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,RenderBitmap,The following statement contains a magic number: pm.M32 = m - 1 - (j * 2);  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetTotalNumberOfTriangles,The following statement contains a magic number: viewport.Children.Traverse<GeometryModel3D> ((m' t) => {  	var geometry = m.Geometry as MeshGeometry3D;  	if (geometry != null && geometry.TriangleIndices != null) {  		count += geometry.TriangleIndices.Count / 3;  	}  });  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetTotalNumberOfTriangles,The following statement contains a magic number: if (geometry != null && geometry.TriangleIndices != null) {  	count += geometry.TriangleIndices.Count / 3;  }  
Magic Number,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,GetTotalNumberOfTriangles,The following statement contains a magic number: count += geometry.TriangleIndices.Count / 3;  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,Read,The following statement contains a magic number: using (var reader = new BinaryReader (s)) {  	long length = reader.BaseStream.Length;  	// http://gpwiki.org/index.php/Loading_3ds_files  	// http://www.flipcode.com/archives/3DS_File_Loader.shtml  	// http://sandy.googlecode.com/svn/trunk/sandy/as3/branches/3.0.2/src/sandy/parser/Parser3DS.as  	var headerId = this.ReadChunkId (reader);  	if (headerId != ChunkID.MAIN3DS) {  		throw new FileFormatException ("Unknown file");  	}  	int headerSize = this.ReadChunkSize (reader);  	if (headerSize != length) {  		throw new FileFormatException ("Incomplete file (file length does not match header)");  	}  	while (reader.BaseStream.Position < reader.BaseStream.Length) {  		var id = this.ReadChunkId (reader);  		int size = this.ReadChunkSize (reader);  		switch (id) {  		case ChunkID.EDIT_MATERIAL:  			this.ReadMaterial (reader' size);  			break;  		case ChunkID.EDIT_OBJECT:  			this.ReadObject (reader' size);  			break;  		case ChunkID.EDIT3DS:  		case ChunkID.OBJ_CAMERA:  		case ChunkID.OBJ_LIGHT:  		case ChunkID.OBJ_TRIMESH:  			// don't read the whole chunk' read the sub-defines...  			break;  		default:  			// download the whole chunk  			this.ReadData (reader' size - 6);  			break;  		}  	}  	Model3DGroup mg = null;  	this.Dispatch (() => {  		mg = new Model3DGroup ();  		foreach (var m in this.meshes) {  			var model = m.CreateModel ();  			if (this.Freeze) {  				model.Freeze ();  			}  			mg.Children.Add (model);  		}  		if (this.Freeze) {  			mg.Freeze ();  		}  	});  	return mg;  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,Read,The following statement contains a magic number: while (reader.BaseStream.Position < reader.BaseStream.Length) {  	var id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	switch (id) {  	case ChunkID.EDIT_MATERIAL:  		this.ReadMaterial (reader' size);  		break;  	case ChunkID.EDIT_OBJECT:  		this.ReadObject (reader' size);  		break;  	case ChunkID.EDIT3DS:  	case ChunkID.OBJ_CAMERA:  	case ChunkID.OBJ_LIGHT:  	case ChunkID.OBJ_TRIMESH:  		// don't read the whole chunk' read the sub-defines...  		break;  	default:  		// download the whole chunk  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,Read,The following statement contains a magic number: switch (id) {  case ChunkID.EDIT_MATERIAL:  	this.ReadMaterial (reader' size);  	break;  case ChunkID.EDIT_OBJECT:  	this.ReadObject (reader' size);  	break;  case ChunkID.EDIT3DS:  case ChunkID.OBJ_CAMERA:  case ChunkID.OBJ_LIGHT:  case ChunkID.OBJ_TRIMESH:  	// don't read the whole chunk' read the sub-defines...  	break;  default:  	// download the whole chunk  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,Read,The following statement contains a magic number: this.ReadData (reader' size - 6);  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: while (total < chunkSize) {  	var id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	total += size;  	switch (id) {  	case ChunkID.TRI_FACEMAT: {  		string name = this.ReadString (reader);  		int n = reader.ReadUInt16 ();  		var c = new List<int> ();  		for (int i = 0; i < n; i++) {  			c.Add (reader.ReadUInt16 ());  		}  		var fm = new FaceSet {  			Name = name'  			Faces = c  		};  		list.Add (fm);  		break;  	}  	case ChunkID.TRI_SMOOTH: {  		this.ReadData (reader' size - 6);  		break;  	}  	default: {  		this.ReadData (reader' size - 6);  		break;  	}  	}  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: while (total < chunkSize) {  	var id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	total += size;  	switch (id) {  	case ChunkID.TRI_FACEMAT: {  		string name = this.ReadString (reader);  		int n = reader.ReadUInt16 ();  		var c = new List<int> ();  		for (int i = 0; i < n; i++) {  			c.Add (reader.ReadUInt16 ());  		}  		var fm = new FaceSet {  			Name = name'  			Faces = c  		};  		list.Add (fm);  		break;  	}  	case ChunkID.TRI_SMOOTH: {  		this.ReadData (reader' size - 6);  		break;  	}  	default: {  		this.ReadData (reader' size - 6);  		break;  	}  	}  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: switch (id) {  case ChunkID.TRI_FACEMAT: {  	string name = this.ReadString (reader);  	int n = reader.ReadUInt16 ();  	var c = new List<int> ();  	for (int i = 0; i < n; i++) {  		c.Add (reader.ReadUInt16 ());  	}  	var fm = new FaceSet {  		Name = name'  		Faces = c  	};  	list.Add (fm);  	break;  }  case ChunkID.TRI_SMOOTH: {  	this.ReadData (reader' size - 6);  	break;  }  default: {  	this.ReadData (reader' size - 6);  	break;  }  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: switch (id) {  case ChunkID.TRI_FACEMAT: {  	string name = this.ReadString (reader);  	int n = reader.ReadUInt16 ();  	var c = new List<int> ();  	for (int i = 0; i < n; i++) {  		c.Add (reader.ReadUInt16 ());  	}  	var fm = new FaceSet {  		Name = name'  		Faces = c  	};  	list.Add (fm);  	break;  }  case ChunkID.TRI_SMOOTH: {  	this.ReadData (reader' size - 6);  	break;  }  default: {  	this.ReadData (reader' size - 6);  	break;  }  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: this.ReadData (reader' size - 6);  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: this.ReadData (reader' size - 6);  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadMatMap,The following statement contains a magic number: size -= 14;  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadMaterial,The following statement contains a magic number: while (total < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	// Debug.WriteLine(id);  	total += size;  	switch (id) {  	case ChunkID.MAT_NAME01:  		name = this.ReadString (reader);  		// name = ReadString(size - 6);  		break;  	case ChunkID.MAT_LUMINANCE:  		luminance = this.ReadColor (reader);  		break;  	case ChunkID.MAT_DIFFUSE:  		diffuse = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SPECULAR:  		specular = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SHININESS:  		byte[] bytes = this.ReadData (reader' size - 6);  		// shininess = ReadColor(r' size);  		break;  	case ChunkID.MAT_MAP:  		texture = this.ReadMatMap (reader' size - 6);  		break;  	case ChunkID.MAT_MAPFILE:  		this.ReadData (reader' size - 6);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadMaterial,The following statement contains a magic number: while (total < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	// Debug.WriteLine(id);  	total += size;  	switch (id) {  	case ChunkID.MAT_NAME01:  		name = this.ReadString (reader);  		// name = ReadString(size - 6);  		break;  	case ChunkID.MAT_LUMINANCE:  		luminance = this.ReadColor (reader);  		break;  	case ChunkID.MAT_DIFFUSE:  		diffuse = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SPECULAR:  		specular = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SHININESS:  		byte[] bytes = this.ReadData (reader' size - 6);  		// shininess = ReadColor(r' size);  		break;  	case ChunkID.MAT_MAP:  		texture = this.ReadMatMap (reader' size - 6);  		break;  	case ChunkID.MAT_MAPFILE:  		this.ReadData (reader' size - 6);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadMaterial,The following statement contains a magic number: while (total < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	// Debug.WriteLine(id);  	total += size;  	switch (id) {  	case ChunkID.MAT_NAME01:  		name = this.ReadString (reader);  		// name = ReadString(size - 6);  		break;  	case ChunkID.MAT_LUMINANCE:  		luminance = this.ReadColor (reader);  		break;  	case ChunkID.MAT_DIFFUSE:  		diffuse = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SPECULAR:  		specular = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SHININESS:  		byte[] bytes = this.ReadData (reader' size - 6);  		// shininess = ReadColor(r' size);  		break;  	case ChunkID.MAT_MAP:  		texture = this.ReadMatMap (reader' size - 6);  		break;  	case ChunkID.MAT_MAPFILE:  		this.ReadData (reader' size - 6);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadMaterial,The following statement contains a magic number: while (total < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	// Debug.WriteLine(id);  	total += size;  	switch (id) {  	case ChunkID.MAT_NAME01:  		name = this.ReadString (reader);  		// name = ReadString(size - 6);  		break;  	case ChunkID.MAT_LUMINANCE:  		luminance = this.ReadColor (reader);  		break;  	case ChunkID.MAT_DIFFUSE:  		diffuse = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SPECULAR:  		specular = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SHININESS:  		byte[] bytes = this.ReadData (reader' size - 6);  		// shininess = ReadColor(r' size);  		break;  	case ChunkID.MAT_MAP:  		texture = this.ReadMatMap (reader' size - 6);  		break;  	case ChunkID.MAT_MAPFILE:  		this.ReadData (reader' size - 6);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id) {  case ChunkID.MAT_NAME01:  	name = this.ReadString (reader);  	// name = ReadString(size - 6);  	break;  case ChunkID.MAT_LUMINANCE:  	luminance = this.ReadColor (reader);  	break;  case ChunkID.MAT_DIFFUSE:  	diffuse = this.ReadColor (reader);  	break;  case ChunkID.MAT_SPECULAR:  	specular = this.ReadColor (reader);  	break;  case ChunkID.MAT_SHININESS:  	byte[] bytes = this.ReadData (reader' size - 6);  	// shininess = ReadColor(r' size);  	break;  case ChunkID.MAT_MAP:  	texture = this.ReadMatMap (reader' size - 6);  	break;  case ChunkID.MAT_MAPFILE:  	this.ReadData (reader' size - 6);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id) {  case ChunkID.MAT_NAME01:  	name = this.ReadString (reader);  	// name = ReadString(size - 6);  	break;  case ChunkID.MAT_LUMINANCE:  	luminance = this.ReadColor (reader);  	break;  case ChunkID.MAT_DIFFUSE:  	diffuse = this.ReadColor (reader);  	break;  case ChunkID.MAT_SPECULAR:  	specular = this.ReadColor (reader);  	break;  case ChunkID.MAT_SHININESS:  	byte[] bytes = this.ReadData (reader' size - 6);  	// shininess = ReadColor(r' size);  	break;  case ChunkID.MAT_MAP:  	texture = this.ReadMatMap (reader' size - 6);  	break;  case ChunkID.MAT_MAPFILE:  	this.ReadData (reader' size - 6);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id) {  case ChunkID.MAT_NAME01:  	name = this.ReadString (reader);  	// name = ReadString(size - 6);  	break;  case ChunkID.MAT_LUMINANCE:  	luminance = this.ReadColor (reader);  	break;  case ChunkID.MAT_DIFFUSE:  	diffuse = this.ReadColor (reader);  	break;  case ChunkID.MAT_SPECULAR:  	specular = this.ReadColor (reader);  	break;  case ChunkID.MAT_SHININESS:  	byte[] bytes = this.ReadData (reader' size - 6);  	// shininess = ReadColor(r' size);  	break;  case ChunkID.MAT_MAP:  	texture = this.ReadMatMap (reader' size - 6);  	break;  case ChunkID.MAT_MAPFILE:  	this.ReadData (reader' size - 6);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id) {  case ChunkID.MAT_NAME01:  	name = this.ReadString (reader);  	// name = ReadString(size - 6);  	break;  case ChunkID.MAT_LUMINANCE:  	luminance = this.ReadColor (reader);  	break;  case ChunkID.MAT_DIFFUSE:  	diffuse = this.ReadColor (reader);  	break;  case ChunkID.MAT_SPECULAR:  	specular = this.ReadColor (reader);  	break;  case ChunkID.MAT_SHININESS:  	byte[] bytes = this.ReadData (reader' size - 6);  	// shininess = ReadColor(r' size);  	break;  case ChunkID.MAT_MAP:  	texture = this.ReadMatMap (reader' size - 6);  	break;  case ChunkID.MAT_MAPFILE:  	this.ReadData (reader' size - 6);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadMaterial,The following statement contains a magic number: texture = this.ReadMatMap (reader' size - 6);  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadMaterial,The following statement contains a magic number: this.ReadData (reader' size - 6);  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadMaterial,The following statement contains a magic number: this.ReadData (reader' size - 6);  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadObject,The following statement contains a magic number: while (total < chunkSize) {  	var id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	total += size;  	switch (id) {  	case ChunkID.OBJ_TRIMESH:  		this.ReadTriangularMesh (reader' size);  		break;  	// case ChunkID.OBJ_CAMERA:  	default: {  		this.ReadData (reader' size - 6);  		break;  	}  	}  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadObject,The following statement contains a magic number: switch (id) {  case ChunkID.OBJ_TRIMESH:  	this.ReadTriangularMesh (reader' size);  	break;  // case ChunkID.OBJ_CAMERA:  default: {  	this.ReadData (reader' size - 6);  	break;  }  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadObject,The following statement contains a magic number: this.ReadData (reader' size - 6);  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	bytesRead += size;  	switch (id) {  	case ChunkID.TRI_VERTEXL:  		positions = this.ReadVertexList (reader);  		break;  	case ChunkID.TRI_FACEL1:  		faces = this.ReadFaceList (reader);  		size -= (faces.Count / 3 * 8) + 2;  		faceSets = this.ReadFaceSets (reader' size - 6);  		break;  	case ChunkID.TRI_TEXCOORD:  		textureCoordinates = this.ReadTexCoords (reader);  		break;  	case ChunkID.TRI_LOCAL:  		this.ReadTransformation (reader);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	bytesRead += size;  	switch (id) {  	case ChunkID.TRI_VERTEXL:  		positions = this.ReadVertexList (reader);  		break;  	case ChunkID.TRI_FACEL1:  		faces = this.ReadFaceList (reader);  		size -= (faces.Count / 3 * 8) + 2;  		faceSets = this.ReadFaceSets (reader' size - 6);  		break;  	case ChunkID.TRI_TEXCOORD:  		textureCoordinates = this.ReadTexCoords (reader);  		break;  	case ChunkID.TRI_LOCAL:  		this.ReadTransformation (reader);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	bytesRead += size;  	switch (id) {  	case ChunkID.TRI_VERTEXL:  		positions = this.ReadVertexList (reader);  		break;  	case ChunkID.TRI_FACEL1:  		faces = this.ReadFaceList (reader);  		size -= (faces.Count / 3 * 8) + 2;  		faceSets = this.ReadFaceSets (reader' size - 6);  		break;  	case ChunkID.TRI_TEXCOORD:  		textureCoordinates = this.ReadTexCoords (reader);  		break;  	case ChunkID.TRI_LOCAL:  		this.ReadTransformation (reader);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	bytesRead += size;  	switch (id) {  	case ChunkID.TRI_VERTEXL:  		positions = this.ReadVertexList (reader);  		break;  	case ChunkID.TRI_FACEL1:  		faces = this.ReadFaceList (reader);  		size -= (faces.Count / 3 * 8) + 2;  		faceSets = this.ReadFaceSets (reader' size - 6);  		break;  	case ChunkID.TRI_TEXCOORD:  		textureCoordinates = this.ReadTexCoords (reader);  		break;  	case ChunkID.TRI_LOCAL:  		this.ReadTransformation (reader);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	bytesRead += size;  	switch (id) {  	case ChunkID.TRI_VERTEXL:  		positions = this.ReadVertexList (reader);  		break;  	case ChunkID.TRI_FACEL1:  		faces = this.ReadFaceList (reader);  		size -= (faces.Count / 3 * 8) + 2;  		faceSets = this.ReadFaceSets (reader' size - 6);  		break;  	case ChunkID.TRI_TEXCOORD:  		textureCoordinates = this.ReadTexCoords (reader);  		break;  	case ChunkID.TRI_LOCAL:  		this.ReadTransformation (reader);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id) {  case ChunkID.TRI_VERTEXL:  	positions = this.ReadVertexList (reader);  	break;  case ChunkID.TRI_FACEL1:  	faces = this.ReadFaceList (reader);  	size -= (faces.Count / 3 * 8) + 2;  	faceSets = this.ReadFaceSets (reader' size - 6);  	break;  case ChunkID.TRI_TEXCOORD:  	textureCoordinates = this.ReadTexCoords (reader);  	break;  case ChunkID.TRI_LOCAL:  	this.ReadTransformation (reader);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id) {  case ChunkID.TRI_VERTEXL:  	positions = this.ReadVertexList (reader);  	break;  case ChunkID.TRI_FACEL1:  	faces = this.ReadFaceList (reader);  	size -= (faces.Count / 3 * 8) + 2;  	faceSets = this.ReadFaceSets (reader' size - 6);  	break;  case ChunkID.TRI_TEXCOORD:  	textureCoordinates = this.ReadTexCoords (reader);  	break;  case ChunkID.TRI_LOCAL:  	this.ReadTransformation (reader);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id) {  case ChunkID.TRI_VERTEXL:  	positions = this.ReadVertexList (reader);  	break;  case ChunkID.TRI_FACEL1:  	faces = this.ReadFaceList (reader);  	size -= (faces.Count / 3 * 8) + 2;  	faceSets = this.ReadFaceSets (reader' size - 6);  	break;  case ChunkID.TRI_TEXCOORD:  	textureCoordinates = this.ReadTexCoords (reader);  	break;  case ChunkID.TRI_LOCAL:  	this.ReadTransformation (reader);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id) {  case ChunkID.TRI_VERTEXL:  	positions = this.ReadVertexList (reader);  	break;  case ChunkID.TRI_FACEL1:  	faces = this.ReadFaceList (reader);  	size -= (faces.Count / 3 * 8) + 2;  	faceSets = this.ReadFaceSets (reader' size - 6);  	break;  case ChunkID.TRI_TEXCOORD:  	textureCoordinates = this.ReadTexCoords (reader);  	break;  case ChunkID.TRI_LOCAL:  	this.ReadTransformation (reader);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id) {  case ChunkID.TRI_VERTEXL:  	positions = this.ReadVertexList (reader);  	break;  case ChunkID.TRI_FACEL1:  	faces = this.ReadFaceList (reader);  	size -= (faces.Count / 3 * 8) + 2;  	faceSets = this.ReadFaceSets (reader' size - 6);  	break;  case ChunkID.TRI_TEXCOORD:  	textureCoordinates = this.ReadTexCoords (reader);  	break;  case ChunkID.TRI_LOCAL:  	this.ReadTransformation (reader);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: size -= (faces.Count / 3 * 8) + 2;  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: size -= (faces.Count / 3 * 8) + 2;  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: size -= (faces.Count / 3 * 8) + 2;  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: faceSets = this.ReadFaceSets (reader' size - 6);  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: this.ReadData (reader' size - 6);  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: foreach (int f in subFaces) {  	triangleIndices.Add (faces [f * 3]);  	triangleIndices.Add (faces [(f * 3) + 1]);  	triangleIndices.Add (faces [(f * 3) + 2]);  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: foreach (int f in subFaces) {  	triangleIndices.Add (faces [f * 3]);  	triangleIndices.Add (faces [(f * 3) + 1]);  	triangleIndices.Add (faces [(f * 3) + 2]);  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: foreach (int f in subFaces) {  	triangleIndices.Add (faces [f * 3]);  	triangleIndices.Add (faces [(f * 3) + 1]);  	triangleIndices.Add (faces [(f * 3) + 2]);  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: foreach (int f in subFaces) {  	triangleIndices.Add (faces [f * 3]);  	triangleIndices.Add (faces [(f * 3) + 1]);  	triangleIndices.Add (faces [(f * 3) + 2]);  }  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: triangleIndices.Add (faces [f * 3]);  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: triangleIndices.Add (faces [(f * 3) + 1]);  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: triangleIndices.Add (faces [(f * 3) + 2]);  
Magic Number,HelixToolkit.Wpf,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: triangleIndices.Add (faces [(f * 3) + 2]);  
Magic Number,HelixToolkit.Wpf,VectorFieldVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\VectorFieldVisual3D.cs,VectorFieldVisual3D,The following statement contains a magic number: this.ThetaDiv = 37;  
Magic Number,HelixToolkit.Wpf,VectorFieldVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\VectorFieldVisual3D.cs,VectorFieldVisual3D,The following statement contains a magic number: this.HeadLength = 2;  
Magic Number,HelixToolkit.Wpf,SortingVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\SortingVisual3D.cs,GetCameraDistance,The following statement contains a magic number: switch (this.Method) {  case SortingMethod.BoundingBoxCenter:  	var mid = new Point3D (bounds.X + bounds.SizeX * 0.5' bounds.Y + bounds.SizeY * 0.5' bounds.Z + bounds.SizeZ * 0.5);  	return (mid - cameraPos).LengthSquared;  case SortingMethod.BoundingBoxCorners:  	double d = double.MaxValue;  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X' bounds.Y' bounds.Z)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X + bounds.SizeX' bounds.Y' bounds.Z)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X + bounds.SizeX' bounds.Y + bounds.SizeY' bounds.Z)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X' bounds.Y + bounds.SizeY' bounds.Z)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X' bounds.Y' bounds.Z + bounds.SizeZ)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X + bounds.SizeX' bounds.Y' bounds.Z + bounds.SizeZ)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X + bounds.SizeX' bounds.Y + bounds.SizeY' bounds.Z + bounds.SizeZ)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X' bounds.Y + bounds.SizeY' bounds.Z + bounds.SizeZ)));  	return d;  default:  	var boundingSphere = BoundingSphere.CreateFromRect3D (bounds);  	return boundingSphere.DistanceFrom (cameraPos);  }  
Magic Number,HelixToolkit.Wpf,SortingVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\SortingVisual3D.cs,GetCameraDistance,The following statement contains a magic number: switch (this.Method) {  case SortingMethod.BoundingBoxCenter:  	var mid = new Point3D (bounds.X + bounds.SizeX * 0.5' bounds.Y + bounds.SizeY * 0.5' bounds.Z + bounds.SizeZ * 0.5);  	return (mid - cameraPos).LengthSquared;  case SortingMethod.BoundingBoxCorners:  	double d = double.MaxValue;  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X' bounds.Y' bounds.Z)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X + bounds.SizeX' bounds.Y' bounds.Z)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X + bounds.SizeX' bounds.Y + bounds.SizeY' bounds.Z)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X' bounds.Y + bounds.SizeY' bounds.Z)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X' bounds.Y' bounds.Z + bounds.SizeZ)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X + bounds.SizeX' bounds.Y' bounds.Z + bounds.SizeZ)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X + bounds.SizeX' bounds.Y + bounds.SizeY' bounds.Z + bounds.SizeZ)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X' bounds.Y + bounds.SizeY' bounds.Z + bounds.SizeZ)));  	return d;  default:  	var boundingSphere = BoundingSphere.CreateFromRect3D (bounds);  	return boundingSphere.DistanceFrom (cameraPos);  }  
Magic Number,HelixToolkit.Wpf,SortingVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\SortingVisual3D.cs,GetCameraDistance,The following statement contains a magic number: switch (this.Method) {  case SortingMethod.BoundingBoxCenter:  	var mid = new Point3D (bounds.X + bounds.SizeX * 0.5' bounds.Y + bounds.SizeY * 0.5' bounds.Z + bounds.SizeZ * 0.5);  	return (mid - cameraPos).LengthSquared;  case SortingMethod.BoundingBoxCorners:  	double d = double.MaxValue;  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X' bounds.Y' bounds.Z)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X + bounds.SizeX' bounds.Y' bounds.Z)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X + bounds.SizeX' bounds.Y + bounds.SizeY' bounds.Z)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X' bounds.Y + bounds.SizeY' bounds.Z)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X' bounds.Y' bounds.Z + bounds.SizeZ)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X + bounds.SizeX' bounds.Y' bounds.Z + bounds.SizeZ)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X + bounds.SizeX' bounds.Y + bounds.SizeY' bounds.Z + bounds.SizeZ)));  	d = Math.Min (d' cameraPos.DistanceTo (new Point3D (bounds.X' bounds.Y + bounds.SizeY' bounds.Z + bounds.SizeZ)));  	return d;  default:  	var boundingSphere = BoundingSphere.CreateFromRect3D (bounds);  	return boundingSphere.DistanceFrom (cameraPos);  }  
Magic Number,HelixToolkit.Wpf,LightVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\LightVisual3D.cs,OnLightChanged,The following statement contains a magic number: if (dl != null) {  	var arrow = new ArrowVisual3D ();  	double distance = 10;  	double length = 5;  	arrow.BeginEdit ();  	arrow.Point1 = new Point3D () + dl.Direction * distance;  	arrow.Point2 = arrow.Point1 - dl.Direction * length;  	arrow.Diameter = 0.1 * length;  	arrow.Fill = new SolidColorBrush (dl.Color);  	arrow.EndEdit ();  	this.Children.Add (arrow);  }  
Magic Number,HelixToolkit.Wpf,LightVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\LightVisual3D.cs,OnLightChanged,The following statement contains a magic number: if (dl != null) {  	var arrow = new ArrowVisual3D ();  	double distance = 10;  	double length = 5;  	arrow.BeginEdit ();  	arrow.Point1 = new Point3D () + dl.Direction * distance;  	arrow.Point2 = arrow.Point1 - dl.Direction * length;  	arrow.Diameter = 0.1 * length;  	arrow.Fill = new SolidColorBrush (dl.Color);  	arrow.EndEdit ();  	this.Children.Add (arrow);  }  
Magic Number,HelixToolkit.Wpf,LightVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\LightVisual3D.cs,OnLightChanged,The following statement contains a magic number: if (dl != null) {  	var arrow = new ArrowVisual3D ();  	double distance = 10;  	double length = 5;  	arrow.BeginEdit ();  	arrow.Point1 = new Point3D () + dl.Direction * distance;  	arrow.Point2 = arrow.Point1 - dl.Direction * length;  	arrow.Diameter = 0.1 * length;  	arrow.Fill = new SolidColorBrush (dl.Color);  	arrow.EndEdit ();  	this.Children.Add (arrow);  }  
Magic Number,HelixToolkit.Wpf,LightVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\LightVisual3D.cs,OnLightChanged,The following statement contains a magic number: arrow.Diameter = 0.1 * length;  
Magic Number,HelixToolkit.Wpf,LightVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\LightVisual3D.cs,OnLightChanged,The following statement contains a magic number: if (sl != null) {  	var sphere = new SphereVisual3D ();  	sphere.BeginEdit ();  	sphere.Center = sl.Position;  	sphere.Fill = new SolidColorBrush (sl.Color);  	sphere.EndEdit ();  	this.Children.Add (sphere);  	var arrow = new ArrowVisual3D ();  	arrow.BeginEdit ();  	arrow.Point1 = sl.Position;  	arrow.Point2 = sl.Position + sl.Direction;  	arrow.Diameter = 0.1;  	arrow.EndEdit ();  	this.Children.Add (arrow);  }  
Magic Number,HelixToolkit.Wpf,LightVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\LightVisual3D.cs,OnLightChanged,The following statement contains a magic number: arrow.Diameter = 0.1;  
Magic Number,HelixToolkit.Wpf,MeshNormalsVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\MeshNormalsVisual3D.cs,OnMeshChanged,The following statement contains a magic number: for (int i = 0; i < this.Mesh.Positions.Count; i++) {  	builder.AddArrow (this.Mesh.Positions [i]' this.Mesh.Positions [i] + this.Mesh.Normals [i]' this.Diameter' 3' 10);  }  
Magic Number,HelixToolkit.Wpf,MeshNormalsVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\MeshNormalsVisual3D.cs,OnMeshChanged,The following statement contains a magic number: for (int i = 0; i < this.Mesh.Positions.Count; i++) {  	builder.AddArrow (this.Mesh.Positions [i]' this.Mesh.Positions [i] + this.Mesh.Normals [i]' this.Diameter' 3' 10);  }  
Magic Number,HelixToolkit.Wpf,MeshNormalsVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\MeshNormalsVisual3D.cs,OnMeshChanged,The following statement contains a magic number: builder.AddArrow (this.Mesh.Positions [i]' this.Mesh.Positions [i] + this.Mesh.Normals [i]' this.Diameter' 3' 10);  
Magic Number,HelixToolkit.Wpf,MeshNormalsVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\MeshNormalsVisual3D.cs,OnMeshChanged,The following statement contains a magic number: builder.AddArrow (this.Mesh.Positions [i]' this.Mesh.Positions [i] + this.Mesh.Normals [i]' this.Diameter' 3' 10);  
Magic Number,HelixToolkit.Wpf,PieSliceVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\PieSliceVisual3D.cs,Tessellate,The following statement contains a magic number: for (int i = 0; i < this.ThetaDiv; i++) {  	double angle = this.StartAngle + ((this.EndAngle - this.StartAngle) * i / (this.ThetaDiv - 1));  	double angleRad = angle / 180 * Math.PI;  	var dir = (right * Math.Cos (angleRad)) + (this.UpVector * Math.Sin (angleRad));  	pts.Add (this.Center + (dir * this.InnerRadius));  	pts.Add (this.Center + (dir * this.OuterRadius));  }  
Magic Number,HelixToolkit.Wpf,ExtrudedVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ExtrudedVisual3D.cs,Tessellate,The following statement contains a magic number: if (this.Path == null || this.Path.Count < 2) {  	return null;  }  
Magic Number,HelixToolkit.Wpf,ExtrudedVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ExtrudedVisual3D.cs,Tessellate,The following statement contains a magic number: if (sectionXAxis.Length < 1e-6) {  	sectionXAxis = new Vector3D (1' 0' 0);  }  
Magic Number,HelixToolkit.Wpf,ExtrudedVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\ExtrudedVisual3D.cs,Tessellate,The following statement contains a magic number: if (up.LengthSquared < 1e-6) {  	sectionXAxis = forward.FindAnyPerpendicular ();  }  
Magic Number,HelixToolkit.Wpf,TubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\TubeVisual3D.cs,Tessellate,The following statement contains a magic number: if (this.Path == null || this.Path.Count < 2) {  	return null;  }  
Magic Number,HelixToolkit.Wpf,TubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\TubeVisual3D.cs,Tessellate,The following statement contains a magic number: if (sectionXAxis.Length < 1e-6) {  	sectionXAxis = new Vector3D (1' 0' 0);  }  
Magic Number,HelixToolkit.Wpf,TubeVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\TubeVisual3D.cs,Tessellate,The following statement contains a magic number: if (up.LengthSquared < 1e-6) {  	sectionXAxis = forward.FindAnyPerpendicular ();  }  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,Tessellate,The following statement contains a magic number: while (x <= maxX + eps) {  	double t = this.Thickness;  	if (IsMultipleOf (x' this.MajorDistance)) {  		t *= 2;  	}  	this.AddLineX (mesh' x' minY' maxY' t);  	x += this.MinorDistance;  }  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,Tessellate,The following statement contains a magic number: if (IsMultipleOf (x' this.MajorDistance)) {  	t *= 2;  }  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,Tessellate,The following statement contains a magic number: t *= 2;  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,Tessellate,The following statement contains a magic number: while (y <= maxY + eps) {  	double t = this.Thickness;  	if (IsMultipleOf (y' this.MajorDistance)) {  		t *= 2;  	}  	this.AddLineY (mesh' y' minX' maxX' t);  	y += this.MinorDistance;  }  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,Tessellate,The following statement contains a magic number: if (IsMultipleOf (y' this.MajorDistance)) {  	t *= 2;  }  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,Tessellate,The following statement contains a magic number: t *= 2;  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,IsMultipleOf,The following statement contains a magic number: return Math.Abs (y - y2) < 1e-3;  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineX,The following statement contains a magic number: mesh.Positions.Add (this.GetPoint (x - (thickness / 2)' minY));  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineX,The following statement contains a magic number: mesh.Positions.Add (this.GetPoint (x - (thickness / 2)' maxY));  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineX,The following statement contains a magic number: mesh.Positions.Add (this.GetPoint (x + (thickness / 2)' maxY));  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineX,The following statement contains a magic number: mesh.Positions.Add (this.GetPoint (x + (thickness / 2)' minY));  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineX,The following statement contains a magic number: mesh.TriangleIndices.Add (i0 + 2);  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineX,The following statement contains a magic number: mesh.TriangleIndices.Add (i0 + 2);  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineX,The following statement contains a magic number: mesh.TriangleIndices.Add (i0 + 3);  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineY,The following statement contains a magic number: mesh.Positions.Add (this.GetPoint (minX' y + (thickness / 2)));  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineY,The following statement contains a magic number: mesh.Positions.Add (this.GetPoint (maxX' y + (thickness / 2)));  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineY,The following statement contains a magic number: mesh.Positions.Add (this.GetPoint (maxX' y - (thickness / 2)));  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineY,The following statement contains a magic number: mesh.Positions.Add (this.GetPoint (minX' y - (thickness / 2)));  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineY,The following statement contains a magic number: mesh.TriangleIndices.Add (i0 + 2);  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineY,The following statement contains a magic number: mesh.TriangleIndices.Add (i0 + 2);  
Magic Number,HelixToolkit.Wpf,GridLinesVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\GridLinesVisual3D.cs,AddLineY,The following statement contains a magic number: mesh.TriangleIndices.Add (i0 + 3);  
Magic Number,HelixToolkit.Wpf,RectangleVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\RectangleVisual3D.cs,Tessellate,The following statement contains a magic number: for (int i = 0; i < this.DivLength; i++) {  	double fi = -0.5 + ((double)i / (this.DivLength - 1));  	for (int j = 0; j < this.DivWidth; j++) {  		double fj = -0.5 + ((double)j / (this.DivWidth - 1));  		pts.Add (this.Origin + (u * le * fi) + (v * wi * fj));  	}  }  
Magic Number,HelixToolkit.Wpf,RectangleVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\RectangleVisual3D.cs,Tessellate,The following statement contains a magic number: for (int i = 0; i < this.DivLength; i++) {  	double fi = -0.5 + ((double)i / (this.DivLength - 1));  	for (int j = 0; j < this.DivWidth; j++) {  		double fj = -0.5 + ((double)j / (this.DivWidth - 1));  		pts.Add (this.Origin + (u * le * fi) + (v * wi * fj));  	}  }  
Magic Number,HelixToolkit.Wpf,RectangleVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\RectangleVisual3D.cs,Tessellate,The following statement contains a magic number: for (int j = 0; j < this.DivWidth; j++) {  	double fj = -0.5 + ((double)j / (this.DivWidth - 1));  	pts.Add (this.Origin + (u * le * fi) + (v * wi * fj));  }  
Magic Number,HelixToolkit.Wpf,RectangleVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\MeshVisuals\RectangleVisual3D.cs,CoerceDivValue,The following statement contains a magic number: return Math.Max (2' (int)baseValue);  
Magic Number,HelixToolkit.Wpf,BoundingBoxVisual3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\BoundingBoxVisual3D.cs,AddEdge,The following statement contains a magic number: fv.ThetaDiv = 10;  
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: if (n < 3) {  	return null;  }  
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: for (int v = nv - 1; nv > 2;) {  	// if we loop' it is probably a non-simple polygon  	if (0 >= (count--)) {  		// ERROR - probable bad polygon!  		return null;  	}  	// three consecutive vertices in current polygon' <u'v'w>  	int u = v;  	if (nv <= u) {  		u = 0;  		// previous  	}  	v = u + 1;  	if (nv <= v) {  		v = 0;  		// new v  	}  	int w = v + 1;  	if (nv <= w) {  		w = 0;  		// next  	}  	if (Snip (contour' u' v' w' nv' V)) {  		int s' t;  		// true names of the vertices  		int a = V [u];  		int b = V [v];  		int c = V [w];  		// output Triangle  		result.Add (a);  		result.Add (b);  		result.Add (c);  		// remove v from remaining polygon  		for (s = v' t = v + 1; t < nv; s++' t++) {  			V [s] = V [t];  		}  		nv--;  		// resest error detection counter  		count = 2 * nv;  	}  }  
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: for (int v = nv - 1; nv > 2;) {  	// if we loop' it is probably a non-simple polygon  	if (0 >= (count--)) {  		// ERROR - probable bad polygon!  		return null;  	}  	// three consecutive vertices in current polygon' <u'v'w>  	int u = v;  	if (nv <= u) {  		u = 0;  		// previous  	}  	v = u + 1;  	if (nv <= v) {  		v = 0;  		// new v  	}  	int w = v + 1;  	if (nv <= w) {  		w = 0;  		// next  	}  	if (Snip (contour' u' v' w' nv' V)) {  		int s' t;  		// true names of the vertices  		int a = V [u];  		int b = V [v];  		int c = V [w];  		// output Triangle  		result.Add (a);  		result.Add (b);  		result.Add (c);  		// remove v from remaining polygon  		for (s = v' t = v + 1; t < nv; s++' t++) {  			V [s] = V [t];  		}  		nv--;  		// resest error detection counter  		count = 2 * nv;  	}  }  
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: if (Snip (contour' u' v' w' nv' V)) {  	int s' t;  	// true names of the vertices  	int a = V [u];  	int b = V [v];  	int c = V [w];  	// output Triangle  	result.Add (a);  	result.Add (b);  	result.Add (c);  	// remove v from remaining polygon  	for (s = v' t = v + 1; t < nv; s++' t++) {  		V [s] = V [t];  	}  	nv--;  	// resest error detection counter  	count = 2 * nv;  }  
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: count = 2 * nv;  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,GetCircle,The following statement contains a magic number: if ((!closed && !CircleCache.Value.TryGetValue (thetaDiv' out circle)) || (closed && !ClosedCircleCache.Value.TryGetValue (thetaDiv' out circle))) {  	circle = new PointCollection ();  	// Add to the cache  	if (!closed) {  		CircleCache.Value.Add (thetaDiv' circle);  	} else {  		ClosedCircleCache.Value.Add (thetaDiv' circle);  	}  	// Determine the angle steps  	var num = closed ? thetaDiv : thetaDiv - 1;  	for (int i = 0; i < thetaDiv; i++) {  		var theta = (DoubleOrSingle)Math.PI * 2 * ((DoubleOrSingle)i / num);  		circle.Add (new Point ((DoubleOrSingle)Math.Cos (theta)' -(DoubleOrSingle)Math.Sin (theta)));  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,GetCircle,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	var theta = (DoubleOrSingle)Math.PI * 2 * ((DoubleOrSingle)i / num);  	circle.Add (new Point ((DoubleOrSingle)Math.Cos (theta)' -(DoubleOrSingle)Math.Sin (theta)));  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormals,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3) {  	var i1 = triangleIndices [t];  	var i2 = triangleIndices [t + 1];  	var i3 = triangleIndices [t + 2];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var p1 = v2 - v1;  	var p2 = v3 - v1;  	var n = SharedFunctions.CrossProduct (ref p1' ref p2);  	// angle  	p1.Normalize ();  	p2.Normalize ();  	var a = (float)Math.Acos (SharedFunctions.DotProduct (ref p1' ref p2));  	n.Normalize ();  	normals [i1] += (a * n);  	normals [i2] += (a * n);  	normals [i3] += (a * n);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormals,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3) {  	var i1 = triangleIndices [t];  	var i2 = triangleIndices [t + 1];  	var i3 = triangleIndices [t + 2];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var p1 = v2 - v1;  	var p2 = v3 - v1;  	var n = SharedFunctions.CrossProduct (ref p1' ref p2);  	// angle  	p1.Normalize ();  	p2.Normalize ();  	var a = (float)Math.Acos (SharedFunctions.DotProduct (ref p1' ref p2));  	n.Normalize ();  	normals [i1] += (a * n);  	normals [i2] += (a * n);  	normals [i3] += (a * n);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormals,The following statement contains a magic number: t += 3
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3) {  	var i1 = triangleIndices [t];  	var i2 = triangleIndices [t + 1];  	var i3 = triangleIndices [t + 2];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var w1 = textureCoordinates [i1];  	var w2 = textureCoordinates [i2];  	var w3 = textureCoordinates [i3];  	var x1 = v2.X - v1.X;  	var x2 = v3.X - v1.X;  	var y1 = v2.Y - v1.Y;  	var y2 = v3.Y - v1.Y;  	var z1 = v2.Z - v1.Z;  	var z2 = v3.Z - v1.Z;  	var s1 = w2.X - w1.X;  	var s2 = w3.X - w1.X;  	var t1 = w2.Y - w1.Y;  	var t2 = w3.Y - w1.Y;  	var r = 1.0f / (s1 * t2 - s2 * t1);  	var udir = new Vector3D ((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);  	tan1 [i1] += udir;  	tan1 [i2] += udir;  	tan1 [i3] += udir;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3) {  	var i1 = triangleIndices [t];  	var i2 = triangleIndices [t + 1];  	var i3 = triangleIndices [t + 2];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var w1 = textureCoordinates [i1];  	var w2 = textureCoordinates [i2];  	var w3 = textureCoordinates [i3];  	var x1 = v2.X - v1.X;  	var x2 = v3.X - v1.X;  	var y1 = v2.Y - v1.Y;  	var y2 = v3.Y - v1.Y;  	var z1 = v2.Z - v1.Z;  	var z2 = v3.Z - v1.Z;  	var s1 = w2.X - w1.X;  	var s2 = w3.X - w1.X;  	var t1 = w2.Y - w1.Y;  	var t2 = w3.Y - w1.Y;  	var r = 1.0f / (s1 * t2 - s2 * t1);  	var udir = new Vector3D ((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);  	tan1 [i1] += udir;  	tan1 [i2] += udir;  	tan1 [i3] += udir;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The following statement contains a magic number: t += 3
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: for (int t = 0; t < indices.Count; t += 4) {  	var i1 = indices [t];  	var i2 = indices [t + 1];  	var i3 = indices [t + 2];  	var i4 = indices [t + 3];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var v4 = positions [i4];  	var w1 = textureCoordinates [i1];  	var w2 = textureCoordinates [i2];  	var w3 = textureCoordinates [i3];  	var w4 = textureCoordinates [i4];  	var x1 = v2.X - v1.X;  	var x2 = v4.X - v1.X;  	var y1 = v2.Y - v1.Y;  	var y2 = v4.Y - v1.Y;  	var z1 = v2.Z - v1.Z;  	var z2 = v4.Z - v1.Z;  	var s1 = w2.X - w1.X;  	var s2 = w4.X - w1.X;  	var t1 = w2.Y - w1.Y;  	var t2 = w4.Y - w1.Y;  	var r = 1.0f / (s1 * t2 - s2 * t1);  	var udir = new Vector3D ((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);  	tan1 [i1] += udir;  	tan1 [i2] += udir;  	tan1 [i3] += udir;  	tan1 [i4] += udir;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: for (int t = 0; t < indices.Count; t += 4) {  	var i1 = indices [t];  	var i2 = indices [t + 1];  	var i3 = indices [t + 2];  	var i4 = indices [t + 3];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var v4 = positions [i4];  	var w1 = textureCoordinates [i1];  	var w2 = textureCoordinates [i2];  	var w3 = textureCoordinates [i3];  	var w4 = textureCoordinates [i4];  	var x1 = v2.X - v1.X;  	var x2 = v4.X - v1.X;  	var y1 = v2.Y - v1.Y;  	var y2 = v4.Y - v1.Y;  	var z1 = v2.Z - v1.Z;  	var z2 = v4.Z - v1.Z;  	var s1 = w2.X - w1.X;  	var s2 = w4.X - w1.X;  	var t1 = w2.Y - w1.Y;  	var t2 = w4.Y - w1.Y;  	var r = 1.0f / (s1 * t2 - s2 * t1);  	var udir = new Vector3D ((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);  	tan1 [i1] += udir;  	tan1 [i2] += udir;  	tan1 [i3] += udir;  	tan1 [i4] += udir;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: for (int t = 0; t < indices.Count; t += 4) {  	var i1 = indices [t];  	var i2 = indices [t + 1];  	var i3 = indices [t + 2];  	var i4 = indices [t + 3];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var v4 = positions [i4];  	var w1 = textureCoordinates [i1];  	var w2 = textureCoordinates [i2];  	var w3 = textureCoordinates [i3];  	var w4 = textureCoordinates [i4];  	var x1 = v2.X - v1.X;  	var x2 = v4.X - v1.X;  	var y1 = v2.Y - v1.Y;  	var y2 = v4.Y - v1.Y;  	var z1 = v2.Z - v1.Z;  	var z2 = v4.Z - v1.Z;  	var s1 = w2.X - w1.X;  	var s2 = w4.X - w1.X;  	var t1 = w2.Y - w1.Y;  	var t2 = w4.Y - w1.Y;  	var r = 1.0f / (s1 * t2 - s2 * t1);  	var udir = new Vector3D ((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);  	tan1 [i1] += udir;  	tan1 [i2] += udir;  	tan1 [i3] += udir;  	tan1 [i4] += udir;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: t += 4
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: up *= (DoubleOrSingle)height / 2;  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: right *= (DoubleOrSingle)width / 2;  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add (i0 + 2);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add (i0 + 3);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add (i0 + 2);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The following statement contains a magic number: this.AddCone (p1' n' diameter / 2' diameter / 2' l' false' false' thetaDiv);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The following statement contains a magic number: this.AddCone (p1' n' diameter / 2' diameter / 2' l' false' false' thetaDiv);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation (this.positions.Skip (positionsCount).Take (5).Select ((p' i) => i).ToList ());  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation (this.positions.Skip (positionsCount + 15).Select ((p' i) => 15 + i).ToList ());  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation (this.positions.Skip (positionsCount + 15).Select ((p' i) => 15 + i).ToList ());  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEdges,The following statement contains a magic number: for (int i = 0; i < edges.Count - 1; i += 2) {  	this.AddCylinder (points [edges [i]]' points [edges [i + 1]]' diameter' thetaDiv);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEdges,The following statement contains a magic number: i += 2
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The following statement contains a magic number: for (int pi = 0; pi <= phiDiv; pi++) {  	var phi = pi * dp;  	for (int ti = 0; ti <= thetaDiv; ti++) {  		// we want to start the mesh on the x axis  		var theta = ti * dt;  		// Spherical coordinates  		// http://mathworld.wolfram.com/SphericalCoordinates.html  		var x = (DoubleOrSingle)Math.Cos (theta) * (DoubleOrSingle)Math.Sin (phi);  		var y = (DoubleOrSingle)Math.Sin (theta) * (DoubleOrSingle)Math.Sin (phi);  		var z = (DoubleOrSingle)Math.Cos (phi);  		var p = new Point3D (center.X + (DoubleOrSingle)(radiusx * x)' center.Y + (DoubleOrSingle)(radiusy * y)' center.Z + (DoubleOrSingle)(radiusz * z));  		this.positions.Add (p);  		if (this.normals != null) {  			var n = new Vector3D (x' y' z);  			this.normals.Add (n);  		}  		if (this.textureCoordinates != null) {  			var uv = new Point (theta / (2 * (DoubleOrSingle)Math.PI)' phi / (DoubleOrSingle)Math.PI);  			this.textureCoordinates.Add (uv);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The following statement contains a magic number: for (int ti = 0; ti <= thetaDiv; ti++) {  	// we want to start the mesh on the x axis  	var theta = ti * dt;  	// Spherical coordinates  	// http://mathworld.wolfram.com/SphericalCoordinates.html  	var x = (DoubleOrSingle)Math.Cos (theta) * (DoubleOrSingle)Math.Sin (phi);  	var y = (DoubleOrSingle)Math.Sin (theta) * (DoubleOrSingle)Math.Sin (phi);  	var z = (DoubleOrSingle)Math.Cos (phi);  	var p = new Point3D (center.X + (DoubleOrSingle)(radiusx * x)' center.Y + (DoubleOrSingle)(radiusy * y)' center.Z + (DoubleOrSingle)(radiusz * z));  	this.positions.Add (p);  	if (this.normals != null) {  		var n = new Vector3D (x' y' z);  		this.normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv = new Point (theta / (2 * (DoubleOrSingle)Math.PI)' phi / (DoubleOrSingle)Math.PI);  		this.textureCoordinates.Add (uv);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The following statement contains a magic number: if (this.textureCoordinates != null) {  	var uv = new Point (theta / (2 * (DoubleOrSingle)Math.PI)' phi / (DoubleOrSingle)Math.PI);  	this.textureCoordinates.Add (uv);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedGeometry,The following statement contains a magic number: foreach (var p in points) {  	var v = (xaxis * p.X) + (ydirection * p.Y);  	this.positions.Add (p0 + v);  	this.positions.Add (p1 + v);  	v.Normalize ();  	if (this.normals != null) {  		this.normals.Add (v);  		this.normals.Add (v);  	}  	if (this.textureCoordinates != null) {  		this.textureCoordinates.Add (new Point (0' 0));  		this.textureCoordinates.Add (new Point (1' 0));  	}  	int i1 = index0 + 1;  	int i2 = (index0 + 2) % np;  	int i3 = ((index0 + 2) % np) + 1;  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i3);  	this.triangleIndices.Add (i2);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedGeometry,The following statement contains a magic number: foreach (var p in points) {  	var v = (xaxis * p.X) + (ydirection * p.Y);  	this.positions.Add (p0 + v);  	this.positions.Add (p1 + v);  	v.Normalize ();  	if (this.normals != null) {  		this.normals.Add (v);  		this.normals.Add (v);  	}  	if (this.textureCoordinates != null) {  		this.textureCoordinates.Add (new Point (0' 0));  		this.textureCoordinates.Add (new Point (1' 0));  	}  	int i1 = index0 + 1;  	int i2 = (index0 + 2) % np;  	int i3 = ((index0 + 2) % np) + 1;  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i3);  	this.triangleIndices.Add (i2);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: if (points.Count % 2 != 0) {  	throw new InvalidOperationException ("The number of points should be even.");  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int i0 = index0 + (i * 2);  	int i1 = i0 + 1;  	int i2 = i0 + 3;  	int i3 = i0 + 2;  	this.triangleIndices.Add (i0);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i3);  	this.triangleIndices.Add (i0);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int i0 = index0 + (i * 2);  	int i1 = i0 + 1;  	int i2 = i0 + 3;  	int i3 = i0 + 2;  	this.triangleIndices.Add (i0);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i3);  	this.triangleIndices.Add (i0);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int i0 = index0 + (i * 2);  	int i1 = i0 + 1;  	int i2 = i0 + 3;  	int i3 = i0 + 2;  	this.triangleIndices.Add (i0);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i3);  	this.triangleIndices.Add (i0);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The following statement contains a magic number: up *= (DoubleOrSingle)height / 2;  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The following statement contains a magic number: right *= (DoubleOrSingle)sideLength / 2;  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: if (innerDiameter > 0) {  	// Add the inner surface  	pc.Add (new Point (0' (DoubleOrSingle)innerDiameter / 2));  	tc.Add (1);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: pc.Add (new Point (0' (DoubleOrSingle)innerDiameter / 2));  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipes,The following statement contains a magic number: for (int i = 0; i < edges.Count - 1; i += 2) {  	this.AddCylinder ((Point3D)points [edges [i]]' (Point3D)points [edges [i + 1]]' diameter' thetaDiv);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipes,The following statement contains a magic number: i += 2
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count) {  case 3:  	this.AddTriangle (points [0]' points [1]' points [2]);  	break;  case 4:  	this.AddQuad (points [0]' points [1]' points [2]' points [3]);  	break;  default:  	this.AddTriangleFan (points);  	break;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count) {  case 3:  	this.AddTriangle (points [0]' points [1]' points [2]);  	break;  case 4:  	this.AddQuad (points [0]' points [1]' points [2]' points [3]);  	break;  default:  	this.AddTriangleFan (points);  	break;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count) {  case 3:  	this.AddTriangle (points [0]' points [1]' points [2]);  	break;  case 4:  	this.AddQuad (points [0]' points [1]' points [2]' points [3]);  	break;  default:  	this.AddTriangleFan (points);  	break;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count) {  case 3:  	this.AddTriangle (points [0]' points [1]' points [2]);  	break;  case 4:  	this.AddQuad (points [0]' points [1]' points [2]' points [3]);  	break;  default:  	this.AddTriangleFan (points);  	break;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count) {  case 3:  	this.AddTriangle (points [0]' points [1]' points [2]);  	break;  case 4:  	this.AddQuad (points [0]' points [1]' points [2]' points [3]);  	break;  default:  	this.AddTriangleFan (points);  	break;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: this.AddTriangle (points [0]' points [1]' points [2]);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: this.AddQuad (points [0]' points [1]' points [2]' points [3]);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: this.AddQuad (points [0]' points [1]' points [2]' points [3]);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: for (int i = 0; i + 2 < n; i++) {  	this.triangleIndices.Add (vertexIndices [0]);  	this.triangleIndices.Add (vertexIndices [i + 1]);  	this.triangleIndices.Add (vertexIndices [i + 2]);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: for (int i = 0; i + 2 < n; i++) {  	this.triangleIndices.Add (vertexIndices [0]);  	this.triangleIndices.Add (vertexIndices [i + 1]);  	this.triangleIndices.Add (vertexIndices [i + 2]);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: this.triangleIndices.Add (vertexIndices [i + 2]);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: right *= (DoubleOrSingle)sideLength / 2;  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	this.triangleIndices.Add (vertexIndices [i]);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add (i0 + 2);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add (i0 + 2);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add (i0 + 3);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: Debug.Assert (quadPositions.Count > 0 && quadPositions.Count % 4 == 0' "Wrong number of positions.");  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 3);  	this.triangleIndices.Add (i);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 3);  	this.triangleIndices.Add (i);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 3);  	this.triangleIndices.Add (i);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 3);  	this.triangleIndices.Add (i);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: this.triangleIndices.Add (i + 2);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: this.triangleIndices.Add (i + 2);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: this.triangleIndices.Add (i + 3);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The following statement contains a magic number: if (columns < 2 || rows < 2) {  	throw new ArgumentNullException ("columns or rows too small");  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The following statement contains a magic number: if (columns < 2 || rows < 2) {  	throw new ArgumentNullException ("columns or rows too small");  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndices,The following statement contains a magic number: for (int i = 0; i < rows - 1; i++) {  	for (int j = 0; j < columns - 1; j++) {  		int ij = (i * columns) + j;  		if (!isSpherical || i > 0) {  			this.triangleIndices.Add (index0 + ij);  			this.triangleIndices.Add (index0 + ij + 1 + columns);  			this.triangleIndices.Add (index0 + ij + 1);  		}  		if (!isSpherical || i < rows - 2) {  			this.triangleIndices.Add (index0 + ij + 1 + columns);  			this.triangleIndices.Add (index0 + ij);  			this.triangleIndices.Add (index0 + ij + columns);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndices,The following statement contains a magic number: for (int j = 0; j < columns - 1; j++) {  	int ij = (i * columns) + j;  	if (!isSpherical || i > 0) {  		this.triangleIndices.Add (index0 + ij);  		this.triangleIndices.Add (index0 + ij + 1 + columns);  		this.triangleIndices.Add (index0 + ij + 1);  	}  	if (!isSpherical || i < rows - 2) {  		this.triangleIndices.Add (index0 + ij + 1 + columns);  		this.triangleIndices.Add (index0 + ij);  		this.triangleIndices.Add (index0 + ij + columns);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndices,The following statement contains a magic number: if (!isSpherical || i < rows - 2) {  	this.triangleIndices.Add (index0 + ij + 1 + columns);  	this.triangleIndices.Add (index0 + ij);  	this.triangleIndices.Add (index0 + ij + columns);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndicesFlipped,The following statement contains a magic number: for (int i = 0; i < rows - 1; i++) {  	for (int j = 0; j < columns - 1; j++) {  		int ij = (i * columns) + j;  		if (!isSpherical || i > 0) {  			this.triangleIndices.Add (index0 + ij);  			this.triangleIndices.Add (index0 + ij + 1);  			this.triangleIndices.Add (index0 + ij + 1 + columns);  		}  		if (!isSpherical || i < rows - 2) {  			this.triangleIndices.Add (index0 + ij + 1 + columns);  			this.triangleIndices.Add (index0 + ij + columns);  			this.triangleIndices.Add (index0 + ij);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndicesFlipped,The following statement contains a magic number: for (int j = 0; j < columns - 1; j++) {  	int ij = (i * columns) + j;  	if (!isSpherical || i > 0) {  		this.triangleIndices.Add (index0 + ij);  		this.triangleIndices.Add (index0 + ij + 1);  		this.triangleIndices.Add (index0 + ij + 1 + columns);  	}  	if (!isSpherical || i < rows - 2) {  		this.triangleIndices.Add (index0 + ij + 1 + columns);  		this.triangleIndices.Add (index0 + ij + columns);  		this.triangleIndices.Add (index0 + ij);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndicesFlipped,The following statement contains a magic number: if (!isSpherical || i < rows - 2) {  	this.triangleIndices.Add (index0 + ij + 1 + columns);  	this.triangleIndices.Add (index0 + ij + columns);  	this.triangleIndices.Add (index0 + ij);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: if (shareVertices) {  	int index0 = this.positions.Count;  	foreach (var v in icosahedronVertices) {  		this.positions.Add (center + (v * (DoubleOrSingle)radius));  	}  	foreach (int i in icosahedronIndices) {  		this.triangleIndices.Add (index0 + i);  	}  } else {  	for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3) {  		this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius));  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: if (shareVertices) {  	int index0 = this.positions.Count;  	foreach (var v in icosahedronVertices) {  		this.positions.Add (center + (v * (DoubleOrSingle)radius));  	}  	foreach (int i in icosahedronIndices) {  		this.triangleIndices.Add (index0 + i);  	}  } else {  	for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3) {  		this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius));  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: if (shareVertices) {  	int index0 = this.positions.Count;  	foreach (var v in icosahedronVertices) {  		this.positions.Add (center + (v * (DoubleOrSingle)radius));  	}  	foreach (int i in icosahedronIndices) {  		this.triangleIndices.Add (index0 + i);  	}  } else {  	for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3) {  		this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius));  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3) {  	this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius));  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3) {  	this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius));  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3) {  	this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius));  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius));  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	var w = (v * circle [i].X) + (u * circle [i].Y);  	for (int j = 0; j + 1 < n; j++) {  		// Add segment  		var q1 = origin + (direction * points [j].X) + (w * points [j].Y);  		var q2 = origin + (direction * points [j + 1].X) + (w * points [j + 1].Y);  		// TODO: should not add segment if q1==q2 (corner point)  		// const double eps = 1e-6;  		// if (Point3D.Subtract(q1' q2).LengthSquared < eps)  		// continue;  		this.positions.Add (q1);  		this.positions.Add (q2);  		if (this.normals != null) {  			var tx = points [j + 1].X - points [j].X;  			var ty = points [j + 1].Y - points [j].Y;  			var normal = (-direction * ty) + (w * tx);  			normal.Normalize ();  			this.normals.Add (normal);  			this.normals.Add (normal);  		}  		if (this.textureCoordinates != null) {  			this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues [j]));  			this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues [j + 1]));  		}  		int i0 = index0 + (i * rowNodes) + (j * 2);  		int i1 = i0 + 1;  		int i2 = index0 + ((((i + 1) * rowNodes) + (j * 2)) % totalNodes);  		int i3 = i2 + 1;  		this.triangleIndices.Add (i1);  		this.triangleIndices.Add (i0);  		this.triangleIndices.Add (i2);  		this.triangleIndices.Add (i1);  		this.triangleIndices.Add (i2);  		this.triangleIndices.Add (i3);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	var w = (v * circle [i].X) + (u * circle [i].Y);  	for (int j = 0; j + 1 < n; j++) {  		// Add segment  		var q1 = origin + (direction * points [j].X) + (w * points [j].Y);  		var q2 = origin + (direction * points [j + 1].X) + (w * points [j + 1].Y);  		// TODO: should not add segment if q1==q2 (corner point)  		// const double eps = 1e-6;  		// if (Point3D.Subtract(q1' q2).LengthSquared < eps)  		// continue;  		this.positions.Add (q1);  		this.positions.Add (q2);  		if (this.normals != null) {  			var tx = points [j + 1].X - points [j].X;  			var ty = points [j + 1].Y - points [j].Y;  			var normal = (-direction * ty) + (w * tx);  			normal.Normalize ();  			this.normals.Add (normal);  			this.normals.Add (normal);  		}  		if (this.textureCoordinates != null) {  			this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues [j]));  			this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues [j + 1]));  		}  		int i0 = index0 + (i * rowNodes) + (j * 2);  		int i1 = i0 + 1;  		int i2 = index0 + ((((i + 1) * rowNodes) + (j * 2)) % totalNodes);  		int i3 = i2 + 1;  		this.triangleIndices.Add (i1);  		this.triangleIndices.Add (i0);  		this.triangleIndices.Add (i2);  		this.triangleIndices.Add (i1);  		this.triangleIndices.Add (i2);  		this.triangleIndices.Add (i3);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: for (int j = 0; j + 1 < n; j++) {  	// Add segment  	var q1 = origin + (direction * points [j].X) + (w * points [j].Y);  	var q2 = origin + (direction * points [j + 1].X) + (w * points [j + 1].Y);  	// TODO: should not add segment if q1==q2 (corner point)  	// const double eps = 1e-6;  	// if (Point3D.Subtract(q1' q2).LengthSquared < eps)  	// continue;  	this.positions.Add (q1);  	this.positions.Add (q2);  	if (this.normals != null) {  		var tx = points [j + 1].X - points [j].X;  		var ty = points [j + 1].Y - points [j].Y;  		var normal = (-direction * ty) + (w * tx);  		normal.Normalize ();  		this.normals.Add (normal);  		this.normals.Add (normal);  	}  	if (this.textureCoordinates != null) {  		this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues [j]));  		this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues [j + 1]));  	}  	int i0 = index0 + (i * rowNodes) + (j * 2);  	int i1 = i0 + 1;  	int i2 = index0 + ((((i + 1) * rowNodes) + (j * 2)) % totalNodes);  	int i3 = i2 + 1;  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i0);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i3);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: for (int j = 0; j + 1 < n; j++) {  	// Add segment  	var q1 = origin + (direction * points [j].X) + (w * points [j].Y);  	var q2 = origin + (direction * points [j + 1].X) + (w * points [j + 1].Y);  	// TODO: should not add segment if q1==q2 (corner point)  	// const double eps = 1e-6;  	// if (Point3D.Subtract(q1' q2).LengthSquared < eps)  	// continue;  	this.positions.Add (q1);  	this.positions.Add (q2);  	if (this.normals != null) {  		var tx = points [j + 1].X - points [j].X;  		var ty = points [j + 1].Y - points [j].Y;  		var normal = (-direction * ty) + (w * tx);  		normal.Normalize ();  		this.normals.Add (normal);  		this.normals.Add (normal);  	}  	if (this.textureCoordinates != null) {  		this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues [j]));  		this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues [j + 1]));  	}  	int i0 = index0 + (i * rowNodes) + (j * 2);  	int i1 = i0 + 1;  	int i2 = index0 + ((((i + 1) * rowNodes) + (j * 2)) % totalNodes);  	int i3 = i2 + 1;  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i0);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i3);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	var ii = (i + 1) % thetaDiv;  	for (int j = 0; j + 1 < sectionIndices.Count; j += 2) {  		var j0 = sectionIndices [j];  		var j1 = sectionIndices [j + 1];  		int i0 = index0 + (i * n) + j0;  		int i1 = index0 + (ii * n) + j0;  		int i2 = index0 + (i * n) + j1;  		int i3 = index0 + (ii * n) + j1;  		this.triangleIndices.Add (i0);  		this.triangleIndices.Add (i1);  		this.triangleIndices.Add (i3);  		this.triangleIndices.Add (i3);  		this.triangleIndices.Add (i2);  		this.triangleIndices.Add (i0);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The following statement contains a magic number: for (int j = 0; j + 1 < sectionIndices.Count; j += 2) {  	var j0 = sectionIndices [j];  	var j1 = sectionIndices [j + 1];  	int i0 = index0 + (i * n) + j0;  	int i1 = index0 + (ii * n) + j0;  	int i2 = index0 + (i * n) + j1;  	int i3 = index0 + (ii * n) + j1;  	this.triangleIndices.Add (i0);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i3);  	this.triangleIndices.Add (i3);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i0);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The following statement contains a magic number: j += 2
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (selfIntersecting) {  	// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  	var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  	var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  	var offset = -circleAngle / 2;  	// The Cross-Section is defined by only a Segment of a Circle  	crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  } // "normal" Torus (with a Circle as Cross-Section of the Torus  else {  	crossSectionPoints = GetCircle (phiDiv' true);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (selfIntersecting) {  	// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  	var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  	var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  	var offset = -circleAngle / 2;  	// The Cross-Section is defined by only a Segment of a Circle  	crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  } // "normal" Torus (with a Circle as Cross-Section of the Torus  else {  	crossSectionPoints = GetCircle (phiDiv' true);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (selfIntersecting) {  	// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  	var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  	var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  	var offset = -circleAngle / 2;  	// The Cross-Section is defined by only a Segment of a Circle  	crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  } // "normal" Torus (with a Circle as Cross-Section of the Torus  else {  	crossSectionPoints = GetCircle (phiDiv' true);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	// Angle of the current Cross-Section in the XY-Plane  	var angle = Math.PI * 2 * ((double)i / thetaDiv);  	// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  	var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  	for (int j = 0; j < phiDiv; j++) {  		// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  		// We only need the first and last Point of the first Cross-Section once!  		if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  			continue;  		// Add the Position  		this.positions.Add (rotatedPoints [j]);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (this.normals != null) {  	for (int i = 0; i < thetaDiv; i++) {  		// Transform the Cross-Section as well as the Origin of the Cross-Section  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  		if (selfIntersecting && i > 0) {  			rotatedPoints.RemoveAt (0);  			rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  		}  		// Transform the Center of the Cross-Section  		var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  		// Add the Normal of the Vertex  		for (int j = 0; j < rotatedPoints.Count; j++) {  			// The default Normal has the same Direction as the Vector from the Center to the Vertex  			var normal = rotatedPoints [j] - rotatedOrigin;  			normal.Normalize ();  			// If self-intersecting Torus and first Point of first Cross-Section'  			// modify Normal  			if (selfIntersecting && i == 0 && j == 0) {  				normal = new Vector3D (0' 0' -1);  			} // If self-intersecting Torus and last Point of first Cross-Section  			// modify Normal  			else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  				normal = new Vector3D (0' 0' 1);  			}  			// Add the Normal  			this.normals.Add (normal);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	// Transform the Cross-Section as well as the Origin of the Cross-Section  	var angle = Math.PI * 2 * ((double)i / thetaDiv);  	var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  	// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  	if (selfIntersecting && i > 0) {  		rotatedPoints.RemoveAt (0);  		rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  	}  	// Transform the Center of the Cross-Section  	var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  	// Add the Normal of the Vertex  	for (int j = 0; j < rotatedPoints.Count; j++) {  		// The default Normal has the same Direction as the Vector from the Center to the Vertex  		var normal = rotatedPoints [j] - rotatedOrigin;  		normal.Normalize ();  		// If self-intersecting Torus and first Point of first Cross-Section'  		// modify Normal  		if (selfIntersecting && i == 0 && j == 0) {  			normal = new Vector3D (0' 0' -1);  		} // If self-intersecting Torus and last Point of first Cross-Section  		// modify Normal  		else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  			normal = new Vector3D (0' 0' 1);  		}  		// Add the Normal  		this.normals.Add (normal);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (this.textureCoordinates != null) {  	// For all Points' calculate a simple uv Coordinate  	for (int i = 0; i < thetaDiv; i++) {  		// Determine the Number of Vertices of this Cross-Section present in the positions Collection  		var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  		for (int j = 0; j < numCS; j++) {  			// Calculate u- and v- Coordinates for the Points  			var u = (DoubleOrSingle)i / thetaDiv;  			DoubleOrSingle v = 0;  			if (i > 0 && selfIntersecting)  				v = (DoubleOrSingle)(j + 1) / phiDiv;  			else  				v = (DoubleOrSingle)j / phiDiv;  			// Add the Texture-Coordinate  			this.textureCoordinates.Add (new Point (u' v));  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	// Determine the Number of Vertices of this Cross-Section present in the positions Collection  	var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  	for (int j = 0; j < numCS; j++) {  		// Calculate u- and v- Coordinates for the Points  		var u = (DoubleOrSingle)i / thetaDiv;  		DoubleOrSingle v = 0;  		if (i > 0 && selfIntersecting)  			v = (DoubleOrSingle)(j + 1) / phiDiv;  		else  			v = (DoubleOrSingle)j / phiDiv;  		// Add the Texture-Coordinate  		this.textureCoordinates.Add (new Point (u' v));  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	// Normal non-selfintersecting Torus  	// Just add Triangle-Strips between all neighboring Cross-Sections  	if (!selfIntersecting) {  		var firstPointIdx = i * phiDiv;  		var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  		for (int j = 0; j < phiDiv; j++) {  			var jNext = (j + 1) % phiDiv;  			this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  			this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  		}  	} // Selfintersecting Torus  	else {  		// Add intermediate Triangles like for the non-selfintersecting Torus  		// Skip the first and last Triangles' the "Caps" will be added later  		// Determine the Index of the first Point of the first Cross-Section  		var firstPointIdx = i * (phiDiv - 2) + 1;  		firstPointIdx += i > 0 ? 1 : 0;  		// Determine the Index of the first Point of the next Cross-Section  		var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  		firstPointIdxNextCircle -= i > 0 ? 1 : 0;  		if (firstPointIdxNextCircle >= this.positions.Count) {  			firstPointIdxNextCircle %= this.positions.Count;  			firstPointIdxNextCircle++;  		}  		// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  		for (int j = 1; j < phiDiv - 2; j++) {  			this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  			this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  			this.triangleIndices.Add (firstPointIdx + j + positionsCount);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	// Normal non-selfintersecting Torus  	// Just add Triangle-Strips between all neighboring Cross-Sections  	if (!selfIntersecting) {  		var firstPointIdx = i * phiDiv;  		var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  		for (int j = 0; j < phiDiv; j++) {  			var jNext = (j + 1) % phiDiv;  			this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  			this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  		}  	} // Selfintersecting Torus  	else {  		// Add intermediate Triangles like for the non-selfintersecting Torus  		// Skip the first and last Triangles' the "Caps" will be added later  		// Determine the Index of the first Point of the first Cross-Section  		var firstPointIdx = i * (phiDiv - 2) + 1;  		firstPointIdx += i > 0 ? 1 : 0;  		// Determine the Index of the first Point of the next Cross-Section  		var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  		firstPointIdxNextCircle -= i > 0 ? 1 : 0;  		if (firstPointIdxNextCircle >= this.positions.Count) {  			firstPointIdxNextCircle %= this.positions.Count;  			firstPointIdxNextCircle++;  		}  		// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  		for (int j = 1; j < phiDiv - 2; j++) {  			this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  			this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  			this.triangleIndices.Add (firstPointIdx + j + positionsCount);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (!selfIntersecting) {  	var firstPointIdx = i * phiDiv;  	var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  	for (int j = 0; j < phiDiv; j++) {  		var jNext = (j + 1) % phiDiv;  		this.triangleIndices.Add (firstPointIdx + j + positionsCount);  		this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  		this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  	}  } // Selfintersecting Torus  else {  	// Add intermediate Triangles like for the non-selfintersecting Torus  	// Skip the first and last Triangles' the "Caps" will be added later  	// Determine the Index of the first Point of the first Cross-Section  	var firstPointIdx = i * (phiDiv - 2) + 1;  	firstPointIdx += i > 0 ? 1 : 0;  	// Determine the Index of the first Point of the next Cross-Section  	var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  	firstPointIdxNextCircle -= i > 0 ? 1 : 0;  	if (firstPointIdxNextCircle >= this.positions.Count) {  		firstPointIdxNextCircle %= this.positions.Count;  		firstPointIdxNextCircle++;  	}  	// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  	for (int j = 1; j < phiDiv - 2; j++) {  		this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  		this.triangleIndices.Add (firstPointIdx + j + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  		this.triangleIndices.Add (firstPointIdx + j + positionsCount);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (!selfIntersecting) {  	var firstPointIdx = i * phiDiv;  	var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  	for (int j = 0; j < phiDiv; j++) {  		var jNext = (j + 1) % phiDiv;  		this.triangleIndices.Add (firstPointIdx + j + positionsCount);  		this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  		this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  	}  } // Selfintersecting Torus  else {  	// Add intermediate Triangles like for the non-selfintersecting Torus  	// Skip the first and last Triangles' the "Caps" will be added later  	// Determine the Index of the first Point of the first Cross-Section  	var firstPointIdx = i * (phiDiv - 2) + 1;  	firstPointIdx += i > 0 ? 1 : 0;  	// Determine the Index of the first Point of the next Cross-Section  	var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  	firstPointIdxNextCircle -= i > 0 ? 1 : 0;  	if (firstPointIdxNextCircle >= this.positions.Count) {  		firstPointIdxNextCircle %= this.positions.Count;  		firstPointIdxNextCircle++;  	}  	// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  	for (int j = 1; j < phiDiv - 2; j++) {  		this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  		this.triangleIndices.Add (firstPointIdx + j + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  		this.triangleIndices.Add (firstPointIdx + j + positionsCount);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int j = 1; j < phiDiv - 2; j++) {  	this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  	this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  	this.triangleIndices.Add (firstPointIdx + j + positionsCount);  	this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  	this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  	this.triangleIndices.Add (firstPointIdx + j + positionsCount);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (selfIntersecting) {  	// Add bottom Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	var verts = new List<int> ();  	verts.Add (0);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (1 + positionsCount);  		} else {  			verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  		}  	}  	verts.Add (1 + positionsCount);  	verts.Reverse ();  	AddTriangleFan (verts);  	// Add top Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	verts = new List<int> ();  	verts.Add (phiDiv - 1 + positionsCount);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (phiDiv - 2 + positionsCount);  		} else {  			verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  		}  	}  	verts.Add (phiDiv - 2 + positionsCount);  	AddTriangleFan (verts);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (selfIntersecting) {  	// Add bottom Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	var verts = new List<int> ();  	verts.Add (0);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (1 + positionsCount);  		} else {  			verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  		}  	}  	verts.Add (1 + positionsCount);  	verts.Reverse ();  	AddTriangleFan (verts);  	// Add top Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	verts = new List<int> ();  	verts.Add (phiDiv - 1 + positionsCount);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (phiDiv - 2 + positionsCount);  		} else {  			verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  		}  	}  	verts.Add (phiDiv - 2 + positionsCount);  	AddTriangleFan (verts);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (selfIntersecting) {  	// Add bottom Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	var verts = new List<int> ();  	verts.Add (0);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (1 + positionsCount);  		} else {  			verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  		}  	}  	verts.Add (1 + positionsCount);  	verts.Reverse ();  	AddTriangleFan (verts);  	// Add top Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	verts = new List<int> ();  	verts.Add (phiDiv - 1 + positionsCount);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (phiDiv - 2 + positionsCount);  		} else {  			verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  		}  	}  	verts.Add (phiDiv - 2 + positionsCount);  	AddTriangleFan (verts);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (selfIntersecting) {  	// Add bottom Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	var verts = new List<int> ();  	verts.Add (0);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (1 + positionsCount);  		} else {  			verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  		}  	}  	verts.Add (1 + positionsCount);  	verts.Reverse ();  	AddTriangleFan (verts);  	// Add top Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	verts = new List<int> ();  	verts.Add (phiDiv - 1 + positionsCount);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (phiDiv - 2 + positionsCount);  		} else {  			verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  		}  	}  	verts.Add (phiDiv - 2 + positionsCount);  	AddTriangleFan (verts);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	if (i == 0) {  		verts.Add (1 + positionsCount);  	} else {  		verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (i == 0) {  	verts.Add (1 + positionsCount);  } else {  	verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	if (i == 0) {  		verts.Add (phiDiv - 2 + positionsCount);  	} else {  		verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	if (i == 0) {  		verts.Add (phiDiv - 2 + positionsCount);  	} else {  		verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (i == 0) {  	verts.Add (phiDiv - 2 + positionsCount);  } else {  	verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (i == 0) {  	verts.Add (phiDiv - 2 + positionsCount);  } else {  	verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: verts.Add (phiDiv - 2 + positionsCount);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: verts.Add (phiDiv - 2 + positionsCount);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	this.triangleIndices.Add (vertexIndices [i]);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The following statement contains a magic number: this.triangleIndices.Add (i0 + 2);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = 0; i + 2 < vertices.Count; i++) {  	this.triangleIndices.Add (vertices [0]);  	this.triangleIndices.Add (vertices [i + 1]);  	this.triangleIndices.Add (vertices [i + 2]);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = 0; i + 2 < vertices.Count; i++) {  	this.triangleIndices.Add (vertices [0]);  	this.triangleIndices.Add (vertices [i + 1]);  	this.triangleIndices.Add (vertices [i + 2]);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: this.triangleIndices.Add (vertices [i + 2]);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i++) {  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i++) {  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: this.triangleIndices.Add (i + 2);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangles,The following statement contains a magic number: if (trianglePositions.Count % 3 != 0) {  	throw new InvalidOperationException (WrongNumberOfPositions);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	if (i + 3 < indexEnd) {  		this.triangleIndices.Add (i + 1);  		this.triangleIndices.Add (i + 3);  		this.triangleIndices.Add (i + 2);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	if (i + 3 < indexEnd) {  		this.triangleIndices.Add (i + 1);  		this.triangleIndices.Add (i + 3);  		this.triangleIndices.Add (i + 2);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	if (i + 3 < indexEnd) {  		this.triangleIndices.Add (i + 1);  		this.triangleIndices.Add (i + 3);  		this.triangleIndices.Add (i + 2);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	if (i + 3 < indexEnd) {  		this.triangleIndices.Add (i + 1);  		this.triangleIndices.Add (i + 3);  		this.triangleIndices.Add (i + 2);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	if (i + 3 < indexEnd) {  		this.triangleIndices.Add (i + 1);  		this.triangleIndices.Add (i + 3);  		this.triangleIndices.Add (i + 2);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	if (i + 3 < indexEnd) {  		this.triangleIndices.Add (i + 1);  		this.triangleIndices.Add (i + 3);  		this.triangleIndices.Add (i + 2);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: i += 2
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: this.triangleIndices.Add (i + 2);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: if (i + 3 < indexEnd) {  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 3);  	this.triangleIndices.Add (i + 2);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: if (i + 3 < indexEnd) {  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 3);  	this.triangleIndices.Add (i + 2);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: if (i + 3 < indexEnd) {  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 3);  	this.triangleIndices.Add (i + 2);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: this.triangleIndices.Add (i + 3);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: this.triangleIndices.Add (i + 2);  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2) {  	return;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2) {  	return;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: for (int i = 0; i < pathLength; i++) {  	var r = diameters != null ? (DoubleOrSingle)diameters [i % diametersCount] / 2 : 1;  	int i0 = i > 0 ? i - 1 : i;  	int i1 = i + 1 < pathLength ? i + 1 : i;  	var forward = path [i1] - path [i0];  	var right = SharedFunctions.CrossProduct (ref up' ref forward);  	up = SharedFunctions.CrossProduct (ref forward' ref right);  	up.Normalize ();  	right.Normalize ();  	var u = right;  	var v = up;  	//*******************************  	//*** PROPOSED SOLUTION *********  	// ** I think this will work because if path[n-1] is same point'   	// ** it is always a reflection of the current move  	// ** so reversing the last move vector should work?  	//*******************************  	if (u.IsUndefined () || v.IsUndefined ()) {  		forward = lastForward;  		forward *= -1;  		up = lastUp;  		//** Please verify that negation of "up" is correct here  		up *= -1;  		right = SharedFunctions.CrossProduct (ref up' ref forward);  		up.Normalize ();  		right.Normalize ();  		u = right;  		v = up;  	}  	lastForward = forward;  	lastUp = up;  	//*** PROPOSED SOLUTION *********  	//*******************************  	for (int j = 0; j < sectionLength; j++) {  		var w = (section [j].X * u * r) + (section [j].Y * v * r);  		var q = path [i] + w;  		this.positions.Add (q);  		if (this.normals != null) {  			w.Normalize ();  			this.normals.Add (w);  		}  		if (this.textureCoordinates != null) {  			this.textureCoordinates.Add (values != null ? new Point ((DoubleOrSingle)values [i % valuesCount]' (DoubleOrSingle)j / (sectionLength - 1)) : new Point ());  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (frontCap || backCap && path.Count > 1) {  	var normals = new Vector3D[section.Count];  	var fanTextures = new Point[section.Count];  	var count = path.Count;  	if (backCap) {  		var circleBack = Positions.Skip (Positions.Count - section.Count).Take (section.Count).Reverse ().ToArray ();  		var normal = path [count - 1] - path [count - 2];  		normal.Normalize ();  		for (int i = 0; i < normals.Length; ++i) {  			normals [i] = normal;  		}  		this.AddTriangleFan (circleBack' normals' fanTextures);  	}  	if (frontCap) {  		var circleFront = Positions.Take (section.Count).ToArray ();  		var normal = path [0] - path [1];  		normal.Normalize ();  		for (int i = 0; i < normals.Length; ++i) {  			normals [i] = normal;  		}  		this.AddTriangleFan (circleFront' normals' fanTextures);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (backCap) {  	var circleBack = Positions.Skip (Positions.Count - section.Count).Take (section.Count).Reverse ().ToArray ();  	var normal = path [count - 1] - path [count - 2];  	normal.Normalize ();  	for (int i = 0; i < normals.Length; ++i) {  		normals [i] = normal;  	}  	this.AddTriangleFan (circleBack' normals' fanTextures);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2) {  	return;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2) {  	return;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: for (int i = 0; i < pathLength; i++) {  	var radius = diameters != null ? (DoubleOrSingle)diameters [i % diametersCount] / 2 : 1;  	var theta = angles != null ? (DoubleOrSingle)angles [i % anglesCount] : 0.0;  	var ct = (DoubleOrSingle)Math.Cos (theta);  	var st = (DoubleOrSingle)Math.Sin (theta);  	int i0 = i > 0 ? i - 1 : i;  	int i1 = i + 1 < pathLength ? i + 1 : i;  	forward = path [i1] - path [i0];  	right = SharedFunctions.CrossProduct (ref up' ref forward);  	if (SharedFunctions.LengthSquared (ref right) > 1e-6f) {  		up = SharedFunctions.CrossProduct (ref forward' ref right);  	}  	up.Normalize ();  	right.Normalize ();  	for (int j = 0; j < sectionLength; j++) {  		var x = (section [j].X * ct) - (section [j].Y * st);  		var y = (section [j].X * st) + (section [j].Y * ct);  		var w = (x * right * radius) + (y * up * radius);  		var q = path [i] + w;  		this.positions.Add (q);  		if (this.normals != null) {  			w.Normalize ();  			this.normals.Add (w);  		}  		if (this.textureCoordinates != null) {  			this.textureCoordinates.Add (values != null ? new Point ((DoubleOrSingle)values [i % valuesCount]' (DoubleOrSingle)j / (sectionLength - 1)) : new Point ());  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (frontCap || backCap && path.Count > 1) {  	var normals = new Vector3D[section.Count];  	var fanTextures = new Point[section.Count];  	var count = path.Count;  	if (backCap) {  		var circleBack = Positions.Skip (Positions.Count - section.Count).Take (section.Count).Reverse ().ToArray ();  		var normal = path [count - 1] - path [count - 2];  		normal.Normalize ();  		for (int i = 0; i < normals.Length; ++i) {  			normals [i] = normal;  		}  		this.AddTriangleFan (circleBack' normals' fanTextures);  	}  	if (frontCap) {  		var circleFront = Positions.Take (section.Count).ToArray ();  		var normal = path [0] - path [1];  		normal.Normalize ();  		for (int i = 0; i < normals.Length; ++i) {  			normals [i] = normal;  		}  		this.AddTriangleFan (circleFront' normals' fanTextures);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (backCap) {  	var circleBack = Positions.Skip (Positions.Count - section.Count).Take (section.Count).Reverse ().ToArray ();  	var normal = path [count - 1] - path [count - 2];  	normal.Normalize ();  	for (int i = 0; i < normals.Length; ++i) {  		normals [i] = normal;  	}  	this.AddTriangleFan (circleBack' normals' fanTextures);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	var p0 = this.positions [this.triangleIndices [i0]];  	var p1 = this.positions [this.triangleIndices [i1]];  	var p2 = this.positions [this.triangleIndices [i2]];  	var pp0 = p - p0;  	var pp1 = p - p1;  	var pp2 = p - p2;  	var d0 = SharedFunctions.LengthSquared (ref pp0);  	var d1 = SharedFunctions.LengthSquared (ref pp1);  	var d2 = SharedFunctions.LengthSquared (ref pp2);  	var mind = Math.Min (d0' Math.Min (d1' d2));  	if (mind > eps) {  		continue;  	}  	if (d1 < eps) {  		i0 = i + 1;  		i1 = i + 2;  		i2 = i;  	}  	if (d2 < eps) {  		i0 = i + 2;  		i1 = i;  		i2 = i + 1;  	}  	p0 = this.positions [this.triangleIndices [i0]];  	p1 = this.positions [this.triangleIndices [i1]];  	p2 = this.positions [this.triangleIndices [i2]];  	// origin is the corner vertex (at index i0)  	// find the intersections between the chamfer plane and the two edges connected to the corner  	var p01 = plane.LineIntersection (p0' p1);  	var p02 = plane.LineIntersection (p0' p2);  	if (p01 == null) {  		continue;  	}  	if (p02 == null) {  		continue;  	}  	if (chamferPoints != null) {  		// add the chamfered points  		if (!chamferPoints.Contains (p01.Value)) {  			chamferPoints.Add (p01.Value);  		}  		if (!chamferPoints.Contains (p02.Value)) {  			chamferPoints.Add (p02.Value);  		}  	}  	int i01 = i0;  	// change the original triangle to use the first chamfer point  	this.positions [this.triangleIndices [i01]] = p01.Value;  	int i02 = this.positions.Count;  	this.positions.Add (p02.Value);  	// add a new triangle for the other chamfer point  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i02);  	// add a triangle connecting the chamfer points and the new corner point  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i02);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	var p0 = this.positions [this.triangleIndices [i0]];  	var p1 = this.positions [this.triangleIndices [i1]];  	var p2 = this.positions [this.triangleIndices [i2]];  	var pp0 = p - p0;  	var pp1 = p - p1;  	var pp2 = p - p2;  	var d0 = SharedFunctions.LengthSquared (ref pp0);  	var d1 = SharedFunctions.LengthSquared (ref pp1);  	var d2 = SharedFunctions.LengthSquared (ref pp2);  	var mind = Math.Min (d0' Math.Min (d1' d2));  	if (mind > eps) {  		continue;  	}  	if (d1 < eps) {  		i0 = i + 1;  		i1 = i + 2;  		i2 = i;  	}  	if (d2 < eps) {  		i0 = i + 2;  		i1 = i;  		i2 = i + 1;  	}  	p0 = this.positions [this.triangleIndices [i0]];  	p1 = this.positions [this.triangleIndices [i1]];  	p2 = this.positions [this.triangleIndices [i2]];  	// origin is the corner vertex (at index i0)  	// find the intersections between the chamfer plane and the two edges connected to the corner  	var p01 = plane.LineIntersection (p0' p1);  	var p02 = plane.LineIntersection (p0' p2);  	if (p01 == null) {  		continue;  	}  	if (p02 == null) {  		continue;  	}  	if (chamferPoints != null) {  		// add the chamfered points  		if (!chamferPoints.Contains (p01.Value)) {  			chamferPoints.Add (p01.Value);  		}  		if (!chamferPoints.Contains (p02.Value)) {  			chamferPoints.Add (p02.Value);  		}  	}  	int i01 = i0;  	// change the original triangle to use the first chamfer point  	this.positions [this.triangleIndices [i01]] = p01.Value;  	int i02 = this.positions.Count;  	this.positions.Add (p02.Value);  	// add a new triangle for the other chamfer point  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i02);  	// add a triangle connecting the chamfer points and the new corner point  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i02);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	var p0 = this.positions [this.triangleIndices [i0]];  	var p1 = this.positions [this.triangleIndices [i1]];  	var p2 = this.positions [this.triangleIndices [i2]];  	var pp0 = p - p0;  	var pp1 = p - p1;  	var pp2 = p - p2;  	var d0 = SharedFunctions.LengthSquared (ref pp0);  	var d1 = SharedFunctions.LengthSquared (ref pp1);  	var d2 = SharedFunctions.LengthSquared (ref pp2);  	var mind = Math.Min (d0' Math.Min (d1' d2));  	if (mind > eps) {  		continue;  	}  	if (d1 < eps) {  		i0 = i + 1;  		i1 = i + 2;  		i2 = i;  	}  	if (d2 < eps) {  		i0 = i + 2;  		i1 = i;  		i2 = i + 1;  	}  	p0 = this.positions [this.triangleIndices [i0]];  	p1 = this.positions [this.triangleIndices [i1]];  	p2 = this.positions [this.triangleIndices [i2]];  	// origin is the corner vertex (at index i0)  	// find the intersections between the chamfer plane and the two edges connected to the corner  	var p01 = plane.LineIntersection (p0' p1);  	var p02 = plane.LineIntersection (p0' p2);  	if (p01 == null) {  		continue;  	}  	if (p02 == null) {  		continue;  	}  	if (chamferPoints != null) {  		// add the chamfered points  		if (!chamferPoints.Contains (p01.Value)) {  			chamferPoints.Add (p01.Value);  		}  		if (!chamferPoints.Contains (p02.Value)) {  			chamferPoints.Add (p02.Value);  		}  	}  	int i01 = i0;  	// change the original triangle to use the first chamfer point  	this.positions [this.triangleIndices [i01]] = p01.Value;  	int i02 = this.positions.Count;  	this.positions.Add (p02.Value);  	// add a new triangle for the other chamfer point  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i02);  	// add a triangle connecting the chamfer points and the new corner point  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i02);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	var p0 = this.positions [this.triangleIndices [i0]];  	var p1 = this.positions [this.triangleIndices [i1]];  	var p2 = this.positions [this.triangleIndices [i2]];  	var pp0 = p - p0;  	var pp1 = p - p1;  	var pp2 = p - p2;  	var d0 = SharedFunctions.LengthSquared (ref pp0);  	var d1 = SharedFunctions.LengthSquared (ref pp1);  	var d2 = SharedFunctions.LengthSquared (ref pp2);  	var mind = Math.Min (d0' Math.Min (d1' d2));  	if (mind > eps) {  		continue;  	}  	if (d1 < eps) {  		i0 = i + 1;  		i1 = i + 2;  		i2 = i;  	}  	if (d2 < eps) {  		i0 = i + 2;  		i1 = i;  		i2 = i + 1;  	}  	p0 = this.positions [this.triangleIndices [i0]];  	p1 = this.positions [this.triangleIndices [i1]];  	p2 = this.positions [this.triangleIndices [i2]];  	// origin is the corner vertex (at index i0)  	// find the intersections between the chamfer plane and the two edges connected to the corner  	var p01 = plane.LineIntersection (p0' p1);  	var p02 = plane.LineIntersection (p0' p2);  	if (p01 == null) {  		continue;  	}  	if (p02 == null) {  		continue;  	}  	if (chamferPoints != null) {  		// add the chamfered points  		if (!chamferPoints.Contains (p01.Value)) {  			chamferPoints.Add (p01.Value);  		}  		if (!chamferPoints.Contains (p02.Value)) {  			chamferPoints.Add (p02.Value);  		}  	}  	int i01 = i0;  	// change the original triangle to use the first chamfer point  	this.positions [this.triangleIndices [i01]] = p01.Value;  	int i02 = this.positions.Count;  	this.positions.Add (p02.Value);  	// add a new triangle for the other chamfer point  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i02);  	// add a triangle connecting the chamfer points and the new corner point  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i02);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: if (d1 < eps) {  	i0 = i + 1;  	i1 = i + 2;  	i2 = i;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: i1 = i + 2;  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: if (d2 < eps) {  	i0 = i + 2;  	i1 = i;  	i2 = i + 1;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: i0 = i + 2;  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,CheckPerformanceLimits,The following statement contains a magic number: if (this.positions.Count > 20000) {  	Trace.WriteLine (string.Format ("Too many positions ({0})."' this.positions.Count));  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,CheckPerformanceLimits,The following statement contains a magic number: if (this.triangleIndices.Count > 60002) {  	Trace.WriteLine (string.Format ("Too many triangle indices ({0})."' this.triangleIndices.Count));  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,FindCornerNormal,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	var p0 = this.positions [this.triangleIndices [i0]];  	var p1 = this.positions [this.triangleIndices [i1]];  	var p2 = this.positions [this.triangleIndices [i2]];  	// check if any of the vertices are on the corner  	var pp0 = p - p0;  	var pp1 = p - p1;  	var pp2 = p - p2;  	var d0 = SharedFunctions.LengthSquared (ref pp0);  	var d1 = SharedFunctions.LengthSquared (ref pp1);  	var d2 = SharedFunctions.LengthSquared (ref pp2);  	var mind = Math.Min (d0' Math.Min (d1' d2));  	if (mind > eps) {  		continue;  	}  	// calculate the triangle normal and check if this face is already added  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var normal = SharedFunctions.CrossProduct (ref p10' ref p20);  	normal.Normalize ();  	// todo: need to use the epsilon value to compare the normals?  	if (addedNormals.Contains (normal)) {  		continue;  	}  	// todo: this does not work yet  	// double dp = 1;  	// foreach (var n in addedNormals)  	// {  	// dp = Math.Abs(Vector3D.DotProduct(n' normal) - 1);  	// if (dp < eps)  	// continue;  	// }  	// if (dp < eps)  	// {  	// continue;  	// }  	count++;  	sum += normal;  	addedNormals.Add (normal);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,FindCornerNormal,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	var p0 = this.positions [this.triangleIndices [i0]];  	var p1 = this.positions [this.triangleIndices [i1]];  	var p2 = this.positions [this.triangleIndices [i2]];  	// check if any of the vertices are on the corner  	var pp0 = p - p0;  	var pp1 = p - p1;  	var pp2 = p - p2;  	var d0 = SharedFunctions.LengthSquared (ref pp0);  	var d1 = SharedFunctions.LengthSquared (ref pp1);  	var d2 = SharedFunctions.LengthSquared (ref pp2);  	var mind = Math.Min (d0' Math.Min (d1' d2));  	if (mind > eps) {  		continue;  	}  	// calculate the triangle normal and check if this face is already added  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var normal = SharedFunctions.CrossProduct (ref p10' ref p20);  	normal.Normalize ();  	// todo: need to use the epsilon value to compare the normals?  	if (addedNormals.Contains (normal)) {  		continue;  	}  	// todo: this does not work yet  	// double dp = 1;  	// foreach (var n in addedNormals)  	// {  	// dp = Math.Abs(Vector3D.DotProduct(n' normal) - 1);  	// if (dp < eps)  	// continue;  	// }  	// if (dp < eps)  	// {  	// continue;  	// }  	count++;  	sum += normal;  	addedNormals.Add (normal);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,FindCornerNormal,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	int index0 = this.triangleIndices [i0];  	int index1 = this.triangleIndices [i1];  	int index2 = this.triangleIndices [i2];  	var p0 = this.positions [index0];  	var p1 = this.positions [index1];  	var p2 = this.positions [index2];  	p.Add (p0);  	p.Add (p1);  	p.Add (p2);  	ti.Add (i0);  	ti.Add (i1);  	ti.Add (i2);  	if (n != null) {  		n.Add (this.normals [index0]);  		n.Add (this.normals [index1]);  		n.Add (this.normals [index2]);  	}  	if (tc != null) {  		tc.Add (this.textureCoordinates [index0]);  		tc.Add (this.textureCoordinates [index1]);  		tc.Add (this.textureCoordinates [index2]);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	int index0 = this.triangleIndices [i0];  	int index1 = this.triangleIndices [i1];  	int index2 = this.triangleIndices [i2];  	var p0 = this.positions [index0];  	var p1 = this.positions [index1];  	var p2 = this.positions [index2];  	p.Add (p0);  	p.Add (p1);  	p.Add (p2);  	ti.Add (i0);  	ti.Add (i1);  	ti.Add (i2);  	if (n != null) {  		n.Add (this.normals [index0]);  		n.Add (this.normals [index1]);  		n.Add (this.normals [index2]);  	}  	if (tc != null) {  		tc.Add (this.textureCoordinates [index0]);  		tc.Add (this.textureCoordinates [index1]);  		tc.Add (this.textureCoordinates [index2]);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,NoSharedVertices,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	int i01 = ip++;  	int i12 = ip++;  	int i20 = ip++;  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = i20;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i20);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	int i01 = ip++;  	int i12 = ip++;  	int i20 = ip++;  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = i20;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i20);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	int i01 = ip++;  	int i12 = ip++;  	int i20 = ip++;  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = i20;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i20);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	int i01 = ip++;  	int i12 = ip++;  	int i20 = ip++;  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = i20;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i20);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: if (this.textureCoordinates != null) {  	var uv0 = this.TextureCoordinates [i0];  	var uv1 = this.TextureCoordinates [i0 + 1];  	var uv2 = this.TextureCoordinates [i0 + 2];  	var t01 = uv1 - uv0;  	var t12 = uv2 - uv1;  	var t20 = uv0 - uv2;  	var u01 = uv0 + (t01 * 0.5f);  	var u12 = uv1 + (t12 * 0.5f);  	var u20 = uv2 + (t20 * 0.5f);  	this.TextureCoordinates.Add (u01);  	this.TextureCoordinates.Add (u12);  	this.TextureCoordinates.Add (u20);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: this.TriangleIndices [i + 2] = i20;  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: if (this.textureCoordinates != null) {  	var uv0 = this.TextureCoordinates [i0];  	var uv1 = this.TextureCoordinates [i0 + 1];  	var uv2 = this.TextureCoordinates [i0 + 2];  	var t01 = uv1 - uv0;  	var t12 = uv2 - uv1;  	var t20 = uv0 - uv2;  	var u01 = uv0 + (t01 * 0.5f);  	var u12 = uv1 + (t12 * 0.5f);  	var u20 = uv2 + (t20 * 0.5f);  	var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  	this.TextureCoordinates.Add (uvm);  	this.TextureCoordinates.Add (u01);  	this.TextureCoordinates.Add (u12);  	this.TextureCoordinates.Add (u20);  }  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: this.TriangleIndices [i + 2] = im;  
Magic Number,HelixToolkit.Wpf,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: im += 4;  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < triangleIndices.Count; i += 3) {  	int index0 = triangleIndices [i];  	int index1 = triangleIndices [i + 1];  	int index2 = triangleIndices [i + 2];  	var p0 = positions [index0];  	var p1 = positions [index1];  	var p2 = positions [index2];  	Vector3D u = p1 - p0;  	Vector3D v = p2 - p0;  	Vector3D w = SharedFunctions.CrossProduct (ref u' ref v);  	w.Normalize ();  	normals [index0] += w;  	normals [index1] += w;  	normals [index2] += w;  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < triangleIndices.Count; i += 3) {  	int index0 = triangleIndices [i];  	int index1 = triangleIndices [i + 1];  	int index2 = triangleIndices [i + 2];  	var p0 = positions [index0];  	var p1 = positions [index1];  	var p2 = positions [index2];  	Vector3D u = p1 - p0;  	Vector3D v = p2 - p0;  	Vector3D w = SharedFunctions.CrossProduct (ref u' ref v);  	w.Normalize ();  	normals [index0] += w;  	normals [index1] += w;  	normals [index2] += w;  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CalculateNormals,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (dict.ContainsKey (key)) {  			dict [key] = dict [key] + 1;  		} else {  			dict.Add (key' 1);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (dict.ContainsKey (key)) {  			dict [key] = dict [key] + 1;  		} else {  			dict.Add (key' 1);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (dict.ContainsKey (key)) {  			dict [key] = dict [key] + 1;  		} else {  			dict.Add (key' 1);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (dict.ContainsKey (key)) {  			dict [key] = dict [key] + 1;  		} else {  			dict.Add (key' 1);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int j = 0; j < 3; j++) {  	int index0 = mesh.TriangleIndices [i0 + j];  	int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  	int minIndex = Math.Min (index0' index1);  	int maxIndex = Math.Max (index1' index0);  	ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  	if (dict.ContainsKey (key)) {  		dict [key] = dict [key] + 1;  	} else {  		dict.Add (key' 1);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int j = 0; j < 3; j++) {  	int index0 = mesh.TriangleIndices [i0 + j];  	int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  	int minIndex = Math.Min (index0' index1);  	int maxIndex = Math.Max (index1' index0);  	ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  	if (dict.ContainsKey (key)) {  		dict [key] = dict [key] + 1;  	} else {  		dict.Add (key' 1);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (!dict.Contains (key)) {  			edges.Add (minIndex);  			edges.Add (maxIndex);  			dict.Add (key);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (!dict.Contains (key)) {  			edges.Add (minIndex);  			edges.Add (maxIndex);  			dict.Add (key);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (!dict.Contains (key)) {  			edges.Add (minIndex);  			edges.Add (maxIndex);  			dict.Add (key);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (!dict.Contains (key)) {  			edges.Add (minIndex);  			edges.Add (maxIndex);  			dict.Add (key);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int j = 0; j < 3; j++) {  	int index0 = mesh.TriangleIndices [i0 + j];  	int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  	int minIndex = Math.Min (index0' index1);  	int maxIndex = Math.Max (index1' index0);  	ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  	if (!dict.Contains (key)) {  		edges.Add (minIndex);  		edges.Add (maxIndex);  		dict.Add (key);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int j = 0; j < 3; j++) {  	int index0 = mesh.TriangleIndices [i0 + j];  	int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  	int minIndex = Math.Min (index0' index1);  	int maxIndex = Math.Max (index1' index0);  	ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  	if (!dict.Contains (key)) {  		edges.Add (minIndex);  		edges.Add (maxIndex);  		dict.Add (key);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	var p0 = mesh.Positions [mesh.TriangleIndices [i0]];  	var p1 = mesh.Positions [mesh.TriangleIndices [i0 + 1]];  	var p2 = mesh.Positions [mesh.TriangleIndices [i0 + 2]];  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var n = SharedFunctions.CrossProduct (ref p10' ref p20);  	n.Normalize ();  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index0' index1);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		Vector3D value;  		if (edgeNormals.TryGetValue (key' out value)) {  			var n2 = value;  			n2.Normalize ();  			var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  			if (angle > minimumAngle) {  				edgeIndices.Add (minIndex);  				edgeIndices.Add (maxIndex);  			}  		} else {  			edgeNormals.Add (key' n);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	var p0 = mesh.Positions [mesh.TriangleIndices [i0]];  	var p1 = mesh.Positions [mesh.TriangleIndices [i0 + 1]];  	var p2 = mesh.Positions [mesh.TriangleIndices [i0 + 2]];  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var n = SharedFunctions.CrossProduct (ref p10' ref p20);  	n.Normalize ();  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index0' index1);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		Vector3D value;  		if (edgeNormals.TryGetValue (key' out value)) {  			var n2 = value;  			n2.Normalize ();  			var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  			if (angle > minimumAngle) {  				edgeIndices.Add (minIndex);  				edgeIndices.Add (maxIndex);  			}  		} else {  			edgeNormals.Add (key' n);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	var p0 = mesh.Positions [mesh.TriangleIndices [i0]];  	var p1 = mesh.Positions [mesh.TriangleIndices [i0 + 1]];  	var p2 = mesh.Positions [mesh.TriangleIndices [i0 + 2]];  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var n = SharedFunctions.CrossProduct (ref p10' ref p20);  	n.Normalize ();  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index0' index1);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		Vector3D value;  		if (edgeNormals.TryGetValue (key' out value)) {  			var n2 = value;  			n2.Normalize ();  			var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  			if (angle > minimumAngle) {  				edgeIndices.Add (minIndex);  				edgeIndices.Add (maxIndex);  			}  		} else {  			edgeNormals.Add (key' n);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	var p0 = mesh.Positions [mesh.TriangleIndices [i0]];  	var p1 = mesh.Positions [mesh.TriangleIndices [i0 + 1]];  	var p2 = mesh.Positions [mesh.TriangleIndices [i0 + 2]];  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var n = SharedFunctions.CrossProduct (ref p10' ref p20);  	n.Normalize ();  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index0' index1);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		Vector3D value;  		if (edgeNormals.TryGetValue (key' out value)) {  			var n2 = value;  			n2.Normalize ();  			var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  			if (angle > minimumAngle) {  				edgeIndices.Add (minIndex);  				edgeIndices.Add (maxIndex);  			}  		} else {  			edgeNormals.Add (key' n);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	var p0 = mesh.Positions [mesh.TriangleIndices [i0]];  	var p1 = mesh.Positions [mesh.TriangleIndices [i0 + 1]];  	var p2 = mesh.Positions [mesh.TriangleIndices [i0 + 2]];  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var n = SharedFunctions.CrossProduct (ref p10' ref p20);  	n.Normalize ();  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index0' index1);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		Vector3D value;  		if (edgeNormals.TryGetValue (key' out value)) {  			var n2 = value;  			n2.Normalize ();  			var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  			if (angle > minimumAngle) {  				edgeIndices.Add (minIndex);  				edgeIndices.Add (maxIndex);  			}  		} else {  			edgeNormals.Add (key' n);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	var p0 = mesh.Positions [mesh.TriangleIndices [i0]];  	var p1 = mesh.Positions [mesh.TriangleIndices [i0 + 1]];  	var p2 = mesh.Positions [mesh.TriangleIndices [i0 + 2]];  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var n = SharedFunctions.CrossProduct (ref p10' ref p20);  	n.Normalize ();  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index0' index1);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		Vector3D value;  		if (edgeNormals.TryGetValue (key' out value)) {  			var n2 = value;  			n2.Normalize ();  			var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  			if (angle > minimumAngle) {  				edgeIndices.Add (minIndex);  				edgeIndices.Add (maxIndex);  			}  		} else {  			edgeNormals.Add (key' n);  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int j = 0; j < 3; j++) {  	int index0 = mesh.TriangleIndices [i0 + j];  	int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  	int minIndex = Math.Min (index0' index1);  	int maxIndex = Math.Max (index0' index1);  	ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  	Vector3D value;  	if (edgeNormals.TryGetValue (key' out value)) {  		var n2 = value;  		n2.Normalize ();  		var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  		if (angle > minimumAngle) {  			edgeIndices.Add (minIndex);  			edgeIndices.Add (maxIndex);  		}  	} else {  		edgeNormals.Add (key' n);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int j = 0; j < 3; j++) {  	int index0 = mesh.TriangleIndices [i0 + j];  	int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  	int minIndex = Math.Min (index0' index1);  	int maxIndex = Math.Max (index0' index1);  	ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  	Vector3D value;  	if (edgeNormals.TryGetValue (key' out value)) {  		var n2 = value;  		n2.Normalize ();  		var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  		if (angle > minimumAngle) {  			edgeIndices.Add (minIndex);  			edgeIndices.Add (maxIndex);  		}  	} else {  		edgeNormals.Add (key' n);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int j = 0; j < 3; j++) {  	int index0 = mesh.TriangleIndices [i0 + j];  	int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  	int minIndex = Math.Min (index0' index1);  	int maxIndex = Math.Max (index0' index1);  	ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  	Vector3D value;  	if (edgeNormals.TryGetValue (key' out value)) {  		var n2 = value;  		n2.Normalize ();  		var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  		if (angle > minimumAngle) {  			edgeIndices.Add (minIndex);  			edgeIndices.Add (maxIndex);  		}  	} else {  		edgeNormals.Add (key' n);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: if (edgeNormals.TryGetValue (key' out value)) {  	var n2 = value;  	n2.Normalize ();  	var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  	if (angle > minimumAngle) {  		edgeIndices.Add (minIndex);  		edgeIndices.Add (maxIndex);  	}  } else {  	edgeNormals.Add (key' n);  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < input.TriangleIndices.Count; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	int index0 = input.TriangleIndices [i0];  	int index1 = input.TriangleIndices [i1];  	int index2 = input.TriangleIndices [i2];  	var p0 = input.Positions [index0];  	var p1 = input.Positions [index1];  	var p2 = input.Positions [index2];  	p.Add (p0);  	p.Add (p1);  	p.Add (p2);  	ti.Add (i0);  	ti.Add (i1);  	ti.Add (i2);  	if (n != null) {  		n.Add (input.Normals [index0]);  		n.Add (input.Normals [index1]);  		n.Add (input.Normals [index2]);  	}  	if (tc != null) {  		tc.Add (input.TextureCoordinates [index0]);  		tc.Add (input.TextureCoordinates [index1]);  		tc.Add (input.TextureCoordinates [index2]);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < input.TriangleIndices.Count; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	int index0 = input.TriangleIndices [i0];  	int index1 = input.TriangleIndices [i1];  	int index2 = input.TriangleIndices [i2];  	var p0 = input.Positions [index0];  	var p1 = input.Positions [index1];  	var p2 = input.Positions [index2];  	p.Add (p0);  	p.Add (p1);  	p.Add (p2);  	ti.Add (i0);  	ti.Add (i1);  	ti.Add (i2);  	if (n != null) {  		n.Add (input.Normals [index0]);  		n.Add (input.Normals [index1]);  		n.Add (input.Normals [index2]);  	}  	if (tc != null) {  		tc.Add (input.TextureCoordinates [index0]);  		tc.Add (input.TextureCoordinates [index1]);  		tc.Add (input.TextureCoordinates [index2]);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: if (mesh.TriangleIndices.Count % 3 != 0) {  	sb.AppendLine ("TriangleIndices not complete");  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i++) {  	int index = mesh.TriangleIndices [i];  	if (index < 0 || index >= mesh.Positions.Count) {  		sb.AppendFormat ("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);  		sb.AppendLine ();  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i++) {  	int index = mesh.TriangleIndices [i];  	if (index < 0 || index >= mesh.Positions.Count) {  		sb.AppendFormat ("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);  		sb.AppendLine ();  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: if (index < 0 || index >= mesh.Positions.Count) {  	sb.AppendFormat ("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);  	sb.AppendLine ();  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: if (index < 0 || index >= mesh.Positions.Count) {  	sb.AppendFormat ("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);  	sb.AppendLine ();  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: sb.AppendFormat ("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: sb.AppendFormat ("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The following statement contains a magic number: for (var i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	var index0 = mesh.TriangleIndices [i];  	var index1 = mesh.TriangleIndices [i + 1];  	var index2 = mesh.TriangleIndices [i + 2];  	Point3D[] positions;  	Vector3D[] normals;  	Point[] textureCoordinates;  	int[] triangleIndices;  	contourHelper.ContourFacet (index0' index1' index2' out positions' out normals' out textureCoordinates' out triangleIndices);  	foreach (var p in positions) {  		meshBuilder.Positions.Add (p);  	}  	foreach (var tc in textureCoordinates) {  		meshBuilder.TextureCoordinates.Add (tc);  	}  	foreach (var n in normals) {  		meshBuilder.Normals.Add (n);  	}  	foreach (var ti in triangleIndices) {  		meshBuilder.TriangleIndices.Add (ti);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The following statement contains a magic number: for (var i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	var index0 = mesh.TriangleIndices [i];  	var index1 = mesh.TriangleIndices [i + 1];  	var index2 = mesh.TriangleIndices [i + 2];  	Point3D[] positions;  	Vector3D[] normals;  	Point[] textureCoordinates;  	int[] triangleIndices;  	contourHelper.ContourFacet (index0' index1' index2' out positions' out normals' out textureCoordinates' out triangleIndices);  	foreach (var p in positions) {  		meshBuilder.Positions.Add (p);  	}  	foreach (var tc in textureCoordinates) {  		meshBuilder.TextureCoordinates.Add (tc);  	}  	foreach (var n in normals) {  		meshBuilder.Normals.Add (n);  	}  	foreach (var ti in triangleIndices) {  		meshBuilder.TriangleIndices.Add (ti);  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	Point3D[] positions;  	Vector3D[] normals;  	Point[] textureCoordinates;  	int[] triangleIndices;  	contourHelper.ContourFacet (mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2]' out positions' out normals' out textureCoordinates' out triangleIndices);  	segments.AddRange (positions);  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	Point3D[] positions;  	Vector3D[] normals;  	Point[] textureCoordinates;  	int[] triangleIndices;  	contourHelper.ContourFacet (mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2]' out positions' out normals' out textureCoordinates' out triangleIndices);  	segments.AddRange (positions);  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The following statement contains a magic number: contourHelper.ContourFacet (mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2]' out positions' out normals' out textureCoordinates' out triangleIndices);  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0) {  	if (curveCount > 0) {  		// Find a segment that is connected to the head of the contour  		segment1 = FindConnectedSegment (segments' curve [0]' eps);  		if (segment1 >= 0) {  			if (segment1 % 2 == 1) {  				curve.Insert (0' segments [segment1 - 1]);  				segments.RemoveAt (segment1 - 1);  				segments.RemoveAt (segment1 - 1);  			} else {  				curve.Insert (0' segments [segment1 + 1]);  				segments.RemoveAt (segment1);  				segments.RemoveAt (segment1);  			}  			curveCount++;  			segmentCount -= 2;  		}  		// Find a segment that is connected to the tail of the contour  		segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  		if (segment2 >= 0) {  			if (segment2 % 2 == 1) {  				curve.Add (segments [segment2 - 1]);  				segments.RemoveAt (segment2 - 1);  				segments.RemoveAt (segment2 - 1);  			} else {  				curve.Add (segments [segment2 + 1]);  				segments.RemoveAt (segment2);  				segments.RemoveAt (segment2);  			}  			curveCount++;  			segmentCount -= 2;  		}  	}  	if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  		if (curveCount > 0) {  			yield return curve;  			curve = new List<Point3D> ();  			curveCount = 0;  		}  		if (segmentCount > 0) {  			curve.Add (segments [0]);  			curve.Add (segments [1]);  			curveCount += 2;  			segments.RemoveAt (0);  			segments.RemoveAt (0);  			segmentCount -= 2;  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0) {  	if (curveCount > 0) {  		// Find a segment that is connected to the head of the contour  		segment1 = FindConnectedSegment (segments' curve [0]' eps);  		if (segment1 >= 0) {  			if (segment1 % 2 == 1) {  				curve.Insert (0' segments [segment1 - 1]);  				segments.RemoveAt (segment1 - 1);  				segments.RemoveAt (segment1 - 1);  			} else {  				curve.Insert (0' segments [segment1 + 1]);  				segments.RemoveAt (segment1);  				segments.RemoveAt (segment1);  			}  			curveCount++;  			segmentCount -= 2;  		}  		// Find a segment that is connected to the tail of the contour  		segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  		if (segment2 >= 0) {  			if (segment2 % 2 == 1) {  				curve.Add (segments [segment2 - 1]);  				segments.RemoveAt (segment2 - 1);  				segments.RemoveAt (segment2 - 1);  			} else {  				curve.Add (segments [segment2 + 1]);  				segments.RemoveAt (segment2);  				segments.RemoveAt (segment2);  			}  			curveCount++;  			segmentCount -= 2;  		}  	}  	if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  		if (curveCount > 0) {  			yield return curve;  			curve = new List<Point3D> ();  			curveCount = 0;  		}  		if (segmentCount > 0) {  			curve.Add (segments [0]);  			curve.Add (segments [1]);  			curveCount += 2;  			segments.RemoveAt (0);  			segments.RemoveAt (0);  			segmentCount -= 2;  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0) {  	if (curveCount > 0) {  		// Find a segment that is connected to the head of the contour  		segment1 = FindConnectedSegment (segments' curve [0]' eps);  		if (segment1 >= 0) {  			if (segment1 % 2 == 1) {  				curve.Insert (0' segments [segment1 - 1]);  				segments.RemoveAt (segment1 - 1);  				segments.RemoveAt (segment1 - 1);  			} else {  				curve.Insert (0' segments [segment1 + 1]);  				segments.RemoveAt (segment1);  				segments.RemoveAt (segment1);  			}  			curveCount++;  			segmentCount -= 2;  		}  		// Find a segment that is connected to the tail of the contour  		segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  		if (segment2 >= 0) {  			if (segment2 % 2 == 1) {  				curve.Add (segments [segment2 - 1]);  				segments.RemoveAt (segment2 - 1);  				segments.RemoveAt (segment2 - 1);  			} else {  				curve.Add (segments [segment2 + 1]);  				segments.RemoveAt (segment2);  				segments.RemoveAt (segment2);  			}  			curveCount++;  			segmentCount -= 2;  		}  	}  	if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  		if (curveCount > 0) {  			yield return curve;  			curve = new List<Point3D> ();  			curveCount = 0;  		}  		if (segmentCount > 0) {  			curve.Add (segments [0]);  			curve.Add (segments [1]);  			curveCount += 2;  			segments.RemoveAt (0);  			segments.RemoveAt (0);  			segmentCount -= 2;  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0) {  	if (curveCount > 0) {  		// Find a segment that is connected to the head of the contour  		segment1 = FindConnectedSegment (segments' curve [0]' eps);  		if (segment1 >= 0) {  			if (segment1 % 2 == 1) {  				curve.Insert (0' segments [segment1 - 1]);  				segments.RemoveAt (segment1 - 1);  				segments.RemoveAt (segment1 - 1);  			} else {  				curve.Insert (0' segments [segment1 + 1]);  				segments.RemoveAt (segment1);  				segments.RemoveAt (segment1);  			}  			curveCount++;  			segmentCount -= 2;  		}  		// Find a segment that is connected to the tail of the contour  		segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  		if (segment2 >= 0) {  			if (segment2 % 2 == 1) {  				curve.Add (segments [segment2 - 1]);  				segments.RemoveAt (segment2 - 1);  				segments.RemoveAt (segment2 - 1);  			} else {  				curve.Add (segments [segment2 + 1]);  				segments.RemoveAt (segment2);  				segments.RemoveAt (segment2);  			}  			curveCount++;  			segmentCount -= 2;  		}  	}  	if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  		if (curveCount > 0) {  			yield return curve;  			curve = new List<Point3D> ();  			curveCount = 0;  		}  		if (segmentCount > 0) {  			curve.Add (segments [0]);  			curve.Add (segments [1]);  			curveCount += 2;  			segments.RemoveAt (0);  			segments.RemoveAt (0);  			segmentCount -= 2;  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0) {  	if (curveCount > 0) {  		// Find a segment that is connected to the head of the contour  		segment1 = FindConnectedSegment (segments' curve [0]' eps);  		if (segment1 >= 0) {  			if (segment1 % 2 == 1) {  				curve.Insert (0' segments [segment1 - 1]);  				segments.RemoveAt (segment1 - 1);  				segments.RemoveAt (segment1 - 1);  			} else {  				curve.Insert (0' segments [segment1 + 1]);  				segments.RemoveAt (segment1);  				segments.RemoveAt (segment1);  			}  			curveCount++;  			segmentCount -= 2;  		}  		// Find a segment that is connected to the tail of the contour  		segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  		if (segment2 >= 0) {  			if (segment2 % 2 == 1) {  				curve.Add (segments [segment2 - 1]);  				segments.RemoveAt (segment2 - 1);  				segments.RemoveAt (segment2 - 1);  			} else {  				curve.Add (segments [segment2 + 1]);  				segments.RemoveAt (segment2);  				segments.RemoveAt (segment2);  			}  			curveCount++;  			segmentCount -= 2;  		}  	}  	if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  		if (curveCount > 0) {  			yield return curve;  			curve = new List<Point3D> ();  			curveCount = 0;  		}  		if (segmentCount > 0) {  			curve.Add (segments [0]);  			curve.Add (segments [1]);  			curveCount += 2;  			segments.RemoveAt (0);  			segments.RemoveAt (0);  			segmentCount -= 2;  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0) {  	if (curveCount > 0) {  		// Find a segment that is connected to the head of the contour  		segment1 = FindConnectedSegment (segments' curve [0]' eps);  		if (segment1 >= 0) {  			if (segment1 % 2 == 1) {  				curve.Insert (0' segments [segment1 - 1]);  				segments.RemoveAt (segment1 - 1);  				segments.RemoveAt (segment1 - 1);  			} else {  				curve.Insert (0' segments [segment1 + 1]);  				segments.RemoveAt (segment1);  				segments.RemoveAt (segment1);  			}  			curveCount++;  			segmentCount -= 2;  		}  		// Find a segment that is connected to the tail of the contour  		segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  		if (segment2 >= 0) {  			if (segment2 % 2 == 1) {  				curve.Add (segments [segment2 - 1]);  				segments.RemoveAt (segment2 - 1);  				segments.RemoveAt (segment2 - 1);  			} else {  				curve.Add (segments [segment2 + 1]);  				segments.RemoveAt (segment2);  				segments.RemoveAt (segment2);  			}  			curveCount++;  			segmentCount -= 2;  		}  	}  	if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  		if (curveCount > 0) {  			yield return curve;  			curve = new List<Point3D> ();  			curveCount = 0;  		}  		if (segmentCount > 0) {  			curve.Add (segments [0]);  			curve.Add (segments [1]);  			curveCount += 2;  			segments.RemoveAt (0);  			segments.RemoveAt (0);  			segmentCount -= 2;  		}  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (curveCount > 0) {  	// Find a segment that is connected to the head of the contour  	segment1 = FindConnectedSegment (segments' curve [0]' eps);  	if (segment1 >= 0) {  		if (segment1 % 2 == 1) {  			curve.Insert (0' segments [segment1 - 1]);  			segments.RemoveAt (segment1 - 1);  			segments.RemoveAt (segment1 - 1);  		} else {  			curve.Insert (0' segments [segment1 + 1]);  			segments.RemoveAt (segment1);  			segments.RemoveAt (segment1);  		}  		curveCount++;  		segmentCount -= 2;  	}  	// Find a segment that is connected to the tail of the contour  	segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  	if (segment2 >= 0) {  		if (segment2 % 2 == 1) {  			curve.Add (segments [segment2 - 1]);  			segments.RemoveAt (segment2 - 1);  			segments.RemoveAt (segment2 - 1);  		} else {  			curve.Add (segments [segment2 + 1]);  			segments.RemoveAt (segment2);  			segments.RemoveAt (segment2);  		}  		curveCount++;  		segmentCount -= 2;  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (curveCount > 0) {  	// Find a segment that is connected to the head of the contour  	segment1 = FindConnectedSegment (segments' curve [0]' eps);  	if (segment1 >= 0) {  		if (segment1 % 2 == 1) {  			curve.Insert (0' segments [segment1 - 1]);  			segments.RemoveAt (segment1 - 1);  			segments.RemoveAt (segment1 - 1);  		} else {  			curve.Insert (0' segments [segment1 + 1]);  			segments.RemoveAt (segment1);  			segments.RemoveAt (segment1);  		}  		curveCount++;  		segmentCount -= 2;  	}  	// Find a segment that is connected to the tail of the contour  	segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  	if (segment2 >= 0) {  		if (segment2 % 2 == 1) {  			curve.Add (segments [segment2 - 1]);  			segments.RemoveAt (segment2 - 1);  			segments.RemoveAt (segment2 - 1);  		} else {  			curve.Add (segments [segment2 + 1]);  			segments.RemoveAt (segment2);  			segments.RemoveAt (segment2);  		}  		curveCount++;  		segmentCount -= 2;  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (curveCount > 0) {  	// Find a segment that is connected to the head of the contour  	segment1 = FindConnectedSegment (segments' curve [0]' eps);  	if (segment1 >= 0) {  		if (segment1 % 2 == 1) {  			curve.Insert (0' segments [segment1 - 1]);  			segments.RemoveAt (segment1 - 1);  			segments.RemoveAt (segment1 - 1);  		} else {  			curve.Insert (0' segments [segment1 + 1]);  			segments.RemoveAt (segment1);  			segments.RemoveAt (segment1);  		}  		curveCount++;  		segmentCount -= 2;  	}  	// Find a segment that is connected to the tail of the contour  	segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  	if (segment2 >= 0) {  		if (segment2 % 2 == 1) {  			curve.Add (segments [segment2 - 1]);  			segments.RemoveAt (segment2 - 1);  			segments.RemoveAt (segment2 - 1);  		} else {  			curve.Add (segments [segment2 + 1]);  			segments.RemoveAt (segment2);  			segments.RemoveAt (segment2);  		}  		curveCount++;  		segmentCount -= 2;  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (curveCount > 0) {  	// Find a segment that is connected to the head of the contour  	segment1 = FindConnectedSegment (segments' curve [0]' eps);  	if (segment1 >= 0) {  		if (segment1 % 2 == 1) {  			curve.Insert (0' segments [segment1 - 1]);  			segments.RemoveAt (segment1 - 1);  			segments.RemoveAt (segment1 - 1);  		} else {  			curve.Insert (0' segments [segment1 + 1]);  			segments.RemoveAt (segment1);  			segments.RemoveAt (segment1);  		}  		curveCount++;  		segmentCount -= 2;  	}  	// Find a segment that is connected to the tail of the contour  	segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  	if (segment2 >= 0) {  		if (segment2 % 2 == 1) {  			curve.Add (segments [segment2 - 1]);  			segments.RemoveAt (segment2 - 1);  			segments.RemoveAt (segment2 - 1);  		} else {  			curve.Add (segments [segment2 + 1]);  			segments.RemoveAt (segment2);  			segments.RemoveAt (segment2);  		}  		curveCount++;  		segmentCount -= 2;  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segment1 >= 0) {  	if (segment1 % 2 == 1) {  		curve.Insert (0' segments [segment1 - 1]);  		segments.RemoveAt (segment1 - 1);  		segments.RemoveAt (segment1 - 1);  	} else {  		curve.Insert (0' segments [segment1 + 1]);  		segments.RemoveAt (segment1);  		segments.RemoveAt (segment1);  	}  	curveCount++;  	segmentCount -= 2;  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segment1 >= 0) {  	if (segment1 % 2 == 1) {  		curve.Insert (0' segments [segment1 - 1]);  		segments.RemoveAt (segment1 - 1);  		segments.RemoveAt (segment1 - 1);  	} else {  		curve.Insert (0' segments [segment1 + 1]);  		segments.RemoveAt (segment1);  		segments.RemoveAt (segment1);  	}  	curveCount++;  	segmentCount -= 2;  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segment1 % 2 == 1) {  	curve.Insert (0' segments [segment1 - 1]);  	segments.RemoveAt (segment1 - 1);  	segments.RemoveAt (segment1 - 1);  } else {  	curve.Insert (0' segments [segment1 + 1]);  	segments.RemoveAt (segment1);  	segments.RemoveAt (segment1);  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: segmentCount -= 2;  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segment2 >= 0) {  	if (segment2 % 2 == 1) {  		curve.Add (segments [segment2 - 1]);  		segments.RemoveAt (segment2 - 1);  		segments.RemoveAt (segment2 - 1);  	} else {  		curve.Add (segments [segment2 + 1]);  		segments.RemoveAt (segment2);  		segments.RemoveAt (segment2);  	}  	curveCount++;  	segmentCount -= 2;  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segment2 >= 0) {  	if (segment2 % 2 == 1) {  		curve.Add (segments [segment2 - 1]);  		segments.RemoveAt (segment2 - 1);  		segments.RemoveAt (segment2 - 1);  	} else {  		curve.Add (segments [segment2 + 1]);  		segments.RemoveAt (segment2);  		segments.RemoveAt (segment2);  	}  	curveCount++;  	segmentCount -= 2;  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segment2 % 2 == 1) {  	curve.Add (segments [segment2 - 1]);  	segments.RemoveAt (segment2 - 1);  	segments.RemoveAt (segment2 - 1);  } else {  	curve.Add (segments [segment2 + 1]);  	segments.RemoveAt (segment2);  	segments.RemoveAt (segment2);  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: segmentCount -= 2;  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  	if (curveCount > 0) {  		yield return curve;  		curve = new List<Point3D> ();  		curveCount = 0;  	}  	if (segmentCount > 0) {  		curve.Add (segments [0]);  		curve.Add (segments [1]);  		curveCount += 2;  		segments.RemoveAt (0);  		segments.RemoveAt (0);  		segmentCount -= 2;  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  	if (curveCount > 0) {  		yield return curve;  		curve = new List<Point3D> ();  		curveCount = 0;  	}  	if (segmentCount > 0) {  		curve.Add (segments [0]);  		curve.Add (segments [1]);  		curveCount += 2;  		segments.RemoveAt (0);  		segments.RemoveAt (0);  		segmentCount -= 2;  	}  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segmentCount > 0) {  	curve.Add (segments [0]);  	curve.Add (segments [1]);  	curveCount += 2;  	segments.RemoveAt (0);  	segments.RemoveAt (0);  	segmentCount -= 2;  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segmentCount > 0) {  	curve.Add (segments [0]);  	curve.Add (segments [1]);  	curveCount += 2;  	segments.RemoveAt (0);  	segments.RemoveAt (0);  	segmentCount -= 2;  }  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: curveCount += 2;  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: segmentCount -= 2;  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CreateKey,The following statement contains a magic number: return ((ulong)i0 << 32) + i1;  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i0 = (uint)(key >> 32);  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i1 = (uint)((key << 32) >> 32);  
Magic Number,HelixToolkit.Wpf,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i1 = (uint)((key << 32) >> 32);  
Magic Number,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)  	return null;  else if (count == 3) {  	if (!didReverse) {  		return new Int32Collection {  			0'  			1'  			2  		};  	} else {  		return new Int32Collection {  			2'  			1'  			1  		};  	}  }  
Magic Number,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)  	return null;  else if (count == 3) {  	if (!didReverse) {  		return new Int32Collection {  			0'  			1'  			2  		};  	} else {  		return new Int32Collection {  			2'  			1'  			1  		};  	}  }  
Magic Number,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)  	return null;  else if (count == 3) {  	if (!didReverse) {  		return new Int32Collection {  			0'  			1'  			2  		};  	} else {  		return new Int32Collection {  			2'  			1'  			1  		};  	}  }  
Magic Number,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)  	return null;  else if (count == 3) {  	if (!didReverse) {  		return new Int32Collection {  			0'  			1'  			2  		};  	} else {  		return new Int32Collection {  			2'  			1'  			1  		};  	}  }  
Magic Number,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count == 3) {  	if (!didReverse) {  		return new Int32Collection {  			0'  			1'  			2  		};  	} else {  		return new Int32Collection {  			2'  			1'  			1  		};  	}  }  
Magic Number,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count == 3) {  	if (!didReverse) {  		return new Int32Collection {  			0'  			1'  			2  		};  	} else {  		return new Int32Collection {  			2'  			1'  			1  		};  	}  }  
Magic Number,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count == 3) {  	if (!didReverse) {  		return new Int32Collection {  			0'  			1'  			2  		};  	} else {  		return new Int32Collection {  			2'  			1'  			1  		};  	}  }  
Magic Number,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (!didReverse) {  	return new Int32Collection {  		0'  		1'  		2  	};  } else {  	return new Int32Collection {  		2'  		1'  		1  	};  }  
Magic Number,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (!didReverse) {  	return new Int32Collection {  		0'  		1'  		2  	};  } else {  	return new Int32Collection {  		2'  		1'  		1  	};  }  
Magic Number,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: return new Int32Collection {  	0'  	1'  	2  };  
Magic Number,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: return new Int32Collection {  	2'  	1'  	1  };  
Magic Number,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,The following statement contains a magic number: for (int i = 2; i < pointCnt; i++) {  	// The current Point  	var newPoint = events [i];  	var top = pointStack.Peek ();  	// If the new Point is not on the same side as the last Point on the Stack  	//if (!(leftChain.Contains(top) && leftChain.Contains(newPoint) || rightChain.Contains(top) && rightChain.Contains(newPoint)))  	if (!(top.Last == newPoint || top.Next == newPoint)) {  		// Determine this Point's Chain (left or right)  		if (left.Next == newPoint) {  			left = newPoint;  		} else if (right.Last == newPoint) {  			right = newPoint;  		}  		// Third triangle Point  		var p2 = top;  		// While there is a Point on the Stack  		while (pointStack.Count != 0) {  			// Pop and set the third Point  			top = pointStack.Pop ();  			p2 = top;  			if (pointStack.Count != 0) {  				// Pop again  				top = pointStack.Pop ();  				// Add to the result. The Order is depending on the Side  				if (left == newPoint) {  					result.Add (newPoint.Index);  					result.Add (p2.Index);  					result.Add (top.Index);  				} else {  					result.Add (newPoint.Index);  					result.Add (top.Index);  					result.Add (p2.Index);  				}  			}  			// If more Points are on the Stack'  			// Push the Point back again' to be able to form the Triangles  			if (pointStack.Count != 0)  				pointStack.Push (top);  		}  		// Push the last to Points on the Stack  		pointStack.Push (events [i - 1]);  		pointStack.Push (newPoint);  	} // If the newPoint is on the same Side (i.e. Chain)  	else {  		// Get to Point on the Stack  		top = pointStack.Pop ();  		var p2 = top;  		// Determine this Point's Chain (left or right)  		if (left.Next == newPoint && right.Last == newPoint) {  			if (top.Last == newPoint)  				right = newPoint;  			else if (top.Next == newPoint)  				left = newPoint;  			else  				throw new Exception ("Triangulation error");  		} else if (left.Next == newPoint) {  			left = newPoint;  		} else if (right.Last == newPoint) {  			right = newPoint;  		}  		while (pointStack.Count != 0) {  			// If the Triangle is possible' add it to the result (Point Order depends on the Side)  			if (right == newPoint && IsCCW (new List<Point> {  				newPoint.Point'  				p2.Point'  				pointStack.Peek ().Point  			})) {  				top = pointStack.Pop ();  				result.Add (newPoint.Index);  				result.Add (p2.Index);  				result.Add (top.Index);  				p2 = top;  			} else if (left == newPoint && !IsCCW (new List<Point> {  				newPoint.Point'  				p2.Point'  				pointStack.Peek ().Point  			})) {  				top = pointStack.Pop ();  				result.Add (newPoint.Index);  				result.Add (top.Index);  				result.Add (p2.Index);  				p2 = top;  			} // No Triangle possible' just leave the Loop  			else  				break;  		}  		// Push the last two Points on the Stack  		pointStack.Push (p2);  		pointStack.Push (newPoint);  	}  }  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourHelper,The following statement contains a magic number: this.normals = hasNormals ? new Vector3D[3] : null;  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourHelper,The following statement contains a magic number: this.textures = hasTextureCoordinates ? new Point[3] : null;  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,GetContourFacet,The following statement contains a magic number: if (this.IsSideAlone (2)) {  	return this.sides [2] > 0 ? ContourFacetResult.TwoOnly : ContourFacetResult.ZeroAndOne;  }  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,GetContourFacet,The following statement contains a magic number: if (this.IsSideAlone (2)) {  	return this.sides [2] > 0 ? ContourFacetResult.TwoOnly : ContourFacetResult.ZeroAndOne;  }  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,GetContourFacet,The following statement contains a magic number: return this.sides [2] > 0 ? ContourFacetResult.TwoOnly : ContourFacetResult.ZeroAndOne;  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.indices [2] = index2;  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.points [2] = this.meshPositions [index2];  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: if (this.normals != null) {  	this.normals [0] = this.meshNormals [index0];  	this.normals [1] = this.meshNormals [index1];  	this.normals [2] = this.meshNormals [index2];  }  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.normals [2] = this.meshNormals [index2];  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: if (this.textures != null) {  	this.textures [0] = this.meshTextureCoordinates [index0];  	this.textures [1] = this.meshTextureCoordinates [index1];  	this.textures [2] = this.meshTextureCoordinates [index2];  }  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.textures [2] = this.meshTextureCoordinates [index2];  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides [2] = (this.a * this.points [2].X) + (this.b * this.points [2].Y) + (this.c * this.points [2].Z) + this.d;  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides [2] = (this.a * this.points [2].X) + (this.b * this.points [2].Y) + (this.c * this.points [2].Z) + this.d;  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides [2] = (this.a * this.points [2].X) + (this.b * this.points [2].Y) + (this.c * this.points [2].Z) + this.d;  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides [2] = (this.a * this.points [2].X) + (this.b * this.points [2].Y) + (this.c * this.points [2].Z) + this.d;  
Magic Number,HelixToolkit.Wpf,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,AllSidesBelowContour,The following statement contains a magic number: return this.sides [0] >= 0 && this.sides [1] >= 0 && this.sides [2] >= 0;  
Missing Default,HelixToolkit.Wpf,InterlacedView3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\Stereo\InterlacedView3D.xaml.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  case Key.Left:  	this.HorizontalOffset -= 0.001f;  	break;  case Key.Right:  	this.HorizontalOffset += 0.001f;  	break;  }  
Missing Default,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,Rotate,The following switch statement is missing a default case: switch (this.Controller.CameraRotationMode) {  case CameraRotationMode.Trackball:  	this.RotateTrackball (p0' p1' rotateAround);  	break;  case CameraRotationMode.Turntable:  	this.RotateTurntable (p1 - p0' rotateAround);  	break;  case CameraRotationMode.Turnball:  	this.RotateTurnball (p0' p1' rotateAround);  	break;  }  
Missing Default,HelixToolkit.Wpf,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\RotateHandler.cs,Started,The following switch statement is missing a default case: switch (this.Controller.CameraRotationMode) {  case CameraRotationMode.Trackball:  	break;  case CameraRotationMode.Turntable:  	break;  case CameraRotationMode.Turnball:  	this.InitTurnballRotationAxes (e.CurrentPosition);  	break;  }  
Missing Default,HelixToolkit.Wpf,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomHandler.cs,ZoomByChangingCameraPosition,The following switch statement is missing a default case: switch (this.CameraMode) {  case CameraMode.Inspect:  	this.ChangeCameraDistance (delta' zoomAround);  	break;  case CameraMode.WalkAround:  	this.CameraPosition -= this.CameraLookDirection * delta;  	break;  }  
Missing Default,HelixToolkit.Wpf,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomHandler.cs,MoveCameraPosition,The following switch statement is missing a default case: switch (this.CameraMode) {  case CameraMode.Inspect:  case CameraMode.WalkAround:  	this.CameraPosition += (x * delta.X) + (y * delta.Y) + (z * delta.Z);  	break;  }  
Missing Default,HelixToolkit.Wpf,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\ZoomHandler.cs,ZoomByChangingCameraWidth,The following switch statement is missing a default case: switch (this.CameraMode) {  case CameraMode.WalkAround:  case CameraMode.Inspect:  case CameraMode.FixedPosition:  	this.ChangeCameraDistance (delta' zoomAround);  	// Modify the camera width  	var ocamera = this.Camera as OrthographicCamera;  	if (ocamera != null) {  		ocamera.Width *= 1 + delta;  	}  	break;  }  
Missing Default,HelixToolkit.Wpf,ColorAxis,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\ColorAxis\ColorAxis.cs,AddVisuals,The following switch statement is missing a default case: switch (this.Position) {  case ColorAxisPosition.Left:  	this.ColorArea = new Rect (this.Padding.Left' this.Padding.Top' this.BarWidth' this.ActualHeight - this.Padding.Bottom - this.Padding.Top);  	break;  case ColorAxisPosition.Right:  	this.ColorArea = new Rect (this.ActualWidth - this.Padding.Right - this.BarWidth' this.Padding.Top' this.BarWidth' this.ActualHeight - this.Padding.Bottom - this.Padding.Top);  	break;  }  
Missing Default,HelixToolkit.Wpf,HelixViewport3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\HelixViewport3D.cs,OnItemsChanged,The following switch statement is missing a default case: switch (e.Action) {  case NotifyCollectionChangedAction.Add:  	this.AddItems (e.NewItems);  	break;  case NotifyCollectionChangedAction.Move:  	throw new NotImplementedException ("Move operation not implemented.");  case NotifyCollectionChangedAction.Remove:  	this.RemoveItems (e.OldItems);  	break;  case NotifyCollectionChangedAction.Replace:  	throw new NotImplementedException ("Replace operation not implemented.");  case NotifyCollectionChangedAction.Reset:  	this.Children.Clear ();  	break;  }  
Missing Default,HelixToolkit.Wpf,ColorHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\ColorHelper.cs,HsvToColor,The following switch statement is missing a default case: switch (i) {  case 0:  	r = val;  	g = cc;  	b = aa;  	break;  case 1:  	r = bb;  	g = val;  	b = aa;  	break;  case 2:  	r = aa;  	g = val;  	b = cc;  	break;  case 3:  	r = aa;  	g = bb;  	b = val;  	break;  case 4:  	r = cc;  	g = aa;  	b = val;  	break;  case 5:  	r = val;  	g = aa;  	b = bb;  	break;  }  
Missing Default,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  case Key.Left:  	this.AddRotateForce (-1 * f * this.LeftRightRotationSensitivity' 0);  	e.Handled = true;  	break;  case Key.Right:  	this.AddRotateForce (1 * f * this.LeftRightRotationSensitivity' 0);  	e.Handled = true;  	break;  case Key.Up:  	this.AddRotateForce (0' -1 * f * this.UpDownRotationSensitivity);  	e.Handled = true;  	break;  case Key.Down:  	this.AddRotateForce (0' 1 * f * this.UpDownRotationSensitivity);  	e.Handled = true;  	break;  }  
Missing Default,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  case Key.Left:  	this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Right:  	this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Up:  	this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  case Key.Down:  	this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  }  
Missing Default,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  case Key.PageUp:  	this.AddZoomForce (-0.1 * f * this.PageUpDownZoomSensitivity);  	e.Handled = true;  	break;  case Key.PageDown:  	this.AddZoomForce (0.1 * f * this.PageUpDownZoomSensitivity);  	e.Handled = true;  	break;  case Key.Back:  	if (this.RestoreCameraSetting ()) {  		e.Handled = true;  	}  	break;  }  
Missing Default,HelixToolkit.Wpf,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\CameraController\CameraController.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  case Key.W:  	this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  	break;  case Key.A:  	this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.S:  	this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  	break;  case Key.D:  	this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.Z:  	this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  case Key.Q:  	this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  }  
Missing Default,HelixToolkit.Wpf,AnaglyphView3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Controls\Stereo\AnaglyphView3D.xaml.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  case Key.Left:  	this.HorizontalOffset -= 0.001f;  	break;  case Key.Right:  	this.HorizontalOffset += 0.001f;  	break;  }  
Missing Default,HelixToolkit.Wpf,CuttingPlaneGroup,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Composite\CuttingPlaneGroup.cs,ApplyCuttingPlanesToModel,The following switch statement is missing a default case: switch (this.Operation) {  case CuttingOperation.Intersect:  	var intersectedGeometry = originalMeshGeometry;  	// Calculate the intersection of all the intersections  	foreach (var cp in this.CuttingPlanes) {  		intersectedGeometry = this.Intersect (intersectedGeometry' inverseTransform' cp' false);  	}  	newGeometry = intersectedGeometry;  	break;  case CuttingOperation.Subtract:  	var builder = new MeshBuilder (originalMeshGeometry.Normals.Any ()' originalMeshGeometry.TextureCoordinates.Any ());  	// Calculate the union of all complement intersections  	foreach (var cp in this.CuttingPlanes) {  		var cg = this.Intersect (originalMeshGeometry' inverseTransform' cp' true);  		builder.Append (cg);  	}  	newGeometry = builder.ToMesh (true);  	break;  }  
Missing Default,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,Read,The following switch statement is missing a default case: switch (keyword.ToLower ()) {  // Vertex data  case "v":  	// geometric vertices  	this.AddVertex (values);  	break;  case "vt":  	// texture vertices  	this.AddTexCoord (values);  	break;  case "vn":  	// vertex normals  	this.AddNormal (values);  	break;  case "vp":  // parameter space vertices  case "cstype":  // rational or non-rational forms of curve or surface type: basis matrix' Bezier' B-spline' Cardinal' Taylor  case "degree":  // degree  case "bmat":  // basis matrix  case "step":  	// step size  	// not supported  	break;  // Elements  case "f":  	// face  	this.AddFace (values);  	break;  case "p":  // point  case "l":  // line  case "curv":  // curve  case "curv2":  // 2D curve  case "surf":  	// surface  	// not supported  	break;  // Free-form curve/surface body statements  case "parm":  // parameter name  case "trim":  // outer trimming loop (trim)  case "hole":  // inner trimming loop (hole)  case "scrv":  // special curve (scrv)  case "sp":  // special point (sp)  case "end":  	// end statement (end)  	// not supported  	break;  // Connectivity between free-form surfaces  case "con":  	// connect  	// not supported  	break;  // Grouping  case "g":  	// group name  	this.AddGroup (values);  	break;  case "s":  	// smoothing group  	this.SetSmoothingGroup (values);  	break;  case "mg":  	// merging group  	break;  case "o":  	// object name  	// not supported  	break;  // Display/render attributes  case "mtllib":  	// material library  	this.LoadMaterialLib (values);  	break;  case "usemtl":  	// material name  	this.EnsureNewMesh ();  	this.SetMaterial (values);  	break;  case "usemap":  	// texture map name  	this.EnsureNewMesh ();  	break;  case "bevel":  // bevel interpolation  case "c_interp":  // color interpolation  case "d_interp":  // dissolve interpolation  case "lod":  // level of detail  case "shadow_obj":  // shadow casting  case "trace_obj":  // ray tracing  case "ctech":  // curve approximation technique  case "stech":  	// surface approximation technique  	// not supported  	break;  }  
Missing Default,HelixToolkit.Wpf,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\ObjReader.cs,LoadMaterialLib,The following switch statement is missing a default case: switch (keyword.ToLower ()) {  case "newmtl":  	if (value != null) {  		currentMaterial = new MaterialDefinition (value);  		this.Materials.Add (value' currentMaterial);  	}  	break;  case "ka":  	if (currentMaterial != null && value != null) {  		currentMaterial.Ambient = ColorParse (value);  	}  	break;  case "kd":  	if (currentMaterial != null && value != null) {  		currentMaterial.Diffuse = ColorParse (value);  	}  	break;  case "ks":  	if (currentMaterial != null && value != null) {  		currentMaterial.Specular = ColorParse (value);  	}  	break;  case "ns":  	if (currentMaterial != null && value != null) {  		currentMaterial.SpecularCoefficient = DoubleParse (value);  	}  	break;  case "d":  	if (currentMaterial != null && value != null) {  		currentMaterial.Dissolved = DoubleParse (value);  	}  	break;  case "tr":  	if (!this.SkipTransparencyValues && currentMaterial != null && value != null) {  		currentMaterial.Dissolved = DoubleParse (value);  	}  	break;  case "illum":  	if (currentMaterial != null && value != null) {  		currentMaterial.Illumination = int.Parse (value);  	}  	break;  case "map_ka":  	if (currentMaterial != null) {  		currentMaterial.AmbientMap = value;  	}  	break;  case "map_kd":  	if (currentMaterial != null) {  		currentMaterial.DiffuseMap = value;  	}  	break;  case "map_ks":  	if (currentMaterial != null) {  		currentMaterial.SpecularMap = value;  	}  	break;  case "map_d":  	if (currentMaterial != null) {  		currentMaterial.AlphaMap = value;  	}  	break;  case "map_bump":  case "bump":  	if (currentMaterial != null) {  		currentMaterial.BumpMap = value;  	}  	break;  }  
Missing Default,HelixToolkit.Wpf,StLReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Importers\StLReader.cs,TryReadAscii,The following switch statement is missing a default case: switch (id) {  case "solid":  	this.Header = values.Trim ();  	break;  case "facet":  	this.ReadFacet (reader' values);  	break;  case "endsolid":  	break;  }  
Missing Default,HelixToolkit.Wpf,TerrainModel,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Visual3Ds\Terrain\TerrainModel.cs,Load,The following switch statement is missing a default case: switch (ext) {  case ".btz":  	this.ReadZippedFile (source);  	break;  case ".bt":  	this.ReadTerrainFile (source);  	break;  }  
Missing Default,HelixToolkit.Wpf,Viewport3DHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf\Helpers\Viewport3DHelper.cs,FindHits,The following switch statement is missing a default case: switch (mode) {  case SelectionHitMode.Inside:  	status = status && triangle.IsCompletelyInside (rectangle);  	break;  case SelectionHitMode.Touch:  	status = status || triangle.IsCompletelyInside (rectangle) || triangle.IntersectsWith (rectangle) || triangle.IsRectCompletelyInside (rectangle);  	break;  }  
Missing Default,HelixToolkit.Wpf,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,CalculateDiagonals,The following switch statement is missing a default case: switch (evClass) {  case PolygonPointClass.Start:  	// Just add the left Edge (depending on the sweeping direction)  	statusAndHelper.Add (new StatusHelperElement (sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));  	break;  case PolygonPointClass.Stop:  	// Just remove the left Edge (depending on the sweeping direction)  	statusAndHelper.Remove (sweepDown ? ev.EdgeOne : ev.EdgeTwo);  	break;  case PolygonPointClass.Regular:  	// If the Polygon is positioned on the right Side of this Event  	if (ev.Last > ev.Next) {  		// Replace the corresponding (old) StatusHelperElement with the new one  		statusAndHelper.Remove (sweepDown ? ev.EdgeOne : ev.EdgeTwo);  		statusAndHelper.Add (new StatusHelperElement (sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));  	} else {  		// Search Edge left of the Event and set Event as it's Helper  		she = statusAndHelper.SearchLeft (ev);  		she.Helper = ev;  	}  	break;  case PolygonPointClass.Merge:  	// Just remove the left Edge (depending on the sweeping direction)  	statusAndHelper.Remove (sweepDown ? ev.EdgeOne : ev.EdgeTwo);  	// Search Edge left of the Event and set Event as it's Helper  	she = statusAndHelper.SearchLeft (ev);  	she.Helper = ev;  	break;  case PolygonPointClass.Split:  	// Search Edge left of the Event  	she = statusAndHelper.SearchLeft (ev);  	// Chose diagonal from Helper of Edge to Event.  	var minP = Math.Min (she.Helper.Index' ev.Index);  	var maxP = Math.Max (she.Helper.Index' ev.Index);  	var diagonal = new Tuple<int' int> (minP' maxP);  	diagonals.Add (diagonal);  	// Replace the Helper of the StatusHelperElement by Event  	she.Helper = ev;  	// Insert the right Edge from Event  	statusAndHelper.Add (new StatusHelperElement (sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));  	break;  }  
