Implementation smell,Namespace,Class,File,Method,Description
Long Method,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The method has 130 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitGBuffer,The method has 137 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,The method has 101 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnApplyTemplate,The method has 108 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The method has 172 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The method has 132 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,OffReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The method has 113 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,Items3DControl,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\Items3DControl.cs,OnItemsChanged,The method has 110 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,ItemsModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ItemsModel3D.cs,ItemsModel3D_CollectionChanged,The method has 131 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,ObjExporter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMaterial,The method has 100 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,Read,The method has 116 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The method has 167 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,LoadMaterialLib,The method has 116 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The method has 110 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The method has 202 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 109 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The method has 108 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The method has 131 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,The method has 125 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The method has 157 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The method has 211 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The method has 163 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The method has 206 lines of code.
Complex Method,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,Render,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,Render,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,Render,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnApplyTemplate,Cyclomatic complexity of the method is 16
Complex Method,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnCameraChanged,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,BuildSubTree,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTest,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindNearestPointFromPoint,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,Expand,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindNearestPointBySphereExcludeChild,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,PointGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,PointGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindNearestPointBySphereExcludeChild,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,Items3DControl,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\Items3DControl.cs,OnItemsSourceChanged,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,ItemsModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ItemsModel3D.cs,ItemsSourceChanged,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,ShadowMap3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,ObjExporter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMesh,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,Cyclomatic complexity of the method is 25
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddLoftedGeometry,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangles,Cyclomatic complexity of the method is 13
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,Cyclomatic complexity of the method is 14
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,Cyclomatic complexity of the method is 15
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Append,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Simplify,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,Cyclomatic complexity of the method is 13
Complex Method,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,Cyclomatic complexity of the method is 21
Complex Method,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,Cyclomatic complexity of the method is 26
Complex Method,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,BoundingBoxExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BoundingBoxExtensions.cs,Transform,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX.Utilities,TokenizerHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TokenizerHelper.cs,NextToken,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,Cyclomatic complexity of the method is 11
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,GetDXGIFormat,Cyclomatic complexity of the method is 8
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,Cyclomatic complexity of the method is 16
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,Cyclomatic complexity of the method is 15
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,Cyclomatic complexity of the method is 12
Complex Method,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,CalculateImageArray,Cyclomatic complexity of the method is 8
Complex Method,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,OnPropertyChanged,Cyclomatic complexity of the method is 12
Long Parameter List,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,OnWindowMessage,The method has 5 parameters. Parameters: hwnd' msg' wParam' lParam' handled
Long Parameter List,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,OnWindowMessage,The method has 5 parameters. Parameters: hwnd' msg' wParam' lParam' handled
Long Parameter List,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The method has 5 parameters. Parameters: camera' newPosition' newDirection' newUpDirection' animationTime
Long Parameter List,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,LookAt,The method has 5 parameters. Parameters: camera' target' newLookDirection' newUpDirection' animationTime
Long Parameter List,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The method has 5 parameters. Parameters: camera' viewport' center' radius' animationTime
Long Parameter List,HelixToolkit.Wpf.SharpDX,RenderUtil,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\RenderUtil.cs,CreateBuffer,The method has 5 parameters. Parameters: device' flags' sizeofT' range' length
Long Parameter List,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,Copy,The method has 5 parameters. Parameters: view' width' height' background' m
Long Parameter List,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,FindNearest,The method has 5 parameters. Parameters: viewport' position' point' normal' model
Long Parameter List,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The method has 5 parameters. Parameters: view' width' height' background' m
Long Parameter List,HelixToolkit.Wpf.SharpDX,BitmapExtension,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\BitmapExtension.cs,StringToBitmapSource,The method has 5 parameters. Parameters: str' fontSize' foreground' background' fontFamily
Long Parameter List,HelixToolkit.Wpf.SharpDX,BitmapExtension,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\BitmapExtension.cs,StringToBitmapSource,The method has 6 parameters. Parameters: str' fontSize' foreground' background' fontFamily' fontWeight
Long Parameter List,HelixToolkit.Wpf.SharpDX,BitmapExtension,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\BitmapExtension.cs,StringToBitmapSource,The method has 8 parameters. Parameters: str' fontSize' foreground' background' fontFamily' fontWeight' fontStyle' padding
Long Parameter List,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The method has 5 parameters. Parameters: text' origin' w' h' info
Long Parameter List,HelixToolkit.Wpf.SharpDX,BillboardText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardText3D.cs,DrawCharacter,The method has 6 parameters. Parameters: character' origin' w' h' kerning' info
Long Parameter List,HelixToolkit.Wpf.SharpDX,AffectsRenderFrameworkPropertyMetadata,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\AffectsRenderPropertyMetadata.cs,AffectsRenderFrameworkPropertyMetadata,The method has 5 parameters. Parameters: defaultValue' flags' propertyChangedCallback' coerceValueCallback' isAnimationProhibited
Long Parameter List,HelixToolkit.Wpf.SharpDX,AffectsRenderFrameworkPropertyMetadata,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\AffectsRenderPropertyMetadata.cs,AffectsRenderFrameworkPropertyMetadata,The method has 6 parameters. Parameters: defaultValue' flags' propertyChangedCallback' coerceValueCallback' isAnimationProhibited' defaultUpdateSourceTrigger
Long Parameter List,HelixToolkit.Wpf.SharpDX,IOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTest,The method has 5 parameters. Parameters: context' model' modelMatrix' rayWS' hits
Long Parameter List,HelixToolkit.Wpf.SharpDX,IOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 7 parameters. Parameters: context' model' modelMatrix' rayWS' rayModel' hits' isIntersect
Long Parameter List,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,OctreeBase,The method has 5 parameters. Parameters: bound' objList' parent' parameter' queueCache
Long Parameter List,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,TreeTraversal,The method has 5 parameters. Parameters: root' queue' criteria' process' breakCriteria
Long Parameter List,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTest,The method has 5 parameters. Parameters: context' model' modelMatrix' rayWS' hits
Long Parameter List,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 7 parameters. Parameters: context' model' modelMatrix' rayWS' rayModel' hits' isIntersect
Long Parameter List,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,PushExistingToChild,The method has 5 parameters. Parameters: node' index' isContains' createNodeFunc' octant
Long Parameter List,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindSmallestNodeContainsBoundingBox,The method has 5 parameters. Parameters: bound' item' isContains' root' queueCache
Long Parameter List,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindChildByItemBound,The method has 6 parameters. Parameters: item' bound' isContains' root' queueCache' index
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,MeshGeometryOctree,The method has 7 parameters. Parameters: positions' indices' bound' triIndex' parent' paramter' queueCache
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,MeshGeometryOctree,The method has 5 parameters. Parameters: bound' list' parent' paramter' queueCache
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 7 parameters. Parameters: context' model' modelMatrix' rayWS' rayModel' hits' isIntersect
Long Parameter List,HelixToolkit.Wpf.SharpDX,PointGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,PointGeometryOctree,The method has 6 parameters. Parameters: bound' positions' list' parent' paramter' queueCache
Long Parameter List,HelixToolkit.Wpf.SharpDX,PointGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 7 parameters. Parameters: context' model' modelMatrix' rayWS' rayModel' hits' isIntersect
Long Parameter List,HelixToolkit.Wpf.SharpDX,GeometryModel3DOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,GeometryModel3DOctree,The method has 5 parameters. Parameters: bound' objList' parent' paramter' queueCache
Long Parameter List,HelixToolkit.Wpf.SharpDX,GeometryModel3DOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 7 parameters. Parameters: context' model' modelMatrix' rayWS' rayModel' hits' isIntersect
Long Parameter List,HelixToolkit.Wpf.SharpDX,InstancingModel3DOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,InstancingModel3DOctree,The method has 6 parameters. Parameters: bound' instanceMatrix' objects' parent' parameter' queueCache
Long Parameter List,HelixToolkit.Wpf.SharpDX,InstancingModel3DOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 7 parameters. Parameters: context' model' modelMatrix' rayWS' rayModel' hits' isIntersect
Long Parameter List,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,CreateMesh,The method has 7 parameters. Parameters: positions' textureCoordinates' triangleIndices' normals' tangents' bitangents' material
Long Parameter List,HelixToolkit.Wpf.SharpDX,Mouse3DEventArgs,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\GeometryModel3D.cs,Mouse3DEventArgs,The method has 5 parameters. Parameters: routedEvent' source' hitTestResult' position' viewport
Long Parameter List,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddGrid,The method has 5 parameters. Parameters: plane' columns' rows' width' height
Long Parameter List,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateGrid,The method has 5 parameters. Parameters: plane' min0' max0' min1' max1
Long Parameter List,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GetPointToLineDistance2D,The method has 5 parameters. Parameters: pt' p0' p1' closest' t
Long Parameter List,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GetRayToLineDistance,The method has 7 parameters. Parameters: ray' t0' t1' sp' tp' sc' tc
Long Parameter List,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GetLineToLineDistance,The method has 9 parameters. Parameters: s0' s1' t0' t1' sp' tp' sc' tc' sIsRay
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The method has 6 parameters. Parameters: positions' normals' textureCoordinates' triangleIndices' tangents' bitangents
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The method has 6 parameters. Parameters: positions' normals' textureCoordinates' indices' tangents' bitangents
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddArrow,The method has 5 parameters. Parameters: point1' point2' diameter' headLength' thetaDiv
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBox,The method has 5 parameters. Parameters: center' xlength' ylength' zlength' faces
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBox,The method has 7 parameters. Parameters: center' x' y' xlength' ylength' zlength' faces
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCone,The method has 8 parameters. Parameters: origin' direction' baseRadius' topRadius' height' baseCap' topCap' thetaDiv
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCone,The method has 5 parameters. Parameters: origin' apex' baseRadius' baseCap' thetaDiv
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The method has 6 parameters. Parameters: center' normal' up' dist' width' height
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The method has 6 parameters. Parameters: p1' p2' radius' thetaDiv' cap1' cap2
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The method has 6 parameters. Parameters: center' radiusx' radiusy' radiusz' thetaDiv' phiDiv
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The method has 5 parameters. Parameters: center' forward' up' sideLength' height
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The method has 5 parameters. Parameters: point1' point2' innerDiameter' diameter' thetaDiv
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The method has 6 parameters. Parameters: center' forward' up' sideLength' height' closeBase
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The method has 8 parameters. Parameters: p0' p1' p2' p3' uv0' uv1' uv2' uv3
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The method has 8 parameters. Parameters: plane' columns' rows' width' height' flipTriangles' flipTexCoordsUAxis' flipTexCoordsVAxis
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndices,The method has 5 parameters. Parameters: index0' rows' columns' rowsClosed' columnsClosed
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The method has 5 parameters. Parameters: points' textureValues' origin' direction' thetaDiv
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The method has 6 parameters. Parameters: origin' axis' section' sectionIndices' thetaDiv' textureValues
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The method has 6 parameters. Parameters: p0' p1' p2' uv0' uv1' uv2
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 7 parameters. Parameters: path' values' diameters' thetaDiv' isTubeClosed' frontCap' backCap
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 6 parameters. Parameters: path' diameter' thetaDiv' isTubeClosed' frontCap' backCap
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 8 parameters. Parameters: path' values' diameters' section' isTubeClosed' isSectionClosed' frontCap' backCap
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 10 parameters. Parameters: path' angles' values' diameters' section' sectionXAxis' isTubeClosed' isSectionClosed' frontCap' backCap
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,The method has 8 parameters. Parameters: vertices' triangles' texture' normals' verticesOut' trianglesOut' textureOut' normalOut
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The method has 6 parameters. Parameters: p' i0' i1' v0' v1' deleted
Long Parameter List,HelixToolkit.Wpf.SharpDX,SymmetricMatrix,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,SymmetricMatrix,The method has 10 parameters. Parameters: m11' m12' m13' m14' m22' m23' m24' m33' m34' m44
Long Parameter List,HelixToolkit.Wpf.SharpDX,SymmetricMatrix,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,det,The method has 9 parameters. Parameters: a11' a12' a13' a21' a22' a23' a31' a32' a33
Long Parameter List,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourFacet,The method has 7 parameters. Parameters: index0' index1' index2' newPositions' newNormals' newTextureCoordinates' triangleIndices
Long Parameter List,HelixToolkit.Wpf.SharpDX.Utilities,ConstantBufferProxy<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\BufferProxy.cs,ConstantBufferProxy,The method has 5 parameters. Parameters: structSize' bindFlags' cpuAccessFlags' optionFlags' usage
Long Parameter List,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,InsideTriangle,The method has 8 parameters. Parameters: Ax' Ay' Bx' By' Cx' Cy' Px' Py
Long Parameter List,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Snip,The method has 6 parameters. Parameters: contour' u' v' w' n' V
Long Parameter List,SharpDX.Toolkit.Graphics,PixelFormat,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDS.cs,PixelFormat,The method has 7 parameters. Parameters: flags' fourCC' rgbBitCount' rBitMask' gBitMask' bBitMask' aBitMask
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The method has 5 parameters. Parameters: headerPtr' size' flags' description' convFlags
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The method has 5 parameters. Parameters: description' flags' pDestination' maxsize' required
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The method has 8 parameters. Parameters: pDestination' outSize' outFormat' pSource' inSize' inFormat' pal8' flags
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The method has 8 parameters. Parameters: pDDS' offset' size' metadata' cpFlags' convFlags' pal8' handle
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SaveToDDSStream,The method has 5 parameters. Parameters: pixelBuffers' count' metadata' flags' stream
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The method has 6 parameters. Parameters: pDestination' outSize' pSource' inSize' inFormat' flags
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The method has 6 parameters. Parameters: pDestination' outSize' pSource' inSize' format' flags
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The method has 6 parameters. Parameters: pDestination' outSize' pSource' inSize' format' flags
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Image,The method has 6 parameters. Parameters: description' dataPointer' offset' handle' bufferIsDisposable' pitchFlags
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New2D,The method has 5 parameters. Parameters: width' height' mipMapCount' format' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New3D,The method has 5 parameters. Parameters: width' height' depth' mipMapCount' format
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New1D,The method has 5 parameters. Parameters: width' mipMapCount' format' arraySize' dataPointer
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New2D,The method has 6 parameters. Parameters: width' height' mipMapCount' format' arraySize' dataPointer
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New3D,The method has 6 parameters. Parameters: width' height' depth' mipMapCount' format' dataPointer
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The method has 6 parameters. Parameters: description' dataPointer' offset' handle' bufferIsDisposable' pitchFlags
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,CreateDescription,The method has 7 parameters. Parameters: dimension' width' height' depth' mipMapCount' format' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The method has 8 parameters. Parameters: fmt' width' height' rowPitch' slicePitch' widthCount' heightCount' flags
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,SetupImageArray,The method has 5 parameters. Parameters: buffer' pixelSize' imageDesc' pitchFlags' output
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Save,The method has 5 parameters. Parameters: pixelBuffers' count' description' imageStream' fileType
Long Parameter List,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,MipMapDescription,The method has 7 parameters. Parameters: width' height' depth' rowStride' depthStride' widthPacked' heightPacked
Long Parameter List,SharpDX.Toolkit.Graphics,PixelBuffer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs,PixelBuffer,The method has 6 parameters. Parameters: width' height' format' rowStride' bufferStride' dataPointer
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,New,The method has 5 parameters. Parameters: device' width' format' flags' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,New,The method has 6 parameters. Parameters: device' width' mipCount' format' flags' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,NewRenderTargetDescription,The method has 5 parameters. Parameters: width' format' textureFlags' mipCount' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,New,The method has 7 parameters. Parameters: device' width' height' depth' format' flags' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,New,The method has 8 parameters. Parameters: device' width' height' depth' mipCount' format' flags' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,NewRenderTargetDescription,The method has 6 parameters. Parameters: width' height' depth' format' textureFlags' mipCount
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTargetCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTargetCube.cs,New,The method has 5 parameters. Parameters: device' size' mipCount' format' flags
Long Parameter List,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetDataBox,The method has 6 parameters. Parameters: format' width' height' depth' textureData' fixedPointer
Long Parameter List,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetViewSliceBounds,The method has 5 parameters. Parameters: viewType' arrayOrDepthIndex' mipIndex' arrayOrDepthCount' mipCount
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The method has 6 parameters. Parameters: device' width' format' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The method has 7 parameters. Parameters: device' width' mipCount' format' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The method has 6 parameters. Parameters: device' width' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1DBase.cs,NewDescription,The method has 6 parameters. Parameters: width' format' textureFlags' mipCount' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 7 parameters. Parameters: device' width' height' format' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 8 parameters. Parameters: device' width' height' mipCount' format' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 7 parameters. Parameters: device' width' height' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 9 parameters. Parameters: device' width' height' mipCount' format' textureData' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,NewDescription,The method has 7 parameters. Parameters: width' height' format' textureFlags' mipCount' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 7 parameters. Parameters: device' width' height' depth' format' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 8 parameters. Parameters: device' width' height' depth' mipCount' format' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 8 parameters. Parameters: device' width' height' depth' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 9 parameters. Parameters: device' width' height' depth' mipCount' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3DBase.cs,NewDescription,The method has 7 parameters. Parameters: width' height' depth' format' textureFlags' mipCount' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 5 parameters. Parameters: device' size' format' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 6 parameters. Parameters: device' size' mipCount' format' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 6 parameters. Parameters: device' size' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 6 parameters. Parameters: device' size' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,NewTextureCubeDescription,The method has 5 parameters. Parameters: size' format' flags' mipCount' usage
Long Parameter List,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeMultiframe,The method has 5 parameters. Parameters: images' count' flags' guidContainerFormat' stream
Long Parameter List,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,SaveToWICMemory,The method has 5 parameters. Parameters: pixelBuffer' count' flags' fileType' stream
Long Identifier,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,,The length of the parameter ChangeFieldOfViewCursorProperty is 31.
Long Identifier,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,,The length of the parameter IsChangeFieldOfViewEnabledProperty is 34.
Long Identifier,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,,The length of the parameter LeftRightPanSensitivityProperty is 31.
Long Identifier,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,,The length of the parameter LeftRightRotationSensitivityProperty is 36.
Long Identifier,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,,The length of the parameter PageUpDownZoomSensitivityProperty is 33.
Long Identifier,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,,The length of the parameter RotateAroundMouseDownPointProperty is 34.
Long Identifier,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,,The length of the parameter UpDownRotationSensitivityProperty is 33.
Long Identifier,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,,The length of the parameter ZoomAroundMouseDownPointProperty is 32.
Long Identifier,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,,The length of the parameter gBufferDepthStencilResourceView is 31.
Long Identifier,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,,The length of the parameter randNormalMapShaderResourceView is 31.
Long Identifier,HelixToolkit.Wpf.SharpDX,DeferredLightingVariables,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,,The length of the parameter gBufferShaderResourceVariables is 30.
Long Identifier,HelixToolkit.Wpf.SharpDX,DeferredLightingVariables,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,,The length of the parameter gDepthStencilShaderResourceVariables is 36.
Long Identifier,HelixToolkit.Wpf.SharpDX,ScreenSpaceProcessingVariables,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,,The length of the parameter ssBufferShaderResourceVariables is 31.
Long Identifier,HelixToolkit.Wpf.SharpDX,ScreenSpaceProcessingVariables,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,,The length of the parameter randNormalsShaderResourceVariable is 33.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter ChangeFieldOfViewCursorProperty is 31.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter ChangeFieldOfViewGestureProperty is 32.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter CoordinateSystemHeightProperty is 30.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter CoordinateSystemHorizontalPositionProperty is 42.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter CoordinateSystemLabelForegroundProperty is 39.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter CoordinateSystemLabelXProperty is 30.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter CoordinateSystemLabelYProperty is 30.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter CoordinateSystemLabelZProperty is 30.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter CoordinateSystemVerticalPositionProperty is 40.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter IsShadowMappingEnabledProperty is 30.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter IsChangeFieldOfViewEnabledProperty is 34.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter LeftRightPanSensitivityProperty is 31.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter LeftRightRotationSensitivityProperty is 36.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter OrthographicToggleGestureProperty is 33.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter PageUpDownZoomSensitivityProperty is 33.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter RotateAroundMouseDownPointProperty is 34.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter UpDownRotationSensitivityProperty is 33.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter ViewCubeHorizontalPositionProperty is 34.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter IsViewCubeEdgeClicksEnabledProperty is 35.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter ViewCubeVerticalPositionProperty is 32.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter ZoomAroundMouseDownPointProperty is 32.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter FixedRotationPointEnabledProperty is 33.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter EnableMouseButtonHitTestProperty is 32.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter EnableDeferredRenderingProperty is 31.
Long Identifier,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,,The length of the parameter EnableSwapChainRenderingProperty is 32.
Long Identifier,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the parameter billboardInstancingInputLayout is 30.
Long Identifier,HelixToolkit.Wpf.SharpDX,ScreenSpaceMeshGeometry3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\ScreenSpaceMeshGeometry3D.cs,,The length of the parameter RelativeScreenLocationXProperty is 31.
Long Identifier,HelixToolkit.Wpf.SharpDX,ScreenSpaceMeshGeometry3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\ScreenSpaceMeshGeometry3D.cs,,The length of the parameter RelativeScreenLocationYProperty is 31.
Long Identifier,HelixToolkit.Wpf.SharpDX,OutLineMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\OutLineMeshGeometryModel3D.cs,,The length of the parameter DepthStencilStateDescriptionProperty is 36.
Long Identifier,HelixToolkit.Wpf.SharpDX,ParticleStormModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ParticleStormModel3D.cs,,The length of the parameter AnimateSpriteByEnergyBoundProperty is 34.
Long Identifier,HelixToolkit.Wpf.SharpDX,OctreeManagerBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeManager.cs,,The length of the parameter RecordHitPathBoundingBoxesProperty is 34.
Long Identifier,HelixToolkit.Wpf.SharpDX,OffReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The length of the parameter containsHomogeneousCoordinates is 30.
Long Identifier,HelixToolkit.Wpf.SharpDX,OffReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The length of the parameter nextLineContainsVertexDimension is 31.
Long Identifier,HelixToolkit.Wpf.SharpDX,OffReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The length of the parameter nextLineContainsNumberOfVertices is 32.
Long Identifier,HelixToolkit.Wpf.SharpDX,GeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\GeometryModel3D.cs,,The length of the parameter ReuseVertexArrayBufferProperty is 30.
Long Identifier,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,,The length of the parameter AllCurvesShouldHaveTheSameNumberOfPoints is 40.
Long Identifier,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,,The length of the parameter SourceMeshNormalsShouldNotBeNull is 32.
Long Identifier,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,,The length of the parameter SourceMeshTextureCoordinatesShouldNotBeNull is 43.
Long Identifier,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,,The length of the parameter WrongNumberOfTextureCoordinates is 31.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The length of the statement  "            //// System.Diagnostics.Debug.WriteLine("OnManipulationDelta: T={0}' S={1}' R={2}' O={3}"' e.DeltaManipulation.Translation' e.DeltaManipulation.Scale' e.DeltaManipulation.Rotation' e.ManipulationOrigin); " is 203.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The length of the statement  "            //// System.Diagnostics.Debug.WriteLine(n + " Delta:" + e.DeltaManipulation.Translation + " Origin:" + e.ManipulationOrigin + " pos:" + position); " is 146.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitBuffers,The length of the statement  "            this.deferredLightingVariables = new DeferredLightingVariables(renderHost.EffectsManager' renderHost.RenderTechniquesManager); " is 126.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitBuffers,The length of the statement  "            this.screenSpaceVariables = new ScreenSpaceProcessingVariables(renderHost.EffectsManager' renderHost.RenderTechniquesManager); " is 126.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderLighting,The length of the statement  "            var lights = lightsCollection.Where(l => l is Light3D).Concat(lightsCollection.Where(l => l is Light3DCollection).SelectMany(x => (x as Light3DCollection).Items.Select(xx => xx as ILight3D))); " is 192.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderLighting,The length of the statement  "                var spot = new Vector4((float)Math.Cos(light.OuterAngle / 360.0 * Math.PI)' (float)Math.Cos(light.InnerAngle / 360.0 * Math.PI)' (float)light.Falloff' 0); " is 154.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderScreenSpaceAO,The length of the statement  "            this.deferredLightingVariables.vInvViewportSize.Set(new Vector4(1.0f / (float)contxt.Canvas.ActualWidth' 1.0f / (float)contxt.Canvas.ActualHeight' 0.0f' 0.0f)); " is 160.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitGBuffer,The length of the statement  "                    this.gBufferShaderResourceView[i] = new ShaderResourceView(this.device' this.gBuffer[i]' new ShaderResourceViewDescription() " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitGBuffer,The length of the statement  "                this.gBufferDepthStencilResourceView = new ShaderResourceView(device' this.depthStencilBuffer' new ShaderResourceViewDescription() " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitGBuffer,The length of the statement  "                this.gBufferShaderResourceView[i] = new ShaderResourceView(this.device' this.gBuffer[i]' new ShaderResourceViewDescription() " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitGBuffer,The length of the statement  "            this.gBufferDepthStencilResourceView = new ShaderResourceView(device' depthStencilBuffer' new ShaderResourceViewDescription() " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,ClearRenderTargetViews,The length of the statement  "            this.device.ImmediateContext.ClearDepthStencilView(this.depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 152.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,ClearRenderTargetViews,The length of the statement  "            this.device.ImmediateContext.ClearRenderTargetView(this.gBufferRenderTargetView[1]' this.renderHost.ClearColor); //this.renderHost.ClearColor); " is 143.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitSphereBuffer,The length of the statement  "                IndexBuffer = this.device.CreateBuffer(BindFlags.IndexBuffer' sizeof(int)' meshGeometry.Indices.Array' meshGeometry.Indices.Count)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitConeBuffer,The length of the statement  "                IndexBuffer = this.device.CreateBuffer(BindFlags.IndexBuffer' sizeof(int)' meshGeometry.Indices.Array' meshGeometry.Indices.Count)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,BindQuadBuffer,The length of the statement  "            context.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(this.screenQuad.VertexBuffer' Vector4.SizeInBytes' 0)); " is 136.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,BindSphereBuffer,The length of the statement  "            context.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(this.screenSphere.VertexBuffer' Vector4.SizeInBytes' 0)); " is 138.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,BindConeBuffer,The length of the statement  "            context.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(this.screenCone.VertexBuffer' Vector4.SizeInBytes' 0)); " is 136.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitSSBuffer,The length of the statement  "                this.ssBufferShaderResourceView[i] = new ShaderResourceView(this.device' this.ssBuffer[i]' new ShaderResourceViewDescription() " is 126.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitSSBuffer,The length of the statement  "            this.randNormalMapShaderResourceView = TextureLoader.FromFileAsShaderResourceView(device' @"./Textures/random4x4_dot3.png"); " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,OnLoaded,The length of the statement  "                // https://social.msdn.microsoft.com/Forums/vstudio/en-US/9ed3d13d-0b9f-48ac-ae8d-daf0845c9e8f/bug-in-wpf-windowloaded-exception-handling?forum=wpf " is 147.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,SetDefaultColorTargets,The length of the statement  "            device.ImmediateContext.Rasterizer.SetViewport(0' 0' colorBuffer.Description.Width' colorBuffer.Description.Height' 0.0f' 1.0f); " is 128.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,SetDefaultColorTargets,The length of the statement  "            device.ImmediateContext.ClearDepthStencilView(depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 142.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,ClearRenderTarget,The length of the statement  "                device.ImmediateContext.ClearDepthStencilView(depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 142.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,Render,The length of the statement  "                        RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager?.RenderTechniques[DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique; " is 173.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,UpdateAndRender,The length of the statement  "            if (((pendingValidationCycles && !skipper.IsSkip()) || skipper.DelayTrigger()) && surfaceD3D != null && renderRenderable != null) " is 129.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,RestartRendering,The length of the statement  "                    IsDeferredLighting = (renderTechnique == RenderTechniquesManager.RenderTechniques.Get(DeferredRenderTechniqueNames.Deferred) " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,OnLoaded,The length of the statement  "                // https://social.msdn.microsoft.com/Forums/vstudio/en-US/9ed3d13d-0b9f-48ac-ae8d-daf0845c9e8f/bug-in-wpf-windowloaded-exception-handling?forum=wpf " is 147.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,SetDefaultColorTargets,The length of the statement  "            device.ImmediateContext.Rasterizer.SetViewport(0' 0' colorBuffer.Description.Width' colorBuffer.Description.Height' 0.0f' 1.0f); " is 128.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,ClearRenderTarget,The length of the statement  "              //  device.ImmediateContext.ClearDepthStencilView(depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 146.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,ClearRenderTarget,The length of the statement  "                renderContext?.DeviceContext.ClearDepthStencilView(depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 147.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,The length of the statement  "                        RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager?.RenderTechniques[DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique; " is 173.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,RestartRendering,The length of the statement  "                    IsDeferredLighting = (renderTechnique == RenderTechniquesManager.RenderTechniques.Get(DeferredRenderTechniqueNames.Deferred) " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,OnLoaded,The length of the statement  "                // https://social.msdn.microsoft.com/Forums/vstudio/en-US/9ed3d13d-0b9f-48ac-ae8d-daf0845c9e8f/bug-in-wpf-windowloaded-exception-handling?forum=wpf " is 147.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,CreateSwapChain,The length of the statement  "                swapChain.ResizeBuffers(swapChain.Description1.BufferCount' (int)ActualWidth' (int)ActualHeight' swapChain.Description.ModeDescription.Format' swapChain.Description.Flags); " is 172.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,SetDefaultColorTargets,The length of the statement  "            device.ImmediateContext.ClearDepthStencilView(depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 142.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,ClearRenderTarget,The length of the statement  "                device.ImmediateContext.ClearDepthStencilView(depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 142.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,Render,The length of the statement  "                        RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager?.RenderTechniques[DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique; " is 173.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,RestartRendering,The length of the statement  "                    IsDeferredLighting = (renderTechnique == RenderTechniquesManager.RenderTechniques.Get(DeferredRenderTechniqueNames.Deferred) " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,OnLoaded,The length of the statement  "                // https://social.msdn.microsoft.com/Forums/vstudio/en-US/9ed3d13d-0b9f-48ac-ae8d-daf0845c9e8f/bug-in-wpf-windowloaded-exception-handling?forum=wpf " is 147.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,CreateSwapChain,The length of the statement  "                swapChain.ResizeBuffers(swapChain.Description1.BufferCount' (int)ActualWidth' (int)ActualHeight' swapChain.Description.ModeDescription.Format' swapChain.Description.Flags); " is 172.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,SetDefaultColorTargets,The length of the statement  "            device.ImmediateContext.ClearDepthStencilView(depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 142.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,ClearRenderTarget,The length of the statement  "                //  device.ImmediateContext.ClearDepthStencilView(depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 146.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,ClearRenderTarget,The length of the statement  "                deferredContext.ClearDepthStencilView(depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 134.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,Render,The length of the statement  "                        RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager?.RenderTechniques[DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique; " is 173.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,UpdateAndRender,The length of the statement  "            if (((pendingValidationCycles && !skipper.IsSkip()) || skipper.DelayTrigger()) && !renderThread.IsBusy && renderRenderable != null) " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,RestartRendering,The length of the statement  "                    IsDeferredLighting = (renderTechnique == RenderTechniquesManager.RenderTechniques.Get(DeferredRenderTechniqueNames.Deferred) " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,DX11ImageSource,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DX11ImageSource.cs,SetRenderTargetDX11,The length of the statement  "                this.renderTarget = new Texture(DX11ImageSource.device' target.Description.Width' target.Description.Height' 1' Usage.RenderTarget' format' Pool.Default' ref handle);             " is 166.
Long Statement,HelixToolkit.Wpf.SharpDX,DX11ImageSource,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DX11ImageSource.cs,StartD3D,The length of the statement  "            device = new DeviceEx(context' this.adapterIndex' DeviceType.Hardware' IntPtr.Zero' CreateFlags.HardwareVertexProcessing | CreateFlags.Multithreaded | CreateFlags.FpuPreserve' presentparams); " is 191.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,GetBestAdapter,The length of the statement  "                    if ((bestAdapter == null) || (videoMemory > bestVideoMemory) || ((videoMemory == bestVideoMemory) && (systemMemory > bestSystemMemory))) " is 136.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[] " is 162.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[] " is 189.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[] " is 185.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[] " is 164.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[] " is 166.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[] " is 167.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[] " is 175.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                    new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "                //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm) " is 128.
Long Statement,HelixToolkit.Wpf.SharpDX,IncludeHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,Open,The length of the statement  "                var codeString = Properties.Resources.ResourceManager.GetString(Path.GetFileNameWithoutExtension(fileName)' System.Globalization.CultureInfo.InvariantCulture); " is 159.
Long Statement,HelixToolkit.Wpf.SharpDX,TessellationEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterTessellationLayoutsAndEffects,The length of the statement  "            var tessellationInputLayout = new InputLayout(device' GetEffect(tesselation).GetTechniqueByName(TessellationRenderTechniqueNames.PNTriangles).GetPassByIndex(0).Description.Signature' new[] " is 188.
Long Statement,HelixToolkit.Wpf.SharpDX,FpsCounter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\FpsCounter.cs,TrimFrames,The length of the statement  "                && (target > m_frames.First || m_frames.First > m_frames.Last || m_frames.IsFull())) //the second condition happened when switching tabs' the TotalMilliseconds reset to 0 from composite rendering " is 195.
Long Statement,HelixToolkit.Wpf.SharpDX,MouseGestureHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\MouseGestureHandler.cs,SetMouseDownPoint,The length of the statement  "            if (!this.Viewport.FixedRotationPointEnabled && this.Viewport.FindNearest(this.MouseDownPoint' out nearestPoint' out normal' out visual)) " is 137.
Long Statement,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ChangeCameraDistance,The length of the statement  "            if (newDistance > this.Viewport.ZoomDistanceLimitFar && (oldDistance < this.Viewport.ZoomDistanceLimitFar || newDistance > oldDistance)) " is 136.
Long Statement,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ChangeCameraDistance,The length of the statement  "            if (newDistance < this.Viewport.ZoomDistanceLimitNear && (oldDistance > this.Viewport.ZoomDistanceLimitNear || newDistance < oldDistance)) " is 138.
Long Statement,HelixToolkit.Wpf.SharpDX,BitmapExtension,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\BitmapExtension.cs,ToBitmapSource,The length of the statement  "            var target = new RenderTargetBitmap((int)(element.RenderSize.Width)' (int)(element.RenderSize.Height)' 96' 96' System.Windows.Media.PixelFormats.Pbgra32); " is 154.
Long Statement,HelixToolkit.Wpf.SharpDX,BitmapExtension,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\BitmapExtension.cs,MeasureString,The length of the statement  "            return new Size(formattedText.Width + textBlock.Padding.Left + textBlock.Padding.Right' formattedText.Height + textBlock.Padding.Top + textBlock.Padding.Bottom); " is 161.
Long Statement,HelixToolkit.Wpf.SharpDX,CrossSectionMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CrossSectionMeshGeometryModel3D.cs,OnDrawCall,The length of the statement  "            renderContext.DeviceContext.ClearDepthStencilView(RenderHost.DepthStencilBufferView' DepthStencilClearFlags.Stencil' 0' 0); " is 123.
Long Statement,HelixToolkit.Wpf.SharpDX,CrossSectionMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CrossSectionMeshGeometryModel3D.cs,OnDrawCall,The length of the statement  "            renderContext.DeviceContext.OutputMerger.SetRenderTargets(RenderHost.DepthStencilBufferView' new RenderTargetView[0]);//Remove render target " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,CrossSectionMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CrossSectionMeshGeometryModel3D.cs,OnDrawCall,The length of the statement  "            renderContext.DeviceContext.OutputMerger.SetDepthStencilState(fillStencilState' 1); //Draw backface onto stencil buffer' set value to 1 " is 135.
Long Statement,HelixToolkit.Wpf.SharpDX,CrossSectionMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CrossSectionMeshGeometryModel3D.cs,OnDrawCall,The length of the statement  "            renderContext.DeviceContext.OutputMerger.SetRenderTargets(RenderHost.DepthStencilBufferView' RenderHost.ColorBufferView);//Rebind render target " is 143.
Long Statement,HelixToolkit.Wpf.SharpDX,CrossSectionMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CrossSectionMeshGeometryModel3D.cs,OnDrawCall,The length of the statement  "            renderContext.DeviceContext.OutputMerger.SetDepthStencilState(fillCrossSectionState' 1); //Only pass stencil buffer test if value is 1 " is 134.
Long Statement,HelixToolkit.Wpf.SharpDX,InstanceGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\InstanceGeometryModel3D.cs,UpdateInstancesBounds,The length of the statement  "                var bound = this.BoundsWithTransform.Transform(instanceInternal[0]);// BoundingBox.FromPoints(this.BoundsWithTransform.GetCorners().Select(x => Vector3.TransformCoordinate(x' instanceInternal[0])).ToArray()); " is 208.
Long Statement,HelixToolkit.Wpf.SharpDX,InstanceGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\InstanceGeometryModel3D.cs,UpdateInstancesBounds,The length of the statement  "                    var b = this.BoundsWithTransform.Transform(instance);// BoundingBox.FromPoints(this.BoundsWithTransform.GetCorners().Select(x => Vector3.TransformCoordinate(x' instance)).ToArray()); " is 182.
Long Statement,HelixToolkit.Wpf.SharpDX,InstanceGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\InstanceGeometryModel3D.cs,CanHitTest,The length of the statement  "            return base.CanHitTest(context) && geometryInternal != null && geometryInternal.Positions != null && geometryInternal.Positions.Count > 0; " is 138.
Long Statement,HelixToolkit.Wpf.SharpDX,InstanceGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\InstanceGeometryModel3D.cs,CheckBoundingFrustum,The length of the statement  "            return !hasInstances && base.CheckBoundingFrustum(ref boundingFrustum) || boundingFrustum.Intersects(ref instancesBound); " is 121.
Long Statement,HelixToolkit.Wpf.SharpDX,ScreenSpaceMeshGeometry3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\ScreenSpaceMeshGeometry3D.cs,CreateDepthStencilState,The length of the statement  "            return new DepthStencilState(device' new DepthStencilStateDescription() { IsDepthEnabled = true' IsStencilEnabled = false' DepthWriteMask = DepthWriteMask.All' DepthComparison = Comparison.LessEqual }); " is 202.
Long Statement,HelixToolkit.Wpf.SharpDX,ScreenSpaceMeshGeometry3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\ScreenSpaceMeshGeometry3D.cs,OnRender,The length of the statement  "            renderContext.DeviceContext.ClearDepthStencilView(renderContext.Canvas.DepthStencilBufferView' DepthStencilClearFlags.Depth' 1f' 0); " is 132.
Long Statement,HelixToolkit.Wpf.SharpDX,ScreenSpaceMeshGeometry3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\ScreenSpaceMeshGeometry3D.cs,OnRender,The length of the statement  "            renderContext.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0)); " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRender,The length of the statement  "            renderContext.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(VertexBuffer.Buffer' VertexBuffer.StructureSize' 0)); " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,CreateBillboardVertexArray,The length of the statement  "            var array = ReuseVertexArrayBuffer && vertexArrayBuffer != null && vertexArrayBuffer.Length >= vertexCount ? vertexArrayBuffer : new BillboardVertex[vertexCount]; " is 162.
Long Statement,HelixToolkit.Wpf.SharpDX,BoneSkinMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BoneSkinMeshGeometryModel3D.cs,OnRender,The length of the statement  "            renderContext.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0)); " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,BoneSkinMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BoneSkinMeshGeometryModel3D.cs,OnRender,The length of the statement  "                renderContext.DeviceContext.InputAssembler.SetVertexBuffers(1' new VertexBufferBinding(this.vertexBoneParamsBuffer.Buffer' this.vertexBoneParamsBuffer.StructureSize' 0)); " is 170.
Long Statement,HelixToolkit.Wpf.SharpDX,BoneSkinMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BoneSkinMeshGeometryModel3D.cs,OnRender,The length of the statement  "                renderContext.DeviceContext.InputAssembler.SetVertexBuffers(2' new VertexBufferBinding(this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0)); " is 154.
Long Statement,HelixToolkit.Wpf.SharpDX,BoneSkinMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BoneSkinMeshGeometryModel3D.cs,OnRender,The length of the statement  "                renderContext.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0)); " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,UpdateAxisColor,The length of the statement  "                    { TextInfo = new TextInfo("X"' new Vector3(14' 0' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color }; " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,UpdateAxisColor,The length of the statement  "                    { TextInfo = new TextInfo("Y"' new Vector3(0' 14' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color }; " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,UpdateAxisColor,The length of the statement  "                    { TextInfo = new TextInfo("Z"' new Vector3(0' 0' 14))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color }; " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,UpdateAxisColor,The length of the statement  "            var colors = new Core.Color4Collection(mesh.Colors == null ? Enumerable.Repeat<Color4>(Color.Black' mesh.Positions.Count) : mesh.Colors); " is 137.
Long Statement,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,OnRender,The length of the statement  "            renderContext.DeviceContext.ClearDepthStencilView(renderContext.Canvas.DepthStencilBufferView' DepthStencilClearFlags.Depth' 1f' 0); " is 132.
Long Statement,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,OnRender,The length of the statement  "            renderContext.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0)); " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The length of the statement  "            renderContext.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(VertexBuffer.Buffer' VertexBuffer.StructureSize' 0)); " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The length of the statement  "                renderContext.DeviceContext.InputAssembler.SetVertexBuffers(1' new VertexBufferBinding(this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0)); " is 154.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The length of the statement  "                    renderContext.DeviceContext.InputAssembler.SetVertexBuffers(2' new VertexBufferBinding(this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0)); " is 164.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,CreateBillboardVertexArray,The length of the statement  "            var array = ReuseVertexArrayBuffer && vertexArrayBuffer != null && vertexArrayBuffer.Length >= vertexCount ? vertexArrayBuffer : new BillboardVertex[vertexCount]; " is 162.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingMeshGeometryModel3D.cs,OnRender,The length of the statement  "            renderContext.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0)); " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingMeshGeometryModel3D.cs,OnRender,The length of the statement  "                renderContext.DeviceContext.InputAssembler.SetVertexBuffers(1' new VertexBufferBinding(this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0)); " is 154.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingMeshGeometryModel3D.cs,OnRender,The length of the statement  "                    renderContext.DeviceContext.InputAssembler.SetVertexBuffers(2' new VertexBufferBinding(this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0)); " is 164.
Long Statement,HelixToolkit.Wpf.SharpDX,OutLineMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\OutLineMeshGeometryModel3D.cs,OnOutLineInstancedDrawCall,The length of the statement  "                renderContext.DeviceContext.DrawIndexedInstanced(this.geometryInternal.Indices.Count' this.instanceInternal.Count' 0' 0' 0); " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,ParticleStormModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ParticleStormModel3D.cs,OnRender,The length of the statement  "                context.DeviceContext.CopyStructureCount(frameConstBuffer.Buffer' ParticlePerFrame.NumParticlesOffset' BufferProxies[0].UAV); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,ParticleParameters,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ParticleStormModel3D.cs,UpdateInsertThrottle,The length of the statement  "                insertThrottle = (8.0f * insertVariables.InitialEnergy / insertVariables.EnergyDissipationRate / System.Math.Max(0' (particleCountInternal + 8))); " is 146.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,OnAttach,The length of the statement  "            //    this.instanceBuffer = Buffer.Create(this.device' this.instanceArray' new BufferDescription(Matrix.SizeInBytes * this.instanceArray.Length' ResourceUsage.Dynamic' BindFlags.VertexBuffer' CpuAccessFlags.Write' ResourceOptionFlags.None' 0));                             " is 244.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,OnRender,The length of the statement  "            if (renderTechnique == renderHost.RenderTechniquesManager.RenderTechniques[TessellationRenderTechniqueNames.PNTriangles]) " is 121.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,OnRender,The length of the statement  "            else if (renderTechnique == renderHost.RenderTechniquesManager.RenderTechniques[TessellationRenderTechniqueNames.PNQuads]) " is 122.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,OnRender,The length of the statement  "            renderContext.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(VertexBuffer.Buffer' VertexBuffer.StructureSize' 0)); " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "            var colors = geometry.Colors != null ? geometry.Colors.GetEnumerator() : Enumerable.Repeat(Color4.White' vertexCount).GetEnumerator(); " is 134.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "            var textureCoordinates = geometry.TextureCoordinates != null ? geometry.TextureCoordinates.GetEnumerator() : Enumerable.Repeat(Vector2.Zero' vertexCount).GetEnumerator(); " is 170.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "            var normals = geometry.Normals != null ? geometry.Normals.GetEnumerator() : Enumerable.Repeat(Vector3.Zero' vertexCount).GetEnumerator(); " is 137.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "            var tangents = geometry.Tangents != null ? geometry.Tangents.GetEnumerator() : Enumerable.Repeat(Vector3.Zero' vertexCount).GetEnumerator(); " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "            var bitangents = geometry.BiTangents != null ? geometry.BiTangents.GetEnumerator() : Enumerable.Repeat(Vector3.Zero' vertexCount).GetEnumerator(); " is 146.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "            var array = ReuseVertexArrayBuffer && vertexArrayBuffer != null && vertexArrayBuffer.Length >= vertexCount ? vertexArrayBuffer : new DefaultVertex[vertexCount];" is 160.
Long Statement,HelixToolkit.Wpf.SharpDX,PointGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PointGeometryModel3D.cs,CheckGeometry,The length of the statement  "            return geometryInternal is PointGeometry3D && this.geometryInternal != null && this.geometryInternal.Positions != null && this.geometryInternal.Positions.Count > 0; " is 164.
Long Statement,HelixToolkit.Wpf.SharpDX,PointGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PointGeometryModel3D.cs,CreateVertexArray,The length of the statement  "            var array = ReuseVertexArrayBuffer && vertexArrayBuffer != null && vertexArrayBuffer.Length >= vertexCount ? vertexArrayBuffer : new PointsVertex[vertexCount];" is 159.
Long Statement,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,CreateDepthStencilState,The length of the statement  "            return new DepthStencilState(device' new DepthStencilStateDescription() { IsDepthEnabled = false' IsStencilEnabled = false }); " is 126.
Long Statement,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,CreateTextureCoordinates,The length of the statement  "                mesh.TextureCoordinates[i] = new Vector2(mesh.TextureCoordinates[i].X * inc + inc * (int)(i/segment)' mesh.TextureCoordinates[i].Y); " is 132.
Long Statement,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTest,The length of the statement  "            var rayModel = new Ray(Vector3.TransformCoordinate(rayWS.Position' modelInv)' Vector3.TransformNormal(rayWS.Direction' modelInv)); " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTest,The length of the statement  "                bool nodeHit = node.HitTestCurrentNodeExcludeChild(context' model' modelMatrix' ref rayWS' ref rayModel' ref modelHits' ref isIntersect); " is 137.
Long Statement,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,Expand,The length of the statement  "            var newCenter = center + new Vector3(xDirection * Math.Abs(half.X)' yDirection * Math.Abs(half.Y)' zDirection * Math.Abs(half.Z)); " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,GeometryModel3DOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The length of the statement  "            var bound = Bound.Transform(modelMatrix);// BoundingBox.FromPoints(Bound.GetCorners().Select(x => Vector3.TransformCoordinate(x' modelMatrix)).ToArray()); " is 154.
Long Statement,HelixToolkit.Wpf.SharpDX,GeometryModel3DOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,Expand,The length of the statement  "            (newRoot as GeometryModel3DOctree).TransferOctantDictionary(root' ref root.OctantDictionary);//Transfer the dictionary to new root " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,GeometryModel3DOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,Shrink,The length of the statement  "            (newRoot as GeometryModel3DOctree).TransferOctantDictionary(root' ref root.OctantDictionary);//Transfer the dictionary to new root " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingModel3DOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The length of the statement  "            var bound = Bound.Transform(modelMatrix);// BoundingBox.FromPoints(Bound.GetCorners().Select(x => Vector3.TransformCoordinate(x' modelMatrix)).ToArray()); " is 154.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingModel3DOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The length of the statement  "                    var b = t.Item2.Transform(modelMatrix);// BoundingBox.FromPoints(t.Item2.GetCorners().Select(x => Vector3.TransformCoordinate(x' modelMatrix)).ToArray()); " is 154.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingModel3DOctreeManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeManager.cs,RebuildTree,The length of the statement  "            var octree = new InstancingModel3DOctree(instMatrix' model3D.BoundsWithTransform' this.Parameter' new Queue<IOctree>(256)); " is 123.
Long Statement,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The length of the statement  "                CreateMesh(positions' textureCoordinates' triangleIndices' out normals' out tangents' out bitangents' PhongMaterials.Gray); " is 123.
Long Statement,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,BitMapSoureFromFallBack,The length of the statement  "            //List<MediaColor> colors = new List<System.Windows.Media.Color>() { MediaColor.FromArgb(fallBackColor.A' fallBackColor.R' fallBackColor.G' fallBackColor.B) }; " is 159.
Long Statement,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,BitMapSoureFromFallBack,The length of the statement  "            BitmapSource bitmap = BitmapSource.Create(10' 10' 96' 96' System.Windows.Media.PixelFormats.Indexed1' palette' pixels' stride); " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,EnvironmentMap3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\EnvironmentMapModel3D.cs,OnAttach,The length of the statement  "                this.vertexBuffer = Device.CreateBuffer(BindFlags.VertexBuffer' CubeVertex.SizeInBytes' this.geometry.Positions.Select((x' ii) => new CubeVertex() { Position = new Vector4(x' 1f) }).ToArray()); " is 193.
Long Statement,HelixToolkit.Wpf.SharpDX,EnvironmentMap3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\EnvironmentMapModel3D.cs,OnAttach,The length of the statement  "                this.indexBuffer = Device.CreateBuffer(BindFlags.IndexBuffer' sizeof(int)' geometry.Indices.Array' geometry.Indices.Count); " is 123.
Long Statement,HelixToolkit.Wpf.SharpDX,EnvironmentMap3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\EnvironmentMapModel3D.cs,OnRender,The length of the statement  "            renderContext.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(this.vertexBuffer' CubeVertex.SizeInBytes' 0)); " is 134.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnRender,The length of the statement  "                renderContext.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0)); " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnInstancedDrawCall,The length of the statement  "            renderContext.DeviceContext.DrawIndexedInstanced(this.geometryInternal.Indices.Count' this.instanceInternal.Count' 0' 0' 0); " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The length of the statement  "                    var rayModel = new Ray(Vector3.TransformCoordinate(rayWS.Position' modelInvert)' Vector3.TransformNormal(rayWS.Direction' modelInvert)); " is 136.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "            var colors = geometry.Colors != null ? geometry.Colors.GetEnumerator() : Enumerable.Repeat(Color4.White' vertexCount).GetEnumerator(); " is 134.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "            var textureCoordinates = geometry.TextureCoordinates != null ? geometry.TextureCoordinates.GetEnumerator() : Enumerable.Repeat(Vector2.Zero' vertexCount).GetEnumerator(); " is 170.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "            var normals = geometry.Normals != null ? geometry.Normals.GetEnumerator() : Enumerable.Repeat(Vector3.Zero' vertexCount).GetEnumerator(); " is 137.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "            var tangents = geometry.Tangents != null ? geometry.Tangents.GetEnumerator() : Enumerable.Repeat(Vector3.Zero' vertexCount).GetEnumerator(); " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "            var bitangents = geometry.BiTangents != null ? geometry.BiTangents.GetEnumerator() : Enumerable.Repeat(Vector3.Zero' vertexCount).GetEnumerator(); " is 146.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "            var array = ReuseVertexArrayBuffer && vertexArrayBuffer != null && vertexArrayBuffer.Length >= vertexCount ? vertexArrayBuffer : new DefaultVertex[vertexCount];" is 160.
Long Statement,HelixToolkit.Wpf.SharpDX,UIManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UIManipulator3D.cs,OnOffetChanged,The length of the statement  "            //this.Position = new Point3D(this.Position.X + this.Offset.X' this.Position.Y + this.Offset.Y' this.Position.Z + this.Offset.Z); " is 129.
Long Statement,HelixToolkit.Wpf.SharpDX,UIRotateManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UIRotateManipulator3D.cs,UpdateManipulator,The length of the statement  "                var rotateTransform = new System.Windows.Media.Media3D.RotateTransform3D(new System.Windows.Media.Media3D.AxisAngleRotation3D(this.Axis.ToVector3D()' theta)' Pivot.ToPoint3D()); " is 177.
Long Statement,HelixToolkit.Wpf.SharpDX,Element3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\Element3D.cs,Attach,The length of the statement  "                throw new ArgumentException("EffectManger does not exist. Please make sure the proper EffectManager has been bind from view model."); " is 133.
Long Statement,HelixToolkit.Wpf.SharpDX,Element3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\Element3D.cs,CheckAffectsRender,The length of the statement  "            // => Need to change all relevant DP's metadata to FrameworkPropertyMetadata or to a new "AffectsRenderPropertyMetadata". " is 121.
Long Statement,HelixToolkit.Wpf.SharpDX,GeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\GeometryModel3D.cs,GeometryChanged,The length of the statement  "            if (model.geometryInternal != null && model.geometryInternal.Bound.Maximum == Vector3.Zero && model.geometryInternal.Bound.Minimum == Vector3.Zero) " is 147.
Long Statement,HelixToolkit.Wpf.SharpDX,GeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\GeometryModel3D.cs,CheckGeometry,The length of the statement  "            return !(this.geometryInternal == null || this.geometryInternal.Positions == null || this.geometryInternal.Positions.Count == 0 " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,LineGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\LineGeometryModel3D.cs,OnGeometryPropertyChanged,The length of the statement  "                if (e.PropertyName.Equals(nameof(LineGeometry3D.Positions)) || e.PropertyName.Equals(nameof(LineGeometry3D.Colors)) || e.PropertyName.Equals(Geometry3D.VertexBuffer)) " is 166.
Long Statement,HelixToolkit.Wpf.SharpDX,LineGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\LineGeometryModel3D.cs,OnAttach,The length of the statement  "            //    var texDiffuseMapView = ShaderResourceView.FromFile(device' @"G:\Projects\Deformation Project\FrameworkWPF2012\Externals\HelixToolkit-SharpDX\Source\Examples\SharpDX.Wpf\LightingDemo\TextureCheckerboard2.jpg"); " is 216.
Long Statement,HelixToolkit.Wpf.SharpDX,LineGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\LineGeometryModel3D.cs,OnRender,The length of the statement  "                    renderContext.DeviceContext.DrawIndexedInstanced(this.geometryInternal.Indices.Count' this.instanceInternal.Count' 0' 0' 0); " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,LineGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\LineGeometryModel3D.cs,OnRender,The length of the statement  "                renderContext.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0)); " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,LineGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\LineGeometryModel3D.cs,CreateLinesVertexArray,The length of the statement  "            var array = ReuseVertexArrayBuffer && vertexArrayBuffer != null && vertexArrayBuffer.Length >= vertexCount ? vertexArrayBuffer : new LinesVertex[vertexCount];" is 158.
Long Statement,HelixToolkit.Wpf.SharpDX,PointLight3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\PointLight3D.cs,OnRender,The length of the statement  "            Light3DSceneShared.LightAtt[lightIndex] = new Vector4((float)this.AttenuationInternal.X' (float)this.AttenuationInternal.Y' (float)this.AttenuationInternal.Z' (float)this.RangeInternal); " is 186.
Long Statement,HelixToolkit.Wpf.SharpDX,ShadowMap3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The length of the statement  "            this.Device.ImmediateContext.ClearDepthStencilView(depthViewSM' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 136.
Long Statement,HelixToolkit.Wpf.SharpDX,ShadowMap3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The length of the statement  "                        light.LightProjectionMatrix = CameraExtensions.GetProjectionMatrix(lightCamera' context.Canvas.ActualWidth / context.Canvas.ActualHeight); " is 138.
Long Statement,HelixToolkit.Wpf.SharpDX,SpotLight3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\SpotLight3D.cs,CanRender,The length of the statement  "                //if (renderHost.RenderTechnique == renderHost.RenderTechniquesManager.RenderTechniques.Get(DeferredRenderTechniqueNames.Deferred) || " is 133.
Long Statement,HelixToolkit.Wpf.SharpDX,SpotLight3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\SpotLight3D.cs,CanRender,The length of the statement  "                //    renderHost.RenderTechnique == renderHost.RenderTechniquesManager.RenderTechniques.Get(DeferredRenderTechniqueNames.GBuffer)) " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,SpotLight3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\SpotLight3D.cs,OnRender,The length of the statement  "            Light3DSceneShared.LightSpots[lightIndex] = new Vector4((float)Math.Cos(this.OuterAngleInternal / 360.0 * Math.PI)' (float)Math.Cos(this.InnerAngleInternal / 360.0 * Math.PI)' (float)this.FalloffInternal' 0); " is 208.
Long Statement,HelixToolkit.Wpf.SharpDX,SpotLight3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\SpotLight3D.cs,OnRender,The length of the statement  "            Light3DSceneShared.LightAtt[lightIndex] = new Vector4((float)this.AttenuationInternal.X' (float)this.AttenuationInternal.Y' (float)this.AttenuationInternal.Z' (float)this.RangeInternal); " is 186.
Long Statement,HelixToolkit.Wpf.SharpDX,ObjExporter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMaterial,The length of the statement  "                // "exponent" is the value for the specular exponent.  A high exponent results in a tight' concentrated highlight.  Ns values normally range from 0 to 1000. " is 156.
Long Statement,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,Read,The length of the statement  "                            case "cstype": // rational or non-rational forms of curve or surface type: basis matrix' Bezier' B-spline' Cardinal' Taylor " is 123.
Long Statement,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,Read,The length of the statement  "                        System.Windows.MessageBox.Show(string.Format("Error loading object: {0}"' ex.Message)' "Error"' MessageBoxButton.OKCancel); " is 123.
Long Statement,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,ColorParse,The length of the statement  "            return System.Windows.Media.Color.FromRgb((byte)(fields[0] * 255)' (byte)(fields[1] * 255)' (byte)(fields[2] * 255)).ToColor4(); " is 128.
Long Statement,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The length of the statement  "                    throw new FileFormatException(string.Format("Invalid texture coordinate index ({0}) on line {1}."' vti' this.currentLineNo)); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The length of the statement  "                System.Windows.MessageBox.Show(string.Format("Error composing polygonal object: {0}"' ex.Message)' "Error"' MessageBoxButton.OKCancel); " is 135.
Long Statement,HelixToolkit.Wpf.SharpDX,MaterialDefinition,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,CreateMaterial,The length of the statement  "                    DiffuseMap = (this.DiffuseMap == null) ? null : new FileStream(Path.GetFullPath(Path.Combine(texturePath' "./" + this.DiffuseMap))' FileMode.Open)' " is 147.
Long Statement,HelixToolkit.Wpf.SharpDX,MaterialDefinition,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,CreateMaterial,The length of the statement  "                    NormalMap = (this.BumpMap == null) ? null : new FileStream(Path.GetFullPath(Path.Combine(texturePath' "./" + this.BumpMap))' FileMode.Open)' " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormals,The length of the statement  "            //Cannot use normals[i].normalize() if using Media3D.Vector3DCollection. Does not change the internal value in Vector3DCollection. " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The length of the statement  "            ComputeTangents(meshGeometry.Positions' meshGeometry.Normals' meshGeometry.TextureCoordinates' meshGeometry.TriangleIndices' out t1' out t2); " is 141.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "            var p1 = new Point3D((DoubleOrSingle)boundingBox.X' (DoubleOrSingle)boundingBox.Y + (DoubleOrSingle)boundingBox.SizeY' (DoubleOrSingle)boundingBox.Z); " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "            var p2 = new Point3D((DoubleOrSingle)boundingBox.X + (DoubleOrSingle)boundingBox.SizeX' (DoubleOrSingle)boundingBox.Y + (DoubleOrSingle)boundingBox.SizeY' (DoubleOrSingle)boundingBox.Z); " is 186.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "            var p3 = new Point3D((DoubleOrSingle)boundingBox.X + (DoubleOrSingle)boundingBox.SizeX' (DoubleOrSingle)boundingBox.Y' (DoubleOrSingle)boundingBox.Z); " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "            var p4 = new Point3D((DoubleOrSingle)boundingBox.X' (DoubleOrSingle)boundingBox.Y' (DoubleOrSingle)boundingBox.Z + (DoubleOrSingle)boundingBox.SizeZ); " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "            var p5 = new Point3D((DoubleOrSingle)boundingBox.X' (DoubleOrSingle)boundingBox.Y + (DoubleOrSingle)boundingBox.SizeY' (DoubleOrSingle)boundingBox.Z + (DoubleOrSingle)boundingBox.SizeZ); " is 186.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "            var p6 = new Point3D((DoubleOrSingle)boundingBox.X + (DoubleOrSingle)boundingBox.SizeX' (DoubleOrSingle)boundingBox.Y + (DoubleOrSingle)boundingBox.SizeY' (DoubleOrSingle)boundingBox.Z + (DoubleOrSingle)boundingBox.SizeZ); " is 222.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "            var p7 = new Point3D((DoubleOrSingle)boundingBox.X + (DoubleOrSingle)boundingBox.SizeX' (DoubleOrSingle)boundingBox.Y' (DoubleOrSingle)boundingBox.Z + (DoubleOrSingle)boundingBox.SizeZ); " is 186.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBox,The length of the statement  "                new Point3D((DoubleOrSingle)(rectangle.X + (rectangle.SizeX * 0.5f))' (DoubleOrSingle)(rectangle.Y + (rectangle.SizeY * 0.5f))' (DoubleOrSingle)(rectangle.Z + (rectangle.SizeZ * 0.5f)))' " is 186.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "            var radiusSphere = 0.25f * (DoubleOrSingle)Math.Sqrt(3) * (1 + (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength; " is 122.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "                var newPoint = new Point3D(radiusSphere * (DoubleOrSingle)Math.Cos(gamma)' 0' radiusSphere * (DoubleOrSingle)Math.Sin(gamma)); " is 126.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "                var newPoint = new Point3D(radiusSphere * (DoubleOrSingle)Math.Cos(gamma)' 0' radiusSphere * (DoubleOrSingle)Math.Sin(gamma)); " is 126.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "                    var u = (DoubleOrSingle)Math.Atan2(SharedFunctions.DotProduct(ref planeCTP' ref forward)' SharedFunctions.DotProduct(ref planeCTP' ref right)); " is 143.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The length of the statement  "                    var p = new Point3D(center.X + (DoubleOrSingle)(radiusx * x)' center.Y + (DoubleOrSingle)(radiusy * y)' center.Z + (DoubleOrSingle)(radiusz * z)); " is 146.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The length of the statement  "                        this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues[j])); " is 163.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The length of the statement  "                        this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues[j + 1])); " is 173.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The length of the statement  "                        this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues[j])); " is 163.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                    var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25)))); " is 132.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList(); " is 188.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                    var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList(); " is 246.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                        var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList(); " is 246.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                        var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0); " is 177.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Append,The length of the statement  "            this.Append(mesh.Positions' mesh.TriangleIndices' this.normals != null ? mesh.Normals : null' this.textureCoordinates != null ? mesh.TextureCoordinates : null); " is 160.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Scale,The length of the statement  "                    this.Positions[i].X * (DoubleOrSingle)scaleX' this.Positions[i].Y * (DoubleOrSingle)scaleY' this.Positions[i].Z * (DoubleOrSingle)scaleZ); " is 138.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Scale,The length of the statement  "                        this.Normals[i].X * (DoubleOrSingle)scaleX' this.Normals[i].Y * (DoubleOrSingle)scaleY' this.Normals[i].Z * (DoubleOrSingle)scaleZ); " is 132.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The length of the statement  "            return new MeshGeometry3D { Positions = p' TriangleIndices = new SharpDX.Core.IntCollection(ti)' Normals = n' TextureCoordinates = tc }; " is 136.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The length of the statement  "                contourHelper.ContourFacet(index0' index1' index2' out positions' out normals' out textureCoordinates' out triangleIndices); " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,The length of the statement  "            RemoveIsolatedVertices(mesh.Positions' mesh.TriangleIndices' mesh.TextureCoordinates' mesh.Normals' out vertNew' out triNew' out textureNew' out normalNew); " is 156.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,The length of the statement  "            var newMesh = new MeshGeometry3D() { Positions = vertNew' TriangleIndices = triNew' TextureCoordinates = textureNew' Normals = normalNew }; " is 139.
Long Statement,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,Flatten,The length of the statement  "            var m = new Matrix3D(backward.X' right.X' up.X' 0' backward.Y' right.Y' up.Y' 0' backward.Z' right.Z' up.Z' 0' 0' 0' 0' 1); " is 123.
Long Statement,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,The length of the statement  "                //if (!(leftChain.Contains(top) && leftChain.Contains(newPoint) || rightChain.Contains(top) && rightChain.Contains(newPoint))) " is 126.
Long Statement,HelixToolkit.Wpf.SharpDX,BoundingSphereExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BoundingSphereExtensions.cs,FromPoints,The length of the statement  "                throw new ArgumentOutOfRangeException("start"' start' string.Format("Must be in the range [0' {0}]"' points.Count - 1)); " is 120.
Long Statement,HelixToolkit.Wpf.SharpDX,VectorExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Vector3DExtensions.cs,ToVector4,The length of the statement  "            return new global::SharpDX.Vector4((float)matrix.OffsetX' (float)matrix.OffsetY' (float)matrix.OffsetZ' (float)matrix.M44); " is 123.
Long Statement,HelixToolkit.Wpf.SharpDX,VectorExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Vector3DExtensions.cs,ToColor,The length of the statement  "            //return System.Windows.Media.Color.FromArgb((byte)(color.Alpha * 256)' (byte)(color.Red * 256)' (byte)(color.Green * 256)' (byte)(color.Blue * 256)); " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,TextureLoader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TextureLoader.cs,FromFileAsShaderResourceView,The length of the statement  "                if (!disableAutoGenMipMap && texture.Description.MipLevels == 1)// Check if it already has mipmaps or not' if loaded DDS file' it may already has precompiled mipmaps' don't need to generate again " is 195.
Long Statement,HelixToolkit.Wpf.SharpDX,TextureLoader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TextureLoader.cs,FromMemoryAsShaderResourceView,The length of the statement  "                if (!disableAutoGenMipMap && texture.Description.MipLevels == 1)// Check if it already has mipmaps or not' if loaded DDS file' it may already has precompiled mipmaps' don't need to generate again " is 195.
Long Statement,HelixToolkit.Wpf.SharpDX.Controls,RenderControl,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\RenderControl.cs,OnPaint,The length of the statement  "                e.Graphics.DrawString(text' fontForDesignMode' new SolidBrush(System.Drawing.Color.Black)' (Width - sizeText.Width) / 2' (Height - sizeText.Height) / 2); " is 153.
Long Statement,Wpf3DTools,Trackball,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Trackball.cs,OnMouseMove,The length of the statement  "            if (e.LeftButton == MouseButtonState.Pressed && (Keyboard.IsKeyDown(Key.LeftShift) || Keyboard.IsKeyDown(Key.RightShift))) " is 122.
Long Statement,HelixToolkit.Wpf.SharpDX.Core,Box3,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Core\Box3D.cs,Union,The length of the statement  "            return new Box3(VectorComparisonExtensions.ComponentMin(a.Min' b.Min)' VectorComparisonExtensions.ComponentMax(a.Max' b.Max)); " is 126.
Long Statement,HelixToolkit.Wpf.SharpDX.Core,Box3,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Core\Box3D.cs,Intersection,The length of the statement  "            return new Box3(VectorComparisonExtensions.ComponentMax(a.Min' b.Min)' VectorComparisonExtensions.ComponentMin(a.Max' b.Max)); " is 126.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The length of the statement  "            if ((header.PixelFormat.Flags & DDS.PixelFormatFlags.FourCC) != 0 && (new FourCC('D'' 'X'' '1'' '0') == header.PixelFormat.FourCC)) " is 131.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The length of the statement  "                        throw new InvalidOperationException(string.Format("Unexpected dimension [{0}] from DDS HeaderDX10"' headerDX10.ResourceDimension)); " is 131.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The length of the statement  "                if ((description.ArraySize != 6) || (description.Dimension != TextureDimension.Texture2D) || (description.Dimension != TextureDimension.TextureCube)) " is 149.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The length of the statement  "            Image.ComputePitch(description.Format' description.Width' description.Height' out rowPitch' out slicePitch' out newWidth' out newHeight); " is 137.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LoadFromDDSMemory,The length of the statement  "            var image = CreateImageFromDDS(pSource' offset' size - offset' mdata' (flags & DDSFlags.LegacyDword) != 0 ? Image.PitchFlags.LegacyDword : Image.PitchFlags.None' convFlags' pal8' handle); " is 187.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The length of the statement  "                else if ((convFlags & (ConversionFlags.Format565 | ConversionFlags.Format5551 | ConversionFlags.Format4444 | ConversionFlags.Format8332 | ConversionFlags.FormatA8P8)) != 0) " is 172.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The length of the statement  "            var isCopyNeeded = (convFlags & (ConversionFlags.Expand | ConversionFlags.CopyMemory)) != 0 || ((cpFlags & Image.PitchFlags.LegacyDword) != 0); " is 143.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The length of the statement  "                                        ExpandScanline(pDest' dpitch' pSrc' spitch' (convFlags & ConversionFlags.Format565) != 0 ? DXGI.Format.B5G6R5_UNorm : DXGI.Format.B5G5R5A1_UNorm' tflags); " is 154.
Long Statement,SharpDX.Toolkit.Graphics,DepthStencilBuffer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,GetDepthStencilView,The length of the statement  "                        dsvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? DepthStencilViewDimension.Texture2DMultisampledArray : DepthStencilViewDimension.Texture2DArray; " is 170.
Long Statement,SharpDX.Toolkit.Graphics,DepthStencilBuffer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,GetDepthStencilView,The length of the statement  "                        dsvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? DepthStencilViewDimension.Texture2DMultisampled : DepthStencilViewDimension.Texture2D; " is 160.
Long Statement,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New1D,The length of the statement  "            return new Image(CreateDescription(TextureDimension.Texture1D' width' 1' 1' mipMapCount' format' arraySize)' dataPointer' 0' null' false); " is 138.
Long Statement,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New2D,The length of the statement  "            return new Image(CreateDescription(TextureDimension.Texture2D' width' height' 1' mipMapCount' format' arraySize)' dataPointer' 0' null' false); " is 143.
Long Statement,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,NewCube,The length of the statement  "            return new Image(CreateDescription(TextureDimension.TextureCube' width' width' 1' mipMapCount' format' 6)' dataPointer' 0' null' false); " is 136.
Long Statement,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New3D,The length of the statement  "            return new Image(CreateDescription(TextureDimension.Texture3D' width' width' depth' mipMapCount' format' 1)' dataPointer' 0' null' false); " is 138.
Long Statement,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The length of the statement  "                    description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.Depth' description.MipLevels); " is 132.
Long Statement,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,Equals,The length of the statement  "            return Dimension.Equals(other.Dimension) && Width == other.Width && Height == other.Height && Depth == other.Depth && ArraySize == other.ArraySize && MipLevels == other.MipLevels && Format.Equals(other.Format); " is 210.
Long Statement,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,ToString,The length of the statement  "            return string.Format("Dimension: {0}' Width: {1}' Height: {2}' Depth: {3}' Format: {4}' ArraySize: {5}' MipLevels: {6}"' Dimension' Width' Height' Depth' Format' ArraySize' MipLevels); " is 184.
Long Statement,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,Equals,The length of the statement  "            return this.Width == other.Width && this.Height == other.Height && this.WidthPacked == other.WidthPacked && this.HeightPacked == other.HeightPacked && this.Depth == other.Depth && this.RowStride == other.RowStride && this.MipmapSize == other.MipmapSize && this.DepthStride == other.DepthStride; " is 294.
Long Statement,SharpDX.Toolkit.Graphics,PixelBuffer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs,CopyTo,The length of the statement  "                throw new ArgumentException("Invalid destination pixelBufferArray. Mush have same Width' Height and Format"' "pixelBuffer"); " is 124.
Long Statement,SharpDX.Toolkit.Graphics,PixelBuffer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs,GetPixels,The length of the statement  "                throw new ArgumentException(string.Format("Invalid sizeof(T)' not a multiple of current size [{0}]in bytes "' totalSize)); " is 122.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,New,The length of the statement  "            return new RenderTarget1D(device' NewRenderTargetDescription(width' format' flags | TextureFlags.RenderTarget' mipCount' arraySize)); " is 133.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget2D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget2D.cs,GetRenderTargetView,The length of the statement  "                        rtvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? RenderTargetViewDimension.Texture2DMultisampledArray : RenderTargetViewDimension.Texture2DArray; " is 170.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget2D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget2D.cs,GetRenderTargetView,The length of the statement  "                        rtvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? RenderTargetViewDimension.Texture2DMultisampled : RenderTargetViewDimension.Texture2D; " is 160.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,New,The length of the statement  "            return new RenderTarget3D(device' NewRenderTargetDescription(width' height' depth' format' flags | TextureFlags.RenderTarget' mipCount)); " is 137.
Long Statement,SharpDX.Toolkit.Graphics,RenderTargetCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTargetCube.cs,New,The length of the statement  "            return new RenderTargetCube(device' NewRenderTargetDescription(size' format' flags | TextureFlags.RenderTarget' mipCount)); " is 123.
Long Statement,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,CalculatePixelDataCount,The length of the statement  "            return CalculateWidth<TData>(mipLevel) * CalculateMipSize(Description.Height' mipLevel) * CalculateMipSize(Description.Depth' mipLevel); " is 136.
Long Statement,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,OnPropertyChanged,The length of the statement  "                            if (shaderResourceView != null) shaderResourceView.View.DebugName = Name == null ? null : String.Format("{0} SRV[{1}]"' i' Name); " is 129.
Long Statement,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,OnPropertyChanged,The length of the statement  "                            if (renderTargetView != null) renderTargetView.View.DebugName = Name == null ? null : String.Format("{0} RTV[{1}]"' i' Name); " is 125.
Long Statement,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,OnPropertyChanged,The length of the statement  "                            if (unorderedAccessView != null) unorderedAccessView.DebugName = Name == null ? null : String.Format("{0} UAV[{1}]"' i' Name); " is 126.
Long Statement,SharpDX.Toolkit.Graphics,TextureViewKey,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,Equals,The length of the statement  "                return ViewFormat == other.ViewFormat && ViewType == other.ViewType && ArrayOrDepthSlice == other.ArrayOrDepthSlice && MipIndex == other.MipIndex; " is 146.
Long Statement,SharpDX.Toolkit.Graphics,Texture1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The length of the statement  "                texture = new Texture1D(device' NewDescription(width' format' flags' 1' 1' usage)' GetDataBox(format' width' 1' 1' textureData' ptr)); " is 134.
Long Statement,SharpDX.Toolkit.Graphics,Texture1DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1DBase.cs,GetUnorderedAccessView,The length of the statement  "                        Dimension = this.Description.ArraySize > 1 ? UnorderedAccessViewDimension.Texture1DArray : UnorderedAccessViewDimension.Texture1D " is 129.
Long Statement,SharpDX.Toolkit.Graphics,Texture1DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1DBase.cs,NewDescription,The length of the statement  "            if ((desc.BindFlags & BindFlags.RenderTarget) != 0 && (desc.BindFlags & BindFlags.ShaderResource) != 0 && desc.MipLevels > 1) " is 125.
Long Statement,SharpDX.Toolkit.Graphics,Texture2D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The length of the statement  "                texture = New(device' width' height' 1' format' new[] { GetDataBox(format' width' height' 1' textureData' ptr) }' flags' 1' usage); " is 131.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,GetShaderResourceView,The length of the statement  "                            srvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? ShaderResourceViewDimension.Texture2DMultisampledArray : ShaderResourceViewDimension.Texture2DArray; " is 174.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,GetShaderResourceView,The length of the statement  "                        srvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? ShaderResourceViewDimension.Texture2DMultisampled : ShaderResourceViewDimension.Texture2D; " is 164.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,GetUnorderedAccessView,The length of the statement  "                        Dimension = this.Description.ArraySize > 1 ? UnorderedAccessViewDimension.Texture2DArray : UnorderedAccessViewDimension.Texture2D " is 129.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,NewDescription,The length of the statement  "            if ((desc.BindFlags & BindFlags.RenderTarget) != 0 && (desc.BindFlags & BindFlags.ShaderResource) != 0 && desc.MipLevels > 1) " is 125.
Long Statement,SharpDX.Toolkit.Graphics,Texture3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The length of the statement  "                texture = New(device' width' height' depth' 1' format' new[] { GetDataBox(format' width' height' depth' textureData' ptr) }' flags' usage); " is 139.
Long Statement,SharpDX.Toolkit.Graphics,Texture3DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3DBase.cs,NewDescription,The length of the statement  "            if ((desc.BindFlags & BindFlags.RenderTarget) != 0 && (desc.BindFlags & BindFlags.ShaderResource) != 0 && desc.MipLevels > 1) " is 125.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "            return new TextureCube(device' NewTextureCubeDescription(size' format' flags | TextureFlags.ShaderResource' mipCount' usage)); " is 126.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "            return new TextureCube(device' NewTextureCubeDescription(size' format' flags | TextureFlags.ShaderResource' 1' usage)' dataBox1' dataBox2' dataBox3' dataBox4' dataBox5' dataBox6); " is 179.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "            return new TextureCube(device' NewTextureCubeDescription(size' format' flags | TextureFlags.ShaderResource' 1' usage)' textureData); " is 132.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "            return new TextureCube(device' CreateTextureDescriptionFromImage(image' flags | TextureFlags.ShaderResource' usage)' image.ToDataBox()); " is 136.
Long Statement,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,ToStagingDescription,The length of the statement  "            copy.OptionFlags = copy.Dimension == TextureDimension.TextureCube ? ResourceOptionFlags.TextureCube : ResourceOptionFlags.None; " is 127.
Long Statement,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,Equals,The length of the statement  "            return Dimension.Equals(other.Dimension) && Width == other.Width && Height == other.Height && Depth == other.Depth && ArraySize == other.ArraySize && MipLevels == other.MipLevels && Format.Equals(other.Format) && SampleDescription.Equals(other.SampleDescription) && Usage.Equals(other.Usage) && BindFlags.Equals(other.BindFlags) && CpuAccessFlags.Equals(other.CpuAccessFlags) && OptionFlags.Equals(other.OptionFlags); " is 417.
Long Statement,SharpDX.Toolkit.Graphics,TextureView,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureView.cs,Initialize,The length of the statement  "                        throw new ArgumentException("Expecting argument to be a ShaderResourceView' RenderTargetView or DepthStencilView"' "view"); " is 123.
Long Statement,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The length of the statement  "                using (var source = new Bitmap(Factory' image.Width' image.Height' pfGuid' new DataRectangle(image.DataPointer' image.RowStride)' image.BufferStride)) " is 150.
Complex Conditional,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,UpdateAndRender,The conditional expression  "((pendingValidationCycles && !skipper.IsSkip()) || skipper.DelayTrigger()) && surfaceD3D != null && renderRenderable != null"  is complex.
Complex Conditional,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,UpdateAndRender,The conditional expression  "((pendingValidationCycles && !skipper.IsSkip()) || skipper.DelayTrigger()) && renderRenderable != null"  is complex.
Complex Conditional,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,UpdateAndRender,The conditional expression  "((pendingValidationCycles && !skipper.IsSkip()) || skipper.DelayTrigger()) && !renderThread.IsBusy && renderRenderable != null"  is complex.
Complex Conditional,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,GetBestAdapter,The conditional expression  "(bestAdapter == null) || (videoMemory > bestVideoMemory) || ((videoMemory == bestVideoMemory) && (systemMemory > bestSystemMemory))"  is complex.
Complex Conditional,HelixToolkit.Wpf.SharpDX,FpsCounter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\FpsCounter.cs,TrimFrames,The conditional expression  "m_frames.Count > 10 && Math.Abs(m_frames.Last - m_frames.First) > MinimumUpdateDuration                  && (target > m_frames.First || m_frames.First > m_frames.Last || m_frames.IsFull())"  is complex.
Complex Conditional,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,CreateOctants,The conditional expression  "dimensions == Vector3.Zero || (dimensions.X < minSize && dimensions.Y < minSize && dimensions.Z < minSize)"  is complex.
Complex Conditional,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnGeometryPropertyChanged,The conditional expression  "e.PropertyName.Equals(nameof(MeshGeometry3D.TextureCoordinates))                  || e.PropertyName.Equals(nameof(MeshGeometry3D.Positions))                  || e.PropertyName.Equals(nameof(MeshGeometry3D.Colors))                  || e.PropertyName.Equals(Geometry3D.VertexBuffer)"  is complex.
Complex Conditional,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,GetCircle,The conditional expression  "(!closed && !CircleCache.Value.TryGetValue(thetaDiv' out circle)) ||                  (closed && !ClosedCircleCache.Value.TryGetValue(thetaDiv' out circle))"  is complex.
Complex Conditional,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The conditional expression  "selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1))"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,GetDXGIFormat,The conditional expression  "pixelFormat.RBitMask == entry.PixelFormat.RBitMask                              && pixelFormat.GBitMask == entry.PixelFormat.GBitMask                              && pixelFormat.BBitMask == entry.PixelFormat.BBitMask                              && pixelFormat.ABitMask == entry.PixelFormat.ABitMask"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The conditional expression  "description.Width <= 0 || description.Height != 1 || description.Depth != 1 || description.ArraySize == 0"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The conditional expression  "description.Width <= 0 || description.Height <= 0 || description.Depth != 1 || description.ArraySize == 0"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The conditional expression  "description.Width <= 0 || description.Height <= 0 || description.Depth <= 0 || description.ArraySize != 1"  is complex.
Virtual Method Call from Constructor,HelixToolkit.Wpf.SharpDX,DefaultRenderTechniquesManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\RenderTechniquesManager.cs,DefaultRenderTechniquesManager,The constructor "DefaultRenderTechniquesManager" calls a virtual method "InitTechniques".
Virtual Method Call from Constructor,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,DefaultEffectsManager,The constructor "DefaultEffectsManager" calls a virtual method "InitEffects".
Virtual Method Call from Constructor,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,UICompositeManipulator3D,The constructor "UICompositeManipulator3D" calls a virtual method "OnChildrenChanged".
Empty Catch Block,HelixToolkit.Wpf.SharpDX,Disposer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Disposer.cs,RemoveAndDispose,The method has an empty catch block.
Empty Catch Block,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Load,The method has an empty catch block.
Empty Catch Block,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeSingleFrame,The method has an empty catch block.
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddMoveForce,The following statement contains a magic number: this.moveSpeed += delta * 40;
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddPanForce,The following statement contains a magic number: if (this.IsInertiaEnabled)              {                  this.panSpeed += pan * 40;              }              else              {                  this.panHandler.Pan(pan);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled)              {                  this.rotationPoint3D = this.CameraTarget;                  this.rotationPosition = new Point(this.ActualWidth / 2' this.ActualHeight / 2);                  this.rotationSpeed.X += dx * 40;                  this.rotationSpeed.Y += dy * 40;              }              else              {                  this.rotationPosition = new Point(this.ActualWidth / 2' this.ActualHeight / 2);                  this.rotateHandler.Rotate(                      this.rotationPosition' this.rotationPosition + new Vector(dx' dy)' this.CameraTarget);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled)              {                  this.rotationPoint3D = this.CameraTarget;                  this.rotationPosition = new Point(this.ActualWidth / 2' this.ActualHeight / 2);                  this.rotationSpeed.X += dx * 40;                  this.rotationSpeed.Y += dy * 40;              }              else              {                  this.rotationPosition = new Point(this.ActualWidth / 2' this.ActualHeight / 2);                  this.rotateHandler.Rotate(                      this.rotationPosition' this.rotationPosition + new Vector(dx' dy)' this.CameraTarget);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled)              {                  this.rotationPoint3D = this.CameraTarget;                  this.rotationPosition = new Point(this.ActualWidth / 2' this.ActualHeight / 2);                  this.rotationSpeed.X += dx * 40;                  this.rotationSpeed.Y += dy * 40;              }              else              {                  this.rotationPosition = new Point(this.ActualWidth / 2' this.ActualHeight / 2);                  this.rotateHandler.Rotate(                      this.rotationPosition' this.rotationPosition + new Vector(dx' dy)' this.CameraTarget);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled)              {                  this.rotationPoint3D = this.CameraTarget;                  this.rotationPosition = new Point(this.ActualWidth / 2' this.ActualHeight / 2);                  this.rotationSpeed.X += dx * 40;                  this.rotationSpeed.Y += dy * 40;              }              else              {                  this.rotationPosition = new Point(this.ActualWidth / 2' this.ActualHeight / 2);                  this.rotateHandler.Rotate(                      this.rotationPosition' this.rotationPosition + new Vector(dx' dy)' this.CameraTarget);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled)              {                  this.rotationPoint3D = this.CameraTarget;                  this.rotationPosition = new Point(this.ActualWidth / 2' this.ActualHeight / 2);                  this.rotationSpeed.X += dx * 40;                  this.rotationSpeed.Y += dy * 40;              }              else              {                  this.rotationPosition = new Point(this.ActualWidth / 2' this.ActualHeight / 2);                  this.rotateHandler.Rotate(                      this.rotationPosition' this.rotationPosition + new Vector(dx' dy)' this.CameraTarget);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled)              {                  this.rotationPoint3D = this.CameraTarget;                  this.rotationPosition = new Point(this.ActualWidth / 2' this.ActualHeight / 2);                  this.rotationSpeed.X += dx * 40;                  this.rotationSpeed.Y += dy * 40;              }              else              {                  this.rotationPosition = new Point(this.ActualWidth / 2' this.ActualHeight / 2);                  this.rotateHandler.Rotate(                      this.rotationPosition' this.rotationPosition + new Vector(dx' dy)' this.CameraTarget);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddZoomForce,The following statement contains a magic number: if (this.IsInertiaEnabled)              {                  this.zoomPoint3D = zoomOrigin;                  this.zoomSpeed += delta * 8;              }              else              {                  this.zoomHandler.Zoom(delta' zoomOrigin);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,PushCameraSetting,The following statement contains a magic number: if (this.cameraHistory.Count > 100)              {                  this.cameraHistory.RemoveFirst();              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,ShowRectangle,The following statement contains a magic number: this.rectangleAdorner = new RectangleAdorner(                  this.Viewport' rect' color1' color2' 3' 1' 10' DashStyles.Solid);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,ShowRectangle,The following statement contains a magic number: this.rectangleAdorner = new RectangleAdorner(                  this.Viewport' rect' color1' color2' 3' 1' 10' DashStyles.Solid);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationCompleted,The following statement contains a magic number: if (this.manipulatorCount == 2)              {                  this.panHandler.Completed(new ManipulationEventArgs(p));                  this.zoomHandler.Completed(new ManipulationEventArgs(p));              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (this.manipulatorCount != n)              {                  // the number of manipulators has changed                  if (this.manipulatorCount == 1)                  {                      this.rotateHandler.Completed(new ManipulationEventArgs(position));                  }                    if (this.manipulatorCount == 2)                  {                      this.panHandler.Completed(new ManipulationEventArgs(position));                      this.zoomHandler.Completed(new ManipulationEventArgs(position));                  }                    if (n == 2)                  {                      this.panHandler.Started(new ManipulationEventArgs(position));                      this.zoomHandler.Started(new ManipulationEventArgs(e.ManipulationOrigin));                  }                  else                  {                      this.rotateHandler.Started(new ManipulationEventArgs(position));                  }                    // skip this event' the origin may have changed                  this.manipulatorCount = n;                  e.Handled = true;                  return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (this.manipulatorCount != n)              {                  // the number of manipulators has changed                  if (this.manipulatorCount == 1)                  {                      this.rotateHandler.Completed(new ManipulationEventArgs(position));                  }                    if (this.manipulatorCount == 2)                  {                      this.panHandler.Completed(new ManipulationEventArgs(position));                      this.zoomHandler.Completed(new ManipulationEventArgs(position));                  }                    if (n == 2)                  {                      this.panHandler.Started(new ManipulationEventArgs(position));                      this.zoomHandler.Started(new ManipulationEventArgs(e.ManipulationOrigin));                  }                  else                  {                      this.rotateHandler.Started(new ManipulationEventArgs(position));                  }                    // skip this event' the origin may have changed                  this.manipulatorCount = n;                  e.Handled = true;                  return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (n == 2)              {                  // two fingers pans                  this.panHandler.Delta(new ManipulationEventArgs(position));              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (this.IsTouchZoomEnabled && n == 2)              {                  var zoomAroundPoint = this.zoomHandler.UnProject(                      e.ManipulationOrigin' this.zoomHandler.Origin' this.CameraLookDirection);                  if (zoomAroundPoint != null)                  {                      this.zoomHandler.Zoom(1 - (e.DeltaManipulation.Scale.Length / Math.Sqrt(2))' zoomAroundPoint.Value);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (this.IsTouchZoomEnabled && n == 2)              {                  var zoomAroundPoint = this.zoomHandler.UnProject(                      e.ManipulationOrigin' this.zoomHandler.Origin' this.CameraLookDirection);                  if (zoomAroundPoint != null)                  {                      this.zoomHandler.Zoom(1 - (e.DeltaManipulation.Scale.Length / Math.Sqrt(2))' zoomAroundPoint.Value);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,FindPanVector,The following statement contains a magic number: var f = l * 0.001;
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnCompositionTargetRendering,The following statement contains a magic number: var time = 100e-9 * (ticks - this.lastTick);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: var f = control ? 0.25 : 1;
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: if (!shift)              {                  switch (e.Key)                  {                      case Key.Left:                          this.AddRotateForce(-1 * f * this.LeftRightRotationSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Right:                          this.AddRotateForce(1 * f * this.LeftRightRotationSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Up:                          this.AddRotateForce(0' -1 * f * this.UpDownRotationSensitivity);                          e.Handled = true;                          break;                      case Key.Down:                          this.AddRotateForce(0' 1 * f * this.UpDownRotationSensitivity);                          e.Handled = true;                          break;                  }              }              else              {                  switch (e.Key)                  {                      case Key.Left:                          this.AddPanForce(-5 * f * this.LeftRightPanSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Right:                          this.AddPanForce(5 * f * this.LeftRightPanSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Up:                          this.AddPanForce(0' -5 * f * this.UpDownPanSensitivity);                          e.Handled = true;                          break;                      case Key.Down:                          this.AddPanForce(0' 5 * f * this.UpDownPanSensitivity);                          e.Handled = true;                          break;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: if (!shift)              {                  switch (e.Key)                  {                      case Key.Left:                          this.AddRotateForce(-1 * f * this.LeftRightRotationSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Right:                          this.AddRotateForce(1 * f * this.LeftRightRotationSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Up:                          this.AddRotateForce(0' -1 * f * this.UpDownRotationSensitivity);                          e.Handled = true;                          break;                      case Key.Down:                          this.AddRotateForce(0' 1 * f * this.UpDownRotationSensitivity);                          e.Handled = true;                          break;                  }              }              else              {                  switch (e.Key)                  {                      case Key.Left:                          this.AddPanForce(-5 * f * this.LeftRightPanSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Right:                          this.AddPanForce(5 * f * this.LeftRightPanSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Up:                          this.AddPanForce(0' -5 * f * this.UpDownPanSensitivity);                          e.Handled = true;                          break;                      case Key.Down:                          this.AddPanForce(0' 5 * f * this.UpDownPanSensitivity);                          e.Handled = true;                          break;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: if (!shift)              {                  switch (e.Key)                  {                      case Key.Left:                          this.AddRotateForce(-1 * f * this.LeftRightRotationSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Right:                          this.AddRotateForce(1 * f * this.LeftRightRotationSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Up:                          this.AddRotateForce(0' -1 * f * this.UpDownRotationSensitivity);                          e.Handled = true;                          break;                      case Key.Down:                          this.AddRotateForce(0' 1 * f * this.UpDownRotationSensitivity);                          e.Handled = true;                          break;                  }              }              else              {                  switch (e.Key)                  {                      case Key.Left:                          this.AddPanForce(-5 * f * this.LeftRightPanSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Right:                          this.AddPanForce(5 * f * this.LeftRightPanSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Up:                          this.AddPanForce(0' -5 * f * this.UpDownPanSensitivity);                          e.Handled = true;                          break;                      case Key.Down:                          this.AddPanForce(0' 5 * f * this.UpDownPanSensitivity);                          e.Handled = true;                          break;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: if (!shift)              {                  switch (e.Key)                  {                      case Key.Left:                          this.AddRotateForce(-1 * f * this.LeftRightRotationSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Right:                          this.AddRotateForce(1 * f * this.LeftRightRotationSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Up:                          this.AddRotateForce(0' -1 * f * this.UpDownRotationSensitivity);                          e.Handled = true;                          break;                      case Key.Down:                          this.AddRotateForce(0' 1 * f * this.UpDownRotationSensitivity);                          e.Handled = true;                          break;                  }              }              else              {                  switch (e.Key)                  {                      case Key.Left:                          this.AddPanForce(-5 * f * this.LeftRightPanSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Right:                          this.AddPanForce(5 * f * this.LeftRightPanSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Up:                          this.AddPanForce(0' -5 * f * this.UpDownPanSensitivity);                          e.Handled = true;                          break;                      case Key.Down:                          this.AddPanForce(0' 5 * f * this.UpDownPanSensitivity);                          e.Handled = true;                          break;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key)              {                  case Key.PageUp:                      this.AddZoomForce(-0.1 * f * this.PageUpDownZoomSensitivity);                      e.Handled = true;                      break;                  case Key.PageDown:                      this.AddZoomForce(0.1 * f * this.PageUpDownZoomSensitivity);                      e.Handled = true;                      break;                  case Key.Back:                      if (this.RestoreCameraSetting())                      {                          e.Handled = true;                      }                        break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key)              {                  case Key.PageUp:                      this.AddZoomForce(-0.1 * f * this.PageUpDownZoomSensitivity);                      e.Handled = true;                      break;                  case Key.PageDown:                      this.AddZoomForce(0.1 * f * this.PageUpDownZoomSensitivity);                      e.Handled = true;                      break;                  case Key.Back:                      if (this.RestoreCameraSetting())                      {                          e.Handled = true;                      }                        break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key)              {                  case Key.W:                      this.AddMoveForce(0' 0' 0.1 * f * this.MoveSensitivity);                      break;                  case Key.A:                      this.AddMoveForce(-0.1 * f * this.LeftRightPanSensitivity' 0' 0);                      break;                  case Key.S:                      this.AddMoveForce(0' 0' -0.1 * f * this.MoveSensitivity);                      break;                  case Key.D:                      this.AddMoveForce(0.1 * f * this.LeftRightPanSensitivity' 0' 0);                      break;                  case Key.Z:                      this.AddMoveForce(0' -0.1 * f * this.LeftRightPanSensitivity' 0);                      break;                  case Key.Q:                      this.AddMoveForce(0' 0.1 * f * this.LeftRightPanSensitivity' 0);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key)              {                  case Key.W:                      this.AddMoveForce(0' 0' 0.1 * f * this.MoveSensitivity);                      break;                  case Key.A:                      this.AddMoveForce(-0.1 * f * this.LeftRightPanSensitivity' 0' 0);                      break;                  case Key.S:                      this.AddMoveForce(0' 0' -0.1 * f * this.MoveSensitivity);                      break;                  case Key.D:                      this.AddMoveForce(0.1 * f * this.LeftRightPanSensitivity' 0' 0);                      break;                  case Key.Z:                      this.AddMoveForce(0' -0.1 * f * this.LeftRightPanSensitivity' 0);                      break;                  case Key.Q:                      this.AddMoveForce(0' 0.1 * f * this.LeftRightPanSensitivity' 0);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key)              {                  case Key.W:                      this.AddMoveForce(0' 0' 0.1 * f * this.MoveSensitivity);                      break;                  case Key.A:                      this.AddMoveForce(-0.1 * f * this.LeftRightPanSensitivity' 0' 0);                      break;                  case Key.S:                      this.AddMoveForce(0' 0' -0.1 * f * this.MoveSensitivity);                      break;                  case Key.D:                      this.AddMoveForce(0.1 * f * this.LeftRightPanSensitivity' 0' 0);                      break;                  case Key.Z:                      this.AddMoveForce(0' -0.1 * f * this.LeftRightPanSensitivity' 0);                      break;                  case Key.Q:                      this.AddMoveForce(0' 0.1 * f * this.LeftRightPanSensitivity' 0);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key)              {                  case Key.W:                      this.AddMoveForce(0' 0' 0.1 * f * this.MoveSensitivity);                      break;                  case Key.A:                      this.AddMoveForce(-0.1 * f * this.LeftRightPanSensitivity' 0' 0);                      break;                  case Key.S:                      this.AddMoveForce(0' 0' -0.1 * f * this.MoveSensitivity);                      break;                  case Key.D:                      this.AddMoveForce(0.1 * f * this.LeftRightPanSensitivity' 0' 0);                      break;                  case Key.Z:                      this.AddMoveForce(0' -0.1 * f * this.LeftRightPanSensitivity' 0);                      break;                  case Key.Q:                      this.AddMoveForce(0' 0.1 * f * this.LeftRightPanSensitivity' 0);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key)              {                  case Key.W:                      this.AddMoveForce(0' 0' 0.1 * f * this.MoveSensitivity);                      break;                  case Key.A:                      this.AddMoveForce(-0.1 * f * this.LeftRightPanSensitivity' 0' 0);                      break;                  case Key.S:                      this.AddMoveForce(0' 0' -0.1 * f * this.MoveSensitivity);                      break;                  case Key.D:                      this.AddMoveForce(0.1 * f * this.LeftRightPanSensitivity' 0' 0);                      break;                  case Key.Z:                      this.AddMoveForce(0' -0.1 * f * this.LeftRightPanSensitivity' 0);                      break;                  case Key.Q:                      this.AddMoveForce(0' 0.1 * f * this.LeftRightPanSensitivity' 0);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key)              {                  case Key.W:                      this.AddMoveForce(0' 0' 0.1 * f * this.MoveSensitivity);                      break;                  case Key.A:                      this.AddMoveForce(-0.1 * f * this.LeftRightPanSensitivity' 0' 0);                      break;                  case Key.S:                      this.AddMoveForce(0' 0' -0.1 * f * this.MoveSensitivity);                      break;                  case Key.D:                      this.AddMoveForce(0.1 * f * this.LeftRightPanSensitivity' 0' 0);                      break;                  case Key.Z:                      this.AddMoveForce(0' -0.1 * f * this.LeftRightPanSensitivity' 0);                      break;                  case Key.Q:                      this.AddMoveForce(0' 0.1 * f * this.LeftRightPanSensitivity' 0);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnMouseWheel,The following statement contains a magic number: if (this.ZoomAroundMouseDownPoint)              {                  var point = e.GetPosition(this);                  Point3D nearestPoint;                  Vector3D normal;                  Model3D visual;                  if (this.Viewport.FindNearest(point' out nearestPoint' out normal' out visual))                  {                      this.AddZoomForce(-e.Delta * 0.001' nearestPoint);                      e.Handled = true;                      return;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnMouseWheel,The following statement contains a magic number: this.AddZoomForce(-e.Delta * 0.001);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: var factor = this.IsInertiaEnabled ? Math.Pow(this.InertiaFactor' time / 0.012) : 0;
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: factor = this.Clamp(factor' 0.2' 1);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: if (this.isSpinning && this.spinningSpeed.LengthSquared > 0.1)              {                  this.rotateHandler.Rotate(                      this.spinningPosition' this.spinningPosition + (this.spinningSpeed * time)' this.spinningPoint3D);                    if (!this.InfiniteSpin)                  {                      this.spinningSpeed *= factor;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: if (this.rotationSpeed.LengthSquared > 0.1)              {                  this.rotateHandler.Rotate(                      this.rotationPosition' this.rotationPosition + (this.rotationSpeed * time)' this.rotationPoint3D);                  this.rotationSpeed *= factor;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: if (this.panSpeed.LengthSquared > 0.0001)              {                  this.panHandler.Pan(this.panSpeed * time);                  this.panSpeed *= factor;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: if (this.moveSpeed.LengthSquared > 0.0001)              {                  this.zoomHandler.MoveCameraPosition(this.moveSpeed * time);                  this.moveSpeed *= factor;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: if (Math.Abs(this.zoomSpeed) > 0.1)              {                  this.zoomHandler.Zoom(this.zoomSpeed * time' this.zoomPoint3D);                  this.zoomSpeed *= factor;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitBuffers,The following statement contains a magic number: this.targetWidth = Math.Max((int)host.ActualWidth' 100);
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitBuffers,The following statement contains a magic number: this.targetHeight = Math.Max((int)host.ActualHeight' 100);
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: var midX = this.targetWidth / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: var midY = this.targetHeight / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge)              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(midX' 0' 0' 2 * midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' midY' 0' midX' 2 * midY' 1)'                      renderTarget' 0' 0' midY' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(midX' midY' 0' 2 * midX' 2 * midY' 1)'                      renderTarget' 0' midX' midY' 0);              }              else              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    //context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' midY' 0);                      context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' midY' 0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge)              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(midX' 0' 0' 2 * midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' midY' 0' midX' 2 * midY' 1)'                      renderTarget' 0' 0' midY' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(midX' midY' 0' 2 * midX' 2 * midY' 1)'                      renderTarget' 0' midX' midY' 0);              }              else              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    //context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' midY' 0);                      context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' midY' 0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge)              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(midX' 0' 0' 2 * midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' midY' 0' midX' 2 * midY' 1)'                      renderTarget' 0' 0' midY' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(midX' midY' 0' 2 * midX' 2 * midY' 1)'                      renderTarget' 0' midX' midY' 0);              }              else              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    //context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' midY' 0);                      context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' midY' 0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge)              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(midX' 0' 0' 2 * midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' midY' 0' midX' 2 * midY' 1)'                      renderTarget' 0' 0' midY' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(midX' midY' 0' 2 * midX' 2 * midY' 1)'                      renderTarget' 0' midX' midY' 0);              }              else              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    //context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' midY' 0);                      context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' midY' 0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge)              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(midX' 0' 0' 2 * midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' midY' 0' midX' 2 * midY' 1)'                      renderTarget' 0' 0' midY' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(midX' midY' 0' 2 * midX' 2 * midY' 1)'                      renderTarget' 0' midX' midY' 0);              }              else              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    //context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' midY' 0);                      context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' midY' 0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge)              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(midX' 0' 0' 2 * midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' midY' 0' midX' 2 * midY' 1)'                      renderTarget' 0' 0' midY' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(midX' midY' 0' 2 * midX' 2 * midY' 1)'                      renderTarget' 0' midX' midY' 0);              }              else              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    //context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' midY' 0);                      context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' midY' 0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge)              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(midX' 0' 0' 2 * midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' midY' 0' midX' 2 * midY' 1)'                      renderTarget' 0' 0' midY' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(midX' midY' 0' 2 * midX' 2 * midY' 1)'                      renderTarget' 0' midX' midY' 0);              }              else              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    //context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' midY' 0);                      context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' midY' 0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge)              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(midX' 0' 0' 2 * midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' midY' 0' midX' 2 * midY' 1)'                      renderTarget' 0' 0' midY' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(midX' midY' 0' 2 * midX' 2 * midY' 1)'                      renderTarget' 0' midX' midY' 0);              }              else              {                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[0]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' 0' 0);                    context.DeviceContext.CopySubresourceRegion(this.gBuffer[1]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' 0' 0);                    //context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'                  context.DeviceContext.CopySubresourceRegion(this.gBuffer[2]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' 0' midY' 0);                      context.DeviceContext.CopySubresourceRegion(this.gBuffer[3]' 0'                      new ResourceRegion(0' 0' 0' midX' midY' 1)'                      renderTarget' 0' midX' midY' 0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderSSAO)              {                  if (this.RenderPass == DeferredRenderPasses.RenderDirectDiffuse)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        // render lighting to buffer                      this.SetSSBufferTarget(1' renderContext);                      this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                        // reset default render targets render the buffer-merge pass                      if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        this.BindQuadBuffer(renderContext);                      this.RenderMerge(renderContext);                        // perform FXAA pass                      if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                    }                  else if (this.RenderPass == DeferredRenderPasses.RenderBlured)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        // render blur and merge                      this.RenderBlurPass(renderContext' renderRenderable' FXAAEnabled ? 2 : -1);                        // perform FXAA pass                      if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                  }                  else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        int target = this.RenderBlurPass(renderContext' renderRenderable' 0);                        // render lighting to ping-pong buffer 1                      this.SetSSBufferTarget(1-target' renderContext);                      this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                        // render merge-pass of buffer 0 and 1                      if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        this.BindQuadBuffer(renderContext);                      this.RenderMerge(renderContext);                        if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                  }                  else                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // reset default render targets                       if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        // render AO buffer only                      this.RenderScreenSpaceAO(renderContext);                        if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.BindQuadBuffer(renderContext);                          this.RenderFXAA(renderContext);                      }                  }              }              else               {                  // reset render targets and run lighting pass                  //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                  if (FXAAEnabled)                  {                      this.SetSSBufferTarget(2' renderContext);                  }                  else                  {                      this.renderHost.SetDefaultRenderTargets();                  }                    // set the lights                  this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                    if (FXAAEnabled)                  {                      this.renderHost.SetDefaultRenderTargets();                      this.BindQuadBuffer(renderContext);                      this.RenderFXAA(renderContext);                  }  #else              {                  // reset render targets and run lighting pass                  //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                  this.renderHost.SetDefaultRenderTargets();                  // set the lights                                       this.RenderLighting(renderContext' renderRenderable.Items.OfType<ILight3D>());  #endif              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderSSAO)              {                  if (this.RenderPass == DeferredRenderPasses.RenderDirectDiffuse)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        // render lighting to buffer                      this.SetSSBufferTarget(1' renderContext);                      this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                        // reset default render targets render the buffer-merge pass                      if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        this.BindQuadBuffer(renderContext);                      this.RenderMerge(renderContext);                        // perform FXAA pass                      if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                    }                  else if (this.RenderPass == DeferredRenderPasses.RenderBlured)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        // render blur and merge                      this.RenderBlurPass(renderContext' renderRenderable' FXAAEnabled ? 2 : -1);                        // perform FXAA pass                      if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                  }                  else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        int target = this.RenderBlurPass(renderContext' renderRenderable' 0);                        // render lighting to ping-pong buffer 1                      this.SetSSBufferTarget(1-target' renderContext);                      this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                        // render merge-pass of buffer 0 and 1                      if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        this.BindQuadBuffer(renderContext);                      this.RenderMerge(renderContext);                        if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                  }                  else                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // reset default render targets                       if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        // render AO buffer only                      this.RenderScreenSpaceAO(renderContext);                        if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.BindQuadBuffer(renderContext);                          this.RenderFXAA(renderContext);                      }                  }              }              else               {                  // reset render targets and run lighting pass                  //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                  if (FXAAEnabled)                  {                      this.SetSSBufferTarget(2' renderContext);                  }                  else                  {                      this.renderHost.SetDefaultRenderTargets();                  }                    // set the lights                  this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                    if (FXAAEnabled)                  {                      this.renderHost.SetDefaultRenderTargets();                      this.BindQuadBuffer(renderContext);                      this.RenderFXAA(renderContext);                  }  #else              {                  // reset render targets and run lighting pass                  //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                  this.renderHost.SetDefaultRenderTargets();                  // set the lights                                       this.RenderLighting(renderContext' renderRenderable.Items.OfType<ILight3D>());  #endif              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderSSAO)              {                  if (this.RenderPass == DeferredRenderPasses.RenderDirectDiffuse)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        // render lighting to buffer                      this.SetSSBufferTarget(1' renderContext);                      this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                        // reset default render targets render the buffer-merge pass                      if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        this.BindQuadBuffer(renderContext);                      this.RenderMerge(renderContext);                        // perform FXAA pass                      if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                    }                  else if (this.RenderPass == DeferredRenderPasses.RenderBlured)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        // render blur and merge                      this.RenderBlurPass(renderContext' renderRenderable' FXAAEnabled ? 2 : -1);                        // perform FXAA pass                      if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                  }                  else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        int target = this.RenderBlurPass(renderContext' renderRenderable' 0);                        // render lighting to ping-pong buffer 1                      this.SetSSBufferTarget(1-target' renderContext);                      this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                        // render merge-pass of buffer 0 and 1                      if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        this.BindQuadBuffer(renderContext);                      this.RenderMerge(renderContext);                        if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                  }                  else                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // reset default render targets                       if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        // render AO buffer only                      this.RenderScreenSpaceAO(renderContext);                        if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.BindQuadBuffer(renderContext);                          this.RenderFXAA(renderContext);                      }                  }              }              else               {                  // reset render targets and run lighting pass                  //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                  if (FXAAEnabled)                  {                      this.SetSSBufferTarget(2' renderContext);                  }                  else                  {                      this.renderHost.SetDefaultRenderTargets();                  }                    // set the lights                  this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                    if (FXAAEnabled)                  {                      this.renderHost.SetDefaultRenderTargets();                      this.BindQuadBuffer(renderContext);                      this.RenderFXAA(renderContext);                  }  #else              {                  // reset render targets and run lighting pass                  //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                  this.renderHost.SetDefaultRenderTargets();                  // set the lights                                       this.RenderLighting(renderContext' renderRenderable.Items.OfType<ILight3D>());  #endif              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderSSAO)              {                  if (this.RenderPass == DeferredRenderPasses.RenderDirectDiffuse)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        // render lighting to buffer                      this.SetSSBufferTarget(1' renderContext);                      this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                        // reset default render targets render the buffer-merge pass                      if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        this.BindQuadBuffer(renderContext);                      this.RenderMerge(renderContext);                        // perform FXAA pass                      if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                    }                  else if (this.RenderPass == DeferredRenderPasses.RenderBlured)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        // render blur and merge                      this.RenderBlurPass(renderContext' renderRenderable' FXAAEnabled ? 2 : -1);                        // perform FXAA pass                      if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                  }                  else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        int target = this.RenderBlurPass(renderContext' renderRenderable' 0);                        // render lighting to ping-pong buffer 1                      this.SetSSBufferTarget(1-target' renderContext);                      this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                        // render merge-pass of buffer 0 and 1                      if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        this.BindQuadBuffer(renderContext);                      this.RenderMerge(renderContext);                        if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                  }                  else                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // reset default render targets                       if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        // render AO buffer only                      this.RenderScreenSpaceAO(renderContext);                        if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.BindQuadBuffer(renderContext);                          this.RenderFXAA(renderContext);                      }                  }              }              else               {                  // reset render targets and run lighting pass                  //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                  if (FXAAEnabled)                  {                      this.SetSSBufferTarget(2' renderContext);                  }                  else                  {                      this.renderHost.SetDefaultRenderTargets();                  }                    // set the lights                  this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                    if (FXAAEnabled)                  {                      this.renderHost.SetDefaultRenderTargets();                      this.BindQuadBuffer(renderContext);                      this.RenderFXAA(renderContext);                  }  #else              {                  // reset render targets and run lighting pass                  //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                  this.renderHost.SetDefaultRenderTargets();                  // set the lights                                       this.RenderLighting(renderContext' renderRenderable.Items.OfType<ILight3D>());  #endif              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderSSAO)              {                  if (this.RenderPass == DeferredRenderPasses.RenderDirectDiffuse)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        // render lighting to buffer                      this.SetSSBufferTarget(1' renderContext);                      this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                        // reset default render targets render the buffer-merge pass                      if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        this.BindQuadBuffer(renderContext);                      this.RenderMerge(renderContext);                        // perform FXAA pass                      if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                    }                  else if (this.RenderPass == DeferredRenderPasses.RenderBlured)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        // render blur and merge                      this.RenderBlurPass(renderContext' renderRenderable' FXAAEnabled ? 2 : -1);                        // perform FXAA pass                      if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                  }                  else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse)                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // set SSAO render target and render SSAO                      this.SetSSBufferTarget(0' renderContext);                      this.RenderScreenSpaceAO(renderContext);                        int target = this.RenderBlurPass(renderContext' renderRenderable' 0);                        // render lighting to ping-pong buffer 1                      this.SetSSBufferTarget(1-target' renderContext);                      this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                        // render merge-pass of buffer 0 and 1                      if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        this.BindQuadBuffer(renderContext);                      this.RenderMerge(renderContext);                        if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.RenderFXAA(renderContext);                      }                  }                  else                  {                      // bind quad geometry (good for a full screen-space pass)                      this.BindQuadBuffer(renderContext);                        // reset default render targets                       if (FXAAEnabled)                      {                          this.SetSSBufferTarget(2' renderContext);                      }                      else                      {                          this.renderHost.SetDefaultRenderTargets();                      }                        // render AO buffer only                      this.RenderScreenSpaceAO(renderContext);                        if (FXAAEnabled)                      {                          this.renderHost.SetDefaultRenderTargets();                          this.BindQuadBuffer(renderContext);                          this.RenderFXAA(renderContext);                      }                  }              }              else               {                  // reset render targets and run lighting pass                  //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                  if (FXAAEnabled)                  {                      this.SetSSBufferTarget(2' renderContext);                  }                  else                  {                      this.renderHost.SetDefaultRenderTargets();                  }                    // set the lights                  this.RenderLighting(renderContext' renderRenderable.Renderables.OfType<ILight3D>());                    if (FXAAEnabled)                  {                      this.renderHost.SetDefaultRenderTargets();                      this.BindQuadBuffer(renderContext);                      this.RenderFXAA(renderContext);                  }  #else              {                  // reset render targets and run lighting pass                  //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                  this.renderHost.SetDefaultRenderTargets();                  // set the lights                                       this.RenderLighting(renderContext' renderRenderable.Items.OfType<ILight3D>());  #endif              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderLighting,The following statement contains a magic number: foreach (SpotLight3D light in lights.Where(l => l is SpotLight3D))              {                  var lightRadius = (float)EstimateRadius(light.Attenuation);                    double phiHalfRad = light.OuterAngle / 360.0 * Math.PI;                  float scaleX = lightRadius;                  float scaleYZ = lightRadius * (float)Math.Tan(phiHalfRad);                    Vector3 baseX = light.Direction;                  baseX.Normalize();                  Vector3 baseY' baseZ;                  MakeBasis(baseX' out baseY' out baseZ);                    var spot = new Vector4((float)Math.Cos(light.OuterAngle / 360.0 * Math.PI)' (float)Math.Cos(light.InnerAngle / 360.0 * Math.PI)' (float)light.Falloff' 0);                  this.deferredLightingVariables.vLightSpot.Set(ref spot);                  this.deferredLightingVariables.vLightDir.Set(baseX);                  this.deferredLightingVariables.vLightColor.Set(light.Color);                  this.deferredLightingVariables.vLightPos.Set(light.Position.ToVector4());                  this.deferredLightingVariables.vLightAtt.Set(light.Attenuation.ToVector4(100f));                    Matrix lightModelMatrix = new Matrix(                      baseX.X * scaleX' baseX.Y * scaleX' baseX.Z * scaleX' 0f'                      baseY.X * scaleYZ' baseY.Y * scaleYZ' baseY.Z * scaleYZ' 0f'                      baseZ.X * scaleYZ' baseZ.Y * scaleYZ' baseZ.Z * scaleYZ' 0f'                      (float)light.Position.X' (float)light.Position.Y' (float)light.Position.Z' 1.0f                  );                    this.deferredLightingVariables.mLightModel.SetMatrix(lightModelMatrix);                  this.deferredLightingVariables.mLightView.SetMatrix(context.viewMatrix);                  this.deferredLightingVariables.mLightProj.SetMatrix(context.projectionMatrix);                    // --- render the geometry                  pass.Apply(context.DeviceContext);                  context.DeviceContext.DrawIndexed(this.screenCone.IndexCount' 0' 0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderLighting,The following statement contains a magic number: foreach (SpotLight3D light in lights.Where(l => l is SpotLight3D))              {                  var lightRadius = (float)EstimateRadius(light.Attenuation);                    double phiHalfRad = light.OuterAngle / 360.0 * Math.PI;                  float scaleX = lightRadius;                  float scaleYZ = lightRadius * (float)Math.Tan(phiHalfRad);                    Vector3 baseX = light.Direction;                  baseX.Normalize();                  Vector3 baseY' baseZ;                  MakeBasis(baseX' out baseY' out baseZ);                    var spot = new Vector4((float)Math.Cos(light.OuterAngle / 360.0 * Math.PI)' (float)Math.Cos(light.InnerAngle / 360.0 * Math.PI)' (float)light.Falloff' 0);                  this.deferredLightingVariables.vLightSpot.Set(ref spot);                  this.deferredLightingVariables.vLightDir.Set(baseX);                  this.deferredLightingVariables.vLightColor.Set(light.Color);                  this.deferredLightingVariables.vLightPos.Set(light.Position.ToVector4());                  this.deferredLightingVariables.vLightAtt.Set(light.Attenuation.ToVector4(100f));                    Matrix lightModelMatrix = new Matrix(                      baseX.X * scaleX' baseX.Y * scaleX' baseX.Z * scaleX' 0f'                      baseY.X * scaleYZ' baseY.Y * scaleYZ' baseY.Z * scaleYZ' 0f'                      baseZ.X * scaleYZ' baseZ.Y * scaleYZ' baseZ.Z * scaleYZ' 0f'                      (float)light.Position.X' (float)light.Position.Y' (float)light.Position.Z' 1.0f                  );                    this.deferredLightingVariables.mLightModel.SetMatrix(lightModelMatrix);                  this.deferredLightingVariables.mLightView.SetMatrix(context.viewMatrix);                  this.deferredLightingVariables.mLightProj.SetMatrix(context.projectionMatrix);                    // --- render the geometry                  pass.Apply(context.DeviceContext);                  context.DeviceContext.DrawIndexed(this.screenCone.IndexCount' 0' 0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderLighting,The following statement contains a magic number: foreach (SpotLight3D light in lights.Where(l => l is SpotLight3D))              {                  var lightRadius = (float)EstimateRadius(light.Attenuation);                    double phiHalfRad = light.OuterAngle / 360.0 * Math.PI;                  float scaleX = lightRadius;                  float scaleYZ = lightRadius * (float)Math.Tan(phiHalfRad);                    Vector3 baseX = light.Direction;                  baseX.Normalize();                  Vector3 baseY' baseZ;                  MakeBasis(baseX' out baseY' out baseZ);                    var spot = new Vector4((float)Math.Cos(light.OuterAngle / 360.0 * Math.PI)' (float)Math.Cos(light.InnerAngle / 360.0 * Math.PI)' (float)light.Falloff' 0);                  this.deferredLightingVariables.vLightSpot.Set(ref spot);                  this.deferredLightingVariables.vLightDir.Set(baseX);                  this.deferredLightingVariables.vLightColor.Set(light.Color);                  this.deferredLightingVariables.vLightPos.Set(light.Position.ToVector4());                  this.deferredLightingVariables.vLightAtt.Set(light.Attenuation.ToVector4(100f));                    Matrix lightModelMatrix = new Matrix(                      baseX.X * scaleX' baseX.Y * scaleX' baseX.Z * scaleX' 0f'                      baseY.X * scaleYZ' baseY.Y * scaleYZ' baseY.Z * scaleYZ' 0f'                      baseZ.X * scaleYZ' baseZ.Y * scaleYZ' baseZ.Z * scaleYZ' 0f'                      (float)light.Position.X' (float)light.Position.Y' (float)light.Position.Z' 1.0f                  );                    this.deferredLightingVariables.mLightModel.SetMatrix(lightModelMatrix);                  this.deferredLightingVariables.mLightView.SetMatrix(context.viewMatrix);                  this.deferredLightingVariables.mLightProj.SetMatrix(context.projectionMatrix);                    // --- render the geometry                  pass.Apply(context.DeviceContext);                  context.DeviceContext.DrawIndexed(this.screenCone.IndexCount' 0' 0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,ClearRenderTargetViews,The following statement contains a magic number: this.device.ImmediateContext.ClearRenderTargetView(this.gBufferRenderTargetView[2]' new Color4());
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,ClearRenderTargetViews,The following statement contains a magic number: this.device.ImmediateContext.ClearRenderTargetView(this.gBufferRenderTargetView[3]' new Color4());
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitQuadBuffer,The following statement contains a magic number: int[] indices = { 0' 1' 2' 2' 3' 0 };
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitQuadBuffer,The following statement contains a magic number: int[] indices = { 0' 1' 2' 2' 3' 0 };
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitQuadBuffer,The following statement contains a magic number: int[] indices = { 0' 1' 2' 2' 3' 0 };
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitConeBuffer,The following statement contains a magic number: mesh.AddCone(new Vector3(1.0f' 0.0f' 0.0f)' new Vector3(0.0f' 0.0f' 0.0f)' 1.0' true' 32);
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredLightingVariables,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,DeferredLightingVariables,The following statement contains a magic number: this.gBufferShaderResourceVariables[2] = this.screenGeometryEffect.GetVariableByName("SpecularAlbedoTexture").AsShaderResource();
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredLightingVariables,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,DeferredLightingVariables,The following statement contains a magic number: this.gBufferShaderResourceVariables[3] = this.screenGeometryEffect.GetVariableByName("PositionTexture").AsShaderResource();
Magic Number,HelixToolkit.Wpf.SharpDX,ScreenSpaceProcessingVariables,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,ScreenSpaceProcessingVariables,The following statement contains a magic number: this.ssBufferShaderResourceVariables[2] = this.screenSpaceEffect.GetVariableByName("ScreenSpaceBufferTexture2").AsShaderResource();
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,DPFCanvas,The following statement contains a magic number: MaxRenderingDuration = TimeSpan.FromMilliseconds(20.0);
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,CreateAndBindTargets,The following statement contains a magic number: int width = System.Math.Max((int)ActualWidth' 100);
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,CreateAndBindTargets,The following statement contains a magic number: int height = System.Math.Max((int)ActualHeight' 100);
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,CreateAndBindTargets,The following statement contains a magic number: if (MSAA != MSAALevel.Disable)              {                  do                  {                      var newSampleCount = sampleCount * 2;                      var newSampleQuality = device.CheckMultisampleQualityLevels(Format.B8G8R8A8_UNorm' newSampleCount) - 1;                        if (newSampleQuality < 0)                          break;                        sampleCount = newSampleCount;                      sampleQuality = newSampleQuality;                      if (sampleCount == (int)MSAA)                      {                          break;                      }                  } while (sampleCount < 32);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,CreateAndBindTargets,The following statement contains a magic number: if (MSAA != MSAALevel.Disable)              {                  do                  {                      var newSampleCount = sampleCount * 2;                      var newSampleQuality = device.CheckMultisampleQualityLevels(Format.B8G8R8A8_UNorm' newSampleCount) - 1;                        if (newSampleQuality < 0)                          break;                        sampleCount = newSampleCount;                      sampleQuality = newSampleQuality;                      if (sampleCount == (int)MSAA)                      {                          break;                      }                  } while (sampleCount < 32);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,Render,The following statement contains a magic number: if (renderRenderable != null)              {                  // ---------------------------------------------------------------------------                  // this part is done only if the scene is not attached                  // it is an attach and init pass for all elements in the scene-graph                                  if (!sceneAttached)                  {                      try                      {                          Light3DSceneShared.Reset();                          sceneAttached = true;                          ClearColor = renderRenderable.BackgroundColor;                          IsShadowMapEnabled = renderRenderable.IsShadowMappingEnabled;                            RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager?.RenderTechniques[DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique;                            if (renderContext != null)                          {                              renderContext.Dispose();                          }                          renderContext = new RenderContext(this' EffectsManager.GetEffect(RenderTechnique)' device.ImmediateContext);                          renderContext.EnableBoundingFrustum = EnableRenderFrustum;                          if (EnableSharingModelMode && SharedModelContainer != null)                          {                              SharedModelContainer.CurrentRenderHost = this;                              renderRenderable.Attach(SharedModelContainer);                          }                          else                          {                              renderRenderable.Attach(this);                          }                            RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.GBuffer' out gbuffer);                          RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.Deferred' out deferred);                            if (RenderTechnique == deferred)                          {                              deferredRenderer.InitBuffers(this' Format.R32G32B32A32_Float);                          }                          else if (RenderTechnique == gbuffer)                          {                              deferredRenderer.InitBuffers(this' Format.B8G8R8A8_UNorm);                          }                      }                      catch (Exception ex)                      {                          //MessageBox.Show("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          Debug.WriteLine("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          throw;                      }                  }                  renderContext.TimeStamp = timeStamp;                  // ---------------------------------------------------------------------------                  // this part is per frame                  // ---------------------------------------------------------------------------                  if (EnableSharingModelMode && SharedModelContainer != null)                  {                      SharedModelContainer.CurrentRenderHost = this;                      ClearRenderTarget();                  }                  else                  {                      SetDefaultRenderTargets(true);                  }                    if (RenderTechnique == deferred)                  {                      // set G-Buffer                                          deferredRenderer.SetGBufferTargets(renderContext);                        // render G-Buffer pass                                      renderRenderable.Render(renderContext);                        // call deferred render                       deferredRenderer.RenderDeferred(renderContext' renderRenderable);                    }                  else if (RenderTechnique == gbuffer)                  {                      // set G-Buffer                      deferredRenderer.SetGBufferTargets(targetWidth / 2' targetHeight / 2' renderContext);                        // render G-Buffer pass                                          renderRenderable.Render(renderContext);                        // reset render targets and run lighting pass                                           #if MSAA                      deferredRenderer.RenderGBufferOutput(renderContext' ref renderTargetNMS);  #else                      this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer);  #endif                  }                  else                  {                      renderRenderable.Render(renderContext);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,Render,The following statement contains a magic number: if (renderRenderable != null)              {                  // ---------------------------------------------------------------------------                  // this part is done only if the scene is not attached                  // it is an attach and init pass for all elements in the scene-graph                                  if (!sceneAttached)                  {                      try                      {                          Light3DSceneShared.Reset();                          sceneAttached = true;                          ClearColor = renderRenderable.BackgroundColor;                          IsShadowMapEnabled = renderRenderable.IsShadowMappingEnabled;                            RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager?.RenderTechniques[DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique;                            if (renderContext != null)                          {                              renderContext.Dispose();                          }                          renderContext = new RenderContext(this' EffectsManager.GetEffect(RenderTechnique)' device.ImmediateContext);                          renderContext.EnableBoundingFrustum = EnableRenderFrustum;                          if (EnableSharingModelMode && SharedModelContainer != null)                          {                              SharedModelContainer.CurrentRenderHost = this;                              renderRenderable.Attach(SharedModelContainer);                          }                          else                          {                              renderRenderable.Attach(this);                          }                            RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.GBuffer' out gbuffer);                          RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.Deferred' out deferred);                            if (RenderTechnique == deferred)                          {                              deferredRenderer.InitBuffers(this' Format.R32G32B32A32_Float);                          }                          else if (RenderTechnique == gbuffer)                          {                              deferredRenderer.InitBuffers(this' Format.B8G8R8A8_UNorm);                          }                      }                      catch (Exception ex)                      {                          //MessageBox.Show("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          Debug.WriteLine("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          throw;                      }                  }                  renderContext.TimeStamp = timeStamp;                  // ---------------------------------------------------------------------------                  // this part is per frame                  // ---------------------------------------------------------------------------                  if (EnableSharingModelMode && SharedModelContainer != null)                  {                      SharedModelContainer.CurrentRenderHost = this;                      ClearRenderTarget();                  }                  else                  {                      SetDefaultRenderTargets(true);                  }                    if (RenderTechnique == deferred)                  {                      // set G-Buffer                                          deferredRenderer.SetGBufferTargets(renderContext);                        // render G-Buffer pass                                      renderRenderable.Render(renderContext);                        // call deferred render                       deferredRenderer.RenderDeferred(renderContext' renderRenderable);                    }                  else if (RenderTechnique == gbuffer)                  {                      // set G-Buffer                      deferredRenderer.SetGBufferTargets(targetWidth / 2' targetHeight / 2' renderContext);                        // render G-Buffer pass                                          renderRenderable.Render(renderContext);                        // reset render targets and run lighting pass                                           #if MSAA                      deferredRenderer.RenderGBufferOutput(renderContext' ref renderTargetNMS);  #else                      this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer);  #endif                  }                  else                  {                      renderRenderable.Render(renderContext);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,DPFCanvasThreading,The following statement contains a magic number: MaxRenderingDuration = TimeSpan.FromMilliseconds(20.0);
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,CreateAndBindTargets,The following statement contains a magic number: int width = System.Math.Max((int)ActualWidth' 100);
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,CreateAndBindTargets,The following statement contains a magic number: int height = System.Math.Max((int)ActualHeight' 100);
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,CreateAndBindTargets,The following statement contains a magic number: if (MSAA != MSAALevel.Disable)              {                  do                  {                      var newSampleCount = sampleCount * 2;                      var newSampleQuality = device.CheckMultisampleQualityLevels(Format.B8G8R8A8_UNorm' newSampleCount) - 1;                        if (newSampleQuality < 0)                          break;                        sampleCount = newSampleCount;                      sampleQuality = newSampleQuality;                      if (sampleCount == (int)MSAA)                      {                          break;                      }                  } while (sampleCount < 32);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,CreateAndBindTargets,The following statement contains a magic number: if (MSAA != MSAALevel.Disable)              {                  do                  {                      var newSampleCount = sampleCount * 2;                      var newSampleQuality = device.CheckMultisampleQualityLevels(Format.B8G8R8A8_UNorm' newSampleCount) - 1;                        if (newSampleQuality < 0)                          break;                        sampleCount = newSampleCount;                      sampleQuality = newSampleQuality;                      if (sampleCount == (int)MSAA)                      {                          break;                      }                  } while (sampleCount < 32);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,The following statement contains a magic number: if (renderRenderable != null)              {                  // ---------------------------------------------------------------------------                  // this part is done only if the scene is not attached                  // it is an attach and init pass for all elements in the scene-graph                                  if (!sceneAttached)                  {                      try                      {                          Light3DSceneShared.Reset();                          sceneAttached = true;                          ClearColor = renderRenderable.BackgroundColor;                          IsShadowMapEnabled = renderRenderable.IsShadowMappingEnabled;                            RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager?.RenderTechniques[DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique;                            if (renderContext != null)                          {                              renderContext.Dispose();                          }                          renderContext = new RenderContext(this' EffectsManager.GetEffect(RenderTechnique)' deferredContext);                          renderContext.EnableBoundingFrustum = EnableRenderFrustum;                          if (EnableSharingModelMode && SharedModelContainer != null)                          {                              SharedModelContainer.CurrentRenderHost = this;                              renderRenderable.Attach(SharedModelContainer);                          }                          else                          {                              renderRenderable.Attach(this);                          }                            RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.GBuffer' out gbuffer);                          RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.Deferred' out deferred);                            if (RenderTechnique == deferred)                          {                              deferredRenderer.InitBuffers(this' Format.R32G32B32A32_Float);                          }                          else if (RenderTechnique == gbuffer)                          {                              deferredRenderer.InitBuffers(this' Format.B8G8R8A8_UNorm);                          }                      }                      catch (Exception ex)                      {                          //MessageBox.Show("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          Debug.WriteLine("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          throw;                      }                  }                    // ---------------------------------------------------------------------------                  // this part is per frame                  // ---------------------------------------------------------------------------                  renderContext.TimeStamp = timeStamp;                  if (EnableSharingModelMode && SharedModelContainer != null)                  {                      SharedModelContainer.CurrentRenderHost = this;                      ClearRenderTarget();                  }                  else                  {                      SetDefaultRenderTargets(true);                  }                    if (RenderTechnique == deferred)                  {                      // set G-Buffer                                          deferredRenderer.SetGBufferTargets(renderContext);                      // render G-Buffer pass                                      renderRenderable.Render(renderContext);                        // call deferred render                       deferredRenderer.RenderDeferred(renderContext' renderRenderable);                    }                  else if (RenderTechnique == gbuffer)                  {                      // set G-Buffer                      deferredRenderer.SetGBufferTargets(targetWidth / 2' targetHeight / 2' renderContext);                      // render G-Buffer pass                                          renderRenderable.Render(renderContext);                        // reset render targets and run lighting pass                                           #if MSAA                      deferredRenderer.RenderGBufferOutput(renderContext' ref renderTargetNMS);  #else                      this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer);  #endif                  }                  else                  {                      renderRenderable.Render(renderContext);                  }  #if MSAA                  renderContext.DeviceContext.ResolveSubresource(colorBuffer' 0' renderTargetNMS' 0' Format.B8G8R8A8_UNorm);  #endif                  var command = renderContext.DeviceContext.FinishCommandList(true);                  mRenderThread.InvalidateD3D(command);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,The following statement contains a magic number: if (renderRenderable != null)              {                  // ---------------------------------------------------------------------------                  // this part is done only if the scene is not attached                  // it is an attach and init pass for all elements in the scene-graph                                  if (!sceneAttached)                  {                      try                      {                          Light3DSceneShared.Reset();                          sceneAttached = true;                          ClearColor = renderRenderable.BackgroundColor;                          IsShadowMapEnabled = renderRenderable.IsShadowMappingEnabled;                            RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager?.RenderTechniques[DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique;                            if (renderContext != null)                          {                              renderContext.Dispose();                          }                          renderContext = new RenderContext(this' EffectsManager.GetEffect(RenderTechnique)' deferredContext);                          renderContext.EnableBoundingFrustum = EnableRenderFrustum;                          if (EnableSharingModelMode && SharedModelContainer != null)                          {                              SharedModelContainer.CurrentRenderHost = this;                              renderRenderable.Attach(SharedModelContainer);                          }                          else                          {                              renderRenderable.Attach(this);                          }                            RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.GBuffer' out gbuffer);                          RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.Deferred' out deferred);                            if (RenderTechnique == deferred)                          {                              deferredRenderer.InitBuffers(this' Format.R32G32B32A32_Float);                          }                          else if (RenderTechnique == gbuffer)                          {                              deferredRenderer.InitBuffers(this' Format.B8G8R8A8_UNorm);                          }                      }                      catch (Exception ex)                      {                          //MessageBox.Show("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          Debug.WriteLine("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          throw;                      }                  }                    // ---------------------------------------------------------------------------                  // this part is per frame                  // ---------------------------------------------------------------------------                  renderContext.TimeStamp = timeStamp;                  if (EnableSharingModelMode && SharedModelContainer != null)                  {                      SharedModelContainer.CurrentRenderHost = this;                      ClearRenderTarget();                  }                  else                  {                      SetDefaultRenderTargets(true);                  }                    if (RenderTechnique == deferred)                  {                      // set G-Buffer                                          deferredRenderer.SetGBufferTargets(renderContext);                      // render G-Buffer pass                                      renderRenderable.Render(renderContext);                        // call deferred render                       deferredRenderer.RenderDeferred(renderContext' renderRenderable);                    }                  else if (RenderTechnique == gbuffer)                  {                      // set G-Buffer                      deferredRenderer.SetGBufferTargets(targetWidth / 2' targetHeight / 2' renderContext);                      // render G-Buffer pass                                          renderRenderable.Render(renderContext);                        // reset render targets and run lighting pass                                           #if MSAA                      deferredRenderer.RenderGBufferOutput(renderContext' ref renderTargetNMS);  #else                      this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer);  #endif                  }                  else                  {                      renderRenderable.Render(renderContext);                  }  #if MSAA                  renderContext.DeviceContext.ResolveSubresource(colorBuffer' 0' renderTargetNMS' 0' Format.B8G8R8A8_UNorm);  #endif                  var command = renderContext.DeviceContext.FinishCommandList(true);                  mRenderThread.InvalidateD3D(command);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,DPFSurfaceSwapChain,The following statement contains a magic number: MaxRenderingDuration = TimeSpan.FromMilliseconds(20.0);
Magic Number,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,CreateAndBindTargets,The following statement contains a magic number: int width = System.Math.Max((int)ActualWidth' 100);
Magic Number,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,CreateAndBindTargets,The following statement contains a magic number: int height = System.Math.Max((int)ActualHeight' 100);
Magic Number,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,CreateSwapChainDescription,The following statement contains a magic number: if (MSAA != MSAALevel.Disable)              {                  do                  {                      var newSampleCount = sampleCount * 2;                      var newSampleQuality = device.CheckMultisampleQualityLevels(Format.B8G8R8A8_UNorm' newSampleCount) - 1;                        if (newSampleQuality < 0)                          break;                        sampleCount = newSampleCount;                      sampleQuality = newSampleQuality;                      if (sampleCount == (int)MSAA)                      {                          break;                      }                  } while (sampleCount < 32);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,CreateSwapChainDescription,The following statement contains a magic number: if (MSAA != MSAALevel.Disable)              {                  do                  {                      var newSampleCount = sampleCount * 2;                      var newSampleQuality = device.CheckMultisampleQualityLevels(Format.B8G8R8A8_UNorm' newSampleCount) - 1;                        if (newSampleQuality < 0)                          break;                        sampleCount = newSampleCount;                      sampleQuality = newSampleQuality;                      if (sampleCount == (int)MSAA)                      {                          break;                      }                  } while (sampleCount < 32);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,Render,The following statement contains a magic number: if (renderRenderable != null)              {                  // ---------------------------------------------------------------------------                  // this part is done only if the scene is not attached                  // it is an attach and init pass for all elements in the scene-graph                                  if (!sceneAttached)                  {                      try                      {                          Light3DSceneShared.Reset();                          sceneAttached = true;                          ClearColor = renderRenderable.BackgroundColor;                          IsShadowMapEnabled = renderRenderable.IsShadowMappingEnabled;                            RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager?.RenderTechniques[DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique;                            if (renderContext != null)                          {                              renderContext.Dispose();                          }                          renderContext = new RenderContext(this' EffectsManager.GetEffect(RenderTechnique)' device.ImmediateContext);                          renderContext.EnableBoundingFrustum = EnableRenderFrustum;                          if (EnableSharingModelMode && SharedModelContainer != null)                          {                              SharedModelContainer.CurrentRenderHost = this;                              renderRenderable.Attach(SharedModelContainer);                          }                          else                          {                              renderRenderable.Attach(this);                          }                            RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.GBuffer' out gbuffer);                          RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.Deferred' out deferred);                            if (RenderTechnique == deferred)                          {                              deferredRenderer.InitBuffers(this' Format.R32G32B32A32_Float);                          }                          else if (RenderTechnique == gbuffer)                          {                              deferredRenderer.InitBuffers(this' Format.B8G8R8A8_UNorm);                          }                      }                      catch (Exception ex)                      {                          //MessageBox.Show("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          Debug.WriteLine("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          throw;                      }                  }                  renderContext.TimeStamp = timeStamp;                  // ---------------------------------------------------------------------------                  // this part is per frame                  // ---------------------------------------------------------------------------                  if (EnableSharingModelMode && SharedModelContainer != null)                  {                      SharedModelContainer.CurrentRenderHost = this;                      ClearRenderTarget();                  }                  else                  {                      SetDefaultRenderTargets(true);                  }                  if (RenderTechnique == deferred)                  {                      // set G-Buffer                                          deferredRenderer.SetGBufferTargets(renderContext);                        // render G-Buffer pass                                      renderRenderable.Render(renderContext);                        // call deferred render                       deferredRenderer.RenderDeferred(renderContext' renderRenderable);                    }                  else if (RenderTechnique == gbuffer)                  {                      // set G-Buffer                      deferredRenderer.SetGBufferTargets(targetWidth / 2' targetHeight / 2' renderContext);                        // render G-Buffer pass                                          renderRenderable.Render(renderContext);                        // reset render targets and run lighting pass                                           #if DoubleBuffer                      deferredRenderer.RenderGBufferOutput(renderContext' ref backBuffer);  #else                      this.deferredRenderer.RenderGBufferOutput(renderContext' ref this.backBuffer);  #endif                  }                  else                  {                      renderRenderable.Render(renderContext);                  }  #if DoubleBuffer                  device.ImmediateContext.ResolveSubresource(colorBuffer' 0' backBuffer' 0' Format.B8G8R8A8_UNorm);  #endif              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChain,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChain.cs,Render,The following statement contains a magic number: if (renderRenderable != null)              {                  // ---------------------------------------------------------------------------                  // this part is done only if the scene is not attached                  // it is an attach and init pass for all elements in the scene-graph                                  if (!sceneAttached)                  {                      try                      {                          Light3DSceneShared.Reset();                          sceneAttached = true;                          ClearColor = renderRenderable.BackgroundColor;                          IsShadowMapEnabled = renderRenderable.IsShadowMappingEnabled;                            RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager?.RenderTechniques[DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique;                            if (renderContext != null)                          {                              renderContext.Dispose();                          }                          renderContext = new RenderContext(this' EffectsManager.GetEffect(RenderTechnique)' device.ImmediateContext);                          renderContext.EnableBoundingFrustum = EnableRenderFrustum;                          if (EnableSharingModelMode && SharedModelContainer != null)                          {                              SharedModelContainer.CurrentRenderHost = this;                              renderRenderable.Attach(SharedModelContainer);                          }                          else                          {                              renderRenderable.Attach(this);                          }                            RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.GBuffer' out gbuffer);                          RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.Deferred' out deferred);                            if (RenderTechnique == deferred)                          {                              deferredRenderer.InitBuffers(this' Format.R32G32B32A32_Float);                          }                          else if (RenderTechnique == gbuffer)                          {                              deferredRenderer.InitBuffers(this' Format.B8G8R8A8_UNorm);                          }                      }                      catch (Exception ex)                      {                          //MessageBox.Show("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          Debug.WriteLine("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          throw;                      }                  }                  renderContext.TimeStamp = timeStamp;                  // ---------------------------------------------------------------------------                  // this part is per frame                  // ---------------------------------------------------------------------------                  if (EnableSharingModelMode && SharedModelContainer != null)                  {                      SharedModelContainer.CurrentRenderHost = this;                      ClearRenderTarget();                  }                  else                  {                      SetDefaultRenderTargets(true);                  }                  if (RenderTechnique == deferred)                  {                      // set G-Buffer                                          deferredRenderer.SetGBufferTargets(renderContext);                        // render G-Buffer pass                                      renderRenderable.Render(renderContext);                        // call deferred render                       deferredRenderer.RenderDeferred(renderContext' renderRenderable);                    }                  else if (RenderTechnique == gbuffer)                  {                      // set G-Buffer                      deferredRenderer.SetGBufferTargets(targetWidth / 2' targetHeight / 2' renderContext);                        // render G-Buffer pass                                          renderRenderable.Render(renderContext);                        // reset render targets and run lighting pass                                           #if DoubleBuffer                      deferredRenderer.RenderGBufferOutput(renderContext' ref backBuffer);  #else                      this.deferredRenderer.RenderGBufferOutput(renderContext' ref this.backBuffer);  #endif                  }                  else                  {                      renderRenderable.Render(renderContext);                  }  #if DoubleBuffer                  device.ImmediateContext.ResolveSubresource(colorBuffer' 0' backBuffer' 0' Format.B8G8R8A8_UNorm);  #endif              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,DPFSurfaceSwapChainThreading,The following statement contains a magic number: MaxRenderingDuration = TimeSpan.FromMilliseconds(20.0);
Magic Number,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,CreateAndBindTargets,The following statement contains a magic number: int width = System.Math.Max((int)ActualWidth' 100);
Magic Number,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,CreateAndBindTargets,The following statement contains a magic number: int height = System.Math.Max((int)ActualHeight' 100);
Magic Number,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,CreateSwapChainDescription,The following statement contains a magic number: if (MSAA != MSAALevel.Disable)              {                  do                  {                      var newSampleCount = sampleCount * 2;                      var newSampleQuality = device.CheckMultisampleQualityLevels(Format.B8G8R8A8_UNorm' newSampleCount) - 1;                        if (newSampleQuality < 0)                          break;                        sampleCount = newSampleCount;                      sampleQuality = newSampleQuality;                      if (sampleCount == (int)MSAA)                      {                          break;                      }                  } while (sampleCount < 32);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,CreateSwapChainDescription,The following statement contains a magic number: if (MSAA != MSAALevel.Disable)              {                  do                  {                      var newSampleCount = sampleCount * 2;                      var newSampleQuality = device.CheckMultisampleQualityLevels(Format.B8G8R8A8_UNorm' newSampleCount) - 1;                        if (newSampleQuality < 0)                          break;                        sampleCount = newSampleCount;                      sampleQuality = newSampleQuality;                      if (sampleCount == (int)MSAA)                      {                          break;                      }                  } while (sampleCount < 32);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,Render,The following statement contains a magic number: if (renderRenderable != null)              {                  // ---------------------------------------------------------------------------                  // this part is done only if the scene is not attached                  // it is an attach and init pass for all elements in the scene-graph                                  if (!sceneAttached)                  {                      try                      {                          Light3DSceneShared.Reset();                          sceneAttached = true;                          ClearColor = renderRenderable.BackgroundColor;                          IsShadowMapEnabled = renderRenderable.IsShadowMappingEnabled;                            RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager?.RenderTechniques[DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique;                            if (renderContext != null)                          {                              renderContext.Dispose();                          }                          renderContext = new RenderContext(this' EffectsManager.GetEffect(RenderTechnique)' deferredContext);                          renderContext.EnableBoundingFrustum = EnableRenderFrustum;                          if (EnableSharingModelMode && SharedModelContainer != null)                          {                              SharedModelContainer.CurrentRenderHost = this;                              renderRenderable.Attach(SharedModelContainer);                          }                          else                          {                              renderRenderable.Attach(this);                          }                            RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.GBuffer' out gbuffer);                          RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.Deferred' out deferred);                            if (RenderTechnique == deferred)                          {                              deferredRenderer.InitBuffers(this' Format.R32G32B32A32_Float);                          }                          else if (RenderTechnique == gbuffer)                          {                              deferredRenderer.InitBuffers(this' Format.B8G8R8A8_UNorm);                          }                      }                      catch (Exception ex)                      {                          //MessageBox.Show("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          Debug.WriteLine("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          throw;                      }                  }                  renderContext.TimeStamp = timeStamp;                  renderContext.DeviceContext = deferredContext;                  // ---------------------------------------------------------------------------                  // this part is per frame                  // ---------------------------------------------------------------------------                  if (EnableSharingModelMode && SharedModelContainer != null)                  {                      SharedModelContainer.CurrentRenderHost = this;                      ClearRenderTarget();                  }                  else                  {                      SetDefaultRenderTargets(true);                  }                  if (RenderTechnique == deferred)                  {                      // set G-Buffer                                          deferredRenderer.SetGBufferTargets(renderContext);                        // render G-Buffer pass                                      renderRenderable.Render(renderContext);                        // call deferred render                       deferredRenderer.RenderDeferred(renderContext' renderRenderable);                    }                  else if (RenderTechnique == gbuffer)                  {                      // set G-Buffer                      deferredRenderer.SetGBufferTargets(targetWidth / 2' targetHeight / 2' renderContext);                        // render G-Buffer pass                                          renderRenderable.Render(renderContext);                        // reset render targets and run lighting pass                                           #if DoubleBuffer                      deferredRenderer.RenderGBufferOutput(renderContext' ref backBuffer);  #else                      this.deferredRenderer.RenderGBufferOutput(renderContext' ref this.backBuffer);  #endif                  }                  else                  {                      renderRenderable.Render(renderContext);                  }  #if DoubleBuffer                  device.ImmediateContext.ResolveSubresource(colorBuffer' 0' backBuffer' 0' Format.B8G8R8A8_UNorm);  #endif              }
Magic Number,HelixToolkit.Wpf.SharpDX,DPFSurfaceSwapChainThreading,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFSurfaceSwapChainThreading.cs,Render,The following statement contains a magic number: if (renderRenderable != null)              {                  // ---------------------------------------------------------------------------                  // this part is done only if the scene is not attached                  // it is an attach and init pass for all elements in the scene-graph                                  if (!sceneAttached)                  {                      try                      {                          Light3DSceneShared.Reset();                          sceneAttached = true;                          ClearColor = renderRenderable.BackgroundColor;                          IsShadowMapEnabled = renderRenderable.IsShadowMappingEnabled;                            RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager?.RenderTechniques[DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique;                            if (renderContext != null)                          {                              renderContext.Dispose();                          }                          renderContext = new RenderContext(this' EffectsManager.GetEffect(RenderTechnique)' deferredContext);                          renderContext.EnableBoundingFrustum = EnableRenderFrustum;                          if (EnableSharingModelMode && SharedModelContainer != null)                          {                              SharedModelContainer.CurrentRenderHost = this;                              renderRenderable.Attach(SharedModelContainer);                          }                          else                          {                              renderRenderable.Attach(this);                          }                            RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.GBuffer' out gbuffer);                          RenderTechniquesManager.RenderTechniques.TryGetValue(DeferredRenderTechniqueNames.Deferred' out deferred);                            if (RenderTechnique == deferred)                          {                              deferredRenderer.InitBuffers(this' Format.R32G32B32A32_Float);                          }                          else if (RenderTechnique == gbuffer)                          {                              deferredRenderer.InitBuffers(this' Format.B8G8R8A8_UNorm);                          }                      }                      catch (Exception ex)                      {                          //MessageBox.Show("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          Debug.WriteLine("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");                          throw;                      }                  }                  renderContext.TimeStamp = timeStamp;                  renderContext.DeviceContext = deferredContext;                  // ---------------------------------------------------------------------------                  // this part is per frame                  // ---------------------------------------------------------------------------                  if (EnableSharingModelMode && SharedModelContainer != null)                  {                      SharedModelContainer.CurrentRenderHost = this;                      ClearRenderTarget();                  }                  else                  {                      SetDefaultRenderTargets(true);                  }                  if (RenderTechnique == deferred)                  {                      // set G-Buffer                                          deferredRenderer.SetGBufferTargets(renderContext);                        // render G-Buffer pass                                      renderRenderable.Render(renderContext);                        // call deferred render                       deferredRenderer.RenderDeferred(renderContext' renderRenderable);                    }                  else if (RenderTechnique == gbuffer)                  {                      // set G-Buffer                      deferredRenderer.SetGBufferTargets(targetWidth / 2' targetHeight / 2' renderContext);                        // render G-Buffer pass                                          renderRenderable.Render(renderContext);                        // reset render targets and run lighting pass                                           #if DoubleBuffer                      deferredRenderer.RenderGBufferOutput(renderContext' ref backBuffer);  #else                      this.deferredRenderer.RenderGBufferOutput(renderContext' ref this.backBuffer);  #endif                  }                  else                  {                      renderRenderable.Render(renderContext);                  }  #if DoubleBuffer                  device.ImmediateContext.ResolveSubresource(colorBuffer' 0' backBuffer' 0' Format.B8G8R8A8_UNorm);  #endif              }
Magic Number,HelixToolkit.Wpf.SharpDX,RenderTechnique,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\RenderTechnique.cs,RenderTechnique,The following statement contains a magic number: var is64 = IntPtr.Size == 8;
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,ShowZoomRectangle,The following statement contains a magic number: this.rectangleAdorner = new RectangleAdorner(                  visual' rect' Colors.LightGray' Colors.Black' 3' 1' 10' DashStyles.Solid);
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,ShowZoomRectangle,The following statement contains a magic number: this.rectangleAdorner = new RectangleAdorner(                  visual' rect' Colors.LightGray' Colors.Black' 3' 1' 10' DashStyles.Solid);
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnCameraChanged,The following statement contains a magic number: if (this.coordinateView != null)              {                  var pc = (System.Windows.Media.Media3D.PerspectiveCamera)this.coordinateView.Camera;                  pc.LookDirection = lookdir * 30;                  pc.Position = origin - pc.LookDirection;                  pc.UpDirection = projectionCamera.UpDirection;              }
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnCameraChanged,The following statement contains a magic number: if (this.viewCubeViewport != null)              {                  var pc = (System.Windows.Media.Media3D.PerspectiveCamera)this.viewCubeViewport.Camera;                  pc.LookDirection = lookdir * 20;                  pc.Position = origin - pc.LookDirection;                  pc.UpDirection = projectionCamera.UpDirection;              }
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,GetPressedMouseButtons,The following statement contains a magic number: flags |= (int)Mouse.LeftButton << 20;
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,GetPressedMouseButtons,The following statement contains a magic number: flags |= (int)Mouse.RightButton << 21;
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,GetPressedMouseButtons,The following statement contains a magic number: flags |= (int)Mouse.MiddleButton << 22;
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,GetPressedMouseButtons,The following statement contains a magic number: flags |= (int)Mouse.XButton1 << 23;
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,GetPressedMouseButtons,The following statement contains a magic number: flags |= (int)Mouse.XButton2 << 24;
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,AnimateOpacity,The following statement contains a magic number: var a = new DoubleAnimation(toOpacity' new Duration(TimeSpan.FromMilliseconds(animationTime)))              {                  AccelerationRatio = 0.3'                  DecelerationRatio = 0.5              };
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,AnimateOpacity,The following statement contains a magic number: var a = new DoubleAnimation(toOpacity' new Duration(TimeSpan.FromMilliseconds(animationTime)))              {                  AccelerationRatio = 0.3'                  DecelerationRatio = 0.5              };
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnCompositionTargetRendering,The following statement contains a magic number: if (this.ShowFrameRate && this.fpsWatch.ElapsedMilliseconds > 500)              {                  this.FrameRate = (int)this.FpsCounter.Value;                  this.FrameRateText = this.FrameRate + " FPS";                  this.fpsWatch.Restart();              }
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnCompositionTargetRendering,The following statement contains a magic number: if (this.ShowTriangleCountInfo && this.infoFrameCounter > 100)              {                  int count = this.GetTotalNumberOfTriangles();                  this.TriangleCountInfo = string.Format("Triangles: {0}"' count);                  this.infoFrameCounter = 0;              }
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,ViewCubeClicked,The following statement contains a magic number: pc.AnimateTo(newPosition' e.LookDirection' e.UpDirection' 500);
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,ViewCubeViewportMouseEnter,The following statement contains a magic number: AnimateOpacity(this.viewCubeViewport' 1.0' 200);
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,ViewCubeViewportMouseLeave,The following statement contains a magic number: AnimateOpacity(this.viewCubeViewport' this.ViewCubeOpacity' 200);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0)              {                  var a1 = new Point3DAnimation(                      fromPosition' newPosition' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                    a1.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.PositionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.PositionProperty' a1);                    var a2 = new Vector3DAnimation(                      fromDirection' newDirection' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                  a2.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.LookDirectionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.LookDirectionProperty' a2);                    var a3 = new Vector3DAnimation(                      fromUpDirection' newUpDirection' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                  a3.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.UpDirectionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.UpDirectionProperty' a3);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0)              {                  var a1 = new Point3DAnimation(                      fromPosition' newPosition' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                    a1.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.PositionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.PositionProperty' a1);                    var a2 = new Vector3DAnimation(                      fromDirection' newDirection' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                  a2.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.LookDirectionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.LookDirectionProperty' a2);                    var a3 = new Vector3DAnimation(                      fromUpDirection' newUpDirection' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                  a3.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.UpDirectionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.UpDirectionProperty' a3);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0)              {                  var a1 = new Point3DAnimation(                      fromPosition' newPosition' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                    a1.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.PositionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.PositionProperty' a1);                    var a2 = new Vector3DAnimation(                      fromDirection' newDirection' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                  a2.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.LookDirectionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.LookDirectionProperty' a2);                    var a3 = new Vector3DAnimation(                      fromUpDirection' newUpDirection' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                  a3.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.UpDirectionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.UpDirectionProperty' a3);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0)              {                  var a1 = new Point3DAnimation(                      fromPosition' newPosition' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                    a1.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.PositionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.PositionProperty' a1);                    var a2 = new Vector3DAnimation(                      fromDirection' newDirection' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                  a2.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.LookDirectionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.LookDirectionProperty' a2);                    var a3 = new Vector3DAnimation(                      fromUpDirection' newUpDirection' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                  a3.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.UpDirectionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.UpDirectionProperty' a3);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0)              {                  var a1 = new Point3DAnimation(                      fromPosition' newPosition' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                    a1.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.PositionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.PositionProperty' a1);                    var a2 = new Vector3DAnimation(                      fromDirection' newDirection' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                  a2.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.LookDirectionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.LookDirectionProperty' a2);                    var a3 = new Vector3DAnimation(                      fromUpDirection' newUpDirection' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                  a3.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.UpDirectionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.UpDirectionProperty' a3);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0)              {                  var a1 = new Point3DAnimation(                      fromPosition' newPosition' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                    a1.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.PositionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.PositionProperty' a1);                    var a2 = new Vector3DAnimation(                      fromDirection' newDirection' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                  a2.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.LookDirectionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.LookDirectionProperty' a2);                    var a3 = new Vector3DAnimation(                      fromUpDirection' newUpDirection' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                  a3.Completed += (s' a) => { camera.BeginAnimation(ProjectionCamera.UpDirectionProperty' null); };                  camera.BeginAnimation(ProjectionCamera.UpDirectionProperty' a3);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateWidth,The following statement contains a magic number: if (animationTime > 0)              {                  var a1 = new DoubleAnimation(                      fromWidth' newWidth' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                  camera.BeginAnimation(OrthographicCamera.WidthProperty' a1);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateWidth,The following statement contains a magic number: if (animationTime > 0)              {                  var a1 = new DoubleAnimation(                      fromWidth' newWidth' new Duration(TimeSpan.FromMilliseconds(animationTime)))                      {                          AccelerationRatio = 0.3'                          DecelerationRatio = 0.5'                          FillBehavior = FillBehavior.Stop                      };                  camera.BeginAnimation(OrthographicCamera.WidthProperty' a1);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (pdest != null)              {                  projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance > 0 ? projectionSource.NearPlaneDistance : 1e-1;                  projectionDest.FarPlaneDistance = projectionSource.FarPlaneDistance;                    double fov = 45;                  if (psrc != null)                  {                      fov = psrc.FieldOfView;                  }                    if (osrc != null)                  {                      double dist = projectionSource.LookDirection.Length;                      fov = Math.Atan2(osrc.Width / 2' dist) * (180 / Math.PI);                  }                    pdest.FieldOfView = fov;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (pdest != null)              {                  projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance > 0 ? projectionSource.NearPlaneDistance : 1e-1;                  projectionDest.FarPlaneDistance = projectionSource.FarPlaneDistance;                    double fov = 45;                  if (psrc != null)                  {                      fov = psrc.FieldOfView;                  }                    if (osrc != null)                  {                      double dist = projectionSource.LookDirection.Length;                      fov = Math.Atan2(osrc.Width / 2' dist) * (180 / Math.PI);                  }                    pdest.FieldOfView = fov;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (pdest != null)              {                  projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance > 0 ? projectionSource.NearPlaneDistance : 1e-1;                  projectionDest.FarPlaneDistance = projectionSource.FarPlaneDistance;                    double fov = 45;                  if (psrc != null)                  {                      fov = psrc.FieldOfView;                  }                    if (osrc != null)                  {                      double dist = projectionSource.LookDirection.Length;                      fov = Math.Atan2(osrc.Width / 2' dist) * (180 / Math.PI);                  }                    pdest.FieldOfView = fov;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (pdest != null)              {                  projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance > 0 ? projectionSource.NearPlaneDistance : 1e-1;                  projectionDest.FarPlaneDistance = projectionSource.FarPlaneDistance;                    double fov = 45;                  if (psrc != null)                  {                      fov = psrc.FieldOfView;                  }                    if (osrc != null)                  {                      double dist = projectionSource.LookDirection.Length;                      fov = Math.Atan2(osrc.Width / 2' dist) * (180 / Math.PI);                  }                    pdest.FieldOfView = fov;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (odest != null)              {                  projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance;                  projectionDest.FarPlaneDistance = projectionSource.FarPlaneDistance;                    double width = 100;                  if (psrc != null)                  {                      double dist = projectionSource.LookDirection.Length;                      width = Math.Tan(psrc.FieldOfView / 180 * Math.PI) * 2 * dist;                  }                    if (osrc != null)                  {                      width = osrc.Width;                  }                    odest.Width = width;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (odest != null)              {                  projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance;                  projectionDest.FarPlaneDistance = projectionSource.FarPlaneDistance;                    double width = 100;                  if (psrc != null)                  {                      double dist = projectionSource.LookDirection.Length;                      width = Math.Tan(psrc.FieldOfView / 180 * Math.PI) * 2 * dist;                  }                    if (osrc != null)                  {                      width = osrc.Width;                  }                    odest.Width = width;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (odest != null)              {                  projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance;                  projectionDest.FarPlaneDistance = projectionSource.FarPlaneDistance;                    double width = 100;                  if (psrc != null)                  {                      double dist = projectionSource.LookDirection.Length;                      width = Math.Tan(psrc.FieldOfView / 180 * Math.PI) * 2 * dist;                  }                    if (osrc != null)                  {                      width = osrc.Width;                  }                    odest.Width = width;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,FindPanVector,The following statement contains a magic number: double f = l * 0.001;
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D(20' 10' 40);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D(20' 10' 40);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D(20' 10' 40);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D(-20' -10' -40);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D(-20' -10' -40);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D(-20' -10' -40);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.FieldOfView = 45;
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.NearPlaneDistance = 0.1;
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.FarPlaneDistance = 1000;
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D(20' 10' 40);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D(20' 10' 40);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D(20' 10' 40);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D(-20' -10' -40);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D(-20' -10' -40);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D(-20' -10' -40);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.Width = 40;
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.NearPlaneDistance = 0.1;
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.FarPlaneDistance = 1000;
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: var center = bounds.Location + (diagonal * 0.5);
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: double radius = diagonal.Length * 0.5;
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: if (camera is PerspectiveCamera)              {                  var pcam = camera as PerspectiveCamera;                  double disth = radius / Math.Tan(0.5 * pcam.FieldOfView * Math.PI / 180);                  double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;                  double distv = radius / Math.Tan(0.5 * vfov * Math.PI / 180);                    double dist = Math.Max(disth' distv);                  var dir = projectionCamera.LookDirection;                  dir.Normalize();                  LookAt(projectionCamera' center' dir * dist' animationTime);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: if (camera is PerspectiveCamera)              {                  var pcam = camera as PerspectiveCamera;                  double disth = radius / Math.Tan(0.5 * pcam.FieldOfView * Math.PI / 180);                  double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;                  double distv = radius / Math.Tan(0.5 * vfov * Math.PI / 180);                    double dist = Math.Max(disth' distv);                  var dir = projectionCamera.LookDirection;                  dir.Normalize();                  LookAt(projectionCamera' center' dir * dist' animationTime);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: if (camera is PerspectiveCamera)              {                  var pcam = camera as PerspectiveCamera;                  double disth = radius / Math.Tan(0.5 * pcam.FieldOfView * Math.PI / 180);                  double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;                  double distv = radius / Math.Tan(0.5 * vfov * Math.PI / 180);                    double dist = Math.Max(disth' distv);                  var dir = projectionCamera.LookDirection;                  dir.Normalize();                  LookAt(projectionCamera' center' dir * dist' animationTime);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: if (camera is PerspectiveCamera)              {                  var pcam = camera as PerspectiveCamera;                  double disth = radius / Math.Tan(0.5 * pcam.FieldOfView * Math.PI / 180);                  double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;                  double distv = radius / Math.Tan(0.5 * vfov * Math.PI / 180);                    double dist = Math.Max(disth' distv);                  var dir = projectionCamera.LookDirection;                  dir.Normalize();                  LookAt(projectionCamera' center' dir * dist' animationTime);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: if (camera is OrthographicCamera)              {                  LookAt(projectionCamera' center' projectionCamera.LookDirection' animationTime);                  double newWidth = radius * 2;                    if (viewport.ActualWidth > viewport.ActualHeight)                  {                      newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;                  }                    AnimateWidth(camera as OrthographicCamera' newWidth' animationTime);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: if (camera is OrthographicCamera)              {                  LookAt(projectionCamera' center' projectionCamera.LookDirection' animationTime);                  double newWidth = radius * 2;                    if (viewport.ActualWidth > viewport.ActualHeight)                  {                      newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;                  }                    AnimateWidth(camera as OrthographicCamera' newWidth' animationTime);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomToRectangle,The following statement contains a magic number: var centerRay =                  viewport.UnProjectToRay(                      new Point(                          (zoomRectangle.Left + zoomRectangle.Right) * 0.5'                          (zoomRectangle.Top + zoomRectangle.Bottom) * 0.5));
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomToRectangle,The following statement contains a magic number: var centerRay =                  viewport.UnProjectToRay(                      new Point(                          (zoomRectangle.Left + zoomRectangle.Right) * 0.5'                          (zoomRectangle.Top + zoomRectangle.Bottom) * 0.5));
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomToRectangle,The following statement contains a magic number: if (perspectiveCamera != null)              {                  var distance = pcam.LookDirection.Length;                    // option 1: change distance                  var newDistance = distance * zoomRectangle.Width / viewport.ActualWidth;                  var newLookDirection = newDistance * w;                  var newPosition = perspectiveCamera.Position + ((distance - newDistance) * w);                  var newTarget = newPosition + newLookDirection;                  LookAt(pcam' newTarget' newLookDirection' 200);                    // option 2: change fov                  // double newFieldOfView = Math.Acos(Vector3D.DotProduct(u' v));                  // var newTarget = camera.Position + distance * w;                  // pcamera.FieldOfView = newFieldOfView * 180 / Math.PI;                  // LookAt(camera' newTarget' distance * w' 0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try              {                  RegisterEffect(shaderEffectString'                  new[]                  {                       // put here the techniques which you want to use with this effect                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  });                    var phong = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong];                  defaultInputLayout = new InputLayout(device' GetEffect(phong).GetTechniqueByName(DefaultRenderTechniqueNames.Phong).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var instancingblinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.InstancingBlinn];                  var instancingInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                                     //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var boneSkinBlinn = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BoneSkinBlinn];                  var boneSkinInputLayout = new InputLayout(device' GetEffect(instancingblinn).GetTechniqueByName(DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32_Float'       InputElement.AppendAligned' 0)'                      new InputElement("NORMAL"'   0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("TANGENT"'  0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BINORMAL"' 0' Format.R32G32B32_Float'    InputElement.AppendAligned' 0)'                      new InputElement("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'                      new InputElement("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'                      //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    var lines = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Lines];                  var linesInputLayout = new InputLayout(device' GetEffect(lines).GetTechniqueByName(DefaultRenderTechniqueNames.Lines).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                        //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                  });                    var cubeMap = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CubeMap];                  cubeMapInputLayout = new InputLayout(device' GetEffect(cubeMap).GetTechniqueByName(DefaultRenderTechniqueNames.CubeMap).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                  });                    var points = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Points];                  var pointsInputLayout = new InputLayout(device' GetEffect(points).GetTechniqueByName(DefaultRenderTechniqueNames.Points).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)                  });                    var text = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardText];                  var billboardInputLayout = new InputLayout(device' GetEffect(text).GetTechniqueByName(DefaultRenderTechniqueNames.BillboardText).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float'  InputElement.AppendAligned' 0)'                  });                    var billboardinstancing = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.BillboardInstancing];                  var billboardInstancingInputLayout = new InputLayout(device' GetEffect(billboardinstancing)                      .GetTechniqueByName(DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex(0).Description.Signature' new[]                  {                      new InputElement("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("COLOR"'    0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                      new InputElement("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'                                   //INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern                      new InputElement("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'                      new InputElement("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                      new InputElement("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'                  });                    //var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];                  //var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)                  //    .GetPassByIndex(2).Description.Signature'                  //    null);                    RegisterLayout(new[] { cubeMap }' cubeMapInputLayout);                    RegisterLayout(new[]                  {                      lines                  }'                  linesInputLayout);                    RegisterLayout(new[]                  {                      points                  }'                  pointsInputLayout);                    RegisterLayout(new[]                  {                      text                  }'                  billboardInputLayout);                    RegisterLayout(new[]                  {                       // put here techniques which use the vertex layout below                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Phong]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Blinn]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Diffuse]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Positions]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Normals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.PerturbedNormals]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Tangents]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.TexCoords]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Colors]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.Wires]'                      renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.CrossSection]                  }' defaultInputLayout);                    RegisterLayout(new[] { instancingblinn }' instancingInputLayout);                    RegisterLayout(new[] { boneSkinBlinn }' boneSkinInputLayout);                    RegisterLayout(new[] { billboardinstancing }' billboardInstancingInputLayout);                 //   RegisterLayout(new[] { particle }' particleLayout);              }              catch (Exception ex)              {                  Debug.WriteLine(string.Format("Error registering effect: {0}"' ex.Message)' "Error");                  throw;              }
Magic Number,HelixToolkit.Wpf.SharpDX,FpsCounter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\FpsCounter.cs,TrimFrames,The following statement contains a magic number: while (m_frames.Count > 10 && Math.Abs(m_frames.Last - m_frames.First) > MinimumUpdateDuration                  && (target > m_frames.First || m_frames.First > m_frames.Last || m_frames.IsFull())) //the second condition happened when switching tabs' the TotalMilliseconds reset to 0 from composite rendering              {                  m_frames.RemoveFirst();              }
Magic Number,HelixToolkit.Wpf.SharpDX,FpsCounter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\FpsCounter.cs,UpdateValue,The following statement contains a magic number: if (m_frames.Count < 2)              {                  Value = -1;              }              else              {                  var dt = m_frames.Last - m_frames.First;                  if(dt > MinimumUpdateDuration)                      Value = m_frames.Count / (dt/1000);              }
Magic Number,HelixToolkit.Wpf.SharpDX,FpsCounter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\FpsCounter.cs,UpdateValue,The following statement contains a magic number: if (m_frames.Count < 2)              {                  Value = -1;              }              else              {                  var dt = m_frames.Last - m_frames.First;                  if(dt > MinimumUpdateDuration)                      Value = m_frames.Count / (dt/1000);              }
Magic Number,HelixToolkit.Wpf.SharpDX,PanHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\PanHandler.cs,OnInertiaStarting,The following statement contains a magic number: var speed = (this.LastPoint - this.MouseDownPoint) * (40.0 / elapsedTime);
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,Rotate,The following statement contains a magic number: if (Math.Abs(this.Camera.UpDirection.Length - 1) > 1e-8)              {                  this.Camera.UpDirection.Normalize();              }
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,RotateTurnball,The following statement contains a magic number: if (this.CameraMode != CameraMode.Inspect)              {                  d = 0.2;              }
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,RotateTurnball,The following statement contains a magic number: if ((newUpDirection - modUpDir).Length > 1e-8)              {                  newUpDirection = modUpDir;              }
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,RotateTurntable,The following statement contains a magic number: double d = -0.5;
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,RotateTurntable,The following statement contains a magic number: if (this.CameraMode != CameraMode.Inspect)              {                  d *= -0.2;              }
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,Started,The following statement contains a magic number: this.rotationPoint = new Point(                  this.Viewport.ActualWidth / 2' this.Viewport.ActualHeight / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,Started,The following statement contains a magic number: this.rotationPoint = new Point(                  this.Viewport.ActualWidth / 2' this.Viewport.ActualHeight / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,OnInertiaStarting,The following statement contains a magic number: this.Viewport.StartSpin(                  4 * delta * ((double)this.Viewport.SpinReleaseTime / elapsedTime)'                  this.MouseDownPoint'                  this.rotationPoint3D);
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,ProjectToTrackball,The following statement contains a magic number: double r = Math.Sqrt((w * w) + (h * h)) / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,ProjectToTrackball,The following statement contains a magic number: double x = (point.X - (w / 2)) / r;
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,ProjectToTrackball,The following statement contains a magic number: double y = ((h / 2) - point.Y) / r;
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,InitTurnballRotationAxes,The following statement contains a magic number: if (fy > 0.8 || fy < 0.2)              {                  // delta.Y = 0;              }
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,InitTurnballRotationAxes,The following statement contains a magic number: if (fy > 0.8 || fy < 0.2)              {                  // delta.Y = 0;              }
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,InitTurnballRotationAxes,The following statement contains a magic number: if (fx > 0.8)              {                  // delta.X = 0;                  this.rotationAxisY = dir;              }
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,InitTurnballRotationAxes,The following statement contains a magic number: if (fx < 0.2)              {                  // delta.X = 0;                  this.rotationAxisY = -dir;              }
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,RotateTrackball,The following statement contains a magic number: if (axis.LengthSquared < 1e-8)              {                  return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,RotateTrackball,The following statement contains a magic number: var delta = new Quaternion(axis' -angle * this.RotationSensitivity * 5);
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Delta,The following statement contains a magic number: this.Zoom(delta.Y * 0.01' this.zoomPoint3D);
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Started,The following statement contains a magic number: this.zoomPoint = new Point(this.Viewport.ActualWidth / 2' this.Viewport.ActualHeight / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Started,The following statement contains a magic number: this.zoomPoint = new Point(this.Viewport.ActualWidth / 2' this.Viewport.ActualHeight / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Zoom,The following statement contains a magic number: if (this.Camera is PerspectiveCamera)              {                  if (delta < -0.5)                  {                      delta = -0.5;                  }                    delta *= this.ZoomSensitivity;                    if (this.CameraMode == CameraMode.FixedPosition || this.changeFieldOfView)                  {                      this.Viewport.ZoomByChangingFieldOfView(delta);                  }                  else                  {                      switch (this.CameraMode)                      {                          case CameraMode.Inspect:                              this.ChangeCameraDistance(delta' zoomAround);                              break;                          case CameraMode.WalkAround:                              this.Camera.Position -= this.Camera.LookDirection * delta;                              break;                      }                  }                    return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Zoom,The following statement contains a magic number: if (this.Camera is PerspectiveCamera)              {                  if (delta < -0.5)                  {                      delta = -0.5;                  }                    delta *= this.ZoomSensitivity;                    if (this.CameraMode == CameraMode.FixedPosition || this.changeFieldOfView)                  {                      this.Viewport.ZoomByChangingFieldOfView(delta);                  }                  else                  {                      switch (this.CameraMode)                      {                          case CameraMode.Inspect:                              this.ChangeCameraDistance(delta' zoomAround);                              break;                          case CameraMode.WalkAround:                              this.Camera.Position -= this.Camera.LookDirection * delta;                              break;                      }                  }                    return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ZoomByChangingCameraWidth,The following statement contains a magic number: if (delta < -0.5)              {                  delta = -0.5;              }
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ZoomByChangingCameraWidth,The following statement contains a magic number: if (delta < -0.5)              {                  delta = -0.5;              }
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ZoomByChangingCameraWidth,The following statement contains a magic number: switch (this.CameraMode)              {                  case CameraMode.WalkAround:                  case CameraMode.Inspect:                  case CameraMode.FixedPosition:                      this.ChangeCameraDistance(delta' zoomAround);                        // Modify the camera width                      var ocamera = this.Camera as OrthographicCamera;                      if (ocamera != null)                      {                          ocamera.Width *= Math.Pow(2.5' delta);                      }                        break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ChangeCameraDistance,The following statement contains a magic number: if (relativePosition.Length < 1e-4)              {                  if (delta > 0) //If Zoom out from very close distance' increase the initial relativePosition                  {                      relativePosition.Normalize();                      relativePosition /= 10;                  }                  else//If Zoom in too close' stop it.                  {                      return;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ChangeCameraDistance,The following statement contains a magic number: if (relativePosition.Length < 1e-4)              {                  if (delta > 0) //If Zoom out from very close distance' increase the initial relativePosition                  {                      relativePosition.Normalize();                      relativePosition /= 10;                  }                  else//If Zoom in too close' stop it.                  {                      return;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ChangeCameraDistance,The following statement contains a magic number: var f = Math.Pow(2.5' delta);
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomRectangleHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomRectangleHandler.cs,ZoomRectangle,The following statement contains a magic number: if (rectangle.Width < 10 || rectangle.Height < 10)              {                  return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomRectangleHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomRectangleHandler.cs,ZoomRectangle,The following statement contains a magic number: if (rectangle.Width < 10 || rectangle.Height < 10)              {                  return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetTotalNumberOfTriangles,The following statement contains a magic number: foreach (var item in viewport.Renderables)              {                  var model = item as MeshGeometryModel3D;                  if (model != null)                  {                      if (model.Visibility == Visibility.Visible)                          count += model.Geometry.Indices.Count / 3;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetViewportMatrix,The following statement contains a magic number: return new Matrix(                  (float)(viewport.ActualWidth / 2)'                  0'                  0'                  0'                  0'                  (float)(-viewport.ActualHeight / 2)'                  0'                  0'                  0'                  0'                  1'                  0'                  (float)((viewport.ActualWidth - 1) / 2)'                  (float)((viewport.ActualHeight - 1) / 2)'                  0'                  1);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetViewportMatrix,The following statement contains a magic number: return new Matrix(                  (float)(viewport.ActualWidth / 2)'                  0'                  0'                  0'                  0'                  (float)(-viewport.ActualHeight / 2)'                  0'                  0'                  0'                  0'                  1'                  0'                  (float)((viewport.ActualWidth - 1) / 2)'                  (float)((viewport.ActualHeight - 1) / 2)'                  0'                  1);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetViewportMatrix,The following statement contains a magic number: return new Matrix(                  (float)(viewport.ActualWidth / 2)'                  0'                  0'                  0'                  0'                  (float)(-viewport.ActualHeight / 2)'                  0'                  0'                  0'                  0'                  1'                  0'                  (float)((viewport.ActualWidth - 1) / 2)'                  (float)((viewport.ActualHeight - 1) / 2)'                  0'                  1);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetViewportMatrix,The following statement contains a magic number: return new Matrix(                  (float)(viewport.ActualWidth / 2)'                  0'                  0'                  0'                  0'                  (float)(-viewport.ActualHeight / 2)'                  0'                  0'                  0'                  0'                  1'                  0'                  (float)((viewport.ActualWidth - 1) / 2)'                  (float)((viewport.ActualHeight - 1) / 2)'                  0'                  1);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,UnProject,The following statement contains a magic number: if (camera != null)              {                  var px = (float)point2d.X;                  var py = (float)point2d.Y;                    var viewMatrix = camera.GetViewMatrix();                  Vector3 v = new Vector3();                                    var matrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                  float w = (float)viewport.ActualWidth;                  float h = (float)viewport.ActualHeight;                  var aspectRatio = w / h;                    var projMatrix = camera.GetProjectionMatrix(aspectRatio);                  Vector3 zn' zf;                  v.X = (2 * px / w - 1) / projMatrix.M11;                  v.Y = -(2 * py / h - 1) / projMatrix.M22;                  v.Z = 1 / projMatrix.M33;                  Vector3.TransformCoordinate(ref v' ref matrix' out zf);                    if (camera is PerspectiveCamera)                  {                      zn = camera.Position.ToVector3();                  }                  else                  {                      v.Z = 0;                      Vector3.TransformCoordinate(ref v' ref matrix' out zn);                  }                             Vector3 r = zf - zn;                  r.Normalize();                                   return new Ray(zn' r);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,UnProject,The following statement contains a magic number: if (camera != null)              {                  var px = (float)point2d.X;                  var py = (float)point2d.Y;                    var viewMatrix = camera.GetViewMatrix();                  Vector3 v = new Vector3();                                    var matrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                  float w = (float)viewport.ActualWidth;                  float h = (float)viewport.ActualHeight;                  var aspectRatio = w / h;                    var projMatrix = camera.GetProjectionMatrix(aspectRatio);                  Vector3 zn' zf;                  v.X = (2 * px / w - 1) / projMatrix.M11;                  v.Y = -(2 * py / h - 1) / projMatrix.M22;                  v.Z = 1 / projMatrix.M33;                  Vector3.TransformCoordinate(ref v' ref matrix' out zf);                    if (camera is PerspectiveCamera)                  {                      zn = camera.Position.ToVector3();                  }                  else                  {                      v.Z = 0;                      Vector3.TransformCoordinate(ref v' ref matrix' out zn);                  }                             Vector3 r = zf - zn;                  r.Normalize();                                   return new Ray(zn' r);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: var target = new WriteableBitmap(                  (int)view.ActualWidth * m' (int)view.ActualHeight * m' 96' 96' PixelFormats.Pbgra32' null);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: var target = new WriteableBitmap(                  (int)view.ActualWidth * m' (int)view.ActualHeight * m' 96' 96' PixelFormats.Pbgra32' null);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++)              {                  for (int j = 0; j < m; j++)                  {                      // change the camera viewport and scaling                      var pm = originalCamera.GetProjectionMatrix3D(ar);                      if (originalCamera is OrthographicCamera)                      {                          pm.OffsetX = m - 1 - (i * 2);                          pm.OffsetY = -(m - 1 - (j * 2));                      }                        if (originalCamera is PerspectiveCamera)                      {                          pm.M31 = -(m - 1 - (i * 2));                          pm.M32 = m - 1 - (j * 2);                      }                        pm.M11 *= m;                      pm.M22 *= m;                        var mc = new MatrixCamera(vm' pm);                      view.Camera = mc;                        var partialBitmap = new RenderTargetBitmap(                          (int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);                        // render background                      var backgroundRectangle = new Rectangle                          {                              Width = partialBitmap.Width'                              Height = partialBitmap.Height'                              Fill = background                          };                      backgroundRectangle.Arrange(new Rect(0' 0' backgroundRectangle.Width' backgroundRectangle.Height));                      partialBitmap.Render(backgroundRectangle);                        // render 3d                      partialBitmap.Render(view);                        // copy to the target bitmap                      CopyBitmap(partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++)              {                  for (int j = 0; j < m; j++)                  {                      // change the camera viewport and scaling                      var pm = originalCamera.GetProjectionMatrix3D(ar);                      if (originalCamera is OrthographicCamera)                      {                          pm.OffsetX = m - 1 - (i * 2);                          pm.OffsetY = -(m - 1 - (j * 2));                      }                        if (originalCamera is PerspectiveCamera)                      {                          pm.M31 = -(m - 1 - (i * 2));                          pm.M32 = m - 1 - (j * 2);                      }                        pm.M11 *= m;                      pm.M22 *= m;                        var mc = new MatrixCamera(vm' pm);                      view.Camera = mc;                        var partialBitmap = new RenderTargetBitmap(                          (int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);                        // render background                      var backgroundRectangle = new Rectangle                          {                              Width = partialBitmap.Width'                              Height = partialBitmap.Height'                              Fill = background                          };                      backgroundRectangle.Arrange(new Rect(0' 0' backgroundRectangle.Width' backgroundRectangle.Height));                      partialBitmap.Render(backgroundRectangle);                        // render 3d                      partialBitmap.Render(view);                        // copy to the target bitmap                      CopyBitmap(partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++)              {                  for (int j = 0; j < m; j++)                  {                      // change the camera viewport and scaling                      var pm = originalCamera.GetProjectionMatrix3D(ar);                      if (originalCamera is OrthographicCamera)                      {                          pm.OffsetX = m - 1 - (i * 2);                          pm.OffsetY = -(m - 1 - (j * 2));                      }                        if (originalCamera is PerspectiveCamera)                      {                          pm.M31 = -(m - 1 - (i * 2));                          pm.M32 = m - 1 - (j * 2);                      }                        pm.M11 *= m;                      pm.M22 *= m;                        var mc = new MatrixCamera(vm' pm);                      view.Camera = mc;                        var partialBitmap = new RenderTargetBitmap(                          (int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);                        // render background                      var backgroundRectangle = new Rectangle                          {                              Width = partialBitmap.Width'                              Height = partialBitmap.Height'                              Fill = background                          };                      backgroundRectangle.Arrange(new Rect(0' 0' backgroundRectangle.Width' backgroundRectangle.Height));                      partialBitmap.Render(backgroundRectangle);                        // render 3d                      partialBitmap.Render(view);                        // copy to the target bitmap                      CopyBitmap(partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++)              {                  for (int j = 0; j < m; j++)                  {                      // change the camera viewport and scaling                      var pm = originalCamera.GetProjectionMatrix3D(ar);                      if (originalCamera is OrthographicCamera)                      {                          pm.OffsetX = m - 1 - (i * 2);                          pm.OffsetY = -(m - 1 - (j * 2));                      }                        if (originalCamera is PerspectiveCamera)                      {                          pm.M31 = -(m - 1 - (i * 2));                          pm.M32 = m - 1 - (j * 2);                      }                        pm.M11 *= m;                      pm.M22 *= m;                        var mc = new MatrixCamera(vm' pm);                      view.Camera = mc;                        var partialBitmap = new RenderTargetBitmap(                          (int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);                        // render background                      var backgroundRectangle = new Rectangle                          {                              Width = partialBitmap.Width'                              Height = partialBitmap.Height'                              Fill = background                          };                      backgroundRectangle.Arrange(new Rect(0' 0' backgroundRectangle.Width' backgroundRectangle.Height));                      partialBitmap.Render(backgroundRectangle);                        // render 3d                      partialBitmap.Render(view);                        // copy to the target bitmap                      CopyBitmap(partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++)              {                  for (int j = 0; j < m; j++)                  {                      // change the camera viewport and scaling                      var pm = originalCamera.GetProjectionMatrix3D(ar);                      if (originalCamera is OrthographicCamera)                      {                          pm.OffsetX = m - 1 - (i * 2);                          pm.OffsetY = -(m - 1 - (j * 2));                      }                        if (originalCamera is PerspectiveCamera)                      {                          pm.M31 = -(m - 1 - (i * 2));                          pm.M32 = m - 1 - (j * 2);                      }                        pm.M11 *= m;                      pm.M22 *= m;                        var mc = new MatrixCamera(vm' pm);                      view.Camera = mc;                        var partialBitmap = new RenderTargetBitmap(                          (int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);                        // render background                      var backgroundRectangle = new Rectangle                          {                              Width = partialBitmap.Width'                              Height = partialBitmap.Height'                              Fill = background                          };                      backgroundRectangle.Arrange(new Rect(0' 0' backgroundRectangle.Width' backgroundRectangle.Height));                      partialBitmap.Render(backgroundRectangle);                        // render 3d                      partialBitmap.Render(view);                        // copy to the target bitmap                      CopyBitmap(partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++)              {                  for (int j = 0; j < m; j++)                  {                      // change the camera viewport and scaling                      var pm = originalCamera.GetProjectionMatrix3D(ar);                      if (originalCamera is OrthographicCamera)                      {                          pm.OffsetX = m - 1 - (i * 2);                          pm.OffsetY = -(m - 1 - (j * 2));                      }                        if (originalCamera is PerspectiveCamera)                      {                          pm.M31 = -(m - 1 - (i * 2));                          pm.M32 = m - 1 - (j * 2);                      }                        pm.M11 *= m;                      pm.M22 *= m;                        var mc = new MatrixCamera(vm' pm);                      view.Camera = mc;                        var partialBitmap = new RenderTargetBitmap(                          (int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);                        // render background                      var backgroundRectangle = new Rectangle                          {                              Width = partialBitmap.Width'                              Height = partialBitmap.Height'                              Fill = background                          };                      backgroundRectangle.Arrange(new Rect(0' 0' backgroundRectangle.Width' backgroundRectangle.Height));                      partialBitmap.Render(backgroundRectangle);                        // render 3d                      partialBitmap.Render(view);                        // copy to the target bitmap                      CopyBitmap(partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: var center = bounds.Location + (diagonal * 0.5);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: double radius = diagonal.Length * 0.5;
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: if (pcam != null)              {                  double disth = radius / Math.Tan(0.5 * pcam.FieldOfView * Math.PI / 180);                  double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;                  double distv = radius / Math.Tan(0.5 * vfov * Math.PI / 180);                    double dist = Math.Max(disth' distv);                  var dir = pcam.LookDirection;                  dir.Normalize();                  pcam.LookAt(center' dir * dist' animationTime);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: if (pcam != null)              {                  double disth = radius / Math.Tan(0.5 * pcam.FieldOfView * Math.PI / 180);                  double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;                  double distv = radius / Math.Tan(0.5 * vfov * Math.PI / 180);                    double dist = Math.Max(disth' distv);                  var dir = pcam.LookDirection;                  dir.Normalize();                  pcam.LookAt(center' dir * dist' animationTime);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: if (pcam != null)              {                  double disth = radius / Math.Tan(0.5 * pcam.FieldOfView * Math.PI / 180);                  double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;                  double distv = radius / Math.Tan(0.5 * vfov * Math.PI / 180);                    double dist = Math.Max(disth' distv);                  var dir = pcam.LookDirection;                  dir.Normalize();                  pcam.LookAt(center' dir * dist' animationTime);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: if (pcam != null)              {                  double disth = radius / Math.Tan(0.5 * pcam.FieldOfView * Math.PI / 180);                  double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;                  double distv = radius / Math.Tan(0.5 * vfov * Math.PI / 180);                    double dist = Math.Max(disth' distv);                  var dir = pcam.LookDirection;                  dir.Normalize();                  pcam.LookAt(center' dir * dist' animationTime);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: if (ocam != null)              {                  ocam.LookAt(center' ocam.LookDirection' animationTime);                  double newWidth = radius * 2;                    if (viewport.ActualWidth > viewport.ActualHeight)                  {                      newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;                  }                    ocam.AnimateWidth(newWidth' animationTime);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: if (ocam != null)              {                  ocam.LookAt(center' ocam.LookDirection' animationTime);                  double newWidth = radius * 2;                    if (viewport.ActualWidth > viewport.ActualHeight)                  {                      newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;                  }                    ocam.AnimateWidth(newWidth' animationTime);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomByChangingFieldOfView,The following statement contains a magic number: double r = d * Math.Tan(0.5 * fov / 180 * Math.PI);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomByChangingFieldOfView,The following statement contains a magic number: double r = d * Math.Tan(0.5 * fov / 180 * Math.PI);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomByChangingFieldOfView,The following statement contains a magic number: fov *= 1 + (delta * 0.5);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomByChangingFieldOfView,The following statement contains a magic number: double d2 = r / Math.Tan(0.5 * fov / 180 * Math.PI);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomByChangingFieldOfView,The following statement contains a magic number: double d2 = r / Math.Tan(0.5 * fov / 180 * Math.PI);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,CopyBitmap,The following statement contains a magic number: int stride = source.PixelWidth * (source.Format.BitsPerPixel / 8);
Magic Number,HelixToolkit.Wpf.SharpDX,BitmapExtension,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\BitmapExtension.cs,ToBitmapSource,The following statement contains a magic number: var target = new RenderTargetBitmap((int)(element.RenderSize.Width)' (int)(element.RenderSize.Height)' 96' 96' System.Windows.Media.PixelFormats.Pbgra32);
Magic Number,HelixToolkit.Wpf.SharpDX,BitmapExtension,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\BitmapExtension.cs,ToBitmapSource,The following statement contains a magic number: var target = new RenderTargetBitmap((int)(element.RenderSize.Width)' (int)(element.RenderSize.Height)' 96' 96' System.Windows.Media.PixelFormats.Pbgra32);
Magic Number,HelixToolkit.Wpf.SharpDX,CrossSectionMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CrossSectionMeshGeometryModel3D.cs,CreateStates,The following statement contains a magic number: this.fillStencilRasterState = new RasterizerState(this.Device'                  new RasterizerStateDescription()                  {                      FillMode = FillMode.Solid'                      CullMode = CullMode.Front'                      DepthBias = DepthBias'                      DepthBiasClamp = -1000'                      SlopeScaledDepthBias = +0'                      IsDepthClipEnabled = IsDepthClipEnabled'                      IsFrontCounterClockwise = FrontCounterClockwise'                      IsMultisampleEnabled = false'                      IsScissorEnabled = false                  });
Magic Number,HelixToolkit.Wpf.SharpDX,CrossSectionMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CrossSectionMeshGeometryModel3D.cs,OnDrawCall,The following statement contains a magic number: pass = this.effectTechnique.GetPassByIndex(2);
Magic Number,HelixToolkit.Wpf.SharpDX,CrossSectionMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CrossSectionMeshGeometryModel3D.cs,OnDrawCall,The following statement contains a magic number: renderContext.DeviceContext.Draw(4' 0);
Magic Number,HelixToolkit.Wpf.SharpDX,ScreenSpaceMeshGeometry3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\ScreenSpaceMeshGeometry3D.cs,OnCreateProjectionMatrix,The following statement contains a magic number: projectionMatrix = Matrix.OrthoRH(140 * screenRatio / scale' 140 / scale' 1f' 200000);
Magic Number,HelixToolkit.Wpf.SharpDX,ScreenSpaceMeshGeometry3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\ScreenSpaceMeshGeometry3D.cs,OnCreateProjectionMatrix,The following statement contains a magic number: projectionMatrix = Matrix.OrthoRH(140 * screenRatio / scale' 140 / scale' 1f' 200000);
Magic Number,HelixToolkit.Wpf.SharpDX,ScreenSpaceMeshGeometry3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\ScreenSpaceMeshGeometry3D.cs,OnCreateProjectionMatrix,The following statement contains a magic number: projectionMatrix = Matrix.OrthoRH(140 * screenRatio / scale' 140 / scale' 1f' 200000);
Magic Number,HelixToolkit.Wpf.SharpDX,ScreenSpaceMeshGeometry3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\ScreenSpaceMeshGeometry3D.cs,CreateViewMatrix,The following statement contains a magic number: return global::SharpDX.Matrix.LookAtRH(                  -renderContext.Camera.LookDirection.ToVector3().Normalized() * 20'                  Vector3.Zero'                  renderContext.Camera.UpDirection.ToVector3());
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null)              {                  BoundingBox b = new BoundingBox();                  var left = -g.Width / 2;                  var right = -left;                  var top = -g.Height / 2;                  var bottom = -top;                  if (FixedSize)                  {                      var viewportMatrix = context.ViewportMatrix;                      var projectionMatrix = context.ProjectionMatrix;                      var viewMatrix = context.ViewMatrix;                      var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z / spw / projectionMatrix.M33;                        var matrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                      var width = (float)context.ActualWidth;                      var height = (float)context.ActualHeight;                      Vector3 v = new Vector3();                        var x = spx + left * spw;                      var y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 bl;                      Vector3.TransformCoordinate(ref v' ref matrix' out bl);                          x = spx + right * spw;                      y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 br;                      Vector3.TransformCoordinate(ref v' ref matrix' out br);                        x = spx + right * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tr;                      Vector3.TransformCoordinate(ref v' ref matrix' out tr);                        x = spx + left * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tl;                      Vector3.TransformCoordinate(ref v' ref matrix' out tl);                        b = BoundingBox.FromPoints(new Vector3[] { tl' tr' bl' br });                        /*                      var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                        var screenToVisual = visualToScreen.Inverted();                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z;                        //Debug.WriteLine(spw);                      // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                      var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                      bl = Vector4.Transform(bl' screenToVisual);                      bl /= bl.W;                        var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                      br = Vector4.Transform(br' screenToVisual);                      br /= br.W;                        var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                      tr = Vector4.Transform(tr' screenToVisual);                      tr /= tr.W;                        var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                      tl = Vector4.Transform(tl' screenToVisual);                      tl /= tl.W;                        b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                       */                  }                  else                  {                      var center = new Vector4(g.Positions[0]' 1);                      var viewMatrix = context.ViewMatrix;                        var vcenter = Vector4.Transform(center' viewMatrix);                      var vcX = vcenter.X;                      var vcY = vcenter.Y;                        var bl = new Vector4(vcX + left' vcY + bottom' vcenter.Z' vcenter.W);                      var br = new Vector4(vcX + right' vcY + bottom' vcenter.Z' vcenter.W);                      var tr = new Vector4(vcX + right' vcY + top' vcenter.Z' vcenter.W);                      var tl = new Vector4(vcX + left' vcY + top' vcenter.Z' vcenter.W);                      var invViewMatrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                        bl = Vector4.Transform(bl' invViewMatrix);                      bl /= bl.W;                      br = Vector4.Transform(br' invViewMatrix);                      br /= br.W;                      tr = Vector4.Transform(tr' invViewMatrix);                      tr /= tr.W;                      tl = Vector4.Transform(tl' invViewMatrix);                      tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                  }                    // this all happens now in world space now:                  //Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));                  if (rayWS.Intersects(ref b))                  {                        float distance;                      if (Collision.RayIntersectsBox(ref rayWS' ref b' out distance))                      {                          h = true;                          result.ModelHit = this;                          result.IsValid = true;                          result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D();                          result.Distance = distance;                          Debug.WriteLine(string.Format("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null)              {                  BoundingBox b = new BoundingBox();                  var left = -g.Width / 2;                  var right = -left;                  var top = -g.Height / 2;                  var bottom = -top;                  if (FixedSize)                  {                      var viewportMatrix = context.ViewportMatrix;                      var projectionMatrix = context.ProjectionMatrix;                      var viewMatrix = context.ViewMatrix;                      var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z / spw / projectionMatrix.M33;                        var matrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                      var width = (float)context.ActualWidth;                      var height = (float)context.ActualHeight;                      Vector3 v = new Vector3();                        var x = spx + left * spw;                      var y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 bl;                      Vector3.TransformCoordinate(ref v' ref matrix' out bl);                          x = spx + right * spw;                      y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 br;                      Vector3.TransformCoordinate(ref v' ref matrix' out br);                        x = spx + right * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tr;                      Vector3.TransformCoordinate(ref v' ref matrix' out tr);                        x = spx + left * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tl;                      Vector3.TransformCoordinate(ref v' ref matrix' out tl);                        b = BoundingBox.FromPoints(new Vector3[] { tl' tr' bl' br });                        /*                      var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                        var screenToVisual = visualToScreen.Inverted();                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z;                        //Debug.WriteLine(spw);                      // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                      var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                      bl = Vector4.Transform(bl' screenToVisual);                      bl /= bl.W;                        var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                      br = Vector4.Transform(br' screenToVisual);                      br /= br.W;                        var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                      tr = Vector4.Transform(tr' screenToVisual);                      tr /= tr.W;                        var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                      tl = Vector4.Transform(tl' screenToVisual);                      tl /= tl.W;                        b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                       */                  }                  else                  {                      var center = new Vector4(g.Positions[0]' 1);                      var viewMatrix = context.ViewMatrix;                        var vcenter = Vector4.Transform(center' viewMatrix);                      var vcX = vcenter.X;                      var vcY = vcenter.Y;                        var bl = new Vector4(vcX + left' vcY + bottom' vcenter.Z' vcenter.W);                      var br = new Vector4(vcX + right' vcY + bottom' vcenter.Z' vcenter.W);                      var tr = new Vector4(vcX + right' vcY + top' vcenter.Z' vcenter.W);                      var tl = new Vector4(vcX + left' vcY + top' vcenter.Z' vcenter.W);                      var invViewMatrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                        bl = Vector4.Transform(bl' invViewMatrix);                      bl /= bl.W;                      br = Vector4.Transform(br' invViewMatrix);                      br /= br.W;                      tr = Vector4.Transform(tr' invViewMatrix);                      tr /= tr.W;                      tl = Vector4.Transform(tl' invViewMatrix);                      tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                  }                    // this all happens now in world space now:                  //Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));                  if (rayWS.Intersects(ref b))                  {                        float distance;                      if (Collision.RayIntersectsBox(ref rayWS' ref b' out distance))                      {                          h = true;                          result.ModelHit = this;                          result.IsValid = true;                          result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D();                          result.Distance = distance;                          Debug.WriteLine(string.Format("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null)              {                  BoundingBox b = new BoundingBox();                  var left = -g.Width / 2;                  var right = -left;                  var top = -g.Height / 2;                  var bottom = -top;                  if (FixedSize)                  {                      var viewportMatrix = context.ViewportMatrix;                      var projectionMatrix = context.ProjectionMatrix;                      var viewMatrix = context.ViewMatrix;                      var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z / spw / projectionMatrix.M33;                        var matrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                      var width = (float)context.ActualWidth;                      var height = (float)context.ActualHeight;                      Vector3 v = new Vector3();                        var x = spx + left * spw;                      var y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 bl;                      Vector3.TransformCoordinate(ref v' ref matrix' out bl);                          x = spx + right * spw;                      y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 br;                      Vector3.TransformCoordinate(ref v' ref matrix' out br);                        x = spx + right * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tr;                      Vector3.TransformCoordinate(ref v' ref matrix' out tr);                        x = spx + left * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tl;                      Vector3.TransformCoordinate(ref v' ref matrix' out tl);                        b = BoundingBox.FromPoints(new Vector3[] { tl' tr' bl' br });                        /*                      var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                        var screenToVisual = visualToScreen.Inverted();                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z;                        //Debug.WriteLine(spw);                      // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                      var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                      bl = Vector4.Transform(bl' screenToVisual);                      bl /= bl.W;                        var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                      br = Vector4.Transform(br' screenToVisual);                      br /= br.W;                        var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                      tr = Vector4.Transform(tr' screenToVisual);                      tr /= tr.W;                        var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                      tl = Vector4.Transform(tl' screenToVisual);                      tl /= tl.W;                        b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                       */                  }                  else                  {                      var center = new Vector4(g.Positions[0]' 1);                      var viewMatrix = context.ViewMatrix;                        var vcenter = Vector4.Transform(center' viewMatrix);                      var vcX = vcenter.X;                      var vcY = vcenter.Y;                        var bl = new Vector4(vcX + left' vcY + bottom' vcenter.Z' vcenter.W);                      var br = new Vector4(vcX + right' vcY + bottom' vcenter.Z' vcenter.W);                      var tr = new Vector4(vcX + right' vcY + top' vcenter.Z' vcenter.W);                      var tl = new Vector4(vcX + left' vcY + top' vcenter.Z' vcenter.W);                      var invViewMatrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                        bl = Vector4.Transform(bl' invViewMatrix);                      bl /= bl.W;                      br = Vector4.Transform(br' invViewMatrix);                      br /= br.W;                      tr = Vector4.Transform(tr' invViewMatrix);                      tr /= tr.W;                      tl = Vector4.Transform(tl' invViewMatrix);                      tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                  }                    // this all happens now in world space now:                  //Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));                  if (rayWS.Intersects(ref b))                  {                        float distance;                      if (Collision.RayIntersectsBox(ref rayWS' ref b' out distance))                      {                          h = true;                          result.ModelHit = this;                          result.IsValid = true;                          result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D();                          result.Distance = distance;                          Debug.WriteLine(string.Format("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null)              {                  BoundingBox b = new BoundingBox();                  var left = -g.Width / 2;                  var right = -left;                  var top = -g.Height / 2;                  var bottom = -top;                  if (FixedSize)                  {                      var viewportMatrix = context.ViewportMatrix;                      var projectionMatrix = context.ProjectionMatrix;                      var viewMatrix = context.ViewMatrix;                      var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z / spw / projectionMatrix.M33;                        var matrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                      var width = (float)context.ActualWidth;                      var height = (float)context.ActualHeight;                      Vector3 v = new Vector3();                        var x = spx + left * spw;                      var y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 bl;                      Vector3.TransformCoordinate(ref v' ref matrix' out bl);                          x = spx + right * spw;                      y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 br;                      Vector3.TransformCoordinate(ref v' ref matrix' out br);                        x = spx + right * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tr;                      Vector3.TransformCoordinate(ref v' ref matrix' out tr);                        x = spx + left * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tl;                      Vector3.TransformCoordinate(ref v' ref matrix' out tl);                        b = BoundingBox.FromPoints(new Vector3[] { tl' tr' bl' br });                        /*                      var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                        var screenToVisual = visualToScreen.Inverted();                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z;                        //Debug.WriteLine(spw);                      // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                      var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                      bl = Vector4.Transform(bl' screenToVisual);                      bl /= bl.W;                        var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                      br = Vector4.Transform(br' screenToVisual);                      br /= br.W;                        var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                      tr = Vector4.Transform(tr' screenToVisual);                      tr /= tr.W;                        var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                      tl = Vector4.Transform(tl' screenToVisual);                      tl /= tl.W;                        b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                       */                  }                  else                  {                      var center = new Vector4(g.Positions[0]' 1);                      var viewMatrix = context.ViewMatrix;                        var vcenter = Vector4.Transform(center' viewMatrix);                      var vcX = vcenter.X;                      var vcY = vcenter.Y;                        var bl = new Vector4(vcX + left' vcY + bottom' vcenter.Z' vcenter.W);                      var br = new Vector4(vcX + right' vcY + bottom' vcenter.Z' vcenter.W);                      var tr = new Vector4(vcX + right' vcY + top' vcenter.Z' vcenter.W);                      var tl = new Vector4(vcX + left' vcY + top' vcenter.Z' vcenter.W);                      var invViewMatrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                        bl = Vector4.Transform(bl' invViewMatrix);                      bl /= bl.W;                      br = Vector4.Transform(br' invViewMatrix);                      br /= br.W;                      tr = Vector4.Transform(tr' invViewMatrix);                      tr /= tr.W;                      tl = Vector4.Transform(tl' invViewMatrix);                      tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                  }                    // this all happens now in world space now:                  //Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));                  if (rayWS.Intersects(ref b))                  {                        float distance;                      if (Collision.RayIntersectsBox(ref rayWS' ref b' out distance))                      {                          h = true;                          result.ModelHit = this;                          result.IsValid = true;                          result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D();                          result.Distance = distance;                          Debug.WriteLine(string.Format("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null)              {                  BoundingBox b = new BoundingBox();                  var left = -g.Width / 2;                  var right = -left;                  var top = -g.Height / 2;                  var bottom = -top;                  if (FixedSize)                  {                      var viewportMatrix = context.ViewportMatrix;                      var projectionMatrix = context.ProjectionMatrix;                      var viewMatrix = context.ViewMatrix;                      var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z / spw / projectionMatrix.M33;                        var matrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                      var width = (float)context.ActualWidth;                      var height = (float)context.ActualHeight;                      Vector3 v = new Vector3();                        var x = spx + left * spw;                      var y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 bl;                      Vector3.TransformCoordinate(ref v' ref matrix' out bl);                          x = spx + right * spw;                      y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 br;                      Vector3.TransformCoordinate(ref v' ref matrix' out br);                        x = spx + right * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tr;                      Vector3.TransformCoordinate(ref v' ref matrix' out tr);                        x = spx + left * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tl;                      Vector3.TransformCoordinate(ref v' ref matrix' out tl);                        b = BoundingBox.FromPoints(new Vector3[] { tl' tr' bl' br });                        /*                      var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                        var screenToVisual = visualToScreen.Inverted();                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z;                        //Debug.WriteLine(spw);                      // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                      var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                      bl = Vector4.Transform(bl' screenToVisual);                      bl /= bl.W;                        var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                      br = Vector4.Transform(br' screenToVisual);                      br /= br.W;                        var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                      tr = Vector4.Transform(tr' screenToVisual);                      tr /= tr.W;                        var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                      tl = Vector4.Transform(tl' screenToVisual);                      tl /= tl.W;                        b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                       */                  }                  else                  {                      var center = new Vector4(g.Positions[0]' 1);                      var viewMatrix = context.ViewMatrix;                        var vcenter = Vector4.Transform(center' viewMatrix);                      var vcX = vcenter.X;                      var vcY = vcenter.Y;                        var bl = new Vector4(vcX + left' vcY + bottom' vcenter.Z' vcenter.W);                      var br = new Vector4(vcX + right' vcY + bottom' vcenter.Z' vcenter.W);                      var tr = new Vector4(vcX + right' vcY + top' vcenter.Z' vcenter.W);                      var tl = new Vector4(vcX + left' vcY + top' vcenter.Z' vcenter.W);                      var invViewMatrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                        bl = Vector4.Transform(bl' invViewMatrix);                      bl /= bl.W;                      br = Vector4.Transform(br' invViewMatrix);                      br /= br.W;                      tr = Vector4.Transform(tr' invViewMatrix);                      tr /= tr.W;                      tl = Vector4.Transform(tl' invViewMatrix);                      tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                  }                    // this all happens now in world space now:                  //Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));                  if (rayWS.Intersects(ref b))                  {                        float distance;                      if (Collision.RayIntersectsBox(ref rayWS' ref b' out distance))                      {                          h = true;                          result.ModelHit = this;                          result.IsValid = true;                          result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D();                          result.Distance = distance;                          Debug.WriteLine(string.Format("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null)              {                  BoundingBox b = new BoundingBox();                  var left = -g.Width / 2;                  var right = -left;                  var top = -g.Height / 2;                  var bottom = -top;                  if (FixedSize)                  {                      var viewportMatrix = context.ViewportMatrix;                      var projectionMatrix = context.ProjectionMatrix;                      var viewMatrix = context.ViewMatrix;                      var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z / spw / projectionMatrix.M33;                        var matrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                      var width = (float)context.ActualWidth;                      var height = (float)context.ActualHeight;                      Vector3 v = new Vector3();                        var x = spx + left * spw;                      var y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 bl;                      Vector3.TransformCoordinate(ref v' ref matrix' out bl);                          x = spx + right * spw;                      y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 br;                      Vector3.TransformCoordinate(ref v' ref matrix' out br);                        x = spx + right * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tr;                      Vector3.TransformCoordinate(ref v' ref matrix' out tr);                        x = spx + left * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tl;                      Vector3.TransformCoordinate(ref v' ref matrix' out tl);                        b = BoundingBox.FromPoints(new Vector3[] { tl' tr' bl' br });                        /*                      var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                        var screenToVisual = visualToScreen.Inverted();                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z;                        //Debug.WriteLine(spw);                      // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                      var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                      bl = Vector4.Transform(bl' screenToVisual);                      bl /= bl.W;                        var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                      br = Vector4.Transform(br' screenToVisual);                      br /= br.W;                        var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                      tr = Vector4.Transform(tr' screenToVisual);                      tr /= tr.W;                        var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                      tl = Vector4.Transform(tl' screenToVisual);                      tl /= tl.W;                        b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                       */                  }                  else                  {                      var center = new Vector4(g.Positions[0]' 1);                      var viewMatrix = context.ViewMatrix;                        var vcenter = Vector4.Transform(center' viewMatrix);                      var vcX = vcenter.X;                      var vcY = vcenter.Y;                        var bl = new Vector4(vcX + left' vcY + bottom' vcenter.Z' vcenter.W);                      var br = new Vector4(vcX + right' vcY + bottom' vcenter.Z' vcenter.W);                      var tr = new Vector4(vcX + right' vcY + top' vcenter.Z' vcenter.W);                      var tl = new Vector4(vcX + left' vcY + top' vcenter.Z' vcenter.W);                      var invViewMatrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                        bl = Vector4.Transform(bl' invViewMatrix);                      bl /= bl.W;                      br = Vector4.Transform(br' invViewMatrix);                      br /= br.W;                      tr = Vector4.Transform(tr' invViewMatrix);                      tr /= tr.W;                      tl = Vector4.Transform(tl' invViewMatrix);                      tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                  }                    // this all happens now in world space now:                  //Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));                  if (rayWS.Intersects(ref b))                  {                        float distance;                      if (Collision.RayIntersectsBox(ref rayWS' ref b' out distance))                      {                          h = true;                          result.ModelHit = this;                          result.IsValid = true;                          result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D();                          result.Distance = distance;                          Debug.WriteLine(string.Format("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null)              {                  BoundingBox b = new BoundingBox();                  var left = -g.Width / 2;                  var right = -left;                  var top = -g.Height / 2;                  var bottom = -top;                  if (FixedSize)                  {                      var viewportMatrix = context.ViewportMatrix;                      var projectionMatrix = context.ProjectionMatrix;                      var viewMatrix = context.ViewMatrix;                      var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z / spw / projectionMatrix.M33;                        var matrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                      var width = (float)context.ActualWidth;                      var height = (float)context.ActualHeight;                      Vector3 v = new Vector3();                        var x = spx + left * spw;                      var y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 bl;                      Vector3.TransformCoordinate(ref v' ref matrix' out bl);                          x = spx + right * spw;                      y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 br;                      Vector3.TransformCoordinate(ref v' ref matrix' out br);                        x = spx + right * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tr;                      Vector3.TransformCoordinate(ref v' ref matrix' out tr);                        x = spx + left * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tl;                      Vector3.TransformCoordinate(ref v' ref matrix' out tl);                        b = BoundingBox.FromPoints(new Vector3[] { tl' tr' bl' br });                        /*                      var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                        var screenToVisual = visualToScreen.Inverted();                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z;                        //Debug.WriteLine(spw);                      // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                      var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                      bl = Vector4.Transform(bl' screenToVisual);                      bl /= bl.W;                        var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                      br = Vector4.Transform(br' screenToVisual);                      br /= br.W;                        var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                      tr = Vector4.Transform(tr' screenToVisual);                      tr /= tr.W;                        var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                      tl = Vector4.Transform(tl' screenToVisual);                      tl /= tl.W;                        b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                       */                  }                  else                  {                      var center = new Vector4(g.Positions[0]' 1);                      var viewMatrix = context.ViewMatrix;                        var vcenter = Vector4.Transform(center' viewMatrix);                      var vcX = vcenter.X;                      var vcY = vcenter.Y;                        var bl = new Vector4(vcX + left' vcY + bottom' vcenter.Z' vcenter.W);                      var br = new Vector4(vcX + right' vcY + bottom' vcenter.Z' vcenter.W);                      var tr = new Vector4(vcX + right' vcY + top' vcenter.Z' vcenter.W);                      var tl = new Vector4(vcX + left' vcY + top' vcenter.Z' vcenter.W);                      var invViewMatrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                        bl = Vector4.Transform(bl' invViewMatrix);                      bl /= bl.W;                      br = Vector4.Transform(br' invViewMatrix);                      br /= br.W;                      tr = Vector4.Transform(tr' invViewMatrix);                      tr /= tr.W;                      tl = Vector4.Transform(tl' invViewMatrix);                      tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                  }                    // this all happens now in world space now:                  //Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));                  if (rayWS.Intersects(ref b))                  {                        float distance;                      if (Collision.RayIntersectsBox(ref rayWS' ref b' out distance))                      {                          h = true;                          result.ModelHit = this;                          result.IsValid = true;                          result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D();                          result.Distance = distance;                          Debug.WriteLine(string.Format("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null)              {                  BoundingBox b = new BoundingBox();                  var left = -g.Width / 2;                  var right = -left;                  var top = -g.Height / 2;                  var bottom = -top;                  if (FixedSize)                  {                      var viewportMatrix = context.ViewportMatrix;                      var projectionMatrix = context.ProjectionMatrix;                      var viewMatrix = context.ViewMatrix;                      var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z / spw / projectionMatrix.M33;                        var matrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                      var width = (float)context.ActualWidth;                      var height = (float)context.ActualHeight;                      Vector3 v = new Vector3();                        var x = spx + left * spw;                      var y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 bl;                      Vector3.TransformCoordinate(ref v' ref matrix' out bl);                          x = spx + right * spw;                      y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 br;                      Vector3.TransformCoordinate(ref v' ref matrix' out br);                        x = spx + right * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tr;                      Vector3.TransformCoordinate(ref v' ref matrix' out tr);                        x = spx + left * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tl;                      Vector3.TransformCoordinate(ref v' ref matrix' out tl);                        b = BoundingBox.FromPoints(new Vector3[] { tl' tr' bl' br });                        /*                      var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                        var screenToVisual = visualToScreen.Inverted();                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z;                        //Debug.WriteLine(spw);                      // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                      var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                      bl = Vector4.Transform(bl' screenToVisual);                      bl /= bl.W;                        var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                      br = Vector4.Transform(br' screenToVisual);                      br /= br.W;                        var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                      tr = Vector4.Transform(tr' screenToVisual);                      tr /= tr.W;                        var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                      tl = Vector4.Transform(tl' screenToVisual);                      tl /= tl.W;                        b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                       */                  }                  else                  {                      var center = new Vector4(g.Positions[0]' 1);                      var viewMatrix = context.ViewMatrix;                        var vcenter = Vector4.Transform(center' viewMatrix);                      var vcX = vcenter.X;                      var vcY = vcenter.Y;                        var bl = new Vector4(vcX + left' vcY + bottom' vcenter.Z' vcenter.W);                      var br = new Vector4(vcX + right' vcY + bottom' vcenter.Z' vcenter.W);                      var tr = new Vector4(vcX + right' vcY + top' vcenter.Z' vcenter.W);                      var tl = new Vector4(vcX + left' vcY + top' vcenter.Z' vcenter.W);                      var invViewMatrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                        bl = Vector4.Transform(bl' invViewMatrix);                      bl /= bl.W;                      br = Vector4.Transform(br' invViewMatrix);                      br /= br.W;                      tr = Vector4.Transform(tr' invViewMatrix);                      tr /= tr.W;                      tl = Vector4.Transform(tl' invViewMatrix);                      tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                  }                    // this all happens now in world space now:                  //Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));                  if (rayWS.Intersects(ref b))                  {                        float distance;                      if (Collision.RayIntersectsBox(ref rayWS' ref b' out distance))                      {                          h = true;                          result.ModelHit = this;                          result.IsValid = true;                          result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D();                          result.Distance = distance;                          Debug.WriteLine(string.Format("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null)              {                  BoundingBox b = new BoundingBox();                  var left = -g.Width / 2;                  var right = -left;                  var top = -g.Height / 2;                  var bottom = -top;                  if (FixedSize)                  {                      var viewportMatrix = context.ViewportMatrix;                      var projectionMatrix = context.ProjectionMatrix;                      var viewMatrix = context.ViewMatrix;                      var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z / spw / projectionMatrix.M33;                        var matrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                      var width = (float)context.ActualWidth;                      var height = (float)context.ActualHeight;                      Vector3 v = new Vector3();                        var x = spx + left * spw;                      var y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 bl;                      Vector3.TransformCoordinate(ref v' ref matrix' out bl);                          x = spx + right * spw;                      y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 br;                      Vector3.TransformCoordinate(ref v' ref matrix' out br);                        x = spx + right * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tr;                      Vector3.TransformCoordinate(ref v' ref matrix' out tr);                        x = spx + left * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tl;                      Vector3.TransformCoordinate(ref v' ref matrix' out tl);                        b = BoundingBox.FromPoints(new Vector3[] { tl' tr' bl' br });                        /*                      var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                        var screenToVisual = visualToScreen.Inverted();                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z;                        //Debug.WriteLine(spw);                      // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                      var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                      bl = Vector4.Transform(bl' screenToVisual);                      bl /= bl.W;                        var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                      br = Vector4.Transform(br' screenToVisual);                      br /= br.W;                        var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                      tr = Vector4.Transform(tr' screenToVisual);                      tr /= tr.W;                        var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                      tl = Vector4.Transform(tl' screenToVisual);                      tl /= tl.W;                        b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                       */                  }                  else                  {                      var center = new Vector4(g.Positions[0]' 1);                      var viewMatrix = context.ViewMatrix;                        var vcenter = Vector4.Transform(center' viewMatrix);                      var vcX = vcenter.X;                      var vcY = vcenter.Y;                        var bl = new Vector4(vcX + left' vcY + bottom' vcenter.Z' vcenter.W);                      var br = new Vector4(vcX + right' vcY + bottom' vcenter.Z' vcenter.W);                      var tr = new Vector4(vcX + right' vcY + top' vcenter.Z' vcenter.W);                      var tl = new Vector4(vcX + left' vcY + top' vcenter.Z' vcenter.W);                      var invViewMatrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                        bl = Vector4.Transform(bl' invViewMatrix);                      bl /= bl.W;                      br = Vector4.Transform(br' invViewMatrix);                      br /= br.W;                      tr = Vector4.Transform(tr' invViewMatrix);                      tr /= tr.W;                      tl = Vector4.Transform(tl' invViewMatrix);                      tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                  }                    // this all happens now in world space now:                  //Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));                  if (rayWS.Intersects(ref b))                  {                        float distance;                      if (Collision.RayIntersectsBox(ref rayWS' ref b' out distance))                      {                          h = true;                          result.ModelHit = this;                          result.IsValid = true;                          result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D();                          result.Distance = distance;                          Debug.WriteLine(string.Format("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null)              {                  BoundingBox b = new BoundingBox();                  var left = -g.Width / 2;                  var right = -left;                  var top = -g.Height / 2;                  var bottom = -top;                  if (FixedSize)                  {                      var viewportMatrix = context.ViewportMatrix;                      var projectionMatrix = context.ProjectionMatrix;                      var viewMatrix = context.ViewMatrix;                      var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z / spw / projectionMatrix.M33;                        var matrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                      var width = (float)context.ActualWidth;                      var height = (float)context.ActualHeight;                      Vector3 v = new Vector3();                        var x = spx + left * spw;                      var y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 bl;                      Vector3.TransformCoordinate(ref v' ref matrix' out bl);                          x = spx + right * spw;                      y = spy + bottom * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 br;                      Vector3.TransformCoordinate(ref v' ref matrix' out br);                        x = spx + right * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tr;                      Vector3.TransformCoordinate(ref v' ref matrix' out tr);                        x = spx + left * spw;                      y = spy + top * spw;                      v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;                      v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;                      v.Z = spz;                        Vector3 tl;                      Vector3.TransformCoordinate(ref v' ref matrix' out tl);                        b = BoundingBox.FromPoints(new Vector3[] { tl' tr' bl' br });                        /*                      var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                        var screenToVisual = visualToScreen.Inverted();                        var center = new Vector4(g.Positions[0]' 1);                      var screenPoint = Vector4.Transform(center' visualToScreen);                      var spw = screenPoint.W;                      var spx = screenPoint.X;                      var spy = screenPoint.Y;                      var spz = screenPoint.Z;                        //Debug.WriteLine(spw);                      // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                      var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                      bl = Vector4.Transform(bl' screenToVisual);                      bl /= bl.W;                        var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                      br = Vector4.Transform(br' screenToVisual);                      br /= br.W;                        var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                      tr = Vector4.Transform(tr' screenToVisual);                      tr /= tr.W;                        var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                      tl = Vector4.Transform(tl' screenToVisual);                      tl /= tl.W;                        b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                       */                  }                  else                  {                      var center = new Vector4(g.Positions[0]' 1);                      var viewMatrix = context.ViewMatrix;                        var vcenter = Vector4.Transform(center' viewMatrix);                      var vcX = vcenter.X;                      var vcY = vcenter.Y;                        var bl = new Vector4(vcX + left' vcY + bottom' vcenter.Z' vcenter.W);                      var br = new Vector4(vcX + right' vcY + bottom' vcenter.Z' vcenter.W);                      var tr = new Vector4(vcX + right' vcY + top' vcenter.Z' vcenter.W);                      var tl = new Vector4(vcX + left' vcY + top' vcenter.Z' vcenter.W);                      var invViewMatrix = CameraExtensions.InverseViewMatrix(ref viewMatrix);                        bl = Vector4.Transform(bl' invViewMatrix);                      bl /= bl.W;                      br = Vector4.Transform(br' invViewMatrix);                      br /= br.W;                      tr = Vector4.Transform(tr' invViewMatrix);                      tr /= tr.W;                      tl = Vector4.Transform(tl' invViewMatrix);                      tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                  }                    // this all happens now in world space now:                  //Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));                  if (rayWS.Intersects(ref b))                  {                        float distance;                      if (Collision.RayIntersectsBox(ref rayWS' ref b' out distance))                      {                          h = true;                          result.ModelHit = this;                          result.IsValid = true;                          result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D();                          result.Distance = distance;                          Debug.WriteLine(string.Format("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,CreateRasterState,The following statement contains a magic number: var rasterStateDesc = new RasterizerStateDescription()              {                  FillMode = FillMode.Solid'                  CullMode = CullMode.None'                  DepthBias = DepthBias'                  DepthBiasClamp = -1000'                  SlopeScaledDepthBias = +0'                  IsDepthClipEnabled = true'                  IsFrontCounterClockwise = false'                    IsMultisampleEnabled = false'                  //IsAntialiasedLineEnabled = true'                                      IsScissorEnabled = IsThrowingShadow ? false : IsScissorEnabled'              };
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRender,The following statement contains a magic number: switch (billboardType)              {                  case BillboardType.MultipleText:                      // Use foreground shader to draw text                      effectTechnique.GetPassByIndex(0).Apply(renderContext.DeviceContext);                        // --- draw text' foreground vertex is beginning from 0.                      renderContext.DeviceContext.Draw(vertexCount' 0);                      break;                  case BillboardType.SingleText:                      if (vertexCount == 8)                      {                          var half = vertexCount / 2;                          // Use background shader to draw background first                          effectTechnique.GetPassByIndex(1).Apply(renderContext.DeviceContext);                          // --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>                          renderContext.DeviceContext.Draw(half' half);                            // Use foreground shader to draw text                          effectTechnique.GetPassByIndex(0).Apply(renderContext.DeviceContext);                            // --- draw text' foreground vertex is beginning from 0.                          renderContext.DeviceContext.Draw(half' 0);                      }                      break;                  case BillboardType.SingleImage:                      // Use foreground shader to draw text                      effectTechnique.GetPassByIndex(2).Apply(renderContext.DeviceContext);                        // --- draw text' foreground vertex is beginning from 0.                      renderContext.DeviceContext.Draw(vertexCount' 0);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRender,The following statement contains a magic number: switch (billboardType)              {                  case BillboardType.MultipleText:                      // Use foreground shader to draw text                      effectTechnique.GetPassByIndex(0).Apply(renderContext.DeviceContext);                        // --- draw text' foreground vertex is beginning from 0.                      renderContext.DeviceContext.Draw(vertexCount' 0);                      break;                  case BillboardType.SingleText:                      if (vertexCount == 8)                      {                          var half = vertexCount / 2;                          // Use background shader to draw background first                          effectTechnique.GetPassByIndex(1).Apply(renderContext.DeviceContext);                          // --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>                          renderContext.DeviceContext.Draw(half' half);                            // Use foreground shader to draw text                          effectTechnique.GetPassByIndex(0).Apply(renderContext.DeviceContext);                            // --- draw text' foreground vertex is beginning from 0.                          renderContext.DeviceContext.Draw(half' 0);                      }                      break;                  case BillboardType.SingleImage:                      // Use foreground shader to draw text                      effectTechnique.GetPassByIndex(2).Apply(renderContext.DeviceContext);                        // --- draw text' foreground vertex is beginning from 0.                      renderContext.DeviceContext.Draw(vertexCount' 0);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRender,The following statement contains a magic number: switch (billboardType)              {                  case BillboardType.MultipleText:                      // Use foreground shader to draw text                      effectTechnique.GetPassByIndex(0).Apply(renderContext.DeviceContext);                        // --- draw text' foreground vertex is beginning from 0.                      renderContext.DeviceContext.Draw(vertexCount' 0);                      break;                  case BillboardType.SingleText:                      if (vertexCount == 8)                      {                          var half = vertexCount / 2;                          // Use background shader to draw background first                          effectTechnique.GetPassByIndex(1).Apply(renderContext.DeviceContext);                          // --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>                          renderContext.DeviceContext.Draw(half' half);                            // Use foreground shader to draw text                          effectTechnique.GetPassByIndex(0).Apply(renderContext.DeviceContext);                            // --- draw text' foreground vertex is beginning from 0.                          renderContext.DeviceContext.Draw(half' 0);                      }                      break;                  case BillboardType.SingleImage:                      // Use foreground shader to draw text                      effectTechnique.GetPassByIndex(2).Apply(renderContext.DeviceContext);                        // --- draw text' foreground vertex is beginning from 0.                      renderContext.DeviceContext.Draw(vertexCount' 0);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,BoneSkinMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BoneSkinMeshGeometryModel3D.cs,OnRender,The following statement contains a magic number: if (this.hasInstances)              {                  // --- update instance buffer                  if (this.isInstanceChanged)                  {                      InstanceBuffer.UploadDataToBuffer(renderContext.DeviceContext' this.instanceInternal);                      this.isInstanceChanged = false;                  }                  renderContext.DeviceContext.InputAssembler.SetVertexBuffers(2' new VertexBufferBinding(this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0));                  OnInstancedDrawCall(renderContext);              }              else              {                  // --- bind buffer                                  renderContext.DeviceContext.InputAssembler.SetVertexBuffers(0' new VertexBufferBinding(this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0));                  OnDrawCall(renderContext);              }
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,CoordinateSystemModel3D,The following statement contains a magic number: builder.AddArrow(Vector3.Zero' new Vector3(10' 0' 0)' 1' 2' 10);
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,CoordinateSystemModel3D,The following statement contains a magic number: builder.AddArrow(Vector3.Zero' new Vector3(10' 0' 0)' 1' 2' 10);
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,CoordinateSystemModel3D,The following statement contains a magic number: builder.AddArrow(Vector3.Zero' new Vector3(10' 0' 0)' 1' 2' 10);
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,CoordinateSystemModel3D,The following statement contains a magic number: builder.AddArrow(Vector3.Zero' new Vector3(0' 10' 0)' 1' 2' 10);
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,CoordinateSystemModel3D,The following statement contains a magic number: builder.AddArrow(Vector3.Zero' new Vector3(0' 10' 0)' 1' 2' 10);
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,CoordinateSystemModel3D,The following statement contains a magic number: builder.AddArrow(Vector3.Zero' new Vector3(0' 10' 0)' 1' 2' 10);
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,CoordinateSystemModel3D,The following statement contains a magic number: builder.AddArrow(Vector3.Zero' new Vector3(0' 0' 10)' 1' 2' 10);
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,CoordinateSystemModel3D,The following statement contains a magic number: builder.AddArrow(Vector3.Zero' new Vector3(0' 0' 10)' 1' 2' 10);
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,CoordinateSystemModel3D,The following statement contains a magic number: builder.AddArrow(Vector3.Zero' new Vector3(0' 0' 10)' 1' 2' 10);
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,CoordinateSystemModel3D,The following statement contains a magic number: axisBillboards[2] = new BillboardTextModel3D() { IsHitTestVisible = false };
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,CoordinateSystemModel3D,The following statement contains a magic number: UpdateAxisColor(mesh' 2' AxisZColor.ToColor4());
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)              {                  case 0:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("X"' new Vector3(14' 0' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 1:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Y"' new Vector3(0' 14' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 2:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Z"' new Vector3(0' 0' 14))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)              {                  case 0:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("X"' new Vector3(14' 0' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 1:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Y"' new Vector3(0' 14' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 2:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Z"' new Vector3(0' 0' 14))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)              {                  case 0:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("X"' new Vector3(14' 0' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 1:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Y"' new Vector3(0' 14' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 2:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Z"' new Vector3(0' 0' 14))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)              {                  case 0:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("X"' new Vector3(14' 0' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 1:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Y"' new Vector3(0' 14' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 2:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Z"' new Vector3(0' 0' 14))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)              {                  case 0:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("X"' new Vector3(14' 0' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 1:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Y"' new Vector3(0' 14' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 2:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Z"' new Vector3(0' 0' 14))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)              {                  case 0:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("X"' new Vector3(14' 0' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 1:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Y"' new Vector3(0' 14' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 2:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Z"' new Vector3(0' 0' 14))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)              {                  case 0:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("X"' new Vector3(14' 0' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 1:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Y"' new Vector3(0' 14' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 2:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Z"' new Vector3(0' 0' 14))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,UpdateAxisColor,The following statement contains a magic number: int segment = mesh.Positions.Count / 3;
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,CreateRasterState,The following statement contains a magic number: var rasterStateDesc = new RasterizerStateDescription()              {                  FillMode = FillMode.Solid'                  CullMode = CullMode.None'                  DepthBias = DepthBias'                  DepthBiasClamp = -1000'                  SlopeScaledDepthBias = +0'                  IsDepthClipEnabled = true'                  IsFrontCounterClockwise = false'                    IsMultisampleEnabled = false'                  //IsAntialiasedLineEnabled = true'                                      IsScissorEnabled = IsThrowingShadow ? false : IsScissorEnabled'              };
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: if (this.hasInstances)              {                  if (this.isInstanceChanged)                  {                      InstanceBuffer.UploadDataToBuffer(renderContext.DeviceContext' this.instanceInternal);                      this.isInstanceChanged = false;                  }                  renderContext.DeviceContext.InputAssembler.SetVertexBuffers(1' new VertexBufferBinding(this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0));                  if (this.hasInstanceParams)                  {                      if (instanceParamArrayChanged)                      {                          instanceParamBuffer.UploadDataToBuffer(renderContext.DeviceContext' this.InstanceParamArray);                          this.instanceParamArrayChanged = false;                      }                      renderContext.DeviceContext.InputAssembler.SetVertexBuffers(2' new VertexBufferBinding(this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0));                  }                    switch (billboardType)                  {                      case BillboardType.SingleImage:                          // Use foreground shader to draw text                          effectTechnique.GetPassByIndex(2).Apply(renderContext.DeviceContext);                            // --- draw text' foreground vertex is beginning from 0.                          renderContext.DeviceContext.DrawInstanced(vertexCount' this.instanceInternal.Count' 0' 0);                          break;                      case BillboardType.SingleText:                          if (vertexCount == 8)                          {                              var half = vertexCount / 2;                              // Use background shader to draw background first                              effectTechnique.GetPassByIndex(1).Apply(renderContext.DeviceContext);                              // --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>                              renderContext.DeviceContext.DrawInstanced(half' this.instanceInternal.Count' half' 0);                                // Use foreground shader to draw text                              effectTechnique.GetPassByIndex(0).Apply(renderContext.DeviceContext);                                // --- draw text' foreground vertex is beginning from 0.                              renderContext.DeviceContext.DrawInstanced(half' this.instanceInternal.Count' 0' 0);                          }                          break;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: if (this.hasInstances)              {                  if (this.isInstanceChanged)                  {                      InstanceBuffer.UploadDataToBuffer(renderContext.DeviceContext' this.instanceInternal);                      this.isInstanceChanged = false;                  }                  renderContext.DeviceContext.InputAssembler.SetVertexBuffers(1' new VertexBufferBinding(this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0));                  if (this.hasInstanceParams)                  {                      if (instanceParamArrayChanged)                      {                          instanceParamBuffer.UploadDataToBuffer(renderContext.DeviceContext' this.InstanceParamArray);                          this.instanceParamArrayChanged = false;                      }                      renderContext.DeviceContext.InputAssembler.SetVertexBuffers(2' new VertexBufferBinding(this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0));                  }                    switch (billboardType)                  {                      case BillboardType.SingleImage:                          // Use foreground shader to draw text                          effectTechnique.GetPassByIndex(2).Apply(renderContext.DeviceContext);                            // --- draw text' foreground vertex is beginning from 0.                          renderContext.DeviceContext.DrawInstanced(vertexCount' this.instanceInternal.Count' 0' 0);                          break;                      case BillboardType.SingleText:                          if (vertexCount == 8)                          {                              var half = vertexCount / 2;                              // Use background shader to draw background first                              effectTechnique.GetPassByIndex(1).Apply(renderContext.DeviceContext);                              // --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>                              renderContext.DeviceContext.DrawInstanced(half' this.instanceInternal.Count' half' 0);                                // Use foreground shader to draw text                              effectTechnique.GetPassByIndex(0).Apply(renderContext.DeviceContext);                                // --- draw text' foreground vertex is beginning from 0.                              renderContext.DeviceContext.DrawInstanced(half' this.instanceInternal.Count' 0' 0);                          }                          break;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: if (this.hasInstances)              {                  if (this.isInstanceChanged)                  {                      InstanceBuffer.UploadDataToBuffer(renderContext.DeviceContext' this.instanceInternal);                      this.isInstanceChanged = false;                  }                  renderContext.DeviceContext.InputAssembler.SetVertexBuffers(1' new VertexBufferBinding(this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0));                  if (this.hasInstanceParams)                  {                      if (instanceParamArrayChanged)                      {                          instanceParamBuffer.UploadDataToBuffer(renderContext.DeviceContext' this.InstanceParamArray);                          this.instanceParamArrayChanged = false;                      }                      renderContext.DeviceContext.InputAssembler.SetVertexBuffers(2' new VertexBufferBinding(this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0));                  }                    switch (billboardType)                  {                      case BillboardType.SingleImage:                          // Use foreground shader to draw text                          effectTechnique.GetPassByIndex(2).Apply(renderContext.DeviceContext);                            // --- draw text' foreground vertex is beginning from 0.                          renderContext.DeviceContext.DrawInstanced(vertexCount' this.instanceInternal.Count' 0' 0);                          break;                      case BillboardType.SingleText:                          if (vertexCount == 8)                          {                              var half = vertexCount / 2;                              // Use background shader to draw background first                              effectTechnique.GetPassByIndex(1).Apply(renderContext.DeviceContext);                              // --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>                              renderContext.DeviceContext.DrawInstanced(half' this.instanceInternal.Count' half' 0);                                // Use foreground shader to draw text                              effectTechnique.GetPassByIndex(0).Apply(renderContext.DeviceContext);                                // --- draw text' foreground vertex is beginning from 0.                              renderContext.DeviceContext.DrawInstanced(half' this.instanceInternal.Count' 0' 0);                          }                          break;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: if (this.hasInstances)              {                  if (this.isInstanceChanged)                  {                      InstanceBuffer.UploadDataToBuffer(renderContext.DeviceContext' this.instanceInternal);                      this.isInstanceChanged = false;                  }                  renderContext.DeviceContext.InputAssembler.SetVertexBuffers(1' new VertexBufferBinding(this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0));                  if (this.hasInstanceParams)                  {                      if (instanceParamArrayChanged)                      {                          instanceParamBuffer.UploadDataToBuffer(renderContext.DeviceContext' this.InstanceParamArray);                          this.instanceParamArrayChanged = false;                      }                      renderContext.DeviceContext.InputAssembler.SetVertexBuffers(2' new VertexBufferBinding(this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0));                  }                    switch (billboardType)                  {                      case BillboardType.SingleImage:                          // Use foreground shader to draw text                          effectTechnique.GetPassByIndex(2).Apply(renderContext.DeviceContext);                            // --- draw text' foreground vertex is beginning from 0.                          renderContext.DeviceContext.DrawInstanced(vertexCount' this.instanceInternal.Count' 0' 0);                          break;                      case BillboardType.SingleText:                          if (vertexCount == 8)                          {                              var half = vertexCount / 2;                              // Use background shader to draw background first                              effectTechnique.GetPassByIndex(1).Apply(renderContext.DeviceContext);                              // --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>                              renderContext.DeviceContext.DrawInstanced(half' this.instanceInternal.Count' half' 0);                                // Use foreground shader to draw text                              effectTechnique.GetPassByIndex(0).Apply(renderContext.DeviceContext);                                // --- draw text' foreground vertex is beginning from 0.                              renderContext.DeviceContext.DrawInstanced(half' this.instanceInternal.Count' 0' 0);                          }                          break;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingMeshGeometryModel3D.cs,OnRender,The following statement contains a magic number: if (this.hasInstances)              {                  // --- update instance buffer                  if (this.isInstanceChanged)                  {                      BuildOctree();                      InstanceBuffer.UploadDataToBuffer(renderContext.DeviceContext' this.instanceInternal);                      this.isInstanceChanged = false;                  }                  renderContext.DeviceContext.InputAssembler.SetVertexBuffers(1' new VertexBufferBinding(this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0));                  if (this.hasInstanceParams)                  {                      if (instanceParamArrayChanged)                      {                          instanceParamBuffer.UploadDataToBuffer(renderContext.DeviceContext' this.InstanceParamArray);                          this.instanceParamArrayChanged = false;                      }                      renderContext.DeviceContext.InputAssembler.SetVertexBuffers(2' new VertexBufferBinding(this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0));                  }                    OnInstancedDrawCall(renderContext);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeLineGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\OctreeLineGeometryModel3D.cs,OctreeLineGeometryModel3D,The following statement contains a magic number: HitVisual.Thickness = 1.5;
Magic Number,HelixToolkit.Wpf.SharpDX,OutLineMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\OutLineMeshGeometryModel3D.cs,OnOutLineDrawCall,The following statement contains a magic number: if (enableOutline)              {                  SetParameters();                  // --- render the xray                  //                   var pass1 = this.effectTechnique.GetPassByIndex(2);                  pass1.Apply(renderContext.DeviceContext);                  renderContext.DeviceContext.OutputMerger.SetBlendState(blendState' null' 0xFFFFFFFF);                  renderContext.DeviceContext.OutputMerger.SetDepthStencilState(depthStencilState' 0);                  // --- draw                  renderContext.DeviceContext.DrawIndexed(this.geometryInternal.Indices.Count' 0' 0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OutLineMeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\OutLineMeshGeometryModel3D.cs,OnOutLineInstancedDrawCall,The following statement contains a magic number: if (enableOutline)              {                  SetParameters();                  // --- render the xray                  //                   var pass1 = this.effectTechnique.GetPassByIndex(2);                  pass1.Apply(renderContext.DeviceContext);                  renderContext.DeviceContext.OutputMerger.SetBlendState(blendState' null' 0xFFFFFFFF);                  renderContext.DeviceContext.OutputMerger.SetDepthStencilState(depthStencilState' 0);                  // --- draw                  renderContext.DeviceContext.DrawIndexedInstanced(this.geometryInternal.Indices.Count' this.instanceInternal.Count' 0' 0' 0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ParticleStormModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ParticleStormModel3D.cs,InitializeBuffers,The following statement contains a magic number: var stagingbufferDesc = new BufferDescription()              {                  BindFlags = BindFlags.None'                  OptionFlags = ResourceOptionFlags.None'                  SizeInBytes = 4 * global::SharpDX.Utilities.SizeOf<uint>()'                  CpuAccessFlags = CpuAccessFlags.Read'                  Usage = ResourceUsage.Staging              };
Magic Number,HelixToolkit.Wpf.SharpDX,ParticleStormModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ParticleStormModel3D.cs,OnRender,The following statement contains a magic number: if (isRestart)              {                  pass = this.effectTechnique.GetPassByIndex(1);                  pass.Apply(context.DeviceContext);                  // Reset Both UAV buffers                  context.DeviceContext.ComputeShader.SetUnorderedAccessView(0' BufferProxies[0].UAV' 0);                  context.DeviceContext.ComputeShader.SetUnorderedAccessView(1' BufferProxies[1].UAV' 0);                  context.DeviceContext.ComputeShader.SetConstantBuffer(1' frameConstBuffer.Buffer);                  // Call ComputeShader to add initial particles                  context.DeviceContext.Dispatch(1' 1' 1);                  isRestart = false;              }              else              {                  //upload framebuffer                  context.DeviceContext.UpdateSubresource(ref parameters.frameVariables' frameConstBuffer.Buffer);                  // Get consume buffer count                  context.DeviceContext.CopyStructureCount(frameConstBuffer.Buffer' ParticlePerFrame.NumParticlesOffset' BufferProxies[0].UAV);                  // Calculate existing particles                  pass = this.effectTechnique.GetPassByIndex(1);                  pass.Apply(context.DeviceContext);                  context.DeviceContext.ComputeShader.SetUnorderedAccessView(0' BufferProxies[0].UAV);                  context.DeviceContext.ComputeShader.SetUnorderedAccessView(1' BufferProxies[1].UAV' 0);                  context.DeviceContext.ComputeShader.SetConstantBuffer(1' frameConstBuffer.Buffer);                  context.DeviceContext.Dispatch(System.Math.Max(1' parameters.particleCountInternal / 512)' 1' 1);                  // Get append buffer count                  context.DeviceContext.CopyStructureCount(particleCountGSIABuffer.Buffer' 0' BufferProxies[1].UAV);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ParticleStormModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ParticleStormModel3D.cs,OnRender,The following statement contains a magic number: pass = this.effectTechnique.GetPassByIndex(2);
Magic Number,HelixToolkit.Wpf.SharpDX,ParticleParameters,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ParticleStormModel3D.cs,UpdateInsertThrottle,The following statement contains a magic number: insertThrottle = (8.0f * insertVariables.InitialEnergy / insertVariables.EnergyDissipationRate / System.Math.Max(0' (particleCountInternal + 8)));
Magic Number,HelixToolkit.Wpf.SharpDX,ParticleParameters,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ParticleStormModel3D.cs,UpdateTime,The following statement contains a magic number: float timeElapsed = ((float)context.TimeStamp.TotalMilliseconds - prevTimeMillis) / 1000;
Magic Number,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,CreateRasterState,The following statement contains a magic number: var rasterStateDesc = new RasterizerStateDescription()              {                  FillMode = FillMode'                  CullMode = CullMode'                  DepthBias = -5'                  DepthBiasClamp = -10'                  SlopeScaledDepthBias = +0'                  IsDepthClipEnabled = IsDepthClipEnabled'                  IsFrontCounterClockwise = FrontCounterClockwise'                    IsMultisampleEnabled = IsMultisampleEnabled'                  //IsAntialiasedLineEnabled = true'                  IsScissorEnabled = IsThrowingShadow ? false : IsScissorEnabled              };
Magic Number,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,CreateRasterState,The following statement contains a magic number: var rasterStateDesc = new RasterizerStateDescription()              {                  FillMode = FillMode'                  CullMode = CullMode'                  DepthBias = -5'                  DepthBiasClamp = -10'                  SlopeScaledDepthBias = +0'                  IsDepthClipEnabled = IsDepthClipEnabled'                  IsFrontCounterClockwise = FrontCounterClockwise'                    IsMultisampleEnabled = IsMultisampleEnabled'                  //IsAntialiasedLineEnabled = true'                  IsScissorEnabled = IsThrowingShadow ? false : IsScissorEnabled              };
Magic Number,HelixToolkit.Wpf.SharpDX,PointGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PointGeometryModel3D.cs,CreateRasterState,The following statement contains a magic number: var rasterStateDesc = new RasterizerStateDescription()              {                  FillMode = FillMode.Solid'                  CullMode = CullMode.None'                  DepthBias = DepthBias'                  DepthBiasClamp = -1000'                  SlopeScaledDepthBias = -2'                  IsDepthClipEnabled = true'                  IsFrontCounterClockwise = false'                  IsMultisampleEnabled = true'                  IsScissorEnabled = IsThrowingShadow ? false : IsScissorEnabled              };
Magic Number,HelixToolkit.Wpf.SharpDX,PointGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PointGeometryModel3D.cs,CreateRasterState,The following statement contains a magic number: var rasterStateDesc = new RasterizerStateDescription()              {                  FillMode = FillMode.Solid'                  CullMode = CullMode.None'                  DepthBias = DepthBias'                  DepthBiasClamp = -1000'                  SlopeScaledDepthBias = -2'                  IsDepthClipEnabled = true'                  IsFrontCounterClockwise = false'                  IsMultisampleEnabled = true'                  IsScissorEnabled = IsThrowingShadow ? false : IsScissorEnabled              };
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,ViewBoxModel3D,The following statement contains a magic number: builder.AddBox(Vector3.Zero' 10' 10' 10);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,ViewBoxModel3D,The following statement contains a magic number: builder.AddBox(Vector3.Zero' 10' 10' 10);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,ViewBoxModel3D,The following statement contains a magic number: builder.AddBox(Vector3.Zero' 10' 10' 10);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,ViewBoxModel3D,The following statement contains a magic number: var center = new Vector3(0' -7' 0);
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,ViewBoxModel3D,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  double angle = 0 + (360 * i / (20 - 1));                  double angleRad = angle / 180 * Math.PI;                  var dir = (right * (float)Math.Cos(angleRad)) + (up * (float)Math.Sin(angleRad));                  pts.Add(center + (dir * 8));                  pts.Add(center + (dir * 12));              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,ViewBoxModel3D,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  double angle = 0 + (360 * i / (20 - 1));                  double angleRad = angle / 180 * Math.PI;                  var dir = (right * (float)Math.Cos(angleRad)) + (up * (float)Math.Sin(angleRad));                  pts.Add(center + (dir * 8));                  pts.Add(center + (dir * 12));              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,ViewBoxModel3D,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  double angle = 0 + (360 * i / (20 - 1));                  double angleRad = angle / 180 * Math.PI;                  var dir = (right * (float)Math.Cos(angleRad)) + (up * (float)Math.Sin(angleRad));                  pts.Add(center + (dir * 8));                  pts.Add(center + (dir * 12));              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,ViewBoxModel3D,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  double angle = 0 + (360 * i / (20 - 1));                  double angleRad = angle / 180 * Math.PI;                  var dir = (right * (float)Math.Cos(angleRad)) + (up * (float)Math.Sin(angleRad));                  pts.Add(center + (dir * 8));                  pts.Add(center + (dir * 12));              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,ViewBoxModel3D,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  double angle = 0 + (360 * i / (20 - 1));                  double angleRad = angle / 180 * Math.PI;                  var dir = (right * (float)Math.Cos(angleRad)) + (up * (float)Math.Sin(angleRad));                  pts.Add(center + (dir * 8));                  pts.Add(center + (dir * 12));              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,ViewBoxModel3D,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  double angle = 0 + (360 * i / (20 - 1));                  double angleRad = angle / 180 * Math.PI;                  var dir = (right * (float)Math.Cos(angleRad)) + (up * (float)Math.Sin(angleRad));                  pts.Add(center + (dir * 8));                  pts.Add(center + (dir * 12));              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,ViewBoxModel3D,The following statement contains a magic number: for (int i = 0; i < count; i += 3)              {                  newMesh.Indices.Add(pie.Indices[i + 2]);                  newMesh.Indices.Add(pie.Indices[i + 1]);                  newMesh.Indices.Add(pie.Indices[i]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,ViewBoxModel3D,The following statement contains a magic number: for (int i = 0; i < count; i += 3)              {                  newMesh.Indices.Add(pie.Indices[i + 2]);                  newMesh.Indices.Add(pie.Indices[i + 1]);                  newMesh.Indices.Add(pie.Indices[i]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,CreateTextureCoordinates,The following statement contains a magic number: int faces = 6;
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,CreateTextureCoordinates,The following statement contains a magic number: int segment = 4;
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,CreateTextureCoordinates,The following statement contains a magic number: var t = mesh.TextureCoordinates[3];
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,CreateTextureCoordinates,The following statement contains a magic number: for(int i = 2; i >=0; --i)              {                  mesh.TextureCoordinates[i+1] = mesh.TextureCoordinates[i];              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,CreateTextureCoordinates,The following statement contains a magic number: t = mesh.TextureCoordinates[4];
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,CreateTextureCoordinates,The following statement contains a magic number: for(int i=4; i<7; ++i)              {                  mesh.TextureCoordinates[i] = mesh.TextureCoordinates[i + 1];              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,CreateTextureCoordinates,The following statement contains a magic number: for(int i=4; i<7; ++i)              {                  mesh.TextureCoordinates[i] = mesh.TextureCoordinates[i + 1];              }
Magic Number,HelixToolkit.Wpf.SharpDX,ViewBoxModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ViewBoxModel3D.cs,CreateTextureCoordinates,The following statement contains a magic number: mesh.TextureCoordinates[7] = t;
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,BillboardSingleImage3D,The following statement contains a magic number: Positions = new Vector3Collection(6);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,BillboardSingleImage3D,The following statement contains a magic number: Colors = new Color4Collection(6);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,BillboardSingleImage3D,The following statement contains a magic number: TextureCoordinates = new Vector2Collection(6);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,DrawTexture,The following statement contains a magic number: mTextInfoOffsets = new List<Vector2>(4);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,DrawTexture,The following statement contains a magic number: var a = new Vector2(-w / 2' -h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,DrawTexture,The following statement contains a magic number: var a = new Vector2(-w / 2' -h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,DrawTexture,The following statement contains a magic number: var b = new Vector2(-w / 2' h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,DrawTexture,The following statement contains a magic number: var b = new Vector2(-w / 2' h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,DrawTexture,The following statement contains a magic number: var c = new Vector2(w / 2' -h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,DrawTexture,The following statement contains a magic number: var c = new Vector2(w / 2' -h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,DrawTexture,The following statement contains a magic number: var d = new Vector2(w / 2' h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,DrawTexture,The following statement contains a magic number: var d = new Vector2(w / 2' h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,BillboardSingleText3D,The following statement contains a magic number: Positions = new Vector3Collection(12);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,BillboardSingleText3D,The following statement contains a magic number: Colors = new Color4Collection(12);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,BillboardSingleText3D,The following statement contains a magic number: TextureCoordinates = new Vector2Collection(12);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,BillboardSingleText3D,The following statement contains a magic number: Positions = new Vector3Collection(12);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,BillboardSingleText3D,The following statement contains a magic number: Colors = new Color4Collection(12);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,BillboardSingleText3D,The following statement contains a magic number: TextureCoordinates = new Vector2Collection(12);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The following statement contains a magic number: var a = new Vector2(-w / 2' -h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The following statement contains a magic number: var a = new Vector2(-w / 2' -h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The following statement contains a magic number: var b = new Vector2(-w / 2' h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The following statement contains a magic number: var b = new Vector2(-w / 2' h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The following statement contains a magic number: var c = new Vector2(w / 2' -h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The following statement contains a magic number: var c = new Vector2(w / 2' -h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The following statement contains a magic number: var d = new Vector2(w / 2' h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The following statement contains a magic number: var d = new Vector2(w / 2' h / 2);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,OctreeBase,The following statement contains a magic number: queue = queueCache ?? new Queue<IOctree>(64);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,CreateOctants,The following statement contains a magic number: return new BoundingBox[8] {                  new BoundingBox(minimum' center)'                  new BoundingBox(new Vector3(center.X' minimum.Y' minimum.Z)' new Vector3(maximum.X' center.Y' center.Z))'                  new BoundingBox(new Vector3(center.X' minimum.Y' center.Z)' new Vector3(maximum.X' center.Y' maximum.Z))'                  new BoundingBox(new Vector3(minimum.X' minimum.Y' center.Z)' new Vector3(center.X' center.Y' maximum.Z))'                  new BoundingBox(new Vector3(minimum.X' center.Y' minimum.Z)' new Vector3(center.X' maximum.Y' center.Z))'                  new BoundingBox(new Vector3(center.X' center.Y' minimum.Z)' new Vector3(maximum.X' maximum.Y' center.Z))'                  new BoundingBox(center' maximum)'                  new BoundingBox(new Vector3(minimum.X' center.Y' center.Z)' new Vector3(center.X' maximum.Y' maximum.Z))                  };
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,BuildSubTree,The following statement contains a magic number: var octList = new List<T>[8];
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,BuildSubTree,The following statement contains a magic number: for (int i = 0; i < 8; ++i)                  octList[i] = new List<T>(Objects.Count / 8);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,BuildSubTree,The following statement contains a magic number: for (int i = 0; i < 8; ++i)                  octList[i] = new List<T>(Objects.Count / 8);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,BuildSubTree,The following statement contains a magic number: for (int i = Objects.Count - 1; i >= 0; --i)              {                  var obj = Objects[i];                  for (int x = 0; x < 8; ++x)                  {                                            if(IsContains(Octants[x]' obj))                      {                          octList[x].Add(obj);                          Objects[i] = Objects[--count]; //Disard the existing object from location i' replaced with last valid object.                          break;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,BuildSubTree,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  if (octList[i].Count != 0)                  {                      ChildNodes[i] = CreateNode(ref octants[i]' octList[i]);                      ActiveNodes |= (byte)(1 << i);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindEnclosingCube,The following statement contains a magic number: var v = (bound.Maximum - bound.Minimum) / 2 + bound.Minimum;
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,SigBit,The following statement contains a magic number: if (x >= 0)              {                  return (int)Math.Pow(2' Math.Ceiling(Math.Log(x) / Math.Log(2)));              }              else              {                  x = Math.Abs(x);                  return -(int)Math.Pow(2' Math.Ceiling(Math.Log(x) / Math.Log(2)));              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,SigBit,The following statement contains a magic number: if (x >= 0)              {                  return (int)Math.Pow(2' Math.Ceiling(Math.Log(x) / Math.Log(2)));              }              else              {                  x = Math.Abs(x);                  return -(int)Math.Pow(2' Math.Ceiling(Math.Log(x) / Math.Log(2)));              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,SigBit,The following statement contains a magic number: if (x >= 0)              {                  return (int)Math.Pow(2' Math.Ceiling(Math.Log(x) / Math.Log(2)));              }              else              {                  x = Math.Abs(x);                  return -(int)Math.Pow(2' Math.Ceiling(Math.Log(x) / Math.Log(2)));              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,SigBit,The following statement contains a magic number: if (x >= 0)              {                  return (int)Math.Pow(2' Math.Ceiling(Math.Log(x) / Math.Log(2)));              }              else              {                  x = Math.Abs(x);                  return -(int)Math.Pow(2' Math.Ceiling(Math.Log(x) / Math.Log(2)));              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,Expand,The following statement contains a magic number: var half = dimension / 2 + epsilon;
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,Expand,The following statement contains a magic number: var newSize = dimension * 2;
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase<T>,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,Expand,The following statement contains a magic number: if (!oldRoot.IsEmpty)              {                  int idx = -1;                  float diff = float.MaxValue;                  for (int i = 0; i < newRoot.Octants.Length; ++i)                  {                      var d = (newRoot.Octants[i].Minimum - rootBound.Minimum).LengthSquared();                      if (d < diff)                      {                          diff = d;                          idx = i;                          if (diff < 10e-8)                          {                              break;                          }                      }                  }                  if (idx >= 0 && idx < newRoot.Octants.Length)                  {                      newRoot.ChildNodes[idx] = oldRoot;                      newRoot.Octants[idx] = oldRoot.Bound;                      newRoot.ActiveNodes |= (byte)(1 << idx);                      oldRoot.Parent = newRoot;                      succ = true;                  }                    if (!succ)                  {                      throw new Exception("Expand failed.");                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,MeshGeometryOctree,The following statement contains a magic number: Objects = new List<Tuple<int' BoundingBox>>(indices.Count / 3);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,MeshGeometryOctree,The following statement contains a magic number: foreach (var i in Enumerable.Range(0' indices.Count / 3))              {                  Objects.Add(new Tuple<int' BoundingBox>(i' GetBoundingBox(i)));              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,GetBoundingBox,The following statement contains a magic number: var actual = triangleIndex * 3;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The following statement contains a magic number: if (rayModel.Intersects(ref bound) && (!checkBoundSphere || rayModel.Intersects(ref boundSphere)))              {                  isIntersect = true;                  foreach (var t in this.Objects)                  {                      var idx = t.Item1 * 3;                      var t1 = Indices[idx];                      var t2 = Indices[idx + 1];                      var t3 = Indices[idx + 2];                      var v0 = Positions[t1];                      var v1 = Positions[t2];                      var v2 = Positions[t3];                      float d;                        if (Collision.RayIntersectsTriangle(ref rayModel' ref v0' ref v1' ref v2' out d))                      {                          if (d >= 0 && d < result.Distance) // If d is NaN' the condition is false.                          {                              result.IsValid = true;                              result.ModelHit = model;                              // transform hit-info to world space now:                              var pointWorld = Vector3.TransformCoordinate(rayModel.Position + (rayModel.Direction * d)' modelMatrix);                              result.PointHit = pointWorld.ToPoint3D();                              result.Distance = (rayWS.Position - pointWorld).Length();                                var p0 = Vector3.TransformCoordinate(v0' modelMatrix);                              var p1 = Vector3.TransformCoordinate(v1' modelMatrix);                              var p2 = Vector3.TransformCoordinate(v2' modelMatrix);                              var n = Vector3.Cross(p1 - p0' p2 - p0);                              n.Normalize();                              // transform hit-info to world space now:                              result.NormalAtHit = n.ToVector3D();// Vector3.TransformNormal(n' m).ToVector3D();                              result.TriangleIndices = new System.Tuple<int' int' int>(t1' t2' t3);                              result.Tag = t.Item1;                              isHit = true;                          }                      }                  }                    if (isHit)                  {                      isHit = false;                      if (hits.Count > 0)                      {                          if (hits[0].Distance > result.Distance)                          {                              hits[0] = result;                              isHit = true;                          }                      }                      else                      {                          hits.Add(result);                          isHit = true;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The following statement contains a magic number: if (rayModel.Intersects(ref bound) && (!checkBoundSphere || rayModel.Intersects(ref boundSphere)))              {                  isIntersect = true;                  foreach (var t in this.Objects)                  {                      var idx = t.Item1 * 3;                      var t1 = Indices[idx];                      var t2 = Indices[idx + 1];                      var t3 = Indices[idx + 2];                      var v0 = Positions[t1];                      var v1 = Positions[t2];                      var v2 = Positions[t3];                      float d;                        if (Collision.RayIntersectsTriangle(ref rayModel' ref v0' ref v1' ref v2' out d))                      {                          if (d >= 0 && d < result.Distance) // If d is NaN' the condition is false.                          {                              result.IsValid = true;                              result.ModelHit = model;                              // transform hit-info to world space now:                              var pointWorld = Vector3.TransformCoordinate(rayModel.Position + (rayModel.Direction * d)' modelMatrix);                              result.PointHit = pointWorld.ToPoint3D();                              result.Distance = (rayWS.Position - pointWorld).Length();                                var p0 = Vector3.TransformCoordinate(v0' modelMatrix);                              var p1 = Vector3.TransformCoordinate(v1' modelMatrix);                              var p2 = Vector3.TransformCoordinate(v2' modelMatrix);                              var n = Vector3.Cross(p1 - p0' p2 - p0);                              n.Normalize();                              // transform hit-info to world space now:                              result.NormalAtHit = n.ToVector3D();// Vector3.TransformNormal(n' m).ToVector3D();                              result.TriangleIndices = new System.Tuple<int' int' int>(t1' t2' t3);                              result.Tag = t.Item1;                              isHit = true;                          }                      }                  }                    if (isHit)                  {                      isHit = false;                      if (hits.Count > 0)                      {                          if (hits[0].Distance > result.Distance)                          {                              hits[0] = result;                              isHit = true;                          }                      }                      else                      {                          hits.Add(result);                          isHit = true;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindNearestPointBySphereExcludeChild,The following statement contains a magic number: if (containment == ContainmentType.Contains || containment == ContainmentType.Intersects)              {                  isIntersect = true;                  foreach (var t in Objects)                  {                      containment = t.Item2.Contains(sphere);                      if (containment == ContainmentType.Contains || containment == ContainmentType.Intersects)                      {                          Vector3 cloestPoint;                            var idx = t.Item1 * 3;                          var t1 = Indices[idx];                          var t2 = Indices[idx + 1];                          var t3 = Indices[idx + 2];                          var v0 = Positions[t1];                          var v1 = Positions[t2];                          var v2 = Positions[t3];                          Collision.ClosestPointPointTriangle(ref sphere.Center' ref v0' ref v1' ref v2' out cloestPoint);                          var d = (cloestPoint - sphere.Center).Length();                          if (tempResult.Distance > d)                          {                              tempResult.Distance = d;                              tempResult.IsValid = true;                              tempResult.PointHit = cloestPoint.ToPoint3D();                              tempResult.TriangleIndices = new Tuple<int' int' int>(t1' t2' t3);                              tempResult.Tag = t.Item1;                              isHit = true;                          }                      }                  }                  if (isHit)                  {                      isHit = false;                      if (result.Count > 0)                      {                          if (result[0].Distance > tempResult.Distance)                          {                              result[0] = tempResult;                              isHit = true;                          }                      }                      else                      {                          result.Add(tempResult);                          isHit = true;                      }                  }              }              else              {                  isIntersect = false;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindNearestPointBySphereExcludeChild,The following statement contains a magic number: if (containment == ContainmentType.Contains || containment == ContainmentType.Intersects)              {                  isIntersect = true;                  foreach (var t in Objects)                  {                      containment = t.Item2.Contains(sphere);                      if (containment == ContainmentType.Contains || containment == ContainmentType.Intersects)                      {                          Vector3 cloestPoint;                            var idx = t.Item1 * 3;                          var t1 = Indices[idx];                          var t2 = Indices[idx + 1];                          var t3 = Indices[idx + 2];                          var v0 = Positions[t1];                          var v1 = Positions[t2];                          var v2 = Positions[t3];                          Collision.ClosestPointPointTriangle(ref sphere.Center' ref v0' ref v1' ref v2' out cloestPoint);                          var d = (cloestPoint - sphere.Center).Length();                          if (tempResult.Distance > d)                          {                              tempResult.Distance = d;                              tempResult.IsValid = true;                              tempResult.PointHit = cloestPoint.ToPoint3D();                              tempResult.TriangleIndices = new Tuple<int' int' int>(t1' t2' t3);                              tempResult.Tag = t.Item1;                              isHit = true;                          }                      }                  }                  if (isHit)                  {                      isHit = false;                      if (result.Count > 0)                      {                          if (result[0].Distance > tempResult.Distance)                          {                              result[0] = tempResult;                              isHit = true;                          }                      }                      else                      {                          result.Add(tempResult);                          isHit = true;                      }                  }              }              else              {                  isIntersect = false;              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: Vector3[] verts = new Vector3[8];
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[7] = box.Maximum;
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[0]' verts[2]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[0]' verts[3]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[4]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[4]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[5]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[5]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[6]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[6]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[1]' verts[6]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[1]' verts[5]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[4]' verts[2]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[4]' verts[2]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[4]' verts[3]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[4]' verts[3]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[2]' verts[6]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[2]' verts[6]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[3]' verts[5]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[3]' verts[5]);
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: Vector3[] verts = new Vector3[8];
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path)              {                  verts[0] = box.Minimum;                  verts[1] = new Vector3(box.Minimum.X' box.Minimum.Y' box.Maximum.Z); //Z                  verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z); //Y                  verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z); //X                    verts[7] = box.Maximum;                  verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z); //Z                  verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z); //Y                  verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z); //X                  builder.AddLine(verts[0]' verts[1]);                  builder.AddLine(verts[0]' verts[2]);                  builder.AddLine(verts[0]' verts[3]);                  builder.AddLine(verts[7]' verts[4]);                  builder.AddLine(verts[7]' verts[5]);                  builder.AddLine(verts[7]' verts[6]);                    builder.AddLine(verts[1]' verts[6]);                  builder.AddLine(verts[1]' verts[5]);                  builder.AddLine(verts[4]' verts[2]);                  builder.AddLine(verts[4]' verts[3]);                  builder.AddLine(verts[2]' verts[6]);                  builder.AddLine(verts[3]' verts[5]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,GeometryModel3DOctreeManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeManager.cs,AddItem,The following statement contains a magic number: if (Enabled && item is GeometryModel3D)              {                  var tree = mOctree;                  UpdateOctree(null);                  var model = item as GeometryModel3D;                  if (tree == null)                  {                      RequestRebuild();                  }                  else                  {                      bool succeed = true;                      int counter = 0;                      while (!tree.Add(model))                      {                          var direction = (model.Bounds.Minimum + model.Bounds.Maximum)                              - (tree.Bound.Minimum + tree.Bound.Maximum);                          tree = tree.Expand(ref direction) as GeometryModel3DOctree;                          ++counter;                          if (counter > 10)                          {  #if DEBUG                              throw new Exception("Expand tree failed");  #else                              succeed = false;                              break;  #endif                          }                      }                      if (succeed)                      {                          UpdateOctree(tree);                          SubscribeBoundChangeEvent(model);                      }                      else                      {                          RequestRebuild();                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingModel3DOctreeManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeManager.cs,RebuildTree,The following statement contains a magic number: var octree = new InstancingModel3DOctree(instMatrix' model3D.BoundsWithTransform' this.Parameter' new Queue<IOctree>(256));
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: using (var reader = new StreamReader(s))              {                  bool containsNormals = false;                  bool containsTextureCoordinates = false;                  bool containsColors = false;                  bool containsHomogeneousCoordinates = false;                  int vertexDimension = 3;                  bool nextLineContainsVertexDimension = false;                  bool nextLineContainsNumberOfVertices = false;                  int numberOfVertices = 0;                  int numberOfFaces = 0;                  // int numberOfEdges = 0;                    while (!reader.EndOfStream)                  {                      var line = reader.ReadLine();                      if (line == null)                      {                          break;                      }                        line = line.Trim();                      if (line.StartsWith("#") || line.Length == 0)                      {                          continue;                      }                        if (nextLineContainsVertexDimension)                      {                          var values = GetIntValues(line);                          vertexDimension = values[0];                          nextLineContainsVertexDimension = false;                          continue;                      }                        if (line.Contains("OFF"))                      {                          containsNormals = line.Contains("N");                          containsColors = line.Contains("C");                          containsTextureCoordinates = line.Contains("ST");                          if (line.Contains("4"))                          {                              containsHomogeneousCoordinates = true;                          }                            if (line.Contains("n"))                          {                              nextLineContainsVertexDimension = true;                          }                            nextLineContainsNumberOfVertices = true;                          continue;                      }                        if (nextLineContainsNumberOfVertices)                      {                          var values = GetIntValues(line);                          numberOfVertices = values[0];                          numberOfFaces = values[1];                            /* numberOfEdges = values[2]; */                          nextLineContainsNumberOfVertices = false;                          continue;                      }                        if (this.Vertices.Count < numberOfVertices)                      {                          var x = new double[vertexDimension];                          var values = GetValues(line);                          int i = 0;                          for (int j = 0; j < vertexDimension; j++)                          {                              x[j] = values[i++];                          }                            var n = new double[vertexDimension];                          var uv = new double[2];                          double w = 0;                          if (containsHomogeneousCoordinates)                          {                              w = values[i++];                          }                            if (containsNormals)                          {                              for (int j = 0; j < vertexDimension; j++)                              {                                  n[j] = values[i++];                              }                          }                            if (containsColors)                          {                              // read color                          }                            if (containsTextureCoordinates)                          {                              for (int j = 0; j < 2; j++)                              {                                  uv[j] = values[i++];                              }                          }                            this.Vertices.Add(new Point3D((float)x[0]' (float)x[1]' (float)x[2]));                            continue;                      }                        if (this.Faces.Count < numberOfFaces)                      {                          var values = GetIntValues(line);                          int nv = values[0];                          var vertices = new int[nv];                          for (int i = 0; i < nv; i++)                          {                              vertices[i] = values[i + 1];                          }                            if (containsColors)                          {                              // read colorspec                          }                            this.Faces.Add(vertices);                          continue;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: using (var reader = new StreamReader(s))              {                  bool containsNormals = false;                  bool containsTextureCoordinates = false;                  bool containsColors = false;                  bool containsHomogeneousCoordinates = false;                  int vertexDimension = 3;                  bool nextLineContainsVertexDimension = false;                  bool nextLineContainsNumberOfVertices = false;                  int numberOfVertices = 0;                  int numberOfFaces = 0;                  // int numberOfEdges = 0;                    while (!reader.EndOfStream)                  {                      var line = reader.ReadLine();                      if (line == null)                      {                          break;                      }                        line = line.Trim();                      if (line.StartsWith("#") || line.Length == 0)                      {                          continue;                      }                        if (nextLineContainsVertexDimension)                      {                          var values = GetIntValues(line);                          vertexDimension = values[0];                          nextLineContainsVertexDimension = false;                          continue;                      }                        if (line.Contains("OFF"))                      {                          containsNormals = line.Contains("N");                          containsColors = line.Contains("C");                          containsTextureCoordinates = line.Contains("ST");                          if (line.Contains("4"))                          {                              containsHomogeneousCoordinates = true;                          }                            if (line.Contains("n"))                          {                              nextLineContainsVertexDimension = true;                          }                            nextLineContainsNumberOfVertices = true;                          continue;                      }                        if (nextLineContainsNumberOfVertices)                      {                          var values = GetIntValues(line);                          numberOfVertices = values[0];                          numberOfFaces = values[1];                            /* numberOfEdges = values[2]; */                          nextLineContainsNumberOfVertices = false;                          continue;                      }                        if (this.Vertices.Count < numberOfVertices)                      {                          var x = new double[vertexDimension];                          var values = GetValues(line);                          int i = 0;                          for (int j = 0; j < vertexDimension; j++)                          {                              x[j] = values[i++];                          }                            var n = new double[vertexDimension];                          var uv = new double[2];                          double w = 0;                          if (containsHomogeneousCoordinates)                          {                              w = values[i++];                          }                            if (containsNormals)                          {                              for (int j = 0; j < vertexDimension; j++)                              {                                  n[j] = values[i++];                              }                          }                            if (containsColors)                          {                              // read color                          }                            if (containsTextureCoordinates)                          {                              for (int j = 0; j < 2; j++)                              {                                  uv[j] = values[i++];                              }                          }                            this.Vertices.Add(new Point3D((float)x[0]' (float)x[1]' (float)x[2]));                            continue;                      }                        if (this.Faces.Count < numberOfFaces)                      {                          var values = GetIntValues(line);                          int nv = values[0];                          var vertices = new int[nv];                          for (int i = 0; i < nv; i++)                          {                              vertices[i] = values[i + 1];                          }                            if (containsColors)                          {                              // read colorspec                          }                            this.Faces.Add(vertices);                          continue;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: using (var reader = new StreamReader(s))              {                  bool containsNormals = false;                  bool containsTextureCoordinates = false;                  bool containsColors = false;                  bool containsHomogeneousCoordinates = false;                  int vertexDimension = 3;                  bool nextLineContainsVertexDimension = false;                  bool nextLineContainsNumberOfVertices = false;                  int numberOfVertices = 0;                  int numberOfFaces = 0;                  // int numberOfEdges = 0;                    while (!reader.EndOfStream)                  {                      var line = reader.ReadLine();                      if (line == null)                      {                          break;                      }                        line = line.Trim();                      if (line.StartsWith("#") || line.Length == 0)                      {                          continue;                      }                        if (nextLineContainsVertexDimension)                      {                          var values = GetIntValues(line);                          vertexDimension = values[0];                          nextLineContainsVertexDimension = false;                          continue;                      }                        if (line.Contains("OFF"))                      {                          containsNormals = line.Contains("N");                          containsColors = line.Contains("C");                          containsTextureCoordinates = line.Contains("ST");                          if (line.Contains("4"))                          {                              containsHomogeneousCoordinates = true;                          }                            if (line.Contains("n"))                          {                              nextLineContainsVertexDimension = true;                          }                            nextLineContainsNumberOfVertices = true;                          continue;                      }                        if (nextLineContainsNumberOfVertices)                      {                          var values = GetIntValues(line);                          numberOfVertices = values[0];                          numberOfFaces = values[1];                            /* numberOfEdges = values[2]; */                          nextLineContainsNumberOfVertices = false;                          continue;                      }                        if (this.Vertices.Count < numberOfVertices)                      {                          var x = new double[vertexDimension];                          var values = GetValues(line);                          int i = 0;                          for (int j = 0; j < vertexDimension; j++)                          {                              x[j] = values[i++];                          }                            var n = new double[vertexDimension];                          var uv = new double[2];                          double w = 0;                          if (containsHomogeneousCoordinates)                          {                              w = values[i++];                          }                            if (containsNormals)                          {                              for (int j = 0; j < vertexDimension; j++)                              {                                  n[j] = values[i++];                              }                          }                            if (containsColors)                          {                              // read color                          }                            if (containsTextureCoordinates)                          {                              for (int j = 0; j < 2; j++)                              {                                  uv[j] = values[i++];                              }                          }                            this.Vertices.Add(new Point3D((float)x[0]' (float)x[1]' (float)x[2]));                            continue;                      }                        if (this.Faces.Count < numberOfFaces)                      {                          var values = GetIntValues(line);                          int nv = values[0];                          var vertices = new int[nv];                          for (int i = 0; i < nv; i++)                          {                              vertices[i] = values[i + 1];                          }                            if (containsColors)                          {                              // read colorspec                          }                            this.Faces.Add(vertices);                          continue;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: using (var reader = new StreamReader(s))              {                  bool containsNormals = false;                  bool containsTextureCoordinates = false;                  bool containsColors = false;                  bool containsHomogeneousCoordinates = false;                  int vertexDimension = 3;                  bool nextLineContainsVertexDimension = false;                  bool nextLineContainsNumberOfVertices = false;                  int numberOfVertices = 0;                  int numberOfFaces = 0;                  // int numberOfEdges = 0;                    while (!reader.EndOfStream)                  {                      var line = reader.ReadLine();                      if (line == null)                      {                          break;                      }                        line = line.Trim();                      if (line.StartsWith("#") || line.Length == 0)                      {                          continue;                      }                        if (nextLineContainsVertexDimension)                      {                          var values = GetIntValues(line);                          vertexDimension = values[0];                          nextLineContainsVertexDimension = false;                          continue;                      }                        if (line.Contains("OFF"))                      {                          containsNormals = line.Contains("N");                          containsColors = line.Contains("C");                          containsTextureCoordinates = line.Contains("ST");                          if (line.Contains("4"))                          {                              containsHomogeneousCoordinates = true;                          }                            if (line.Contains("n"))                          {                              nextLineContainsVertexDimension = true;                          }                            nextLineContainsNumberOfVertices = true;                          continue;                      }                        if (nextLineContainsNumberOfVertices)                      {                          var values = GetIntValues(line);                          numberOfVertices = values[0];                          numberOfFaces = values[1];                            /* numberOfEdges = values[2]; */                          nextLineContainsNumberOfVertices = false;                          continue;                      }                        if (this.Vertices.Count < numberOfVertices)                      {                          var x = new double[vertexDimension];                          var values = GetValues(line);                          int i = 0;                          for (int j = 0; j < vertexDimension; j++)                          {                              x[j] = values[i++];                          }                            var n = new double[vertexDimension];                          var uv = new double[2];                          double w = 0;                          if (containsHomogeneousCoordinates)                          {                              w = values[i++];                          }                            if (containsNormals)                          {                              for (int j = 0; j < vertexDimension; j++)                              {                                  n[j] = values[i++];                              }                          }                            if (containsColors)                          {                              // read color                          }                            if (containsTextureCoordinates)                          {                              for (int j = 0; j < 2; j++)                              {                                  uv[j] = values[i++];                              }                          }                            this.Vertices.Add(new Point3D((float)x[0]' (float)x[1]' (float)x[2]));                            continue;                      }                        if (this.Faces.Count < numberOfFaces)                      {                          var values = GetIntValues(line);                          int nv = values[0];                          var vertices = new int[nv];                          for (int i = 0; i < nv; i++)                          {                              vertices[i] = values[i + 1];                          }                            if (containsColors)                          {                              // read colorspec                          }                            this.Faces.Add(vertices);                          continue;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,Read,The following statement contains a magic number: using (var reader = new BinaryReader(s))              {                  long length = reader.BaseStream.Length;                  var headerId = this.ReadChunkId(reader);                  if (headerId != ChunkID.MAIN3DS)                  {                      throw new FileFormatException("Unknown file");                  }                  int headerSize = this.ReadChunkSize(reader);                  if (headerSize != length)                  {                      throw new FileFormatException("Incomplete file (file length does not match header)");                  }                  while (reader.BaseStream.Position < reader.BaseStream.Length)                  {                      var id = this.ReadChunkId(reader);                      int size = this.ReadChunkSize(reader);                      switch (id)                      {                          case ChunkID.EDIT_MATERIAL:                              this.ReadMaterial(reader' size);                              break;                          case ChunkID.EDIT_OBJECT:                              this.ReadObject(reader' size);                              break;                          case ChunkID.EDIT3DS:                          case ChunkID.OBJ_CAMERA:                          case ChunkID.OBJ_LIGHT:                          case ChunkID.OBJ_TRIMESH:                                // don't read the whole chunk' read the sub-defines...                              break;                            default:                                // download the whole chunk                              this.ReadData(reader' size - 6);                              break;                      }                  }                }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: int total = 6;
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: while (total < chunkSize)              {                  ChunkID id = this.ReadChunkId(reader);                  int size = this.ReadChunkSize(reader);                  total += size;                  switch (id)                  {                      case ChunkID.MAT_NAME01:                          name = this.ReadString(reader);                          break;                      case ChunkID.MAT_LUMINANCE:                          luminance = this.ReadColor(reader);                          break;                      case ChunkID.MAT_DIFFUSE:                          diffuse = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SPECULAR:                          specular = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SHININESS:                          byte[] bytes = this.ReadData(reader' size - 6);                          break;                      case ChunkID.MAT_MAP:                          texture = this.ReadMatMap(reader' size - 6);                          break;                      case ChunkID.MAT_MAPFILE:                          this.ReadData(reader' size - 6);                          break;                        default:                          this.ReadData(reader' size - 6);                          break;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: while (total < chunkSize)              {                  ChunkID id = this.ReadChunkId(reader);                  int size = this.ReadChunkSize(reader);                  total += size;                  switch (id)                  {                      case ChunkID.MAT_NAME01:                          name = this.ReadString(reader);                          break;                      case ChunkID.MAT_LUMINANCE:                          luminance = this.ReadColor(reader);                          break;                      case ChunkID.MAT_DIFFUSE:                          diffuse = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SPECULAR:                          specular = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SHININESS:                          byte[] bytes = this.ReadData(reader' size - 6);                          break;                      case ChunkID.MAT_MAP:                          texture = this.ReadMatMap(reader' size - 6);                          break;                      case ChunkID.MAT_MAPFILE:                          this.ReadData(reader' size - 6);                          break;                        default:                          this.ReadData(reader' size - 6);                          break;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: while (total < chunkSize)              {                  ChunkID id = this.ReadChunkId(reader);                  int size = this.ReadChunkSize(reader);                  total += size;                  switch (id)                  {                      case ChunkID.MAT_NAME01:                          name = this.ReadString(reader);                          break;                      case ChunkID.MAT_LUMINANCE:                          luminance = this.ReadColor(reader);                          break;                      case ChunkID.MAT_DIFFUSE:                          diffuse = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SPECULAR:                          specular = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SHININESS:                          byte[] bytes = this.ReadData(reader' size - 6);                          break;                      case ChunkID.MAT_MAP:                          texture = this.ReadMatMap(reader' size - 6);                          break;                      case ChunkID.MAT_MAPFILE:                          this.ReadData(reader' size - 6);                          break;                        default:                          this.ReadData(reader' size - 6);                          break;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: while (total < chunkSize)              {                  ChunkID id = this.ReadChunkId(reader);                  int size = this.ReadChunkSize(reader);                  total += size;                  switch (id)                  {                      case ChunkID.MAT_NAME01:                          name = this.ReadString(reader);                          break;                      case ChunkID.MAT_LUMINANCE:                          luminance = this.ReadColor(reader);                          break;                      case ChunkID.MAT_DIFFUSE:                          diffuse = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SPECULAR:                          specular = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SHININESS:                          byte[] bytes = this.ReadData(reader' size - 6);                          break;                      case ChunkID.MAT_MAP:                          texture = this.ReadMatMap(reader' size - 6);                          break;                      case ChunkID.MAT_MAPFILE:                          this.ReadData(reader' size - 6);                          break;                        default:                          this.ReadData(reader' size - 6);                          break;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: int specularPower = 100;
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadObject,The following statement contains a magic number: int total = 6;
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadObject,The following statement contains a magic number: while (total < chunkSize)              {                  var id = this.ReadChunkId(reader);                  int size = this.ReadChunkSize(reader);                  total += size;                  switch (id)                  {                      case ChunkID.OBJ_TRIMESH:                          this.ReadTriangularMesh(reader' size);                          break;                      default:                          {                              this.ReadData(reader' size - 6);                              break;                          }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: int bytesRead = 6;
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize)              {                  ChunkID id = this.ReadChunkId(reader);                  int size = this.ReadChunkSize(reader);                  bytesRead += size;                  switch (id)                  {                      case ChunkID.TRI_VERTEXL:                          positions = this.ReadVertexList(reader);                          break;                      case ChunkID.TRI_FACEL1:                          faces = ReadFaceList(reader);                          size -= (faces.Count / 3 * 8) + 2;                          facesets = this.ReadFaceSets(reader' size - 6);                          break;                      case ChunkID.TRI_TEXCOORD:                          textureCoordinates = ReadTexCoords(reader);                          break;                      case ChunkID.TRI_LOCAL:                          matrix = this.ReadTransformation(reader);                          break;                      default:                          this.ReadData(reader' size - 6);                          break;                    }              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize)              {                  ChunkID id = this.ReadChunkId(reader);                  int size = this.ReadChunkSize(reader);                  bytesRead += size;                  switch (id)                  {                      case ChunkID.TRI_VERTEXL:                          positions = this.ReadVertexList(reader);                          break;                      case ChunkID.TRI_FACEL1:                          faces = ReadFaceList(reader);                          size -= (faces.Count / 3 * 8) + 2;                          facesets = this.ReadFaceSets(reader' size - 6);                          break;                      case ChunkID.TRI_TEXCOORD:                          textureCoordinates = ReadTexCoords(reader);                          break;                      case ChunkID.TRI_LOCAL:                          matrix = this.ReadTransformation(reader);                          break;                      default:                          this.ReadData(reader' size - 6);                          break;                    }              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize)              {                  ChunkID id = this.ReadChunkId(reader);                  int size = this.ReadChunkSize(reader);                  bytesRead += size;                  switch (id)                  {                      case ChunkID.TRI_VERTEXL:                          positions = this.ReadVertexList(reader);                          break;                      case ChunkID.TRI_FACEL1:                          faces = ReadFaceList(reader);                          size -= (faces.Count / 3 * 8) + 2;                          facesets = this.ReadFaceSets(reader' size - 6);                          break;                      case ChunkID.TRI_TEXCOORD:                          textureCoordinates = ReadTexCoords(reader);                          break;                      case ChunkID.TRI_LOCAL:                          matrix = this.ReadTransformation(reader);                          break;                      default:                          this.ReadData(reader' size - 6);                          break;                    }              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize)              {                  ChunkID id = this.ReadChunkId(reader);                  int size = this.ReadChunkSize(reader);                  bytesRead += size;                  switch (id)                  {                      case ChunkID.TRI_VERTEXL:                          positions = this.ReadVertexList(reader);                          break;                      case ChunkID.TRI_FACEL1:                          faces = ReadFaceList(reader);                          size -= (faces.Count / 3 * 8) + 2;                          facesets = this.ReadFaceSets(reader' size - 6);                          break;                      case ChunkID.TRI_TEXCOORD:                          textureCoordinates = ReadTexCoords(reader);                          break;                      case ChunkID.TRI_LOCAL:                          matrix = this.ReadTransformation(reader);                          break;                      default:                          this.ReadData(reader' size - 6);                          break;                    }              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize)              {                  ChunkID id = this.ReadChunkId(reader);                  int size = this.ReadChunkSize(reader);                  bytesRead += size;                  switch (id)                  {                      case ChunkID.TRI_VERTEXL:                          positions = this.ReadVertexList(reader);                          break;                      case ChunkID.TRI_FACEL1:                          faces = ReadFaceList(reader);                          size -= (faces.Count / 3 * 8) + 2;                          facesets = this.ReadFaceSets(reader' size - 6);                          break;                      case ChunkID.TRI_TEXCOORD:                          textureCoordinates = ReadTexCoords(reader);                          break;                      case ChunkID.TRI_LOCAL:                          matrix = this.ReadTransformation(reader);                          break;                      default:                          this.ReadData(reader' size - 6);                          break;                    }              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ComputeNormals,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3)              {                  var i1 = triangleIndices[t];                  var i2 = triangleIndices[t + 1];                  var i3 = triangleIndices[t + 2];                    var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                    var p1 = v2 - v1;                  var p2 = v3 - v1;                  var n = Vector3.Cross(p1' p2);                  // angle                  p1.Normalize();                  p2.Normalize();                  var a = (float)Math.Acos(Vector3.Dot(p1' p2));                  n.Normalize();                  normals[i1] += (a * n);                  normals[i2] += (a * n);                  normals[i3] += (a * n);              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ComputeNormals,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3)              {                  var i1 = triangleIndices[t];                  var i2 = triangleIndices[t + 1];                  var i3 = triangleIndices[t + 2];                    var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                    var p1 = v2 - v1;                  var p2 = v3 - v1;                  var n = Vector3.Cross(p1' p2);                  // angle                  p1.Normalize();                  p2.Normalize();                  var a = (float)Math.Acos(Vector3.Dot(p1' p2));                  n.Normalize();                  normals[i1] += (a * n);                  normals[i2] += (a * n);                  normals[i3] += (a * n);              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: var triangleIndices = new IntCollection(subFaces.Count * 3);
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: foreach (int f in subFaces)              {                  triangleIndices.Add(faces[f * 3]);                  triangleIndices.Add(faces[(f * 3) + 1]);                  triangleIndices.Add(faces[(f * 3) + 2]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: foreach (int f in subFaces)              {                  triangleIndices.Add(faces[f * 3]);                  triangleIndices.Add(faces[(f * 3) + 1]);                  triangleIndices.Add(faces[(f * 3) + 2]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: foreach (int f in subFaces)              {                  triangleIndices.Add(faces[f * 3]);                  triangleIndices.Add(faces[(f * 3) + 1]);                  triangleIndices.Add(faces[(f * 3) + 2]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: foreach (int f in subFaces)              {                  triangleIndices.Add(faces[f * 3]);                  triangleIndices.Add(faces[(f * 3) + 1]);                  triangleIndices.Add(faces[(f * 3) + 2]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: int total = 6;
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: while (total < chunkSize)              {                  var id = this.ReadChunkId(reader);                  int size = this.ReadChunkSize(reader);                  total += size;                  switch (id)                  {                      case ChunkID.TRI_FACEMAT:                          {                              string name = this.ReadString(reader);                              int n = reader.ReadUInt16();                              var c = new List<int>();                              for (int i = 0; i < n; i++)                              {                                  c.Add(reader.ReadUInt16());                              }                                var fm = new FaceSet { Name = name' Faces = c };                              list.Add(fm);                              break;                          }                        case ChunkID.TRI_SMOOTH:                          {                              this.ReadData(reader' size - 6);                              break;                          }                        default:                          {                              this.ReadData(reader' size - 6);                              break;                          }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: while (total < chunkSize)              {                  var id = this.ReadChunkId(reader);                  int size = this.ReadChunkSize(reader);                  total += size;                  switch (id)                  {                      case ChunkID.TRI_FACEMAT:                          {                              string name = this.ReadString(reader);                              int n = reader.ReadUInt16();                              var c = new List<int>();                              for (int i = 0; i < n; i++)                              {                                  c.Add(reader.ReadUInt16());                              }                                var fm = new FaceSet { Name = name' Faces = c };                              list.Add(fm);                              break;                          }                        case ChunkID.TRI_SMOOTH:                          {                              this.ReadData(reader' size - 6);                              break;                          }                        default:                          {                              this.ReadData(reader' size - 6);                              break;                          }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,BitMapSoureFromFallBack,The following statement contains a magic number: int width = 128;
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,BitMapSoureFromFallBack,The following statement contains a magic number: int height = 128;
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,BitMapSoureFromFallBack,The following statement contains a magic number: int stride = width / 8;
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,BitMapSoureFromFallBack,The following statement contains a magic number: BitmapSource bitmap = BitmapSource.Create(10' 10' 96' 96' System.Windows.Media.PixelFormats.Indexed1' palette' pixels' stride);
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,BitMapSoureFromFallBack,The following statement contains a magic number: BitmapSource bitmap = BitmapSource.Create(10' 10' 96' 96' System.Windows.Media.PixelFormats.Indexed1' palette' pixels' stride);
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,BitMapSoureFromFallBack,The following statement contains a magic number: BitmapSource bitmap = BitmapSource.Create(10' 10' 96' 96' System.Windows.Media.PixelFormats.Indexed1' palette' pixels' stride);
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,BitMapSoureFromFallBack,The following statement contains a magic number: BitmapSource bitmap = BitmapSource.Create(10' 10' 96' 96' System.Windows.Media.PixelFormats.Indexed1' palette' pixels' stride);
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMatMap,The following statement contains a magic number: size -= 14;
Magic Number,HelixToolkit.Wpf.SharpDX,OrthographicCamera,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Camera\OrthographicCamera.cs,OrthographicCamera,The following statement contains a magic number: NearPlaneDistance = -10.0;
Magic Number,HelixToolkit.Wpf.SharpDX,OrthographicCamera,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Camera\OrthographicCamera.cs,OrthographicCamera,The following statement contains a magic number: FarPlaneDistance = 100.0;
Magic Number,HelixToolkit.Wpf.SharpDX,PerspectiveCamera,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Camera\PerspectiveCamera.cs,CreateProjectionMatrix,The following statement contains a magic number: var fov = this.FieldOfView*Math.PI/180;
Magic Number,HelixToolkit.Wpf.SharpDX,PerspectiveCamera,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Camera\PerspectiveCamera.cs,CreateFrustum,The following statement contains a magic number: var fov = this.FieldOfView * Math.PI / 180;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,CreateRasterState,The following statement contains a magic number: var rasterStateDesc = new RasterizerStateDescription()              {                  FillMode = FillMode'                  CullMode = CullMode'                  DepthBias = DepthBias'                  DepthBiasClamp = -1000'                  SlopeScaledDepthBias = +0'                  IsDepthClipEnabled = IsDepthClipEnabled'                  IsFrontCounterClockwise = FrontCounterClockwise'                    IsMultisampleEnabled = IsMultisampleEnabled'                  //IsAntialiasedLineEnabled = true'                                      IsScissorEnabled = IsThrowingShadow? false : IsScissorEnabled'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (g.Octree != null)              {                  isHit = g.Octree.HitTest(context' this' ModelMatrix' rayWS' ref hits);              }              else              {                  var result = new HitTestResult();                  result.Distance = double.MaxValue;                  if (g != null)                  {                      var modelInvert = this.modelMatrix.Inverted();                      //transform ray into model coordinates                      var rayModel = new Ray(Vector3.TransformCoordinate(rayWS.Position' modelInvert)' Vector3.TransformNormal(rayWS.Direction' modelInvert));                        var b = Bounds;                      //Do hit test in local space                      if (rayModel.Intersects(ref b))                      {                          int index = 0;                          foreach (var t in g.Triangles)                          {                              float d;                              var v0 = t.P0;                              var v1 = t.P1;                              var v2 = t.P2;                              if (Collision.RayIntersectsTriangle(ref rayModel' ref v0' ref v1' ref v2' out d))                              {                                  if (d > 0 && d < result.Distance) // If d is NaN' the condition is false.                                  {                                      result.IsValid = true;                                      result.ModelHit = this;                                      // transform hit-info to world space now:                                      var pointWorld = Vector3.TransformCoordinate(rayModel.Position + (rayModel.Direction * d)' modelMatrix);                                      result.PointHit = pointWorld.ToPoint3D();                                      result.Distance = (rayWS.Position - pointWorld).Length();                                      var p0 = Vector3.TransformCoordinate(v0' modelMatrix);                                      var p1 = Vector3.TransformCoordinate(v1' modelMatrix);                                      var p2 = Vector3.TransformCoordinate(v2' modelMatrix);                                      var n = Vector3.Cross(p1 - p0' p2 - p0);                                      n.Normalize();                                      // transform hit-info to world space now:                                      result.NormalAtHit = n.ToVector3D();// Vector3.TransformNormal(n' m).ToVector3D();                                      result.TriangleIndices = new System.Tuple<int' int' int>(g.Indices[index]' g.Indices[index + 1]' g.Indices[index + 2]);                                      result.Tag = index / 3;                                      isHit = true;                                  }                              }                              index += 3;                          }                      }                  }                  if (isHit)                  {                      hits.Add(result);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (g.Octree != null)              {                  isHit = g.Octree.HitTest(context' this' ModelMatrix' rayWS' ref hits);              }              else              {                  var result = new HitTestResult();                  result.Distance = double.MaxValue;                  if (g != null)                  {                      var modelInvert = this.modelMatrix.Inverted();                      //transform ray into model coordinates                      var rayModel = new Ray(Vector3.TransformCoordinate(rayWS.Position' modelInvert)' Vector3.TransformNormal(rayWS.Direction' modelInvert));                        var b = Bounds;                      //Do hit test in local space                      if (rayModel.Intersects(ref b))                      {                          int index = 0;                          foreach (var t in g.Triangles)                          {                              float d;                              var v0 = t.P0;                              var v1 = t.P1;                              var v2 = t.P2;                              if (Collision.RayIntersectsTriangle(ref rayModel' ref v0' ref v1' ref v2' out d))                              {                                  if (d > 0 && d < result.Distance) // If d is NaN' the condition is false.                                  {                                      result.IsValid = true;                                      result.ModelHit = this;                                      // transform hit-info to world space now:                                      var pointWorld = Vector3.TransformCoordinate(rayModel.Position + (rayModel.Direction * d)' modelMatrix);                                      result.PointHit = pointWorld.ToPoint3D();                                      result.Distance = (rayWS.Position - pointWorld).Length();                                      var p0 = Vector3.TransformCoordinate(v0' modelMatrix);                                      var p1 = Vector3.TransformCoordinate(v1' modelMatrix);                                      var p2 = Vector3.TransformCoordinate(v2' modelMatrix);                                      var n = Vector3.Cross(p1 - p0' p2 - p0);                                      n.Normalize();                                      // transform hit-info to world space now:                                      result.NormalAtHit = n.ToVector3D();// Vector3.TransformNormal(n' m).ToVector3D();                                      result.TriangleIndices = new System.Tuple<int' int' int>(g.Indices[index]' g.Indices[index + 1]' g.Indices[index + 2]);                                      result.Tag = index / 3;                                      isHit = true;                                  }                              }                              index += 3;                          }                      }                  }                  if (isHit)                  {                      hits.Add(result);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (g.Octree != null)              {                  isHit = g.Octree.HitTest(context' this' ModelMatrix' rayWS' ref hits);              }              else              {                  var result = new HitTestResult();                  result.Distance = double.MaxValue;                  if (g != null)                  {                      var modelInvert = this.modelMatrix.Inverted();                      //transform ray into model coordinates                      var rayModel = new Ray(Vector3.TransformCoordinate(rayWS.Position' modelInvert)' Vector3.TransformNormal(rayWS.Direction' modelInvert));                        var b = Bounds;                      //Do hit test in local space                      if (rayModel.Intersects(ref b))                      {                          int index = 0;                          foreach (var t in g.Triangles)                          {                              float d;                              var v0 = t.P0;                              var v1 = t.P1;                              var v2 = t.P2;                              if (Collision.RayIntersectsTriangle(ref rayModel' ref v0' ref v1' ref v2' out d))                              {                                  if (d > 0 && d < result.Distance) // If d is NaN' the condition is false.                                  {                                      result.IsValid = true;                                      result.ModelHit = this;                                      // transform hit-info to world space now:                                      var pointWorld = Vector3.TransformCoordinate(rayModel.Position + (rayModel.Direction * d)' modelMatrix);                                      result.PointHit = pointWorld.ToPoint3D();                                      result.Distance = (rayWS.Position - pointWorld).Length();                                      var p0 = Vector3.TransformCoordinate(v0' modelMatrix);                                      var p1 = Vector3.TransformCoordinate(v1' modelMatrix);                                      var p2 = Vector3.TransformCoordinate(v2' modelMatrix);                                      var n = Vector3.Cross(p1 - p0' p2 - p0);                                      n.Normalize();                                      // transform hit-info to world space now:                                      result.NormalAtHit = n.ToVector3D();// Vector3.TransformNormal(n' m).ToVector3D();                                      result.TriangleIndices = new System.Tuple<int' int' int>(g.Indices[index]' g.Indices[index + 1]' g.Indices[index + 2]);                                      result.Tag = index / 3;                                      isHit = true;                                  }                              }                              index += 3;                          }                      }                  }                  if (isHit)                  {                      hits.Add(result);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,UICompositeManipulator3D,The following statement contains a magic number: this.rotateX = new UIRotateManipulator3D { Axis = new Vector3(1' 0' 0)' Length = 0.05' Material = PhongMaterials.Red' };
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,UICompositeManipulator3D,The following statement contains a magic number: this.rotateY = new UIRotateManipulator3D { Axis = new Vector3(0' 1' 0)' Length = 0.05' Material = PhongMaterials.Green };
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,UICompositeManipulator3D,The following statement contains a magic number: this.rotateZ = new UIRotateManipulator3D { Axis = new Vector3(0' 0' 1)' Length = 0.05' Material = PhongMaterials.Blue };
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,OnChildrenChanged,The following statement contains a magic number: rotateY.InnerDiameter += 0.01;
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,OnChildrenChanged,The following statement contains a magic number: rotateZ.InnerDiameter += 0.02;
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,OnChildrenChanged,The following statement contains a magic number: rotateX.OuterDiameter = rotateX.InnerDiameter + 0.25;
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,OnChildrenChanged,The following statement contains a magic number: rotateY.OuterDiameter = rotateY.InnerDiameter + 0.25;
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,OnChildrenChanged,The following statement contains a magic number: rotateZ.OuterDiameter = rotateZ.InnerDiameter + 0.25;
Magic Number,HelixToolkit.Wpf.SharpDX,UIRotateManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UIRotateManipulator3D.cs,OnModelChanged,The following statement contains a magic number: if (this.InnerDiameter >= this.OuterDiameter)                  this.OuterDiameter = this.InnerDiameter + 0.3;
Magic Number,HelixToolkit.Wpf.SharpDX,UIRotateManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UIRotateManipulator3D.cs,OnModelChanged,The following statement contains a magic number: mb.AddPipe(p1' p2' this.InnerDiameter' this.OuterDiameter' 64);
Magic Number,HelixToolkit.Wpf.SharpDX,UIRotateManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UIRotateManipulator3D.cs,UpdateManipulator,The following statement contains a magic number: if (newHit.HasValue)              {                  var newHitPos = newHit.Value;                  var v = this.lastHitPosWS - position;                  var u = newHitPos - position;                  v.Normalize();                  u.Normalize();                                    var currentAxis = Vector3.Cross(u' v);                  var mainAxis = ToWorldVec(this.Axis);// this.Transform.Transform(this.Axis.ToVector3D()).ToVector3();                  double sign = -Vector3.Dot(mainAxis' currentAxis);                  double theta = Math.Sign(sign) * Math.Asin(currentAxis.Length()) / Math.PI * 180;                  this.Value += theta;                                    var rotateTransform = new System.Windows.Media.Media3D.RotateTransform3D(new System.Windows.Media.Media3D.AxisAngleRotation3D(this.Axis.ToVector3D()' theta)' Pivot.ToPoint3D());                    // rotate target                  if (this.TargetTransform != null)                  {                                          this.TargetTransform = rotateTransform.AppendTransform(this.TargetTransform);                  }                  else                  {                      this.Transform = rotateTransform.AppendTransform(this.Transform);                  }                  this.lastHitPosWS = newHitPos;              }
Magic Number,HelixToolkit.Wpf.SharpDX,UITranslateManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UITranslateManipulator3D.cs,OnModelChanged,The following statement contains a magic number: mb.AddArrow(p0' p1' this.Diameter' 2' 64);
Magic Number,HelixToolkit.Wpf.SharpDX,UITranslateManipulator3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UITranslateManipulator3D.cs,OnModelChanged,The following statement contains a magic number: mb.AddArrow(p0' p1' this.Diameter' 2' 64);
Magic Number,HelixToolkit.Wpf.SharpDX,LineGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\LineGeometryModel3D.cs,CreateRasterState,The following statement contains a magic number: var rasterStateDesc = new RasterizerStateDescription()              {                  FillMode = FillMode'                  CullMode = CullMode.None'                  DepthBias = DepthBias'                  DepthBiasClamp = -1000'                  SlopeScaledDepthBias = -2'                  IsDepthClipEnabled = true'                  IsFrontCounterClockwise = false'                    IsMultisampleEnabled = IsMultisampleEnabled'                  //IsAntialiasedLineEnabled = true' // Intel HD 3000 doesn't like this (#10051) and it's not needed                  IsScissorEnabled = IsThrowingShadow ? false : IsScissorEnabled              };
Magic Number,HelixToolkit.Wpf.SharpDX,LineGeometryModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\LineGeometryModel3D.cs,CreateRasterState,The following statement contains a magic number: var rasterStateDesc = new RasterizerStateDescription()              {                  FillMode = FillMode'                  CullMode = CullMode.None'                  DepthBias = DepthBias'                  DepthBiasClamp = -1000'                  SlopeScaledDepthBias = -2'                  IsDepthClipEnabled = true'                  IsFrontCounterClockwise = false'                    IsMultisampleEnabled = IsMultisampleEnabled'                  //IsAntialiasedLineEnabled = true' // Intel HD 3000 doesn't like this (#10051) and it's not needed                  IsScissorEnabled = IsThrowingShadow ? false : IsScissorEnabled              };
Magic Number,HelixToolkit.Wpf.SharpDX,ShadowMap3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The following statement contains a magic number: foreach (var item in root)              {                  var light = item as Light3D;                  if (light != null)                  {                      Camera lightCamera = null;                      //if (light is PointLightBase3D)                      //{                      //    var plight = (PointLightBase3D)light;                      //    lightCamera = new PerspectiveCamera()                      //    {                      //        Position = plight.Position'                      //        LookDirection = plight.Direction'                      //        UpDirection = Vector3.UnitY.ToVector3D()'                      //    };                                              //}                      // else                       if (light is DirectionalLight3D)                      {                          var dlight = (DirectionalLight3D)light;                          var dir = light.DirectionInternal.Normalized();                          var pos = -50 * light.DirectionInternal;                                                    //lightCamera = new PerspectiveCamera()                          //{                          //    LookDirection = dir.ToVector3D()'                          //    Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'                          //    UpDirection = Vector3.UnitZ.ToVector3D()'                                                      //    NearPlaneDistance = 1'                          //    FarPlaneDistance = 100'                          //    FieldOfView = 10'                          //};                            lightCamera = new OrthographicCamera()                          {                              LookDirection = dir.ToVector3D()'                              Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'                                                          UpDirection = Vector3.UnitZ.ToVector3D()'                              Width = 100'                              NearPlaneDistance = 1'                              FarPlaneDistance = 500'                          };                      }                        if (lightCamera != null)                      {                          var sceneCamera = context.Camera;                                                    light.LightViewMatrix = CameraExtensions.GetViewMatrix(lightCamera);                          light.LightProjectionMatrix = CameraExtensions.GetProjectionMatrix(lightCamera' context.Canvas.ActualWidth / context.Canvas.ActualHeight);                            this.shadowPassContext.IsShadowPass = true;                          this.shadowPassContext.Camera = lightCamera;                          foreach (var e in root)                          {                              var smodel = e as IThrowingShadow;                              if (smodel != null)                              {                                  if (smodel.IsThrowingShadow)                                  {                                      var model = smodel as IRenderable;                                      model.Render(this.shadowPassContext);                                  }                              }                          }                          context.Camera = sceneCamera;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,ShadowMap3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The following statement contains a magic number: foreach (var item in root)              {                  var light = item as Light3D;                  if (light != null)                  {                      Camera lightCamera = null;                      //if (light is PointLightBase3D)                      //{                      //    var plight = (PointLightBase3D)light;                      //    lightCamera = new PerspectiveCamera()                      //    {                      //        Position = plight.Position'                      //        LookDirection = plight.Direction'                      //        UpDirection = Vector3.UnitY.ToVector3D()'                      //    };                                              //}                      // else                       if (light is DirectionalLight3D)                      {                          var dlight = (DirectionalLight3D)light;                          var dir = light.DirectionInternal.Normalized();                          var pos = -50 * light.DirectionInternal;                                                    //lightCamera = new PerspectiveCamera()                          //{                          //    LookDirection = dir.ToVector3D()'                          //    Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'                          //    UpDirection = Vector3.UnitZ.ToVector3D()'                                                      //    NearPlaneDistance = 1'                          //    FarPlaneDistance = 100'                          //    FieldOfView = 10'                          //};                            lightCamera = new OrthographicCamera()                          {                              LookDirection = dir.ToVector3D()'                              Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'                                                          UpDirection = Vector3.UnitZ.ToVector3D()'                              Width = 100'                              NearPlaneDistance = 1'                              FarPlaneDistance = 500'                          };                      }                        if (lightCamera != null)                      {                          var sceneCamera = context.Camera;                                                    light.LightViewMatrix = CameraExtensions.GetViewMatrix(lightCamera);                          light.LightProjectionMatrix = CameraExtensions.GetProjectionMatrix(lightCamera' context.Canvas.ActualWidth / context.Canvas.ActualHeight);                            this.shadowPassContext.IsShadowPass = true;                          this.shadowPassContext.Camera = lightCamera;                          foreach (var e in root)                          {                              var smodel = e as IThrowingShadow;                              if (smodel != null)                              {                                  if (smodel.IsThrowingShadow)                                  {                                      var model = smodel as IRenderable;                                      model.Render(this.shadowPassContext);                                  }                              }                          }                          context.Camera = sceneCamera;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,ShadowMap3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The following statement contains a magic number: foreach (var item in root)              {                  var light = item as Light3D;                  if (light != null)                  {                      Camera lightCamera = null;                      //if (light is PointLightBase3D)                      //{                      //    var plight = (PointLightBase3D)light;                      //    lightCamera = new PerspectiveCamera()                      //    {                      //        Position = plight.Position'                      //        LookDirection = plight.Direction'                      //        UpDirection = Vector3.UnitY.ToVector3D()'                      //    };                                              //}                      // else                       if (light is DirectionalLight3D)                      {                          var dlight = (DirectionalLight3D)light;                          var dir = light.DirectionInternal.Normalized();                          var pos = -50 * light.DirectionInternal;                                                    //lightCamera = new PerspectiveCamera()                          //{                          //    LookDirection = dir.ToVector3D()'                          //    Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'                          //    UpDirection = Vector3.UnitZ.ToVector3D()'                                                      //    NearPlaneDistance = 1'                          //    FarPlaneDistance = 100'                          //    FieldOfView = 10'                          //};                            lightCamera = new OrthographicCamera()                          {                              LookDirection = dir.ToVector3D()'                              Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'                                                          UpDirection = Vector3.UnitZ.ToVector3D()'                              Width = 100'                              NearPlaneDistance = 1'                              FarPlaneDistance = 500'                          };                      }                        if (lightCamera != null)                      {                          var sceneCamera = context.Camera;                                                    light.LightViewMatrix = CameraExtensions.GetViewMatrix(lightCamera);                          light.LightProjectionMatrix = CameraExtensions.GetProjectionMatrix(lightCamera' context.Canvas.ActualWidth / context.Canvas.ActualHeight);                            this.shadowPassContext.IsShadowPass = true;                          this.shadowPassContext.Camera = lightCamera;                          foreach (var e in root)                          {                              var smodel = e as IThrowingShadow;                              if (smodel != null)                              {                                  if (smodel.IsThrowingShadow)                                  {                                      var model = smodel as IRenderable;                                      model.Render(this.shadowPassContext);                                  }                              }                          }                          context.Camera = sceneCamera;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,SpotLight3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\SpotLight3D.cs,OnRender,The following statement contains a magic number: Light3DSceneShared.LightSpots[lightIndex] = new Vector4((float)Math.Cos(this.OuterAngleInternal / 360.0 * Math.PI)' (float)Math.Cos(this.InnerAngleInternal / 360.0 * Math.PI)' (float)this.FalloffInternal' 0);
Magic Number,HelixToolkit.Wpf.SharpDX,SpotLight3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\SpotLight3D.cs,OnRender,The following statement contains a magic number: Light3DSceneShared.LightSpots[lightIndex] = new Vector4((float)Math.Cos(this.OuterAngleInternal / 360.0 * Math.PI)' (float)Math.Cos(this.InnerAngleInternal / 360.0 * Math.PI)' (float)this.FalloffInternal' 0);
Magic Number,HelixToolkit.Wpf.SharpDX,Exporter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Exporter.cs,RenderBrush,The following statement contains a magic number: var bmp = new RenderTargetBitmap(w' h' 96' 96' PixelFormats.Pbgra32);
Magic Number,HelixToolkit.Wpf.SharpDX,Exporter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Exporter.cs,RenderBrush,The following statement contains a magic number: var bmp = new RenderTargetBitmap(w' h' 96' 96' PixelFormats.Pbgra32);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange(new[] { i0 + 0' i0 + 4' i0 + 1' i0 + 5' i0 + 2' i0 + 6' i0 + 3' i0 + 7 });
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange(new[] { i0 + 0' i0 + 4' i0 + 1' i0 + 5' i0 + 2' i0 + 6' i0 + 3' i0 + 7 });
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange(new[] { i0 + 0' i0 + 4' i0 + 1' i0 + 5' i0 + 2' i0 + 6' i0 + 3' i0 + 7 });
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange(new[] { i0 + 0' i0 + 4' i0 + 1' i0 + 5' i0 + 2' i0 + 6' i0 + 3' i0 + 7 });
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange(new[] { i0 + 0' i0 + 4' i0 + 1' i0 + 5' i0 + 2' i0 + 6' i0 + 3' i0 + 7 });
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange(new[] { i0 + 0' i0 + 4' i0 + 1' i0 + 5' i0 + 2' i0 + 6' i0 + 3' i0 + 7 });
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddGrid,The following statement contains a magic number: if (columns < 2 || rows < 2)              {                  throw new ArgumentNullException("columns or rows too small");              }
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddGrid,The following statement contains a magic number: if (columns < 2 || rows < 2)              {                  throw new ArgumentNullException("columns or rows too small");              }
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[1]' cc[2]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[2]' cc[3]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[2]' cc[3]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[3]' cc[0]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[4]' cc[5]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[4]' cc[5]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[5]' cc[6]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[5]' cc[6]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[6]' cc[7]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[6]' cc[7]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[7]' cc[4]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[7]' cc[4]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[0]' cc[4]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[1]' cc[5]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[2]' cc[6]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[2]' cc[6]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[3]' cc[7]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[3]' cc[7]);
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateCircle,The following statement contains a magic number: if (segments < 3)              {                  throw new ArgumentNullException("too few segments' at least 3");              }
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateCircle,The following statement contains a magic number: float sectionAngle = (float)(2.0 * Math.PI / segments);
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMesh,The following statement contains a magic number: if (m.Indices != null)              {                  for (int i = 0; i < m.Indices.Count; i += 3)                  {                      int i0 = m.Indices[i];                      int i1 = m.Indices[i + 1];                      int i2 = m.Indices[i + 2];                        this.writer.WriteLine("f {0} {1} {2}"' formatIndices(i0)' formatIndices(i1)' formatIndices(i2));                  }                    this.writer.WriteLine(string.Format("# {0} faces"' m.Indices.Count / 3));              }
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMesh,The following statement contains a magic number: if (m.Indices != null)              {                  for (int i = 0; i < m.Indices.Count; i += 3)                  {                      int i0 = m.Indices[i];                      int i1 = m.Indices[i + 1];                      int i2 = m.Indices[i + 2];                        this.writer.WriteLine("f {0} {1} {2}"' formatIndices(i0)' formatIndices(i1)' formatIndices(i2));                  }                    this.writer.WriteLine(string.Format("# {0} faces"' m.Indices.Count / 3));              }
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMesh,The following statement contains a magic number: if (m.Indices != null)              {                  for (int i = 0; i < m.Indices.Count; i += 3)                  {                      int i0 = m.Indices[i];                      int i1 = m.Indices[i + 1];                      int i2 = m.Indices[i + 2];                        this.writer.WriteLine("f {0} {1} {2}"' formatIndices(i0)' formatIndices(i1)' formatIndices(i2));                  }                    this.writer.WriteLine(string.Format("# {0} faces"' m.Indices.Count / 3));              }
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ToColorString,The following statement contains a magic number: return string.Format(                  CultureInfo.InvariantCulture' "{0:F4} {1:F4} {2:F4}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ToColorString,The following statement contains a magic number: return string.Format(                  CultureInfo.InvariantCulture' "{0:F4} {1:F4} {2:F4}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ToColorString,The following statement contains a magic number: return string.Format(                  CultureInfo.InvariantCulture' "{0:F4} {1:F4} {2:F4}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,ColorParse,The following statement contains a magic number: return System.Windows.Media.Color.FromRgb((byte)(fields[0] * 255)' (byte)(fields[1] * 255)' (byte)(fields[2] * 255)).ToColor4();
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,ColorParse,The following statement contains a magic number: return System.Windows.Media.Color.FromRgb((byte)(fields[0] * 255)' (byte)(fields[1] * 255)' (byte)(fields[2] * 255)).ToColor4();
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,ColorParse,The following statement contains a magic number: return System.Windows.Media.Color.FromRgb((byte)(fields[0] * 255)' (byte)(fields[1] * 255)' (byte)(fields[2] * 255)).ToColor4();
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,ColorParse,The following statement contains a magic number: return System.Windows.Media.Color.FromRgb((byte)(fields[0] * 255)' (byte)(fields[1] * 255)' (byte)(fields[2] * 255)).ToColor4();
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: foreach (var field in fields)              {                  if (string.IsNullOrEmpty(field))                  {                      continue;                  }                    var ff = field.Split('/');                  int vi = int.Parse(ff[0]);                  int vti = ff.Length > 1 && ff[1].Length > 0 ? int.Parse(ff[1]) : int.MaxValue;                  int vni = ff.Length > 2 && ff[2].Length > 0 ? int.Parse(ff[2]) : int.MaxValue;                    // Handle relative indices (negative numbers)                  if (vi < 0)                  {                      vi = this.Points.Count + vi + 1;                  }                    if (vti < 0)                  {                      vti = this.TextureCoordinates.Count + vti + 1;                  }                    if (vni < 0)                  {                      vni = this.Normals.Count + vni + 1;                  }                    // Check if the indices are valid                  if (vi - 1 >= this.Points.Count)                  {                      if (this.IgnoreErrors)                      {                          return;                      }                        throw new FileFormatException(string.Format("Invalid vertex index ({0}) on line {1}."' vi' this.currentLineNo));                  }                    if (vti == int.MaxValue)                  {                      // turn off texture coordinates in the builder                      //builder.CreateTextureCoordinates = false;                      builder.TextureCoordinates = null;                  }                    if (vni == int.MaxValue)                  {                      // turn off normals in the builder                      //builder.CreateNormals = false;                      builder.Normals = null;                  }                    // check if the texture coordinate index is valid                  if (builder.HasTexCoords && vti - 1 >= this.TextureCoordinates.Count)                  {                      if (this.IgnoreErrors)                      {                          return;                      }                        throw new FileFormatException(string.Format("Invalid texture coordinate index ({0}) on line {1}."' vti' this.currentLineNo));                  }                    // check if the normal index is valid                  if (builder.HasNormals && vni - 1 >= this.Normals.Count)                  {                      if (this.IgnoreErrors)                      {                          return;                      }                        throw new FileFormatException(string.Format("Invalid normal index ({0}) on line {1}."' vni' this.currentLineNo));                  }                    bool addVertex = true;                    if (smoothingGroupMap != null)                  {                      var key = Tuple.Create(vi' vti' vni);                        int vix;                      if (smoothingGroupMap.TryGetValue(key' out vix))                      {                          // use the index of a previously defined vertex                          addVertex = false;                      }                      else                      {                          // add a new vertex                          vix = positions.Count;                          smoothingGroupMap.Add(key' vix);                      }                        faceIndices.Add(vix);                  }                  else                  {                      // if smoothing is off' always add a new vertex                      faceIndices.Add(positions.Count);                  }                    if (addVertex)                  {                      // add vertex                      positions.Add(this.Points[vi - 1]);                        // add texture coordinate (if enabled)                      if (builder.HasTexCoords)                      {                          textureCoordinates.Add(this.TextureCoordinates[vti - 1]);                      }                        // add normal (if enabled)                      if (builder.HasNormals)                      {                          normals.Add(this.Normals[vni - 1]);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: foreach (var field in fields)              {                  if (string.IsNullOrEmpty(field))                  {                      continue;                  }                    var ff = field.Split('/');                  int vi = int.Parse(ff[0]);                  int vti = ff.Length > 1 && ff[1].Length > 0 ? int.Parse(ff[1]) : int.MaxValue;                  int vni = ff.Length > 2 && ff[2].Length > 0 ? int.Parse(ff[2]) : int.MaxValue;                    // Handle relative indices (negative numbers)                  if (vi < 0)                  {                      vi = this.Points.Count + vi + 1;                  }                    if (vti < 0)                  {                      vti = this.TextureCoordinates.Count + vti + 1;                  }                    if (vni < 0)                  {                      vni = this.Normals.Count + vni + 1;                  }                    // Check if the indices are valid                  if (vi - 1 >= this.Points.Count)                  {                      if (this.IgnoreErrors)                      {                          return;                      }                        throw new FileFormatException(string.Format("Invalid vertex index ({0}) on line {1}."' vi' this.currentLineNo));                  }                    if (vti == int.MaxValue)                  {                      // turn off texture coordinates in the builder                      //builder.CreateTextureCoordinates = false;                      builder.TextureCoordinates = null;                  }                    if (vni == int.MaxValue)                  {                      // turn off normals in the builder                      //builder.CreateNormals = false;                      builder.Normals = null;                  }                    // check if the texture coordinate index is valid                  if (builder.HasTexCoords && vti - 1 >= this.TextureCoordinates.Count)                  {                      if (this.IgnoreErrors)                      {                          return;                      }                        throw new FileFormatException(string.Format("Invalid texture coordinate index ({0}) on line {1}."' vti' this.currentLineNo));                  }                    // check if the normal index is valid                  if (builder.HasNormals && vni - 1 >= this.Normals.Count)                  {                      if (this.IgnoreErrors)                      {                          return;                      }                        throw new FileFormatException(string.Format("Invalid normal index ({0}) on line {1}."' vni' this.currentLineNo));                  }                    bool addVertex = true;                    if (smoothingGroupMap != null)                  {                      var key = Tuple.Create(vi' vti' vni);                        int vix;                      if (smoothingGroupMap.TryGetValue(key' out vix))                      {                          // use the index of a previously defined vertex                          addVertex = false;                      }                      else                      {                          // add a new vertex                          vix = positions.Count;                          smoothingGroupMap.Add(key' vix);                      }                        faceIndices.Add(vix);                  }                  else                  {                      // if smoothing is off' always add a new vertex                      faceIndices.Add(positions.Count);                  }                    if (addVertex)                  {                      // add vertex                      positions.Add(this.Points[vi - 1]);                        // add texture coordinate (if enabled)                      if (builder.HasTexCoords)                      {                          textureCoordinates.Add(this.TextureCoordinates[vti - 1]);                      }                        // add normal (if enabled)                      if (builder.HasNormals)                      {                          normals.Add(this.Normals[vni - 1]);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: foreach (var field in fields)              {                  if (string.IsNullOrEmpty(field))                  {                      continue;                  }                    var ff = field.Split('/');                  int vi = int.Parse(ff[0]);                  int vti = ff.Length > 1 && ff[1].Length > 0 ? int.Parse(ff[1]) : int.MaxValue;                  int vni = ff.Length > 2 && ff[2].Length > 0 ? int.Parse(ff[2]) : int.MaxValue;                    // Handle relative indices (negative numbers)                  if (vi < 0)                  {                      vi = this.Points.Count + vi + 1;                  }                    if (vti < 0)                  {                      vti = this.TextureCoordinates.Count + vti + 1;                  }                    if (vni < 0)                  {                      vni = this.Normals.Count + vni + 1;                  }                    // Check if the indices are valid                  if (vi - 1 >= this.Points.Count)                  {                      if (this.IgnoreErrors)                      {                          return;                      }                        throw new FileFormatException(string.Format("Invalid vertex index ({0}) on line {1}."' vi' this.currentLineNo));                  }                    if (vti == int.MaxValue)                  {                      // turn off texture coordinates in the builder                      //builder.CreateTextureCoordinates = false;                      builder.TextureCoordinates = null;                  }                    if (vni == int.MaxValue)                  {                      // turn off normals in the builder                      //builder.CreateNormals = false;                      builder.Normals = null;                  }                    // check if the texture coordinate index is valid                  if (builder.HasTexCoords && vti - 1 >= this.TextureCoordinates.Count)                  {                      if (this.IgnoreErrors)                      {                          return;                      }                        throw new FileFormatException(string.Format("Invalid texture coordinate index ({0}) on line {1}."' vti' this.currentLineNo));                  }                    // check if the normal index is valid                  if (builder.HasNormals && vni - 1 >= this.Normals.Count)                  {                      if (this.IgnoreErrors)                      {                          return;                      }                        throw new FileFormatException(string.Format("Invalid normal index ({0}) on line {1}."' vni' this.currentLineNo));                  }                    bool addVertex = true;                    if (smoothingGroupMap != null)                  {                      var key = Tuple.Create(vi' vti' vni);                        int vix;                      if (smoothingGroupMap.TryGetValue(key' out vix))                      {                          // use the index of a previously defined vertex                          addVertex = false;                      }                      else                      {                          // add a new vertex                          vix = positions.Count;                          smoothingGroupMap.Add(key' vix);                      }                        faceIndices.Add(vix);                  }                  else                  {                      // if smoothing is off' always add a new vertex                      faceIndices.Add(positions.Count);                  }                    if (addVertex)                  {                      // add vertex                      positions.Add(this.Points[vi - 1]);                        // add texture coordinate (if enabled)                      if (builder.HasTexCoords)                      {                          textureCoordinates.Add(this.TextureCoordinates[vti - 1]);                      }                        // add normal (if enabled)                      if (builder.HasNormals)                      {                          normals.Add(this.Normals[vni - 1]);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: try              {                      if (faceIndices.Count < 3)                  {                      throw new HelixToolkitException("Polygon must have at least 3 indices!");                  }                      if (this.ModelInfo.Faces == MeshFaces.QuadPatches)                  {                      if (faceIndices.Count == 3)                      {                          faceIndices.Add(faceIndices.Last());                          builder.AddQuad(faceIndices);                      }                      if (faceIndices.Count == 4)                      {                          builder.AddQuad(faceIndices);                      }                      else                      {                          // add triangles by sweep line algorithm                          builder.AddPolygonByTriangulation(faceIndices);                      }                  }                  else                  {                      if (faceIndices.Count == 3)                      {                          builder.AddTriangle(faceIndices);                      }                      else if (faceIndices.Count == 4)                      {                          //builder.AddQuad(faceIndices);                          builder.AddTriangleFan(faceIndices);                      }                      else                      {                          // add triangles by sweep line algorithm                          builder.AddPolygonByTriangulation(faceIndices);                      }                  }              }              catch (Exception ex)              {                    System.Windows.MessageBox.Show(string.Format("Error composing polygonal object: {0}"' ex.Message)' "Error"' MessageBoxButton.OKCancel);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: try              {                      if (faceIndices.Count < 3)                  {                      throw new HelixToolkitException("Polygon must have at least 3 indices!");                  }                      if (this.ModelInfo.Faces == MeshFaces.QuadPatches)                  {                      if (faceIndices.Count == 3)                      {                          faceIndices.Add(faceIndices.Last());                          builder.AddQuad(faceIndices);                      }                      if (faceIndices.Count == 4)                      {                          builder.AddQuad(faceIndices);                      }                      else                      {                          // add triangles by sweep line algorithm                          builder.AddPolygonByTriangulation(faceIndices);                      }                  }                  else                  {                      if (faceIndices.Count == 3)                      {                          builder.AddTriangle(faceIndices);                      }                      else if (faceIndices.Count == 4)                      {                          //builder.AddQuad(faceIndices);                          builder.AddTriangleFan(faceIndices);                      }                      else                      {                          // add triangles by sweep line algorithm                          builder.AddPolygonByTriangulation(faceIndices);                      }                  }              }              catch (Exception ex)              {                    System.Windows.MessageBox.Show(string.Format("Error composing polygonal object: {0}"' ex.Message)' "Error"' MessageBoxButton.OKCancel);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: try              {                      if (faceIndices.Count < 3)                  {                      throw new HelixToolkitException("Polygon must have at least 3 indices!");                  }                      if (this.ModelInfo.Faces == MeshFaces.QuadPatches)                  {                      if (faceIndices.Count == 3)                      {                          faceIndices.Add(faceIndices.Last());                          builder.AddQuad(faceIndices);                      }                      if (faceIndices.Count == 4)                      {                          builder.AddQuad(faceIndices);                      }                      else                      {                          // add triangles by sweep line algorithm                          builder.AddPolygonByTriangulation(faceIndices);                      }                  }                  else                  {                      if (faceIndices.Count == 3)                      {                          builder.AddTriangle(faceIndices);                      }                      else if (faceIndices.Count == 4)                      {                          //builder.AddQuad(faceIndices);                          builder.AddTriangleFan(faceIndices);                      }                      else                      {                          // add triangles by sweep line algorithm                          builder.AddPolygonByTriangulation(faceIndices);                      }                  }              }              catch (Exception ex)              {                    System.Windows.MessageBox.Show(string.Format("Error composing polygonal object: {0}"' ex.Message)' "Error"' MessageBoxButton.OKCancel);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: try              {                      if (faceIndices.Count < 3)                  {                      throw new HelixToolkitException("Polygon must have at least 3 indices!");                  }                      if (this.ModelInfo.Faces == MeshFaces.QuadPatches)                  {                      if (faceIndices.Count == 3)                      {                          faceIndices.Add(faceIndices.Last());                          builder.AddQuad(faceIndices);                      }                      if (faceIndices.Count == 4)                      {                          builder.AddQuad(faceIndices);                      }                      else                      {                          // add triangles by sweep line algorithm                          builder.AddPolygonByTriangulation(faceIndices);                      }                  }                  else                  {                      if (faceIndices.Count == 3)                      {                          builder.AddTriangle(faceIndices);                      }                      else if (faceIndices.Count == 4)                      {                          //builder.AddQuad(faceIndices);                          builder.AddTriangleFan(faceIndices);                      }                      else                      {                          // add triangles by sweep line algorithm                          builder.AddPolygonByTriangulation(faceIndices);                      }                  }              }              catch (Exception ex)              {                    System.Windows.MessageBox.Show(string.Format("Error composing polygonal object: {0}"' ex.Message)' "Error"' MessageBoxButton.OKCancel);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: try              {                      if (faceIndices.Count < 3)                  {                      throw new HelixToolkitException("Polygon must have at least 3 indices!");                  }                      if (this.ModelInfo.Faces == MeshFaces.QuadPatches)                  {                      if (faceIndices.Count == 3)                      {                          faceIndices.Add(faceIndices.Last());                          builder.AddQuad(faceIndices);                      }                      if (faceIndices.Count == 4)                      {                          builder.AddQuad(faceIndices);                      }                      else                      {                          // add triangles by sweep line algorithm                          builder.AddPolygonByTriangulation(faceIndices);                      }                  }                  else                  {                      if (faceIndices.Count == 3)                      {                          builder.AddTriangle(faceIndices);                      }                      else if (faceIndices.Count == 4)                      {                          //builder.AddQuad(faceIndices);                          builder.AddTriangleFan(faceIndices);                      }                      else                      {                          // add triangles by sweep line algorithm                          builder.AddPolygonByTriangulation(faceIndices);                      }                  }              }              catch (Exception ex)              {                    System.Windows.MessageBox.Show(string.Format("Error composing polygonal object: {0}"' ex.Message)' "Error"' MessageBoxButton.OKCancel);              }
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddNormal,The following statement contains a magic number: if (SwitchYZ)              {                  this.Normals.Add(new Vector3D((float)fields[0]' (float)-fields[2]' (float)fields[1]));              }              else              {                  this.Normals.Add(new Vector3D((float)fields[0]' (float)fields[1]' (float)fields[2]));              }
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddNormal,The following statement contains a magic number: if (SwitchYZ)              {                  this.Normals.Add(new Vector3D((float)fields[0]' (float)-fields[2]' (float)fields[1]));              }              else              {                  this.Normals.Add(new Vector3D((float)fields[0]' (float)fields[1]' (float)fields[2]));              }
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddVertex,The following statement contains a magic number: if (SwitchYZ)              {                  this.Points.Add(new Point3D((float)fields[0]' (float)-fields[2]' (float)fields[1]));              }              else              {                  this.Points.Add(new Point3D((float)fields[0]' (float)fields[1]' (float)fields[2]));              }
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddVertex,The following statement contains a magic number: if (SwitchYZ)              {                  this.Points.Add(new Point3D((float)fields[0]' (float)-fields[2]' (float)fields[1]));              }              else              {                  this.Points.Add(new Point3D((float)fields[0]' (float)fields[1]' (float)fields[2]));              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,GetCircle,The following statement contains a magic number: if ((!closed && !CircleCache.Value.TryGetValue(thetaDiv' out circle)) ||                  (closed && !ClosedCircleCache.Value.TryGetValue(thetaDiv' out circle)))              {                  circle = new PointCollection();                  // Add to the cache                  if (!closed)                  {                      CircleCache.Value.Add(thetaDiv' circle);                  }                  else                  {                      ClosedCircleCache.Value.Add(thetaDiv' circle);                  }                  // Determine the angle steps                  var num = closed ? thetaDiv : thetaDiv - 1;                  for (int i = 0; i < thetaDiv; i++)                  {                      var theta = (DoubleOrSingle)Math.PI * 2 * ((DoubleOrSingle)i / num);                      circle.Add(new Point((DoubleOrSingle)Math.Cos(theta)' -(DoubleOrSingle)Math.Sin(theta)));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormals,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3)              {                  var i1 = triangleIndices[t];                  var i2 = triangleIndices[t + 1];                  var i3 = triangleIndices[t + 2];                  var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                  var p1 = v2 - v1;                  var p2 = v3 - v1;                  var n = SharedFunctions.CrossProduct(ref p1' ref p2);                  // angle                  p1.Normalize();                  p2.Normalize();                  var a = (float)Math.Acos(SharedFunctions.DotProduct(ref p1' ref p2));                  n.Normalize();                  normals[i1] += (a * n);                  normals[i2] += (a * n);                  normals[i3] += (a * n);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormals,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3)              {                  var i1 = triangleIndices[t];                  var i2 = triangleIndices[t + 1];                  var i3 = triangleIndices[t + 2];                  var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                  var p1 = v2 - v1;                  var p2 = v3 - v1;                  var n = SharedFunctions.CrossProduct(ref p1' ref p2);                  // angle                  p1.Normalize();                  p2.Normalize();                  var a = (float)Math.Acos(SharedFunctions.DotProduct(ref p1' ref p2));                  n.Normalize();                  normals[i1] += (a * n);                  normals[i2] += (a * n);                  normals[i3] += (a * n);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3)              {                  var i1 = triangleIndices[t];                  var i2 = triangleIndices[t + 1];                  var i3 = triangleIndices[t + 2];                  var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                  var w1 = textureCoordinates[i1];                  var w2 = textureCoordinates[i2];                  var w3 = textureCoordinates[i3];                  var x1 = v2.X - v1.X;                  var x2 = v3.X - v1.X;                  var y1 = v2.Y - v1.Y;                  var y2 = v3.Y - v1.Y;                  var z1 = v2.Z - v1.Z;                  var z2 = v3.Z - v1.Z;                  var s1 = w2.X - w1.X;                  var s2 = w3.X - w1.X;                  var t1 = w2.Y - w1.Y;                  var t2 = w3.Y - w1.Y;                  var r = 1.0f / (s1 * t2 - s2 * t1);                  var udir = new Vector3D((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);                  tan1[i1] += udir;                  tan1[i2] += udir;                  tan1[i3] += udir;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3)              {                  var i1 = triangleIndices[t];                  var i2 = triangleIndices[t + 1];                  var i3 = triangleIndices[t + 2];                  var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                  var w1 = textureCoordinates[i1];                  var w2 = textureCoordinates[i2];                  var w3 = textureCoordinates[i3];                  var x1 = v2.X - v1.X;                  var x2 = v3.X - v1.X;                  var y1 = v2.Y - v1.Y;                  var y2 = v3.Y - v1.Y;                  var z1 = v2.Z - v1.Z;                  var z2 = v3.Z - v1.Z;                  var s1 = w2.X - w1.X;                  var s2 = w3.X - w1.X;                  var t1 = w2.Y - w1.Y;                  var t2 = w3.Y - w1.Y;                  var r = 1.0f / (s1 * t2 - s2 * t1);                  var udir = new Vector3D((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);                  tan1[i1] += udir;                  tan1[i2] += udir;                  tan1[i3] += udir;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: for (int t = 0; t < indices.Count; t += 4)              {                  var i1 = indices[t];                  var i2 = indices[t + 1];                  var i3 = indices[t + 2];                  var i4 = indices[t + 3];                  var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                  var v4 = positions[i4];                  var w1 = textureCoordinates[i1];                  var w2 = textureCoordinates[i2];                  var w3 = textureCoordinates[i3];                  var w4 = textureCoordinates[i4];                  var x1 = v2.X - v1.X;                  var x2 = v4.X - v1.X;                  var y1 = v2.Y - v1.Y;                  var y2 = v4.Y - v1.Y;                  var z1 = v2.Z - v1.Z;                  var z2 = v4.Z - v1.Z;                  var s1 = w2.X - w1.X;                  var s2 = w4.X - w1.X;                  var t1 = w2.Y - w1.Y;                  var t2 = w4.Y - w1.Y;                  var r = 1.0f / (s1 * t2 - s2 * t1);                  var udir = new Vector3D((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);                  tan1[i1] += udir;                  tan1[i2] += udir;                  tan1[i3] += udir;                  tan1[i4] += udir;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: for (int t = 0; t < indices.Count; t += 4)              {                  var i1 = indices[t];                  var i2 = indices[t + 1];                  var i3 = indices[t + 2];                  var i4 = indices[t + 3];                  var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                  var v4 = positions[i4];                  var w1 = textureCoordinates[i1];                  var w2 = textureCoordinates[i2];                  var w3 = textureCoordinates[i3];                  var w4 = textureCoordinates[i4];                  var x1 = v2.X - v1.X;                  var x2 = v4.X - v1.X;                  var y1 = v2.Y - v1.Y;                  var y2 = v4.Y - v1.Y;                  var z1 = v2.Z - v1.Z;                  var z2 = v4.Z - v1.Z;                  var s1 = w2.X - w1.X;                  var s2 = w4.X - w1.X;                  var t1 = w2.Y - w1.Y;                  var t2 = w4.Y - w1.Y;                  var r = 1.0f / (s1 * t2 - s2 * t1);                  var udir = new Vector3D((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);                  tan1[i1] += udir;                  tan1[i2] += udir;                  tan1[i3] += udir;                  tan1[i4] += udir;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: for (int t = 0; t < indices.Count; t += 4)              {                  var i1 = indices[t];                  var i2 = indices[t + 1];                  var i3 = indices[t + 2];                  var i4 = indices[t + 3];                  var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                  var v4 = positions[i4];                  var w1 = textureCoordinates[i1];                  var w2 = textureCoordinates[i2];                  var w3 = textureCoordinates[i3];                  var w4 = textureCoordinates[i4];                  var x1 = v2.X - v1.X;                  var x2 = v4.X - v1.X;                  var y1 = v2.Y - v1.Y;                  var y2 = v4.Y - v1.Y;                  var z1 = v2.Z - v1.Z;                  var z2 = v4.Z - v1.Z;                  var s1 = w2.X - w1.X;                  var s2 = w4.X - w1.X;                  var t1 = w2.Y - w1.Y;                  var t2 = w4.Y - w1.Y;                  var r = 1.0f / (s1 * t2 - s2 * t1);                  var udir = new Vector3D((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);                  tan1[i1] += udir;                  tan1[i2] += udir;                  tan1[i3] += udir;                  tan1[i4] += udir;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddArrow,The following statement contains a magic number: var r = (DoubleOrSingle)diameter / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddArrow,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' 0)'                      new Point(0' r)'                      new Point(length - (DoubleOrSingle)(diameter * headLength)' r)'                      new Point(length - (DoubleOrSingle)(diameter * headLength)' r * 2)'                      new Point(length' 0)                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The following statement contains a magic number: Action<Point3D' Point3D> addEdge = (c1' c2) => this.AddCylinder(c1' c2' diameter' 10);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: var n = normal * (DoubleOrSingle)dist / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: up *= (DoubleOrSingle)height / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: right *= (DoubleOrSingle)width / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add(i0 + 3);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The following statement contains a magic number: this.AddCone(p1' n' diameter / 2' diameter / 2' l' false' false' thetaDiv);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The following statement contains a magic number: this.AddCone(p1' n' diameter / 2' diameter / 2' l' false' false' thetaDiv);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusSphere = 0.25f * (DoubleOrSingle)Math.Sqrt(3) * (1 + (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusSphere = 0.25f * (DoubleOrSingle)Math.Sqrt(3) * (1 + (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusFace = 0.1f * (DoubleOrSingle)Math.Sqrt(50 + 10 * (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusFace = 0.1f * (DoubleOrSingle)Math.Sqrt(50 + 10 * (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusFace = 0.1f * (DoubleOrSingle)Math.Sqrt(50 + 10 * (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var pentagonPoints = GetCircle(5' true);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var gamma = (DoubleOrSingle)Math.Acos(1 - (sideLength * sideLength / (2 * radiusSphere * radiusSphere)));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation(this.positions.Skip(positionsCount).Take(5).Select((p' i) => i).ToList());
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation(this.positions.Skip(positionsCount + 15).Select((p' i) => 15 + i).ToList());
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation(this.positions.Skip(positionsCount + 15).Select((p' i) => 15 + i).ToList());
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEdges,The following statement contains a magic number: for (int i = 0; i < edges.Count - 1; i += 2)              {                  this.AddCylinder(points[edges[i]]' points[edges[i + 1]]' diameter' thetaDiv);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The following statement contains a magic number: var dt = 2 * (DoubleOrSingle)Math.PI / thetaDiv;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The following statement contains a magic number: for (int pi = 0; pi <= phiDiv; pi++)              {                  var phi = pi * dp;                    for (int ti = 0; ti <= thetaDiv; ti++)                  {                      // we want to start the mesh on the x axis                      var theta = ti * dt;                        // Spherical coordinates                      // http://mathworld.wolfram.com/SphericalCoordinates.html                      var x = (DoubleOrSingle)Math.Cos(theta) * (DoubleOrSingle)Math.Sin(phi);                      var y = (DoubleOrSingle)Math.Sin(theta) * (DoubleOrSingle)Math.Sin(phi);                      var z = (DoubleOrSingle)Math.Cos(phi);                        var p = new Point3D(center.X + (DoubleOrSingle)(radiusx * x)' center.Y + (DoubleOrSingle)(radiusy * y)' center.Z + (DoubleOrSingle)(radiusz * z));                      this.positions.Add(p);                        if (this.normals != null)                      {                          var n = new Vector3D(x' y' z);                          this.normals.Add(n);                      }                        if (this.textureCoordinates != null)                      {                          var uv = new Point(theta / (2 * (DoubleOrSingle)Math.PI)' phi / (DoubleOrSingle)Math.PI);                          this.textureCoordinates.Add(uv);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedGeometry,The following statement contains a magic number: int np = 2 * points.Count;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedGeometry,The following statement contains a magic number: foreach (var p in points)              {                  var v = (xaxis * p.X) + (ydirection * p.Y);                  this.positions.Add(p0 + v);                  this.positions.Add(p1 + v);                  v.Normalize();                  if (this.normals != null)                  {                      this.normals.Add(v);                      this.normals.Add(v);                  }                    if (this.textureCoordinates != null)                  {                      this.textureCoordinates.Add(new Point(0' 0));                      this.textureCoordinates.Add(new Point(1' 0));                  }                    int i1 = index0 + 1;                  int i2 = (index0 + 2) % np;                  int i3 = ((index0 + 2) % np) + 1;                    this.triangleIndices.Add(i1);                  this.triangleIndices.Add(i2);                  this.triangleIndices.Add(index0);                    this.triangleIndices.Add(i1);                  this.triangleIndices.Add(i3);                  this.triangleIndices.Add(i2);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedGeometry,The following statement contains a magic number: foreach (var p in points)              {                  var v = (xaxis * p.X) + (ydirection * p.Y);                  this.positions.Add(p0 + v);                  this.positions.Add(p1 + v);                  v.Normalize();                  if (this.normals != null)                  {                      this.normals.Add(v);                      this.normals.Add(v);                  }                    if (this.textureCoordinates != null)                  {                      this.textureCoordinates.Add(new Point(0' 0));                      this.textureCoordinates.Add(new Point(1' 0));                  }                    int i1 = index0 + 1;                  int i2 = (index0 + 2) % np;                  int i3 = ((index0 + 2) % np) + 1;                    this.triangleIndices.Add(i1);                  this.triangleIndices.Add(i2);                  this.triangleIndices.Add(index0);                    this.triangleIndices.Add(i1);                  this.triangleIndices.Add(i3);                  this.triangleIndices.Add(i2);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: if (points.Count % 2 != 0)              {                  throw new InvalidOperationException("The number of points should be even.");              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  int i0 = index0 + (i * 2);                  int i1 = i0 + 1;                  int i2 = i0 + 3;                  int i3 = i0 + 2;                    this.triangleIndices.Add(i0);                  this.triangleIndices.Add(i1);                  this.triangleIndices.Add(i2);                    this.triangleIndices.Add(i2);                  this.triangleIndices.Add(i3);                  this.triangleIndices.Add(i0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  int i0 = index0 + (i * 2);                  int i1 = i0 + 1;                  int i2 = i0 + 3;                  int i3 = i0 + 2;                    this.triangleIndices.Add(i0);                  this.triangleIndices.Add(i1);                  this.triangleIndices.Add(i2);                    this.triangleIndices.Add(i2);                  this.triangleIndices.Add(i3);                  this.triangleIndices.Add(i0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  int i0 = index0 + (i * 2);                  int i1 = i0 + 1;                  int i2 = i0 + 3;                  int i3 = i0 + 2;                    this.triangleIndices.Add(i0);                  this.triangleIndices.Add(i1);                  this.triangleIndices.Add(i2);                    this.triangleIndices.Add(i2);                  this.triangleIndices.Add(i3);                  this.triangleIndices.Add(i0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The following statement contains a magic number: var n = forward * (DoubleOrSingle)sideLength / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The following statement contains a magic number: up *= (DoubleOrSingle)height / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The following statement contains a magic number: right *= (DoubleOrSingle)sideLength / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' (DoubleOrSingle)innerDiameter / 2)'                      new Point(0' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)innerDiameter / 2)                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' (DoubleOrSingle)innerDiameter / 2)'                      new Point(0' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)innerDiameter / 2)                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' (DoubleOrSingle)innerDiameter / 2)'                      new Point(0' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)innerDiameter / 2)                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' (DoubleOrSingle)innerDiameter / 2)'                      new Point(0' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)innerDiameter / 2)                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: if (innerDiameter > 0)              {                  // Add the inner surface                  pc.Add(new Point(0' (DoubleOrSingle)innerDiameter / 2));                  tc.Add(1);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipes,The following statement contains a magic number: for (int i = 0; i < edges.Count - 1; i += 2)              {                  this.AddCylinder((Point3D)points[edges[i]]' (Point3D)points[edges[i + 1]]' diameter' thetaDiv);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: for (int i = 0; i + 2 < n; i++)              {                  this.triangleIndices.Add(vertexIndices[0]);                  this.triangleIndices.Add(vertexIndices[i + 1]);                  this.triangleIndices.Add(vertexIndices[i + 2]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: for (int i = 0; i + 2 < n; i++)              {                  this.triangleIndices.Add(vertexIndices[0]);                  this.triangleIndices.Add(vertexIndices[i + 1]);                  this.triangleIndices.Add(vertexIndices[i + 2]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: var n = forward * (DoubleOrSingle)sideLength / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: right *= (DoubleOrSingle)sideLength / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: var down = -up * 1f / 3;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: var realup = up * 2f / 3;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  this.triangleIndices.Add(vertexIndices[i]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add(i0 + 3);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: Debug.Assert(quadPositions.Count > 0 && quadPositions.Count % 4 == 0' "Wrong number of positions.");
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    this.triangleIndices.Add(i + 2);                  this.triangleIndices.Add(i + 3);                  this.triangleIndices.Add(i);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    this.triangleIndices.Add(i + 2);                  this.triangleIndices.Add(i + 3);                  this.triangleIndices.Add(i);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    this.triangleIndices.Add(i + 2);                  this.triangleIndices.Add(i + 3);                  this.triangleIndices.Add(i);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    this.triangleIndices.Add(i + 2);                  this.triangleIndices.Add(i + 3);                  this.triangleIndices.Add(i);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The following statement contains a magic number: if (columns < 2 || rows < 2)              {                  throw new ArgumentNullException("columns or rows too small");              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The following statement contains a magic number: if (columns < 2 || rows < 2)              {                  throw new ArgumentNullException("columns or rows too small");              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndices,The following statement contains a magic number: for (int i = 0; i < rows - 1; i++)              {                  for (int j = 0; j < columns - 1; j++)                  {                      int ij = (i * columns) + j;                      if (!isSpherical || i > 0)                      {                          this.triangleIndices.Add(index0 + ij);                          this.triangleIndices.Add(index0 + ij + 1 + columns);                          this.triangleIndices.Add(index0 + ij + 1);                      }                        if (!isSpherical || i < rows - 2)                      {                          this.triangleIndices.Add(index0 + ij + 1 + columns);                          this.triangleIndices.Add(index0 + ij);                          this.triangleIndices.Add(index0 + ij + columns);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndicesFlipped,The following statement contains a magic number: for (int i = 0; i < rows - 1; i++)              {                  for (int j = 0; j < columns - 1; j++)                  {                      int ij = (i * columns) + j;                      if (!isSpherical || i > 0)                      {                          this.triangleIndices.Add(index0 + ij);                          this.triangleIndices.Add(index0 + ij + 1);                          this.triangleIndices.Add(index0 + ij + 1 + columns);                      }                        if (!isSpherical || i < rows - 2)                      {                          this.triangleIndices.Add(index0 + ij + 1 + columns);                          this.triangleIndices.Add(index0 + ij + columns);                          this.triangleIndices.Add(index0 + ij);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var a = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 + Math.Sqrt(5.0)));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var a = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 + Math.Sqrt(5.0)));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var a = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 + Math.Sqrt(5.0)));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var b = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 - Math.Sqrt(5.0)));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var b = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 - Math.Sqrt(5.0)));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var b = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 - Math.Sqrt(5.0)));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: if (shareVertices)              {                  int index0 = this.positions.Count;                  foreach (var v in icosahedronVertices)                  {                      this.positions.Add(center + (v * (DoubleOrSingle)radius));                  }                    foreach (int i in icosahedronIndices)                  {                      this.triangleIndices.Add(index0 + i);                  }              }              else              {                  for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3)                  {                      this.AddTriangle(                          center + (icosahedronVertices[icosahedronIndices[i]] * (DoubleOrSingle)radius)'                          center + (icosahedronVertices[icosahedronIndices[i + 1]] * (DoubleOrSingle)radius)'                          center + (icosahedronVertices[icosahedronIndices[i + 2]] * (DoubleOrSingle)radius));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: if (shareVertices)              {                  int index0 = this.positions.Count;                  foreach (var v in icosahedronVertices)                  {                      this.positions.Add(center + (v * (DoubleOrSingle)radius));                  }                    foreach (int i in icosahedronIndices)                  {                      this.triangleIndices.Add(index0 + i);                  }              }              else              {                  for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3)                  {                      this.AddTriangle(                          center + (icosahedronVertices[icosahedronIndices[i]] * (DoubleOrSingle)radius)'                          center + (icosahedronVertices[icosahedronIndices[i + 1]] * (DoubleOrSingle)radius)'                          center + (icosahedronVertices[icosahedronIndices[i + 2]] * (DoubleOrSingle)radius));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: if (shareVertices)              {                  int index0 = this.positions.Count;                  foreach (var v in icosahedronVertices)                  {                      this.positions.Add(center + (v * (DoubleOrSingle)radius));                  }                    foreach (int i in icosahedronIndices)                  {                      this.triangleIndices.Add(index0 + i);                  }              }              else              {                  for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3)                  {                      this.AddTriangle(                          center + (icosahedronVertices[icosahedronIndices[i]] * (DoubleOrSingle)radius)'                          center + (icosahedronVertices[icosahedronIndices[i + 1]] * (DoubleOrSingle)radius)'                          center + (icosahedronVertices[icosahedronIndices[i + 2]] * (DoubleOrSingle)radius));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: int totalNodes = (points.Count - 1) * 2 * thetaDiv;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: int rowNodes = (points.Count - 1) * 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++)              {                  var w = (v * circle[i].X) + (u * circle[i].Y);                    for (int j = 0; j + 1 < n; j++)                  {                      // Add segment                      var q1 = origin + (direction * points[j].X) + (w * points[j].Y);                      var q2 = origin + (direction * points[j + 1].X) + (w * points[j + 1].Y);                        // TODO: should not add segment if q1==q2 (corner point)                      // const double eps = 1e-6;                      // if (Point3D.Subtract(q1' q2).LengthSquared < eps)                      // continue;                      this.positions.Add(q1);                      this.positions.Add(q2);                        if (this.normals != null)                      {                          var tx = points[j + 1].X - points[j].X;                          var ty = points[j + 1].Y - points[j].Y;                          var normal = (-direction * ty) + (w * tx);                          normal.Normalize();                          this.normals.Add(normal);                          this.normals.Add(normal);                      }                        if (this.textureCoordinates != null)                      {                          this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues[j]));                          this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues[j + 1]));                      }                        int i0 = index0 + (i * rowNodes) + (j * 2);                      int i1 = i0 + 1;                      int i2 = index0 + ((((i + 1) * rowNodes) + (j * 2)) % totalNodes);                      int i3 = i2 + 1;                        this.triangleIndices.Add(i1);                      this.triangleIndices.Add(i0);                      this.triangleIndices.Add(i2);                        this.triangleIndices.Add(i1);                      this.triangleIndices.Add(i2);                      this.triangleIndices.Add(i3);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++)              {                  var w = (v * circle[i].X) + (u * circle[i].Y);                    for (int j = 0; j + 1 < n; j++)                  {                      // Add segment                      var q1 = origin + (direction * points[j].X) + (w * points[j].Y);                      var q2 = origin + (direction * points[j + 1].X) + (w * points[j + 1].Y);                        // TODO: should not add segment if q1==q2 (corner point)                      // const double eps = 1e-6;                      // if (Point3D.Subtract(q1' q2).LengthSquared < eps)                      // continue;                      this.positions.Add(q1);                      this.positions.Add(q2);                        if (this.normals != null)                      {                          var tx = points[j + 1].X - points[j].X;                          var ty = points[j + 1].Y - points[j].Y;                          var normal = (-direction * ty) + (w * tx);                          normal.Normalize();                          this.normals.Add(normal);                          this.normals.Add(normal);                      }                        if (this.textureCoordinates != null)                      {                          this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues[j]));                          this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues[j + 1]));                      }                        int i0 = index0 + (i * rowNodes) + (j * 2);                      int i1 = i0 + 1;                      int i2 = index0 + ((((i + 1) * rowNodes) + (j * 2)) % totalNodes);                      int i3 = i2 + 1;                        this.triangleIndices.Add(i1);                      this.triangleIndices.Add(i0);                      this.triangleIndices.Add(i2);                        this.triangleIndices.Add(i1);                      this.triangleIndices.Add(i2);                      this.triangleIndices.Add(i3);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++)              {                  var ii = (i + 1) % thetaDiv;                  for (int j = 0; j + 1 < sectionIndices.Count; j += 2)                  {                      var j0 = sectionIndices[j];                      var j1 = sectionIndices[j + 1];                        int i0 = index0 + (i * n) + j0;                      int i1 = index0 + (ii * n) + j0;                      int i2 = index0 + (i * n) + j1;                      int i3 = index0 + (ii * n) + j1;                        this.triangleIndices.Add(i0);                      this.triangleIndices.Add(i1);                      this.triangleIndices.Add(i3);                        this.triangleIndices.Add(i3);                      this.triangleIndices.Add(i2);                      this.triangleIndices.Add(i0);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var heightSphere = (DoubleOrSingle)Math.Sqrt(6) / 3 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var heightSphere = (DoubleOrSingle)Math.Sqrt(6) / 3 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var radiusSphere = (DoubleOrSingle)Math.Sqrt(6) / 4 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var radiusSphere = (DoubleOrSingle)Math.Sqrt(6) / 4 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var heightFace = (DoubleOrSingle)Math.Sqrt(3) / 2 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var heightFace = (DoubleOrSingle)Math.Sqrt(3) / 2 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var radiusFace = (DoubleOrSingle)Math.Sqrt(3) / 3 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var radiusFace = (DoubleOrSingle)Math.Sqrt(3) / 3 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  this.triangleIndices.Add(vertexIndices[i]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = 0; i + 2 < vertices.Count; i++)              {                  this.triangleIndices.Add(vertices[0]);                  this.triangleIndices.Add(vertices[i + 1]);                  this.triangleIndices.Add(vertices[i + 2]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = 0; i + 2 < vertices.Count; i++)              {                  this.triangleIndices.Add(vertices[0]);                  this.triangleIndices.Add(vertices[i + 1]);                  this.triangleIndices.Add(vertices[i + 2]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i++)              {                  this.triangleIndices.Add(index0);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i++)              {                  this.triangleIndices.Add(index0);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangles,The following statement contains a magic number: if (trianglePositions.Count % 3 != 0)              {                  throw new InvalidOperationException(WrongNumberOfPositions);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    if (i + 3 < indexEnd)                  {                      this.triangleIndices.Add(i + 1);                      this.triangleIndices.Add(i + 3);                      this.triangleIndices.Add(i + 2);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    if (i + 3 < indexEnd)                  {                      this.triangleIndices.Add(i + 1);                      this.triangleIndices.Add(i + 3);                      this.triangleIndices.Add(i + 2);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    if (i + 3 < indexEnd)                  {                      this.triangleIndices.Add(i + 1);                      this.triangleIndices.Add(i + 3);                      this.triangleIndices.Add(i + 2);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    if (i + 3 < indexEnd)                  {                      this.triangleIndices.Add(i + 1);                      this.triangleIndices.Add(i + 3);                      this.triangleIndices.Add(i + 2);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    if (i + 3 < indexEnd)                  {                      this.triangleIndices.Add(i + 1);                      this.triangleIndices.Add(i + 3);                      this.triangleIndices.Add(i + 2);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    if (i + 3 < indexEnd)                  {                      this.triangleIndices.Add(i + 1);                      this.triangleIndices.Add(i + 3);                      this.triangleIndices.Add(i + 2);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2)              {                  return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2)              {                  return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: for (int i = 0; i < pathLength; i++)              {                  var r = diameters != null ? (DoubleOrSingle)diameters[i % diametersCount] / 2 : 1;                  int i0 = i > 0 ? i - 1 : i;                  int i1 = i + 1 < pathLength ? i + 1 : i;                  var forward = path[i1] - path[i0];                  var right = SharedFunctions.CrossProduct(ref up' ref forward);                    up = SharedFunctions.CrossProduct(ref forward' ref right);                  up.Normalize();                  right.Normalize();                  var u = right;                  var v = up;                    //*******************************                  //*** PROPOSED SOLUTION *********                  // ** I think this will work because if path[n-1] is same point'                   // ** it is always a reflection of the current move                  // ** so reversing the last move vector should work?                  //*******************************                  if (u.IsUndefined() || v.IsUndefined())                  {                      forward = lastForward;                      forward *= -1;                      up = lastUp;                      //** Please verify that negation of "up" is correct here                      up *= -1;                      right = SharedFunctions.CrossProduct(ref up' ref forward);                      up.Normalize();                      right.Normalize();                      u = right;                      v = up;                  }                  lastForward = forward;                  lastUp = up;                    //*** PROPOSED SOLUTION *********                  //*******************************                  for (int j = 0; j < sectionLength; j++)                  {                      var w = (section[j].X * u * r) + (section[j].Y * v * r);                      var q = path[i] + w;                      this.positions.Add(q);                      if (this.normals != null)                      {                          w.Normalize();                          this.normals.Add(w);                      }                        if (this.textureCoordinates != null)                      {                          this.textureCoordinates.Add(                              values != null                                  ? new Point((DoubleOrSingle)values[i % valuesCount]' (DoubleOrSingle)j / (sectionLength - 1))                                  : new Point());                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (frontCap || backCap && path.Count > 1)              {                  var normals = new Vector3D[section.Count];                  var fanTextures = new Point[section.Count];                  var count = path.Count;                  if (backCap)                  {                      var circleBack = Positions.Skip(Positions.Count - section.Count).Take(section.Count).Reverse().ToArray();                      var normal = path[count - 1] - path[count - 2];                      normal.Normalize();                      for (int i = 0; i < normals.Length; ++i)                      {                          normals[i] = normal;                      }                      this.AddTriangleFan(circleBack' normals' fanTextures);                  }                  if (frontCap)                  {                      var circleFront = Positions.Take(section.Count).ToArray();                      var normal = path[0] - path[1];                      normal.Normalize();                        for (int i = 0; i < normals.Length; ++i)                      {                          normals[i] = normal;                      }                      this.AddTriangleFan(circleFront' normals' fanTextures);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2)              {                  return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2)              {                  return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: for (int i = 0; i < pathLength; i++)              {                  var radius = diameters != null ? (DoubleOrSingle)diameters[i % diametersCount] / 2 : 1;                  var theta = angles != null ? (DoubleOrSingle)angles[i % anglesCount] : 0.0;                    var ct = (DoubleOrSingle)Math.Cos(theta);                  var st = (DoubleOrSingle)Math.Sin(theta);                    int i0 = i > 0 ? i - 1 : i;                  int i1 = i + 1 < pathLength ? i + 1 : i;                    forward = path[i1] - path[i0];                  right = SharedFunctions.CrossProduct(ref up' ref forward);                  if (SharedFunctions.LengthSquared(ref right) > 1e-6f)                  {                      up = SharedFunctions.CrossProduct(ref forward' ref right);                  }                    up.Normalize();                  right.Normalize();                  for (int j = 0; j < sectionLength; j++)                  {                      var x = (section[j].X * ct) - (section[j].Y * st);                      var y = (section[j].X * st) + (section[j].Y * ct);                        var w = (x * right * radius) + (y * up * radius);                      var q = path[i] + w;                      this.positions.Add(q);                      if (this.normals != null)                      {                          w.Normalize();                          this.normals.Add(w);                      }                        if (this.textureCoordinates != null)                      {                          this.textureCoordinates.Add(                              values != null                                  ? new Point((DoubleOrSingle)values[i % valuesCount]' (DoubleOrSingle)j / (sectionLength - 1))                                  : new Point());                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (frontCap || backCap && path.Count > 1)              {                  var normals = new Vector3D[section.Count];                  var fanTextures = new Point[section.Count];                  var count = path.Count;                  if (backCap)                  {                      var circleBack = Positions.Skip(Positions.Count - section.Count).Take(section.Count).Reverse().ToArray();                      var normal = path[count - 1] - path[count - 2];                      normal.Normalize();                      for (int i = 0; i < normals.Length; ++i)                      {                          normals[i] = normal;                      }                      this.AddTriangleFan(circleBack' normals' fanTextures);                  }                  if (frontCap)                  {                      var circleFront = Positions.Take(section.Count).ToArray();                      var normal = path[0] - path[1];                      normal.Normalize();                        for (int i = 0; i < normals.Length; ++i)                      {                          normals[i] = normal;                      }                      this.AddTriangleFan(circleFront' normals' fanTextures);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  var p0 = this.positions[this.triangleIndices[i0]];                  var p1 = this.positions[this.triangleIndices[i1]];                  var p2 = this.positions[this.triangleIndices[i2]];                  var pp0 = p - p0;                  var pp1 = p - p1;                  var pp2 = p - p2;                  var d0 = SharedFunctions.LengthSquared(ref pp0);                  var d1 = SharedFunctions.LengthSquared(ref pp1);                  var d2 = SharedFunctions.LengthSquared(ref pp2);                  var mind = Math.Min(d0' Math.Min(d1' d2));                  if (mind > eps)                  {                      continue;                  }                    if (d1 < eps)                  {                      i0 = i + 1;                      i1 = i + 2;                      i2 = i;                  }                    if (d2 < eps)                  {                      i0 = i + 2;                      i1 = i;                      i2 = i + 1;                  }                    p0 = this.positions[this.triangleIndices[i0]];                  p1 = this.positions[this.triangleIndices[i1]];                  p2 = this.positions[this.triangleIndices[i2]];                    // origin is the corner vertex (at index i0)                  // find the intersections between the chamfer plane and the two edges connected to the corner                  var p01 = plane.LineIntersection(p0' p1);                  var p02 = plane.LineIntersection(p0' p2);                    if (p01 == null)                  {                      continue;                  }                    if (p02 == null)                  {                      continue;                  }                    if (chamferPoints != null)                  {                      // add the chamfered points                      if (!chamferPoints.Contains(p01.Value))                      {                          chamferPoints.Add(p01.Value);                      }                        if (!chamferPoints.Contains(p02.Value))                      {                          chamferPoints.Add(p02.Value);                      }                  }                    int i01 = i0;                    // change the original triangle to use the first chamfer point                  this.positions[this.triangleIndices[i01]] = p01.Value;                    int i02 = this.positions.Count;                  this.positions.Add(p02.Value);                    // add a new triangle for the other chamfer point                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i2);                  this.triangleIndices.Add(i02);                    // add a triangle connecting the chamfer points and the new corner point                  this.triangleIndices.Add(index0);                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i02);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  var p0 = this.positions[this.triangleIndices[i0]];                  var p1 = this.positions[this.triangleIndices[i1]];                  var p2 = this.positions[this.triangleIndices[i2]];                  var pp0 = p - p0;                  var pp1 = p - p1;                  var pp2 = p - p2;                  var d0 = SharedFunctions.LengthSquared(ref pp0);                  var d1 = SharedFunctions.LengthSquared(ref pp1);                  var d2 = SharedFunctions.LengthSquared(ref pp2);                  var mind = Math.Min(d0' Math.Min(d1' d2));                  if (mind > eps)                  {                      continue;                  }                    if (d1 < eps)                  {                      i0 = i + 1;                      i1 = i + 2;                      i2 = i;                  }                    if (d2 < eps)                  {                      i0 = i + 2;                      i1 = i;                      i2 = i + 1;                  }                    p0 = this.positions[this.triangleIndices[i0]];                  p1 = this.positions[this.triangleIndices[i1]];                  p2 = this.positions[this.triangleIndices[i2]];                    // origin is the corner vertex (at index i0)                  // find the intersections between the chamfer plane and the two edges connected to the corner                  var p01 = plane.LineIntersection(p0' p1);                  var p02 = plane.LineIntersection(p0' p2);                    if (p01 == null)                  {                      continue;                  }                    if (p02 == null)                  {                      continue;                  }                    if (chamferPoints != null)                  {                      // add the chamfered points                      if (!chamferPoints.Contains(p01.Value))                      {                          chamferPoints.Add(p01.Value);                      }                        if (!chamferPoints.Contains(p02.Value))                      {                          chamferPoints.Add(p02.Value);                      }                  }                    int i01 = i0;                    // change the original triangle to use the first chamfer point                  this.positions[this.triangleIndices[i01]] = p01.Value;                    int i02 = this.positions.Count;                  this.positions.Add(p02.Value);                    // add a new triangle for the other chamfer point                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i2);                  this.triangleIndices.Add(i02);                    // add a triangle connecting the chamfer points and the new corner point                  this.triangleIndices.Add(index0);                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i02);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  var p0 = this.positions[this.triangleIndices[i0]];                  var p1 = this.positions[this.triangleIndices[i1]];                  var p2 = this.positions[this.triangleIndices[i2]];                  var pp0 = p - p0;                  var pp1 = p - p1;                  var pp2 = p - p2;                  var d0 = SharedFunctions.LengthSquared(ref pp0);                  var d1 = SharedFunctions.LengthSquared(ref pp1);                  var d2 = SharedFunctions.LengthSquared(ref pp2);                  var mind = Math.Min(d0' Math.Min(d1' d2));                  if (mind > eps)                  {                      continue;                  }                    if (d1 < eps)                  {                      i0 = i + 1;                      i1 = i + 2;                      i2 = i;                  }                    if (d2 < eps)                  {                      i0 = i + 2;                      i1 = i;                      i2 = i + 1;                  }                    p0 = this.positions[this.triangleIndices[i0]];                  p1 = this.positions[this.triangleIndices[i1]];                  p2 = this.positions[this.triangleIndices[i2]];                    // origin is the corner vertex (at index i0)                  // find the intersections between the chamfer plane and the two edges connected to the corner                  var p01 = plane.LineIntersection(p0' p1);                  var p02 = plane.LineIntersection(p0' p2);                    if (p01 == null)                  {                      continue;                  }                    if (p02 == null)                  {                      continue;                  }                    if (chamferPoints != null)                  {                      // add the chamfered points                      if (!chamferPoints.Contains(p01.Value))                      {                          chamferPoints.Add(p01.Value);                      }                        if (!chamferPoints.Contains(p02.Value))                      {                          chamferPoints.Add(p02.Value);                      }                  }                    int i01 = i0;                    // change the original triangle to use the first chamfer point                  this.positions[this.triangleIndices[i01]] = p01.Value;                    int i02 = this.positions.Count;                  this.positions.Add(p02.Value);                    // add a new triangle for the other chamfer point                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i2);                  this.triangleIndices.Add(i02);                    // add a triangle connecting the chamfer points and the new corner point                  this.triangleIndices.Add(index0);                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i02);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  var p0 = this.positions[this.triangleIndices[i0]];                  var p1 = this.positions[this.triangleIndices[i1]];                  var p2 = this.positions[this.triangleIndices[i2]];                  var pp0 = p - p0;                  var pp1 = p - p1;                  var pp2 = p - p2;                  var d0 = SharedFunctions.LengthSquared(ref pp0);                  var d1 = SharedFunctions.LengthSquared(ref pp1);                  var d2 = SharedFunctions.LengthSquared(ref pp2);                  var mind = Math.Min(d0' Math.Min(d1' d2));                  if (mind > eps)                  {                      continue;                  }                    if (d1 < eps)                  {                      i0 = i + 1;                      i1 = i + 2;                      i2 = i;                  }                    if (d2 < eps)                  {                      i0 = i + 2;                      i1 = i;                      i2 = i + 1;                  }                    p0 = this.positions[this.triangleIndices[i0]];                  p1 = this.positions[this.triangleIndices[i1]];                  p2 = this.positions[this.triangleIndices[i2]];                    // origin is the corner vertex (at index i0)                  // find the intersections between the chamfer plane and the two edges connected to the corner                  var p01 = plane.LineIntersection(p0' p1);                  var p02 = plane.LineIntersection(p0' p2);                    if (p01 == null)                  {                      continue;                  }                    if (p02 == null)                  {                      continue;                  }                    if (chamferPoints != null)                  {                      // add the chamfered points                      if (!chamferPoints.Contains(p01.Value))                      {                          chamferPoints.Add(p01.Value);                      }                        if (!chamferPoints.Contains(p02.Value))                      {                          chamferPoints.Add(p02.Value);                      }                  }                    int i01 = i0;                    // change the original triangle to use the first chamfer point                  this.positions[this.triangleIndices[i01]] = p01.Value;                    int i02 = this.positions.Count;                  this.positions.Add(p02.Value);                    // add a new triangle for the other chamfer point                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i2);                  this.triangleIndices.Add(i02);                    // add a triangle connecting the chamfer points and the new corner point                  this.triangleIndices.Add(index0);                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i02);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,CheckPerformanceLimits,The following statement contains a magic number: if (this.positions.Count > 20000)              {                  Trace.WriteLine(string.Format("Too many positions ({0})."' this.positions.Count));              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,CheckPerformanceLimits,The following statement contains a magic number: if (this.triangleIndices.Count > 60002)              {                  Trace.WriteLine(string.Format("Too many triangle indices ({0})."' this.triangleIndices.Count));              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,FindCornerNormal,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  var p0 = this.positions[this.triangleIndices[i0]];                  var p1 = this.positions[this.triangleIndices[i1]];                  var p2 = this.positions[this.triangleIndices[i2]];                    // check if any of the vertices are on the corner                  var pp0 = p - p0;                  var pp1 = p - p1;                  var pp2 = p - p2;                  var d0 = SharedFunctions.LengthSquared(ref pp0);                  var d1 = SharedFunctions.LengthSquared(ref pp1);                  var d2 = SharedFunctions.LengthSquared(ref pp2);                  var mind = Math.Min(d0' Math.Min(d1' d2));                  if (mind > eps)                  {                      continue;                  }                    // calculate the triangle normal and check if this face is already added                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var normal = SharedFunctions.CrossProduct(ref p10' ref p20);                  normal.Normalize();                    // todo: need to use the epsilon value to compare the normals?                  if (addedNormals.Contains(normal))                  {                      continue;                  }                    // todo: this does not work yet                  // double dp = 1;                  // foreach (var n in addedNormals)                  // {                  // dp = Math.Abs(Vector3D.DotProduct(n' normal) - 1);                  // if (dp < eps)                  // continue;                  // }                  // if (dp < eps)                  // {                  // continue;                  // }                  count++;                  sum += normal;                  addedNormals.Add(normal);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,FindCornerNormal,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  var p0 = this.positions[this.triangleIndices[i0]];                  var p1 = this.positions[this.triangleIndices[i1]];                  var p2 = this.positions[this.triangleIndices[i2]];                    // check if any of the vertices are on the corner                  var pp0 = p - p0;                  var pp1 = p - p1;                  var pp2 = p - p2;                  var d0 = SharedFunctions.LengthSquared(ref pp0);                  var d1 = SharedFunctions.LengthSquared(ref pp1);                  var d2 = SharedFunctions.LengthSquared(ref pp2);                  var mind = Math.Min(d0' Math.Min(d1' d2));                  if (mind > eps)                  {                      continue;                  }                    // calculate the triangle normal and check if this face is already added                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var normal = SharedFunctions.CrossProduct(ref p10' ref p20);                  normal.Normalize();                    // todo: need to use the epsilon value to compare the normals?                  if (addedNormals.Contains(normal))                  {                      continue;                  }                    // todo: this does not work yet                  // double dp = 1;                  // foreach (var n in addedNormals)                  // {                  // dp = Math.Abs(Vector3D.DotProduct(n' normal) - 1);                  // if (dp < eps)                  // continue;                  // }                  // if (dp < eps)                  // {                  // continue;                  // }                  count++;                  sum += normal;                  addedNormals.Add(normal);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  int index0 = this.triangleIndices[i0];                  int index1 = this.triangleIndices[i1];                  int index2 = this.triangleIndices[i2];                  var p0 = this.positions[index0];                  var p1 = this.positions[index1];                  var p2 = this.positions[index2];                  p.Add(p0);                  p.Add(p1);                  p.Add(p2);                  ti.Add(i0);                  ti.Add(i1);                  ti.Add(i2);                  if (n != null)                  {                      n.Add(this.normals[index0]);                      n.Add(this.normals[index1]);                      n.Add(this.normals[index2]);                  }                    if (tc != null)                  {                      tc.Add(this.textureCoordinates[index0]);                      tc.Add(this.textureCoordinates[index1]);                      tc.Add(this.textureCoordinates[index2]);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  int index0 = this.triangleIndices[i0];                  int index1 = this.triangleIndices[i1];                  int index2 = this.triangleIndices[i2];                  var p0 = this.positions[index0];                  var p1 = this.positions[index1];                  var p2 = this.positions[index2];                  p.Add(p0);                  p.Add(p1);                  p.Add(p2);                  ti.Add(i0);                  ti.Add(i1);                  ti.Add(i2);                  if (n != null)                  {                      n.Add(this.normals[index0]);                      n.Add(this.normals[index1]);                      n.Add(this.normals[index2]);                  }                    if (tc != null)                  {                      tc.Add(this.textureCoordinates[index0]);                      tc.Add(this.textureCoordinates[index1]);                      tc.Add(this.textureCoordinates[index2]);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                    int i01 = ip++;                  int i12 = ip++;                  int i20 = ip++;                    this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = i20;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i20);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                    int i01 = ip++;                  int i12 = ip++;                  int i20 = ip++;                    this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = i20;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i20);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                    int i01 = ip++;                  int i12 = ip++;                  int i20 = ip++;                    this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = i20;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i20);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                    int i01 = ip++;                  int i12 = ip++;                  int i20 = ip++;                    this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = i20;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i20);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < triangleIndices.Count; i += 3)              {                  int index0 = triangleIndices[i];                  int index1 = triangleIndices[i + 1];                  int index2 = triangleIndices[i + 2];                  var p0 = positions[index0];                  var p1 = positions[index1];                  var p2 = positions[index2];                  Vector3D u = p1 - p0;                  Vector3D v = p2 - p0;                  Vector3D w = SharedFunctions.CrossProduct(ref u' ref v);                  w.Normalize();                  normals[index0] += w;                  normals[index1] += w;                  normals[index2] += w;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < triangleIndices.Count; i += 3)              {                  int index0 = triangleIndices[i];                  int index1 = triangleIndices[i + 1];                  int index2 = triangleIndices[i + 2];                  var p0 = positions[index0];                  var p1 = positions[index1];                  var p2 = positions[index2];                  Vector3D u = p1 - p0;                  Vector3D v = p2 - p0;                  Vector3D w = SharedFunctions.CrossProduct(ref u' ref v);                  w.Normalize();                  normals[index0] += w;                  normals[index1] += w;                  normals[index2] += w;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (dict.ContainsKey(key))                      {                          dict[key] = dict[key] + 1;                      }                      else                      {                          dict.Add(key' 1);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (dict.ContainsKey(key))                      {                          dict[key] = dict[key] + 1;                      }                      else                      {                          dict.Add(key' 1);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (dict.ContainsKey(key))                      {                          dict[key] = dict[key] + 1;                      }                      else                      {                          dict.Add(key' 1);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (dict.ContainsKey(key))                      {                          dict[key] = dict[key] + 1;                      }                      else                      {                          dict.Add(key' 1);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (!dict.Contains(key))                      {                          edges.Add(minIndex);                          edges.Add(maxIndex);                          dict.Add(key);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (!dict.Contains(key))                      {                          edges.Add(minIndex);                          edges.Add(maxIndex);                          dict.Add(key);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (!dict.Contains(key))                      {                          edges.Add(minIndex);                          edges.Add(maxIndex);                          dict.Add(key);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (!dict.Contains(key))                      {                          edges.Add(minIndex);                          edges.Add(maxIndex);                          dict.Add(key);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  var p0 = mesh.Positions[mesh.TriangleIndices[i0]];                  var p1 = mesh.Positions[mesh.TriangleIndices[i0 + 1]];                  var p2 = mesh.Positions[mesh.TriangleIndices[i0 + 2]];                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var n = SharedFunctions.CrossProduct(ref p10' ref p20);                  n.Normalize();                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index0' index1);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      Vector3D value;                      if (edgeNormals.TryGetValue(key' out value))                      {                          var n2 = value;                          n2.Normalize();                          var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos(SharedFunctions.DotProduct(ref n' ref n2));                          if (angle > minimumAngle)                          {                              edgeIndices.Add(minIndex);                              edgeIndices.Add(maxIndex);                          }                      }                      else                      {                          edgeNormals.Add(key' n);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  var p0 = mesh.Positions[mesh.TriangleIndices[i0]];                  var p1 = mesh.Positions[mesh.TriangleIndices[i0 + 1]];                  var p2 = mesh.Positions[mesh.TriangleIndices[i0 + 2]];                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var n = SharedFunctions.CrossProduct(ref p10' ref p20);                  n.Normalize();                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index0' index1);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      Vector3D value;                      if (edgeNormals.TryGetValue(key' out value))                      {                          var n2 = value;                          n2.Normalize();                          var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos(SharedFunctions.DotProduct(ref n' ref n2));                          if (angle > minimumAngle)                          {                              edgeIndices.Add(minIndex);                              edgeIndices.Add(maxIndex);                          }                      }                      else                      {                          edgeNormals.Add(key' n);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  var p0 = mesh.Positions[mesh.TriangleIndices[i0]];                  var p1 = mesh.Positions[mesh.TriangleIndices[i0 + 1]];                  var p2 = mesh.Positions[mesh.TriangleIndices[i0 + 2]];                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var n = SharedFunctions.CrossProduct(ref p10' ref p20);                  n.Normalize();                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index0' index1);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      Vector3D value;                      if (edgeNormals.TryGetValue(key' out value))                      {                          var n2 = value;                          n2.Normalize();                          var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos(SharedFunctions.DotProduct(ref n' ref n2));                          if (angle > minimumAngle)                          {                              edgeIndices.Add(minIndex);                              edgeIndices.Add(maxIndex);                          }                      }                      else                      {                          edgeNormals.Add(key' n);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  var p0 = mesh.Positions[mesh.TriangleIndices[i0]];                  var p1 = mesh.Positions[mesh.TriangleIndices[i0 + 1]];                  var p2 = mesh.Positions[mesh.TriangleIndices[i0 + 2]];                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var n = SharedFunctions.CrossProduct(ref p10' ref p20);                  n.Normalize();                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index0' index1);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      Vector3D value;                      if (edgeNormals.TryGetValue(key' out value))                      {                          var n2 = value;                          n2.Normalize();                          var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos(SharedFunctions.DotProduct(ref n' ref n2));                          if (angle > minimumAngle)                          {                              edgeIndices.Add(minIndex);                              edgeIndices.Add(maxIndex);                          }                      }                      else                      {                          edgeNormals.Add(key' n);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  var p0 = mesh.Positions[mesh.TriangleIndices[i0]];                  var p1 = mesh.Positions[mesh.TriangleIndices[i0 + 1]];                  var p2 = mesh.Positions[mesh.TriangleIndices[i0 + 2]];                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var n = SharedFunctions.CrossProduct(ref p10' ref p20);                  n.Normalize();                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index0' index1);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      Vector3D value;                      if (edgeNormals.TryGetValue(key' out value))                      {                          var n2 = value;                          n2.Normalize();                          var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos(SharedFunctions.DotProduct(ref n' ref n2));                          if (angle > minimumAngle)                          {                              edgeIndices.Add(minIndex);                              edgeIndices.Add(maxIndex);                          }                      }                      else                      {                          edgeNormals.Add(key' n);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  var p0 = mesh.Positions[mesh.TriangleIndices[i0]];                  var p1 = mesh.Positions[mesh.TriangleIndices[i0 + 1]];                  var p2 = mesh.Positions[mesh.TriangleIndices[i0 + 2]];                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var n = SharedFunctions.CrossProduct(ref p10' ref p20);                  n.Normalize();                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index0' index1);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      Vector3D value;                      if (edgeNormals.TryGetValue(key' out value))                      {                          var n2 = value;                          n2.Normalize();                          var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos(SharedFunctions.DotProduct(ref n' ref n2));                          if (angle > minimumAngle)                          {                              edgeIndices.Add(minIndex);                              edgeIndices.Add(maxIndex);                          }                      }                      else                      {                          edgeNormals.Add(key' n);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < input.TriangleIndices.Count; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  int index0 = input.TriangleIndices[i0];                  int index1 = input.TriangleIndices[i1];                  int index2 = input.TriangleIndices[i2];                  var p0 = input.Positions[index0];                  var p1 = input.Positions[index1];                  var p2 = input.Positions[index2];                  p.Add(p0);                  p.Add(p1);                  p.Add(p2);                  ti.Add(i0);                  ti.Add(i1);                  ti.Add(i2);                  if (n != null)                  {                      n.Add(input.Normals[index0]);                      n.Add(input.Normals[index1]);                      n.Add(input.Normals[index2]);                  }                    if (tc != null)                  {                      tc.Add(input.TextureCoordinates[index0]);                      tc.Add(input.TextureCoordinates[index1]);                      tc.Add(input.TextureCoordinates[index2]);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < input.TriangleIndices.Count; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  int index0 = input.TriangleIndices[i0];                  int index1 = input.TriangleIndices[i1];                  int index2 = input.TriangleIndices[i2];                  var p0 = input.Positions[index0];                  var p1 = input.Positions[index1];                  var p2 = input.Positions[index2];                  p.Add(p0);                  p.Add(p1);                  p.Add(p2);                  ti.Add(i0);                  ti.Add(i1);                  ti.Add(i2);                  if (n != null)                  {                      n.Add(input.Normals[index0]);                      n.Add(input.Normals[index1]);                      n.Add(input.Normals[index2]);                  }                    if (tc != null)                  {                      tc.Add(input.TextureCoordinates[index0]);                      tc.Add(input.TextureCoordinates[index1]);                      tc.Add(input.TextureCoordinates[index2]);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: if (mesh.TriangleIndices.Count % 3 != 0)              {                  sb.AppendLine("TriangleIndices not complete");              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i++)              {                  int index = mesh.TriangleIndices[i];                  if (index < 0 || index >= mesh.Positions.Count)                  {                      sb.AppendFormat("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);                      sb.AppendLine();                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i++)              {                  int index = mesh.TriangleIndices[i];                  if (index < 0 || index >= mesh.Positions.Count)                  {                      sb.AppendFormat("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);                      sb.AppendLine();                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The following statement contains a magic number: for (var i = 0; i < mesh.TriangleIndices.Count; i += 3)              {                  var index0 = mesh.TriangleIndices[i];                  var index1 = mesh.TriangleIndices[i + 1];                  var index2 = mesh.TriangleIndices[i + 2];                    Point3D[] positions;                  Vector3D[] normals;                  Point[] textureCoordinates;                  int[] triangleIndices;                    contourHelper.ContourFacet(index0' index1' index2' out positions' out normals' out textureCoordinates' out triangleIndices);                    foreach (var p in positions)                  {                      meshBuilder.Positions.Add(p);                  }                    foreach (var tc in textureCoordinates)                  {                      meshBuilder.TextureCoordinates.Add(tc);                  }                    foreach (var n in normals)                  {                      meshBuilder.Normals.Add(n);                  }                    foreach (var ti in triangleIndices)                  {                      meshBuilder.TriangleIndices.Add(ti);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The following statement contains a magic number: for (var i = 0; i < mesh.TriangleIndices.Count; i += 3)              {                  var index0 = mesh.TriangleIndices[i];                  var index1 = mesh.TriangleIndices[i + 1];                  var index2 = mesh.TriangleIndices[i + 2];                    Point3D[] positions;                  Vector3D[] normals;                  Point[] textureCoordinates;                  int[] triangleIndices;                    contourHelper.ContourFacet(index0' index1' index2' out positions' out normals' out textureCoordinates' out triangleIndices);                    foreach (var p in positions)                  {                      meshBuilder.Positions.Add(p);                  }                    foreach (var tc in textureCoordinates)                  {                      meshBuilder.TextureCoordinates.Add(tc);                  }                    foreach (var n in normals)                  {                      meshBuilder.Normals.Add(n);                  }                    foreach (var ti in triangleIndices)                  {                      meshBuilder.TriangleIndices.Add(ti);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3)              {                  Point3D[] positions;                  Vector3D[] normals;                  Point[] textureCoordinates;                  int[] triangleIndices;                    contourHelper.ContourFacet(                      mesh.TriangleIndices[i]'                      mesh.TriangleIndices[i + 1]'                      mesh.TriangleIndices[i + 2]'                      out positions'                      out normals'                      out textureCoordinates'                      out triangleIndices);                  segments.AddRange(positions);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3)              {                  Point3D[] positions;                  Vector3D[] normals;                  Point[] textureCoordinates;                  int[] triangleIndices;                    contourHelper.ContourFacet(                      mesh.TriangleIndices[i]'                      mesh.TriangleIndices[i + 1]'                      mesh.TriangleIndices[i + 2]'                      out positions'                      out normals'                      out textureCoordinates'                      out triangleIndices);                  segments.AddRange(positions);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0)              {                  if (curveCount > 0)                  {                      // Find a segment that is connected to the head of the contour                      segment1 = FindConnectedSegment(segments' curve[0]' eps);                      if (segment1 >= 0)                      {                          if (segment1 % 2 == 1)                          {                              curve.Insert(0' segments[segment1 - 1]);                              segments.RemoveAt(segment1 - 1);                              segments.RemoveAt(segment1 - 1);                          }                          else                          {                              curve.Insert(0' segments[segment1 + 1]);                              segments.RemoveAt(segment1);                              segments.RemoveAt(segment1);                          }                            curveCount++;                          segmentCount -= 2;                      }                        // Find a segment that is connected to the tail of the contour                      segment2 = FindConnectedSegment(segments' curve[curveCount - 1]' eps);                      if (segment2 >= 0)                      {                          if (segment2 % 2 == 1)                          {                              curve.Add(segments[segment2 - 1]);                              segments.RemoveAt(segment2 - 1);                              segments.RemoveAt(segment2 - 1);                          }                          else                          {                              curve.Add(segments[segment2 + 1]);                              segments.RemoveAt(segment2);                              segments.RemoveAt(segment2);                          }                            curveCount++;                          segmentCount -= 2;                      }                  }                    if ((segment1 < 0 && segment2 < 0) || segmentCount == 0)                  {                      if (curveCount > 0)                      {                          yield return curve;                          curve = new List<Point3D>();                          curveCount = 0;                      }                        if (segmentCount > 0)                      {                          curve.Add(segments[0]);                          curve.Add(segments[1]);                          curveCount += 2;                          segments.RemoveAt(0);                          segments.RemoveAt(0);                          segmentCount -= 2;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0)              {                  if (curveCount > 0)                  {                      // Find a segment that is connected to the head of the contour                      segment1 = FindConnectedSegment(segments' curve[0]' eps);                      if (segment1 >= 0)                      {                          if (segment1 % 2 == 1)                          {                              curve.Insert(0' segments[segment1 - 1]);                              segments.RemoveAt(segment1 - 1);                              segments.RemoveAt(segment1 - 1);                          }                          else                          {                              curve.Insert(0' segments[segment1 + 1]);                              segments.RemoveAt(segment1);                              segments.RemoveAt(segment1);                          }                            curveCount++;                          segmentCount -= 2;                      }                        // Find a segment that is connected to the tail of the contour                      segment2 = FindConnectedSegment(segments' curve[curveCount - 1]' eps);                      if (segment2 >= 0)                      {                          if (segment2 % 2 == 1)                          {                              curve.Add(segments[segment2 - 1]);                              segments.RemoveAt(segment2 - 1);                              segments.RemoveAt(segment2 - 1);                          }                          else                          {                              curve.Add(segments[segment2 + 1]);                              segments.RemoveAt(segment2);                              segments.RemoveAt(segment2);                          }                            curveCount++;                          segmentCount -= 2;                      }                  }                    if ((segment1 < 0 && segment2 < 0) || segmentCount == 0)                  {                      if (curveCount > 0)                      {                          yield return curve;                          curve = new List<Point3D>();                          curveCount = 0;                      }                        if (segmentCount > 0)                      {                          curve.Add(segments[0]);                          curve.Add(segments[1]);                          curveCount += 2;                          segments.RemoveAt(0);                          segments.RemoveAt(0);                          segmentCount -= 2;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0)              {                  if (curveCount > 0)                  {                      // Find a segment that is connected to the head of the contour                      segment1 = FindConnectedSegment(segments' curve[0]' eps);                      if (segment1 >= 0)                      {                          if (segment1 % 2 == 1)                          {                              curve.Insert(0' segments[segment1 - 1]);                              segments.RemoveAt(segment1 - 1);                              segments.RemoveAt(segment1 - 1);                          }                          else                          {                              curve.Insert(0' segments[segment1 + 1]);                              segments.RemoveAt(segment1);                              segments.RemoveAt(segment1);                          }                            curveCount++;                          segmentCount -= 2;                      }                        // Find a segment that is connected to the tail of the contour                      segment2 = FindConnectedSegment(segments' curve[curveCount - 1]' eps);                      if (segment2 >= 0)                      {                          if (segment2 % 2 == 1)                          {                              curve.Add(segments[segment2 - 1]);                              segments.RemoveAt(segment2 - 1);                              segments.RemoveAt(segment2 - 1);                          }                          else                          {                              curve.Add(segments[segment2 + 1]);                              segments.RemoveAt(segment2);                              segments.RemoveAt(segment2);                          }                            curveCount++;                          segmentCount -= 2;                      }                  }                    if ((segment1 < 0 && segment2 < 0) || segmentCount == 0)                  {                      if (curveCount > 0)                      {                          yield return curve;                          curve = new List<Point3D>();                          curveCount = 0;                      }                        if (segmentCount > 0)                      {                          curve.Add(segments[0]);                          curve.Add(segments[1]);                          curveCount += 2;                          segments.RemoveAt(0);                          segments.RemoveAt(0);                          segmentCount -= 2;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0)              {                  if (curveCount > 0)                  {                      // Find a segment that is connected to the head of the contour                      segment1 = FindConnectedSegment(segments' curve[0]' eps);                      if (segment1 >= 0)                      {                          if (segment1 % 2 == 1)                          {                              curve.Insert(0' segments[segment1 - 1]);                              segments.RemoveAt(segment1 - 1);                              segments.RemoveAt(segment1 - 1);                          }                          else                          {                              curve.Insert(0' segments[segment1 + 1]);                              segments.RemoveAt(segment1);                              segments.RemoveAt(segment1);                          }                            curveCount++;                          segmentCount -= 2;                      }                        // Find a segment that is connected to the tail of the contour                      segment2 = FindConnectedSegment(segments' curve[curveCount - 1]' eps);                      if (segment2 >= 0)                      {                          if (segment2 % 2 == 1)                          {                              curve.Add(segments[segment2 - 1]);                              segments.RemoveAt(segment2 - 1);                              segments.RemoveAt(segment2 - 1);                          }                          else                          {                              curve.Add(segments[segment2 + 1]);                              segments.RemoveAt(segment2);                              segments.RemoveAt(segment2);                          }                            curveCount++;                          segmentCount -= 2;                      }                  }                    if ((segment1 < 0 && segment2 < 0) || segmentCount == 0)                  {                      if (curveCount > 0)                      {                          yield return curve;                          curve = new List<Point3D>();                          curveCount = 0;                      }                        if (segmentCount > 0)                      {                          curve.Add(segments[0]);                          curve.Add(segments[1]);                          curveCount += 2;                          segments.RemoveAt(0);                          segments.RemoveAt(0);                          segmentCount -= 2;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0)              {                  if (curveCount > 0)                  {                      // Find a segment that is connected to the head of the contour                      segment1 = FindConnectedSegment(segments' curve[0]' eps);                      if (segment1 >= 0)                      {                          if (segment1 % 2 == 1)                          {                              curve.Insert(0' segments[segment1 - 1]);                              segments.RemoveAt(segment1 - 1);                              segments.RemoveAt(segment1 - 1);                          }                          else                          {                              curve.Insert(0' segments[segment1 + 1]);                              segments.RemoveAt(segment1);                              segments.RemoveAt(segment1);                          }                            curveCount++;                          segmentCount -= 2;                      }                        // Find a segment that is connected to the tail of the contour                      segment2 = FindConnectedSegment(segments' curve[curveCount - 1]' eps);                      if (segment2 >= 0)                      {                          if (segment2 % 2 == 1)                          {                              curve.Add(segments[segment2 - 1]);                              segments.RemoveAt(segment2 - 1);                              segments.RemoveAt(segment2 - 1);                          }                          else                          {                              curve.Add(segments[segment2 + 1]);                              segments.RemoveAt(segment2);                              segments.RemoveAt(segment2);                          }                            curveCount++;                          segmentCount -= 2;                      }                  }                    if ((segment1 < 0 && segment2 < 0) || segmentCount == 0)                  {                      if (curveCount > 0)                      {                          yield return curve;                          curve = new List<Point3D>();                          curveCount = 0;                      }                        if (segmentCount > 0)                      {                          curve.Add(segments[0]);                          curve.Add(segments[1]);                          curveCount += 2;                          segments.RemoveAt(0);                          segments.RemoveAt(0);                          segmentCount -= 2;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0)              {                  if (curveCount > 0)                  {                      // Find a segment that is connected to the head of the contour                      segment1 = FindConnectedSegment(segments' curve[0]' eps);                      if (segment1 >= 0)                      {                          if (segment1 % 2 == 1)                          {                              curve.Insert(0' segments[segment1 - 1]);                              segments.RemoveAt(segment1 - 1);                              segments.RemoveAt(segment1 - 1);                          }                          else                          {                              curve.Insert(0' segments[segment1 + 1]);                              segments.RemoveAt(segment1);                              segments.RemoveAt(segment1);                          }                            curveCount++;                          segmentCount -= 2;                      }                        // Find a segment that is connected to the tail of the contour                      segment2 = FindConnectedSegment(segments' curve[curveCount - 1]' eps);                      if (segment2 >= 0)                      {                          if (segment2 % 2 == 1)                          {                              curve.Add(segments[segment2 - 1]);                              segments.RemoveAt(segment2 - 1);                              segments.RemoveAt(segment2 - 1);                          }                          else                          {                              curve.Add(segments[segment2 + 1]);                              segments.RemoveAt(segment2);                              segments.RemoveAt(segment2);                          }                            curveCount++;                          segmentCount -= 2;                      }                  }                    if ((segment1 < 0 && segment2 < 0) || segmentCount == 0)                  {                      if (curveCount > 0)                      {                          yield return curve;                          curve = new List<Point3D>();                          curveCount = 0;                      }                        if (segmentCount > 0)                      {                          curve.Add(segments[0]);                          curve.Add(segments[1]);                          curveCount += 2;                          segments.RemoveAt(0);                          segments.RemoveAt(0);                          segmentCount -= 2;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CreateKey,The following statement contains a magic number: return ((ulong)i0 << 32) + i1;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i0 = (uint)(key >> 32);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i1 = (uint)((key << 32) >> 32);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i1 = (uint)((key << 32) >> 32);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,MeshSimplification,The following statement contains a magic number: triangles = new List<Triangle>(Enumerable.Range(0' model.TriangleIndices.Count / 3).Select(x=>new Triangle()));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,MeshSimplification,The following statement contains a magic number: foreach(var tri in triangles)              {                  tri.v[0] = model.TriangleIndices[i++];                  tri.v[1] = model.TriangleIndices[i++];                  tri.v[2] = model.TriangleIndices[i++];              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: return Simplify(int.MaxValue' 7' verbose' true);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: int maxIteration = 9999;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: if (!lossless)              {                  maxIteration = 100;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: for (int iteration = 0; iteration < maxIteration; ++iteration)              {                  if (!lossless && triCount - deletedTris <= targetCount)                  {                      break;                  }                  if (lossless || iteration % 5 == 0)                  {                      UpdateMesh(iteration);                  }                    foreach (var tri in triangles)                  {                      tri.dirty = false;                  }                  //                  // All triangles with edges below the threshold will be removed                  //                  // The following numbers works well for most models.                  // If it does not' try to adjust the 3 parameters                  //                  double threshold = 0.001;                  if(!lossless)                      threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);                  if (verbose)                  {                      Debug.WriteLine($"Iteration: {iteration}; Triangles: {triCount - deletedTris}; Threshold: {threshold};");                  }                    foreach (var tri in triangles)                  {                      if (tri.err[3] > threshold || tri.deleted || tri.dirty) { continue; }                        for (int j = 0; j < 3; ++j)                      {                          if (tri.err[j] < threshold)                          {                              int i0 = tri.v[j];                              var v0 = vertices[i0];                              int i1 = tri.v[(j + 1) % 3];                              var v1 = vertices[i1];                              //border check                              if (v0.border != v1.border)                              {                                  continue;                              }                              //Compute vertex to collapse to                              Vector3D p;                              CalculateError(i0' i1' out p);                              deleted0.Clear();                              deleted1.Clear();                              deleted0.AddRange(Enumerable.Repeat(false' v0.tCount));                              deleted1.AddRange(Enumerable.Repeat(false' v1.tCount));                                if (Flipped(ref p' i0' i1' ref v0' ref v1' deleted0)                                  || Flipped(ref p' i1' i0' ref v1' ref v0' deleted1))                              { continue; }                              v0.p = p;                              v0.q = v1.q + v0.q;                                int tStart = refs.Count;                              UpdateTriangles(i0' ref v0' deleted0' ref deletedTris);                              UpdateTriangles(i0' ref v1' deleted1' ref deletedTris);                                int tcount = refs.Count - tStart;                              if (tcount <= v0.tCount)                              {                                  if (tcount > 0)                                  {                                      for (int k = 0; k < tcount; ++k)                                      {                                          refs[v0.tStart + k] = refs[tStart + k];                                      }                                  }                              }                              else                              {                                  v0.tStart = tStart;                              }                                v0.tCount = tcount;                              break;                          }                        }                      if (!lossless && triCount - deletedTris <= targetCount)                      {                          break;                      }                  }                  if (lossless)                  {                      if (deletedTris <= 0)                      {                          break;                      }                      deletedTris = 0;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: for (int iteration = 0; iteration < maxIteration; ++iteration)              {                  if (!lossless && triCount - deletedTris <= targetCount)                  {                      break;                  }                  if (lossless || iteration % 5 == 0)                  {                      UpdateMesh(iteration);                  }                    foreach (var tri in triangles)                  {                      tri.dirty = false;                  }                  //                  // All triangles with edges below the threshold will be removed                  //                  // The following numbers works well for most models.                  // If it does not' try to adjust the 3 parameters                  //                  double threshold = 0.001;                  if(!lossless)                      threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);                  if (verbose)                  {                      Debug.WriteLine($"Iteration: {iteration}; Triangles: {triCount - deletedTris}; Threshold: {threshold};");                  }                    foreach (var tri in triangles)                  {                      if (tri.err[3] > threshold || tri.deleted || tri.dirty) { continue; }                        for (int j = 0; j < 3; ++j)                      {                          if (tri.err[j] < threshold)                          {                              int i0 = tri.v[j];                              var v0 = vertices[i0];                              int i1 = tri.v[(j + 1) % 3];                              var v1 = vertices[i1];                              //border check                              if (v0.border != v1.border)                              {                                  continue;                              }                              //Compute vertex to collapse to                              Vector3D p;                              CalculateError(i0' i1' out p);                              deleted0.Clear();                              deleted1.Clear();                              deleted0.AddRange(Enumerable.Repeat(false' v0.tCount));                              deleted1.AddRange(Enumerable.Repeat(false' v1.tCount));                                if (Flipped(ref p' i0' i1' ref v0' ref v1' deleted0)                                  || Flipped(ref p' i1' i0' ref v1' ref v0' deleted1))                              { continue; }                              v0.p = p;                              v0.q = v1.q + v0.q;                                int tStart = refs.Count;                              UpdateTriangles(i0' ref v0' deleted0' ref deletedTris);                              UpdateTriangles(i0' ref v1' deleted1' ref deletedTris);                                int tcount = refs.Count - tStart;                              if (tcount <= v0.tCount)                              {                                  if (tcount > 0)                                  {                                      for (int k = 0; k < tcount; ++k)                                      {                                          refs[v0.tStart + k] = refs[tStart + k];                                      }                                  }                              }                              else                              {                                  v0.tStart = tStart;                              }                                v0.tCount = tcount;                              break;                          }                        }                      if (!lossless && triCount - deletedTris <= targetCount)                      {                          break;                      }                  }                  if (lossless)                  {                      if (deletedTris <= 0)                      {                          break;                      }                      deletedTris = 0;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: for (int iteration = 0; iteration < maxIteration; ++iteration)              {                  if (!lossless && triCount - deletedTris <= targetCount)                  {                      break;                  }                  if (lossless || iteration % 5 == 0)                  {                      UpdateMesh(iteration);                  }                    foreach (var tri in triangles)                  {                      tri.dirty = false;                  }                  //                  // All triangles with edges below the threshold will be removed                  //                  // The following numbers works well for most models.                  // If it does not' try to adjust the 3 parameters                  //                  double threshold = 0.001;                  if(!lossless)                      threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);                  if (verbose)                  {                      Debug.WriteLine($"Iteration: {iteration}; Triangles: {triCount - deletedTris}; Threshold: {threshold};");                  }                    foreach (var tri in triangles)                  {                      if (tri.err[3] > threshold || tri.deleted || tri.dirty) { continue; }                        for (int j = 0; j < 3; ++j)                      {                          if (tri.err[j] < threshold)                          {                              int i0 = tri.v[j];                              var v0 = vertices[i0];                              int i1 = tri.v[(j + 1) % 3];                              var v1 = vertices[i1];                              //border check                              if (v0.border != v1.border)                              {                                  continue;                              }                              //Compute vertex to collapse to                              Vector3D p;                              CalculateError(i0' i1' out p);                              deleted0.Clear();                              deleted1.Clear();                              deleted0.AddRange(Enumerable.Repeat(false' v0.tCount));                              deleted1.AddRange(Enumerable.Repeat(false' v1.tCount));                                if (Flipped(ref p' i0' i1' ref v0' ref v1' deleted0)                                  || Flipped(ref p' i1' i0' ref v1' ref v0' deleted1))                              { continue; }                              v0.p = p;                              v0.q = v1.q + v0.q;                                int tStart = refs.Count;                              UpdateTriangles(i0' ref v0' deleted0' ref deletedTris);                              UpdateTriangles(i0' ref v1' deleted1' ref deletedTris);                                int tcount = refs.Count - tStart;                              if (tcount <= v0.tCount)                              {                                  if (tcount > 0)                                  {                                      for (int k = 0; k < tcount; ++k)                                      {                                          refs[v0.tStart + k] = refs[tStart + k];                                      }                                  }                              }                              else                              {                                  v0.tStart = tStart;                              }                                v0.tCount = tcount;                              break;                          }                        }                      if (!lossless && triCount - deletedTris <= targetCount)                      {                          break;                      }                  }                  if (lossless)                  {                      if (deletedTris <= 0)                      {                          break;                      }                      deletedTris = 0;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: for (int iteration = 0; iteration < maxIteration; ++iteration)              {                  if (!lossless && triCount - deletedTris <= targetCount)                  {                      break;                  }                  if (lossless || iteration % 5 == 0)                  {                      UpdateMesh(iteration);                  }                    foreach (var tri in triangles)                  {                      tri.dirty = false;                  }                  //                  // All triangles with edges below the threshold will be removed                  //                  // The following numbers works well for most models.                  // If it does not' try to adjust the 3 parameters                  //                  double threshold = 0.001;                  if(!lossless)                      threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);                  if (verbose)                  {                      Debug.WriteLine($"Iteration: {iteration}; Triangles: {triCount - deletedTris}; Threshold: {threshold};");                  }                    foreach (var tri in triangles)                  {                      if (tri.err[3] > threshold || tri.deleted || tri.dirty) { continue; }                        for (int j = 0; j < 3; ++j)                      {                          if (tri.err[j] < threshold)                          {                              int i0 = tri.v[j];                              var v0 = vertices[i0];                              int i1 = tri.v[(j + 1) % 3];                              var v1 = vertices[i1];                              //border check                              if (v0.border != v1.border)                              {                                  continue;                              }                              //Compute vertex to collapse to                              Vector3D p;                              CalculateError(i0' i1' out p);                              deleted0.Clear();                              deleted1.Clear();                              deleted0.AddRange(Enumerable.Repeat(false' v0.tCount));                              deleted1.AddRange(Enumerable.Repeat(false' v1.tCount));                                if (Flipped(ref p' i0' i1' ref v0' ref v1' deleted0)                                  || Flipped(ref p' i1' i0' ref v1' ref v0' deleted1))                              { continue; }                              v0.p = p;                              v0.q = v1.q + v0.q;                                int tStart = refs.Count;                              UpdateTriangles(i0' ref v0' deleted0' ref deletedTris);                              UpdateTriangles(i0' ref v1' deleted1' ref deletedTris);                                int tcount = refs.Count - tStart;                              if (tcount <= v0.tCount)                              {                                  if (tcount > 0)                                  {                                      for (int k = 0; k < tcount; ++k)                                      {                                          refs[v0.tStart + k] = refs[tStart + k];                                      }                                  }                              }                              else                              {                                  v0.tStart = tStart;                              }                                v0.tCount = tcount;                              break;                          }                        }                      if (!lossless && triCount - deletedTris <= targetCount)                      {                          break;                      }                  }                  if (lossless)                  {                      if (deletedTris <= 0)                      {                          break;                      }                      deletedTris = 0;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: for (int iteration = 0; iteration < maxIteration; ++iteration)              {                  if (!lossless && triCount - deletedTris <= targetCount)                  {                      break;                  }                  if (lossless || iteration % 5 == 0)                  {                      UpdateMesh(iteration);                  }                    foreach (var tri in triangles)                  {                      tri.dirty = false;                  }                  //                  // All triangles with edges below the threshold will be removed                  //                  // The following numbers works well for most models.                  // If it does not' try to adjust the 3 parameters                  //                  double threshold = 0.001;                  if(!lossless)                      threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);                  if (verbose)                  {                      Debug.WriteLine($"Iteration: {iteration}; Triangles: {triCount - deletedTris}; Threshold: {threshold};");                  }                    foreach (var tri in triangles)                  {                      if (tri.err[3] > threshold || tri.deleted || tri.dirty) { continue; }                        for (int j = 0; j < 3; ++j)                      {                          if (tri.err[j] < threshold)                          {                              int i0 = tri.v[j];                              var v0 = vertices[i0];                              int i1 = tri.v[(j + 1) % 3];                              var v1 = vertices[i1];                              //border check                              if (v0.border != v1.border)                              {                                  continue;                              }                              //Compute vertex to collapse to                              Vector3D p;                              CalculateError(i0' i1' out p);                              deleted0.Clear();                              deleted1.Clear();                              deleted0.AddRange(Enumerable.Repeat(false' v0.tCount));                              deleted1.AddRange(Enumerable.Repeat(false' v1.tCount));                                if (Flipped(ref p' i0' i1' ref v0' ref v1' deleted0)                                  || Flipped(ref p' i1' i0' ref v1' ref v0' deleted1))                              { continue; }                              v0.p = p;                              v0.q = v1.q + v0.q;                                int tStart = refs.Count;                              UpdateTriangles(i0' ref v0' deleted0' ref deletedTris);                              UpdateTriangles(i0' ref v1' deleted1' ref deletedTris);                                int tcount = refs.Count - tStart;                              if (tcount <= v0.tCount)                              {                                  if (tcount > 0)                                  {                                      for (int k = 0; k < tcount; ++k)                                      {                                          refs[v0.tStart + k] = refs[tStart + k];                                      }                                  }                              }                              else                              {                                  v0.tStart = tStart;                              }                                v0.tCount = tcount;                              break;                          }                        }                      if (!lossless && triCount - deletedTris <= targetCount)                      {                          break;                      }                  }                  if (lossless)                  {                      if (deletedTris <= 0)                      {                          break;                      }                      deletedTris = 0;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: for (int iteration = 0; iteration < maxIteration; ++iteration)              {                  if (!lossless && triCount - deletedTris <= targetCount)                  {                      break;                  }                  if (lossless || iteration % 5 == 0)                  {                      UpdateMesh(iteration);                  }                    foreach (var tri in triangles)                  {                      tri.dirty = false;                  }                  //                  // All triangles with edges below the threshold will be removed                  //                  // The following numbers works well for most models.                  // If it does not' try to adjust the 3 parameters                  //                  double threshold = 0.001;                  if(!lossless)                      threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);                  if (verbose)                  {                      Debug.WriteLine($"Iteration: {iteration}; Triangles: {triCount - deletedTris}; Threshold: {threshold};");                  }                    foreach (var tri in triangles)                  {                      if (tri.err[3] > threshold || tri.deleted || tri.dirty) { continue; }                        for (int j = 0; j < 3; ++j)                      {                          if (tri.err[j] < threshold)                          {                              int i0 = tri.v[j];                              var v0 = vertices[i0];                              int i1 = tri.v[(j + 1) % 3];                              var v1 = vertices[i1];                              //border check                              if (v0.border != v1.border)                              {                                  continue;                              }                              //Compute vertex to collapse to                              Vector3D p;                              CalculateError(i0' i1' out p);                              deleted0.Clear();                              deleted1.Clear();                              deleted0.AddRange(Enumerable.Repeat(false' v0.tCount));                              deleted1.AddRange(Enumerable.Repeat(false' v1.tCount));                                if (Flipped(ref p' i0' i1' ref v0' ref v1' deleted0)                                  || Flipped(ref p' i1' i0' ref v1' ref v0' deleted1))                              { continue; }                              v0.p = p;                              v0.q = v1.q + v0.q;                                int tStart = refs.Count;                              UpdateTriangles(i0' ref v0' deleted0' ref deletedTris);                              UpdateTriangles(i0' ref v1' deleted1' ref deletedTris);                                int tcount = refs.Count - tStart;                              if (tcount <= v0.tCount)                              {                                  if (tcount > 0)                                  {                                      for (int k = 0; k < tcount; ++k)                                      {                                          refs[v0.tStart + k] = refs[tStart + k];                                      }                                  }                              }                              else                              {                                  v0.tStart = tStart;                              }                                v0.tCount = tcount;                              break;                          }                        }                      if (!lossless && triCount - deletedTris <= targetCount)                      {                          break;                      }                  }                  if (lossless)                  {                      if (deletedTris <= 0)                      {                          break;                      }                      deletedTris = 0;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: for (int iteration = 0; iteration < maxIteration; ++iteration)              {                  if (!lossless && triCount - deletedTris <= targetCount)                  {                      break;                  }                  if (lossless || iteration % 5 == 0)                  {                      UpdateMesh(iteration);                  }                    foreach (var tri in triangles)                  {                      tri.dirty = false;                  }                  //                  // All triangles with edges below the threshold will be removed                  //                  // The following numbers works well for most models.                  // If it does not' try to adjust the 3 parameters                  //                  double threshold = 0.001;                  if(!lossless)                      threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);                  if (verbose)                  {                      Debug.WriteLine($"Iteration: {iteration}; Triangles: {triCount - deletedTris}; Threshold: {threshold};");                  }                    foreach (var tri in triangles)                  {                      if (tri.err[3] > threshold || tri.deleted || tri.dirty) { continue; }                        for (int j = 0; j < 3; ++j)                      {                          if (tri.err[j] < threshold)                          {                              int i0 = tri.v[j];                              var v0 = vertices[i0];                              int i1 = tri.v[(j + 1) % 3];                              var v1 = vertices[i1];                              //border check                              if (v0.border != v1.border)                              {                                  continue;                              }                              //Compute vertex to collapse to                              Vector3D p;                              CalculateError(i0' i1' out p);                              deleted0.Clear();                              deleted1.Clear();                              deleted0.AddRange(Enumerable.Repeat(false' v0.tCount));                              deleted1.AddRange(Enumerable.Repeat(false' v1.tCount));                                if (Flipped(ref p' i0' i1' ref v0' ref v1' deleted0)                                  || Flipped(ref p' i1' i0' ref v1' ref v0' deleted1))                              { continue; }                              v0.p = p;                              v0.q = v1.q + v0.q;                                int tStart = refs.Count;                              UpdateTriangles(i0' ref v0' deleted0' ref deletedTris);                              UpdateTriangles(i0' ref v1' deleted1' ref deletedTris);                                int tcount = refs.Count - tStart;                              if (tcount <= v0.tCount)                              {                                  if (tcount > 0)                                  {                                      for (int k = 0; k < tcount; ++k)                                      {                                          refs[v0.tStart + k] = refs[tStart + k];                                      }                                  }                              }                              else                              {                                  v0.tStart = tStart;                              }                                v0.tCount = tcount;                              break;                          }                        }                      if (!lossless && triCount - deletedTris <= targetCount)                      {                          break;                      }                  }                  if (lossless)                  {                      if (deletedTris <= 0)                      {                          break;                      }                      deletedTris = 0;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,GetMesh,The following statement contains a magic number: var tris = new Int32Collection(triangles.Count*3);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,GetMesh,The following statement contains a magic number: foreach (var tri in triangles)              {                  tris.Add(tri.v[0]);                  tris.Add(tri.v[1]);                  tris.Add(tri.v[2]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: for (int i = 0; i < v0.tCount; ++i)              {                  var t = triangles[refs[v0.tStart + i].tid];                  if (t.deleted) { continue; }                  int s = refs[v0.tStart + i].tvertex;                  int id1 = t.v[(s + 1) % 3];                  int id2 = t.v[(s + 2) % 3];                  if (id1 == i1 || id2 == i1)                  {                      deleted[i] = true;                      continue;                  }                    Vector3D d1 = vertices[id1].p - p;                  d1.Normalize();                  Vector3D d2 = vertices[id2].p - p;                  d2.Normalize();                  if (SharedFunctions.DotProduct(ref d1' ref d2) > 0.999)                  {                      return true;                  }                  var n = SharedFunctions.CrossProduct(ref d1' ref d2);                  n.Normalize();                  deleted[i] = false;                  if (SharedFunctions.DotProduct(ref n' ref t.normal) < 0.2)                  {                      return true;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: for (int i = 0; i < v0.tCount; ++i)              {                  var t = triangles[refs[v0.tStart + i].tid];                  if (t.deleted) { continue; }                  int s = refs[v0.tStart + i].tvertex;                  int id1 = t.v[(s + 1) % 3];                  int id2 = t.v[(s + 2) % 3];                  if (id1 == i1 || id2 == i1)                  {                      deleted[i] = true;                      continue;                  }                    Vector3D d1 = vertices[id1].p - p;                  d1.Normalize();                  Vector3D d2 = vertices[id2].p - p;                  d2.Normalize();                  if (SharedFunctions.DotProduct(ref d1' ref d2) > 0.999)                  {                      return true;                  }                  var n = SharedFunctions.CrossProduct(ref d1' ref d2);                  n.Normalize();                  deleted[i] = false;                  if (SharedFunctions.DotProduct(ref n' ref t.normal) < 0.2)                  {                      return true;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: for (int i = 0; i < v0.tCount; ++i)              {                  var t = triangles[refs[v0.tStart + i].tid];                  if (t.deleted) { continue; }                  int s = refs[v0.tStart + i].tvertex;                  int id1 = t.v[(s + 1) % 3];                  int id2 = t.v[(s + 2) % 3];                  if (id1 == i1 || id2 == i1)                  {                      deleted[i] = true;                      continue;                  }                    Vector3D d1 = vertices[id1].p - p;                  d1.Normalize();                  Vector3D d2 = vertices[id2].p - p;                  d2.Normalize();                  if (SharedFunctions.DotProduct(ref d1' ref d2) > 0.999)                  {                      return true;                  }                  var n = SharedFunctions.CrossProduct(ref d1' ref d2);                  n.Normalize();                  deleted[i] = false;                  if (SharedFunctions.DotProduct(ref n' ref t.normal) < 0.2)                  {                      return true;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: for (int i = 0; i < v0.tCount; ++i)              {                  var t = triangles[refs[v0.tStart + i].tid];                  if (t.deleted) { continue; }                  int s = refs[v0.tStart + i].tvertex;                  int id1 = t.v[(s + 1) % 3];                  int id2 = t.v[(s + 2) % 3];                  if (id1 == i1 || id2 == i1)                  {                      deleted[i] = true;                      continue;                  }                    Vector3D d1 = vertices[id1].p - p;                  d1.Normalize();                  Vector3D d2 = vertices[id2].p - p;                  d2.Normalize();                  if (SharedFunctions.DotProduct(ref d1' ref d2) > 0.999)                  {                      return true;                  }                  var n = SharedFunctions.CrossProduct(ref d1' ref d2);                  n.Normalize();                  deleted[i] = false;                  if (SharedFunctions.DotProduct(ref n' ref t.normal) < 0.2)                  {                      return true;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: for (int i = 0; i < v0.tCount; ++i)              {                  var t = triangles[refs[v0.tStart + i].tid];                  if (t.deleted) { continue; }                  int s = refs[v0.tStart + i].tvertex;                  int id1 = t.v[(s + 1) % 3];                  int id2 = t.v[(s + 2) % 3];                  if (id1 == i1 || id2 == i1)                  {                      deleted[i] = true;                      continue;                  }                    Vector3D d1 = vertices[id1].p - p;                  d1.Normalize();                  Vector3D d2 = vertices[id2].p - p;                  d2.Normalize();                  if (SharedFunctions.DotProduct(ref d1' ref d2) > 0.999)                  {                      return true;                  }                  var n = SharedFunctions.CrossProduct(ref d1' ref d2);                  n.Normalize();                  deleted[i] = false;                  if (SharedFunctions.DotProduct(ref n' ref t.normal) < 0.2)                  {                      return true;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: for (int i = 0; i < v.tCount; ++i)              {                  var r = refs[v.tStart + i];                  var t = triangles[r.tid];                  if (t.deleted) { continue; }                  if (deleted[i])                  {                      t.deleted = true;                      deletedTriangles++;                      continue;                  }                    t.v[r.tvertex] = i0;                  t.dirty = true;                  t.err[0] = CalculateError(t.v[0]' t.v[1]' out p);                  t.err[1] = CalculateError(t.v[1]' t.v[2]' out p);                  t.err[2] = CalculateError(t.v[2]' t.v[0]' out p);                  t.err[3] = Math.Min(t.err[0]' Math.Min(t.err[1]' t.err[2]));                  refs.Add(r);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: for (int i = 0; i < v.tCount; ++i)              {                  var r = refs[v.tStart + i];                  var t = triangles[r.tid];                  if (t.deleted) { continue; }                  if (deleted[i])                  {                      t.deleted = true;                      deletedTriangles++;                      continue;                  }                    t.v[r.tvertex] = i0;                  t.dirty = true;                  t.err[0] = CalculateError(t.v[0]' t.v[1]' out p);                  t.err[1] = CalculateError(t.v[1]' t.v[2]' out p);                  t.err[2] = CalculateError(t.v[2]' t.v[0]' out p);                  t.err[3] = Math.Min(t.err[0]' Math.Min(t.err[1]' t.err[2]));                  refs.Add(r);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: for (int i = 0; i < v.tCount; ++i)              {                  var r = refs[v.tStart + i];                  var t = triangles[r.tid];                  if (t.deleted) { continue; }                  if (deleted[i])                  {                      t.deleted = true;                      deletedTriangles++;                      continue;                  }                    t.v[r.tvertex] = i0;                  t.dirty = true;                  t.err[0] = CalculateError(t.v[0]' t.v[1]' out p);                  t.err[1] = CalculateError(t.v[1]' t.v[2]' out p);                  t.err[2] = CalculateError(t.v[2]' t.v[0]' out p);                  t.err[3] = Math.Min(t.err[0]' Math.Min(t.err[1]' t.err[2]));                  refs.Add(r);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: for (int i = 0; i < v.tCount; ++i)              {                  var r = refs[v.tStart + i];                  var t = triangles[r.tid];                  if (t.deleted) { continue; }                  if (deleted[i])                  {                      t.deleted = true;                      deletedTriangles++;                      continue;                  }                    t.v[r.tvertex] = i0;                  t.dirty = true;                  t.err[0] = CalculateError(t.v[0]' t.v[1]' out p);                  t.err[1] = CalculateError(t.v[1]' t.v[2]' out p);                  t.err[2] = CalculateError(t.v[2]' t.v[0]' out p);                  t.err[3] = Math.Min(t.err[0]' Math.Min(t.err[1]' t.err[2]));                  refs.Add(r);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: for (int i = 0; i < v.tCount; ++i)              {                  var r = refs[v.tStart + i];                  var t = triangles[r.tid];                  if (t.deleted) { continue; }                  if (deleted[i])                  {                      t.deleted = true;                      deletedTriangles++;                      continue;                  }                    t.v[r.tvertex] = i0;                  t.dirty = true;                  t.err[0] = CalculateError(t.v[0]' t.v[1]' out p);                  t.err[1] = CalculateError(t.v[1]' t.v[2]' out p);                  t.err[2] = CalculateError(t.v[2]' t.v[0]' out p);                  t.err[3] = Math.Min(t.err[0]' Math.Min(t.err[1]' t.err[2]));                  refs.Add(r);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: if (iteration == 0)              {                  foreach (var vert in vertices)                  {                      vert.q.SetAll(0);                  }                    foreach (var tri in triangles)                  {                      var p0 = vertices[tri.v[0]].p;                      var p1 = vertices[tri.v[1]].p;                      var p2 = vertices[tri.v[2]].p;                      var n = SharedFunctions.CrossProduct(p1 - p0' p2 - p0);                      n.Normalize();                      tri.normal = n;                      for (int j = 0; j < 3; ++j)                      {                          vertices[tri.v[j]].q += new SymmetricMatrix(n.X' n.Y' n.Z' -SharedFunctions.DotProduct(ref n' ref p0));                      }                  }                  Vector3D p;                  foreach (var tri in triangles)                  {                      for (int i = 0; i < 3; ++i)                      {                                                 tri.err[i] = CalculateError(tri.v[i]' tri.v[(i + 1) % 3]' out p);                      }                      tri.err[3] = Math.Min(tri.err[0]' Math.Min(tri.err[1]' tri.err[2]));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: if (iteration == 0)              {                  foreach (var vert in vertices)                  {                      vert.q.SetAll(0);                  }                    foreach (var tri in triangles)                  {                      var p0 = vertices[tri.v[0]].p;                      var p1 = vertices[tri.v[1]].p;                      var p2 = vertices[tri.v[2]].p;                      var n = SharedFunctions.CrossProduct(p1 - p0' p2 - p0);                      n.Normalize();                      tri.normal = n;                      for (int j = 0; j < 3; ++j)                      {                          vertices[tri.v[j]].q += new SymmetricMatrix(n.X' n.Y' n.Z' -SharedFunctions.DotProduct(ref n' ref p0));                      }                  }                  Vector3D p;                  foreach (var tri in triangles)                  {                      for (int i = 0; i < 3; ++i)                      {                                                 tri.err[i] = CalculateError(tri.v[i]' tri.v[(i + 1) % 3]' out p);                      }                      tri.err[3] = Math.Min(tri.err[0]' Math.Min(tri.err[1]' tri.err[2]));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: if (iteration == 0)              {                  foreach (var vert in vertices)                  {                      vert.q.SetAll(0);                  }                    foreach (var tri in triangles)                  {                      var p0 = vertices[tri.v[0]].p;                      var p1 = vertices[tri.v[1]].p;                      var p2 = vertices[tri.v[2]].p;                      var n = SharedFunctions.CrossProduct(p1 - p0' p2 - p0);                      n.Normalize();                      tri.normal = n;                      for (int j = 0; j < 3; ++j)                      {                          vertices[tri.v[j]].q += new SymmetricMatrix(n.X' n.Y' n.Z' -SharedFunctions.DotProduct(ref n' ref p0));                      }                  }                  Vector3D p;                  foreach (var tri in triangles)                  {                      for (int i = 0; i < 3; ++i)                      {                                                 tri.err[i] = CalculateError(tri.v[i]' tri.v[(i + 1) % 3]' out p);                      }                      tri.err[3] = Math.Min(tri.err[0]' Math.Min(tri.err[1]' tri.err[2]));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: if (iteration == 0)              {                  foreach (var vert in vertices)                  {                      vert.q.SetAll(0);                  }                    foreach (var tri in triangles)                  {                      var p0 = vertices[tri.v[0]].p;                      var p1 = vertices[tri.v[1]].p;                      var p2 = vertices[tri.v[2]].p;                      var n = SharedFunctions.CrossProduct(p1 - p0' p2 - p0);                      n.Normalize();                      tri.normal = n;                      for (int j = 0; j < 3; ++j)                      {                          vertices[tri.v[j]].q += new SymmetricMatrix(n.X' n.Y' n.Z' -SharedFunctions.DotProduct(ref n' ref p0));                      }                  }                  Vector3D p;                  foreach (var tri in triangles)                  {                      for (int i = 0; i < 3; ++i)                      {                                                 tri.err[i] = CalculateError(tri.v[i]' tri.v[(i + 1) % 3]' out p);                      }                      tri.err[3] = Math.Min(tri.err[0]' Math.Min(tri.err[1]' tri.err[2]));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: if (iteration == 0)              {                  foreach (var vert in vertices)                  {                      vert.q.SetAll(0);                  }                    foreach (var tri in triangles)                  {                      var p0 = vertices[tri.v[0]].p;                      var p1 = vertices[tri.v[1]].p;                      var p2 = vertices[tri.v[2]].p;                      var n = SharedFunctions.CrossProduct(p1 - p0' p2 - p0);                      n.Normalize();                      tri.normal = n;                      for (int j = 0; j < 3; ++j)                      {                          vertices[tri.v[j]].q += new SymmetricMatrix(n.X' n.Y' n.Z' -SharedFunctions.DotProduct(ref n' ref p0));                      }                  }                  Vector3D p;                  foreach (var tri in triangles)                  {                      for (int i = 0; i < 3; ++i)                      {                                                 tri.err[i] = CalculateError(tri.v[i]' tri.v[(i + 1) % 3]' out p);                      }                      tri.err[3] = Math.Min(tri.err[0]' Math.Min(tri.err[1]' tri.err[2]));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: if (iteration == 0)              {                  foreach (var vert in vertices)                  {                      vert.q.SetAll(0);                  }                    foreach (var tri in triangles)                  {                      var p0 = vertices[tri.v[0]].p;                      var p1 = vertices[tri.v[1]].p;                      var p2 = vertices[tri.v[2]].p;                      var n = SharedFunctions.CrossProduct(p1 - p0' p2 - p0);                      n.Normalize();                      tri.normal = n;                      for (int j = 0; j < 3; ++j)                      {                          vertices[tri.v[j]].q += new SymmetricMatrix(n.X' n.Y' n.Z' -SharedFunctions.DotProduct(ref n' ref p0));                      }                  }                  Vector3D p;                  foreach (var tri in triangles)                  {                      for (int i = 0; i < 3; ++i)                      {                                                 tri.err[i] = CalculateError(tri.v[i]' tri.v[(i + 1) % 3]' out p);                      }                      tri.err[3] = Math.Min(tri.err[0]' Math.Min(tri.err[1]' tri.err[2]));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: foreach (var tri in triangles)              {                  vertices[tri.v[0]].tCount++;                  vertices[tri.v[1]].tCount++;                  vertices[tri.v[2]].tCount++;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: int totalTris = triangles.Count * 3;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: foreach (var tri in triangles)              {                  for (int j = 0; j < 3; ++j)                  {                      var v = vertices[tri.v[j]];                      var r = refs[v.tStart + v.tCount];                      r.tid = count;                      r.tvertex = j;                      refs[v.tStart + v.tCount] = r;                      v.tCount++;                                        }                  ++count;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: if (iteration == 0)              {                  var vCount = new List<int>();                  var vids = new List<int>();                  foreach (var vert in vertices)                  {                      vert.border = false;                  }                    foreach (var vert in vertices)                  {                      vCount.Clear();                      vids.Clear();                      for (int j = 0; j < vert.tCount; ++j)                      {                          var t = triangles[refs[vert.tStart + j].tid];                          for (int k = 0; k < 3; ++k)                          {                              int ofs = 0;                              int id = t.v[k];                              while (ofs < vCount.Count)                              {                                  if (vids[ofs] == id) { break; }                                  ++ofs;                              }                              if (ofs == vCount.Count)                              {                                  vCount.Add(1);                                  vids.Add(id);                              }                              else                              {                                  vCount[ofs]++;                              }                          }                      }                        for (int j = 0; j < vCount.Count; ++j)                      {                          if (vCount[j] == 1)                          {                              vertices[vids[j]].border = true;                          }                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CompactMesh,The following statement contains a magic number: for (int i = 0; i < triangles.Count; ++i)              {                  if (!triangles[i].deleted)                  {                      triangles[dst++] = triangles[i];                      vertices[triangles[i].v[0]].tCount = 1;                      vertices[triangles[i].v[1]].tCount = 1;                      vertices[triangles[i].v[2]].tCount = 1;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CompactMesh,The following statement contains a magic number: foreach (var tri in triangles)              {                  tri.v[0] = vertices[tri.v[0]].tStart;                  tri.v[1] = vertices[tri.v[1]].tStart;                  tri.v[2] = vertices[tri.v[2]].tStart;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CompactMesh,The following statement contains a magic number: foreach (var tri in triangles)              {                  tri.v[0] = vertices[tri.v[0]].tStart;                  tri.v[1] = vertices[tri.v[1]].tStart;                  tri.v[2] = vertices[tri.v[2]].tStart;              }
Magic Number,HelixToolkit.Wpf.SharpDX,Triangle,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Clone,The following statement contains a magic number: t.v[2] = this.v[2];
Magic Number,HelixToolkit.Wpf.SharpDX,Triangle,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Clone,The following statement contains a magic number: t.v[2] = this.v[2];
Magic Number,HelixToolkit.Wpf.SharpDX,Triangle,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Clone,The following statement contains a magic number: t.err[2] = this.err[2];
Magic Number,HelixToolkit.Wpf.SharpDX,Triangle,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Clone,The following statement contains a magic number: t.err[2] = this.err[2];
Magic Number,HelixToolkit.Wpf.SharpDX,Triangle,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Clone,The following statement contains a magic number: t.err[3] = this.err[3];
Magic Number,HelixToolkit.Wpf.SharpDX,Triangle,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Clone,The following statement contains a magic number: t.err[3] = this.err[3];
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: if (this.Points.Count < 3)              {                  throw new InvalidOperationException("At least three points required in the polygon to find a normal.");              }
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++)              {  #if SHARPDX                  var n = Vector3D.Cross(v1' this.Points[i] - this.Points[0]);                    if (n.LengthSquared() > 1e-10)  #else                  var n = Vector3D.CrossProduct(v1' this.Points[i] - this.Points[0]);                    if (n.LengthSquared > 1e-10)  #endif                  {                      n.Normalize();                      return n;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++)              {  #if SHARPDX                  var n = Vector3D.Cross(v1' this.Points[i] - this.Points[0]);                    if (n.LengthSquared() > 1e-10)  #else                  var n = Vector3D.CrossProduct(v1' this.Points[i] - this.Points[0]);                    if (n.LengthSquared > 1e-10)  #endif                  {                      n.Normalize();                      return n;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: Vector3D result = Vector3D.Cross(v1' this.Points[2] - this.Points[0]);
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,IsPlanar,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++)              {  #if SHARPDX                  var n = Vector3D.Cross(v1' this.Points[i] - this.Points[0]);  #else                  var n = Vector3D.CrossProduct(v1' this.Points[i] - this.Points[0]);  #endif                  n.Normalize();                  if (i == 2)                  {                      normal = n;                  }  #if SHARPDX                  else if (Math.Abs(Vector3D.Dot(n' normal) - 1) > 1e-8)  #else                  else if (Math.Abs(Vector3D.DotProduct(n' normal) - 1) > 1e-8)  #endif                  {                      return false;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,IsPlanar,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++)              {  #if SHARPDX                  var n = Vector3D.Cross(v1' this.Points[i] - this.Points[0]);  #else                  var n = Vector3D.CrossProduct(v1' this.Points[i] - this.Points[0]);  #endif                  n.Normalize();                  if (i == 2)                  {                      normal = n;                  }  #if SHARPDX                  else if (Math.Abs(Vector3D.Dot(n' normal) - 1) > 1e-8)  #else                  else if (Math.Abs(Vector3D.DotProduct(n' normal) - 1) > 1e-8)  #endif                  {                      return false;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,IsPlanar,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++)              {  #if SHARPDX                  var n = Vector3D.Cross(v1' this.Points[i] - this.Points[0]);  #else                  var n = Vector3D.CrossProduct(v1' this.Points[i] - this.Points[0]);  #endif                  n.Normalize();                  if (i == 2)                  {                      normal = n;                  }  #if SHARPDX                  else if (Math.Abs(Vector3D.Dot(n' normal) - 1) > 1e-8)  #else                  else if (Math.Abs(Vector3D.DotProduct(n' normal) - 1) > 1e-8)  #endif                  {                      return false;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)                  return null;              else if (count == 3)              {                  if (!didReverse)                  {                      return new Int32Collection { 0' 1' 2 };                  }                  else                  {                      return new Int32Collection { 2' 1' 1 };                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)                  return null;              else if (count == 3)              {                  if (!didReverse)                  {                      return new Int32Collection { 0' 1' 2 };                  }                  else                  {                      return new Int32Collection { 2' 1' 1 };                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)                  return null;              else if (count == 3)              {                  if (!didReverse)                  {                      return new Int32Collection { 0' 1' 2 };                  }                  else                  {                      return new Int32Collection { 2' 1' 1 };                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)                  return null;              else if (count == 3)              {                  if (!didReverse)                  {                      return new Int32Collection { 0' 1' 2 };                  }                  else                  {                      return new Int32Collection { 2' 1' 1 };                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,The following statement contains a magic number: for (int i = 2; i < pointCnt; i++)              {                  // The current Point                  var newPoint = events[i];                  var top = pointStack.Peek();                  // If the new Point is not on the same side as the last Point on the Stack                  //if (!(leftChain.Contains(top) && leftChain.Contains(newPoint) || rightChain.Contains(top) && rightChain.Contains(newPoint)))                  if (!(top.Last == newPoint || top.Next == newPoint))                  {                      // Determine this Point's Chain (left or right)                      if (left.Next == newPoint)                      {                          left = newPoint;                      }                      else if (right.Last == newPoint)                      {                          right = newPoint;                      }                        // Third triangle Point                      var p2 = top;                      // While there is a Point on the Stack                      while (pointStack.Count != 0)                      {                          // Pop and set the third Point                          top = pointStack.Pop();                          p2 = top;                          if (pointStack.Count != 0)                          {                              // Pop again                              top = pointStack.Pop();                                // Add to the result. The Order is depending on the Side                              if (left == newPoint)                              {                                  result.Add(newPoint.Index);                                  result.Add(p2.Index);                                  result.Add(top.Index);                              }                              else                              {                                  result.Add(newPoint.Index);                                  result.Add(top.Index);                                  result.Add(p2.Index);                              }                          }                          // If more Points are on the Stack'                          // Push the Point back again' to be able to form the Triangles                          if (pointStack.Count != 0)                              pointStack.Push(top);                      }                      // Push the last to Points on the Stack                      pointStack.Push(events[i - 1]);                      pointStack.Push(newPoint);                  }                  // If the newPoint is on the same Side (i.e. Chain)                  else                  {                      // Get to Point on the Stack                      top = pointStack.Pop();                      var p2 = top;                        // Determine this Point's Chain (left or right)                      if (left.Next == newPoint && right.Last == newPoint)                      {                          if (top.Last == newPoint)                              right = newPoint;                          else if (top.Next == newPoint)                              left = newPoint;                          else                              throw new Exception("Triangulation error");                      }                      else if (left.Next == newPoint)                      {                          left = newPoint;                      }                      else if (right.Last == newPoint)                      {                          right = newPoint;                      }                        while (pointStack.Count != 0)                      {                          // If the Triangle is possible' add it to the result (Point Order depends on the Side)                          if (right == newPoint && IsCCW(new List<Point> { newPoint.Point' p2.Point' pointStack.Peek().Point }))                          {                              top = pointStack.Pop();                              result.Add(newPoint.Index);                              result.Add(p2.Index);                              result.Add(top.Index);                              p2 = top;                          }                          else if (left == newPoint && !IsCCW(new List<Point> { newPoint.Point' p2.Point' pointStack.Peek().Point }))                          {                              top = pointStack.Pop();                              result.Add(newPoint.Index);                              result.Add(top.Index);                              result.Add(p2.Index);                              p2 = top;                          }                          // No Triangle possible' just leave the Loop                          else                              break;                      }                      // Push the last two Points on the Stack                      pointStack.Push(p2);                      pointStack.Push(newPoint);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,BestEdge,The following statement contains a magic number: var bestAngle = (float)Math.PI * 2;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourHelper,The following statement contains a magic number: this.normals = hasNormals ? new Vector3D[3] : null;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourHelper,The following statement contains a magic number: this.textures = hasTextureCoordinates ? new Point[3] : null;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,GetContourFacet,The following statement contains a magic number: if (this.IsSideAlone(2))              {                  return this.sides[2] > 0 ? ContourFacetResult.TwoOnly : ContourFacetResult.ZeroAndOne;              }
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,GetContourFacet,The following statement contains a magic number: if (this.IsSideAlone(2))              {                  return this.sides[2] > 0 ? ContourFacetResult.TwoOnly : ContourFacetResult.ZeroAndOne;              }
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.indices[2] = index2;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.points[2] = this.meshPositions[index2];
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: if (this.normals != null)              {                  this.normals[0] = this.meshNormals[index0];                  this.normals[1] = this.meshNormals[index1];                  this.normals[2] = this.meshNormals[index2];              }
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: if (this.textures != null)              {                  this.textures[0] = this.meshTextureCoordinates[index0];                  this.textures[1] = this.meshTextureCoordinates[index1];                  this.textures[2] = this.meshTextureCoordinates[index2];              }
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides[2] = (this.a * this.points[2].X) + (this.b * this.points[2].Y) + (this.c * this.points[2].Z) + this.d;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides[2] = (this.a * this.points[2].X) + (this.b * this.points[2].Y) + (this.c * this.points[2].Z) + this.d;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides[2] = (this.a * this.points[2].X) + (this.b * this.points[2].Y) + (this.c * this.points[2].Z) + this.d;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides[2] = (this.a * this.points[2].X) + (this.b * this.points[2].Y) + (this.c * this.points[2].Z) + this.d;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,IsSideAlone,The following statement contains a magic number: Func<int' int> getNext = i => i + 1 > 2 ? 0 : i + 1;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,AllSidesBelowContour,The following statement contains a magic number: return this.sides[0] >= 0                  && this.sides[1] >= 0                  && this.sides[2] >= 0;
Magic Number,HelixToolkit.Wpf.SharpDX,VectorExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Vector3DExtensions.cs,FindAnyPerpendicular,The following statement contains a magic number: if (u.LengthSquared() < 1e-3)              {                  u = Vector3.Cross(new Vector3(1' 0' 0)' n);              }
Magic Number,HelixToolkit.Wpf.SharpDX.Controls,RenderControl,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\RenderControl.cs,OnPaint,The following statement contains a magic number: if (DesignMode)              {                  if (fontForDesignMode == null)                      fontForDesignMode = new Font("Calibri"' 24' FontStyle.Regular);                    e.Graphics.Clear(System.Drawing.Color.WhiteSmoke);                  string text = "SharpDX RenderControl";                  var sizeText = e.Graphics.MeasureString(text' fontForDesignMode);                    e.Graphics.DrawString(text' fontForDesignMode' new SolidBrush(System.Drawing.Color.Black)' (Width - sizeText.Width) / 2' (Height - sizeText.Height) / 2);              }
Magic Number,HelixToolkit.Wpf.SharpDX.Controls,RenderControl,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\RenderControl.cs,OnPaint,The following statement contains a magic number: if (DesignMode)              {                  if (fontForDesignMode == null)                      fontForDesignMode = new Font("Calibri"' 24' FontStyle.Regular);                    e.Graphics.Clear(System.Drawing.Color.WhiteSmoke);                  string text = "SharpDX RenderControl";                  var sizeText = e.Graphics.MeasureString(text' fontForDesignMode);                    e.Graphics.DrawString(text' fontForDesignMode' new SolidBrush(System.Drawing.Color.Black)' (Width - sizeText.Width) / 2' (Height - sizeText.Height) / 2);              }
Magic Number,HelixToolkit.Wpf.SharpDX.Controls,RenderControl,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\RenderControl.cs,OnPaint,The following statement contains a magic number: if (DesignMode)              {                  if (fontForDesignMode == null)                      fontForDesignMode = new Font("Calibri"' 24' FontStyle.Regular);                    e.Graphics.Clear(System.Drawing.Color.WhiteSmoke);                  string text = "SharpDX RenderControl";                  var sizeText = e.Graphics.MeasureString(text' fontForDesignMode);                    e.Graphics.DrawString(text' fontForDesignMode' new SolidBrush(System.Drawing.Color.Black)' (Width - sizeText.Width) / 2' (Height - sizeText.Height) / 2);              }
Magic Number,HelixToolkit.Wpf.SharpDX.Helpers,EventSkipper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Helpers\EventSkipper.cs,IsSkip,The following statement contains a magic number: if (lag < Threshold)              {                                  return true;              }              else              {                  lag = Math.Min(lag - Threshold' Threshold - 2);                  forceRender = true;                  return false;              }
Magic Number,Wpf3DTools,Trackball,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Trackball.cs,Pan,The following statement contains a magic number: _translate.OffsetX += changeVector.X * .1;
Magic Number,Wpf3DTools,Trackball,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Trackball.cs,Pan,The following statement contains a magic number: _translate.OffsetY -= changeVector.Y * .1;
Magic Number,Wpf3DTools,Trackball,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Trackball.cs,Pan,The following statement contains a magic number: _translate.OffsetZ += changeVector.Z * .1;
Magic Number,Wpf3DTools,Trackball,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Trackball.cs,ProjectToTrackball,The following statement contains a magic number: double x = point.X / (width / 2);
Magic Number,Wpf3DTools,Trackball,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Trackball.cs,ProjectToTrackball,The following statement contains a magic number: double y = point.Y / (height / 2);
Magic Number,Wpf3DTools,Trackball,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Trackball.cs,Zoom,The following statement contains a magic number: double scale = _zoomFactor * Math.Exp(-yDelta / 100);
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: if (n < 3)              {                  return null;              }
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: int count = 2 * nv;
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: for (int v = nv - 1; nv > 2;)              {                  // if we loop' it is probably a non-simple polygon                  if (0 >= (count--))                  {                      // ERROR - probable bad polygon!                      return null;                  }                    // three consecutive vertices in current polygon' <u'v'w>                  int u = v;                  if (nv <= u)                  {                      u = 0; // previous                  }                    v = u + 1;                  if (nv <= v)                  {                      v = 0; // new v                  }                    int w = v + 1;                  if (nv <= w)                  {                      w = 0; // next                  }                    if (Snip(contour' u' v' w' nv' V))                  {                      int s' t;                        // true names of the vertices                      int a = V[u];                      int b = V[v];                      int c = V[w];                        // output Triangle                      result.Add(a);                      result.Add(b);                      result.Add(c);                        // remove v from remaining polygon                      for (s = v' t = v + 1; t < nv; s++' t++)                      {                          V[s] = V[t];                      }                        nv--;                        // resest error detection counter                      count = 2 * nv;                  }              }
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: for (int v = nv - 1; nv > 2;)              {                  // if we loop' it is probably a non-simple polygon                  if (0 >= (count--))                  {                      // ERROR - probable bad polygon!                      return null;                  }                    // three consecutive vertices in current polygon' <u'v'w>                  int u = v;                  if (nv <= u)                  {                      u = 0; // previous                  }                    v = u + 1;                  if (nv <= v)                  {                      v = 0; // new v                  }                    int w = v + 1;                  if (nv <= w)                  {                      w = 0; // next                  }                    if (Snip(contour' u' v' w' nv' V))                  {                      int s' t;                        // true names of the vertices                      int a = V[u];                      int b = V[v];                      int c = V[w];                        // output Triangle                      result.Add(a);                      result.Add(b);                      result.Add(c);                        // remove v from remaining polygon                      for (s = v' t = v + 1; t < nv; s++' t++)                      {                          V[s] = V[t];                      }                        nv--;                        // resest error detection counter                      count = 2 * nv;                  }              }
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,InsideTriangle,The following statement contains a magic number: const double EPSILON = -1e-10;
Magic Number,HelixToolkit.SharpDX.Helpers,PointerSizeHelpers,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Helpers\PointerSizeHelpers.cs,ToUInt64,The following statement contains a magic number: if (UIntPtr.Size == 8)              {                  return (ulong)(long)ptr;              }              else              {                  return (uint)(int)ptr;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following statement contains a magic number: if ((header.PixelFormat.Flags & DDS.PixelFormatFlags.FourCC) != 0 && (new FourCC('D'' 'X'' '1'' '0') == header.PixelFormat.FourCC))              {                  // Buffer must be big enough for both headers and magic value                  if (size < (Utilities.SizeOf<DDS.Header>() + sizeof (uint) + Utilities.SizeOf<DDS.HeaderDXT10>()))                      return false;                    var headerDX10 = *(DDS.HeaderDXT10*) ((byte*) headerPtr + sizeof (int) + Utilities.SizeOf<DDS.Header>());                  convFlags |= ConversionFlags.DX10;                    description.ArraySize = headerDX10.ArraySize;                  if (description.ArraySize == 0)                      throw new InvalidOperationException("Unexpected ArraySize == 0 from DDS HeaderDX10 ");                    description.Format = headerDX10.DXGIFormat;                  if (!FormatHelper.IsValid(description.Format))                      throw new InvalidOperationException("Invalid Format from DDS HeaderDX10 ");                    switch (headerDX10.ResourceDimension)                  {                      case ResourceDimension.Texture1D:                            // D3DX writes 1D textures with a fixed Height of 1                          if ((header.Flags & DDS.HeaderFlags.Height) != 0 && header.Height != 1)                              throw new InvalidOperationException("Unexpected Height != 1 from DDS HeaderDX10 ");                            description.Width = header.Width;                          description.Height = 1;                          description.Depth = 1;                          description.Dimension = TextureDimension.Texture1D;                          break;                        case ResourceDimension.Texture2D:                          if ((headerDX10.MiscFlags & ResourceOptionFlags.TextureCube) != 0)                          {                              description.ArraySize *= 6;                              description.Dimension = TextureDimension.TextureCube;                          }                          else                          {                              description.Dimension = TextureDimension.Texture2D;                          }                            description.Width = header.Width;                          description.Height = header.Height;                          description.Depth = 1;                          break;                        case ResourceDimension.Texture3D:                          if ((header.Flags & DDS.HeaderFlags.Volume) == 0)                              throw new InvalidOperationException("Texture3D missing HeaderFlags.Volume from DDS HeaderDX10");                            if (description.ArraySize > 1)                              throw new InvalidOperationException("Unexpected ArraySize > 1 for Texture3D from DDS HeaderDX10");                            description.Width = header.Width;                          description.Height = header.Height;                          description.Depth = header.Depth;                          description.Dimension = TextureDimension.Texture3D;                          break;                        default:                          throw new InvalidOperationException(string.Format("Unexpected dimension [{0}] from DDS HeaderDX10"' headerDX10.ResourceDimension));                  }              }              else              {                  description.ArraySize = 1;                    if ((header.Flags & DDS.HeaderFlags.Volume) != 0)                  {                      description.Width = header.Width;                      description.Height = header.Height;                      description.Depth = header.Depth;                      description.Dimension = TextureDimension.Texture3D;                  }                  else                  {                      if ((header.CubemapFlags & DDS.CubemapFlags.CubeMap) != 0)                      {                          // We require all six faces to be defined                          if ((header.CubemapFlags & DDS.CubemapFlags.AllFaces) != DDS.CubemapFlags.AllFaces)                              throw new InvalidOperationException("Unexpected CubeMap' expecting all faces from DDS Header");                            description.ArraySize = 6;                          description.Dimension = TextureDimension.TextureCube;                      }                      else                      {                          description.Dimension = TextureDimension.Texture2D;                      }                        description.Width = header.Width;                      description.Height = header.Height;                      description.Depth = 1;                      // Note there's no way for a legacy Direct3D 9 DDS to express a '1D' texture                  }                    description.Format = GetDXGIFormat(ref header.PixelFormat' flags' out convFlags);                    if (description.Format == Format.Unknown)                      throw new InvalidOperationException("Unsupported PixelFormat from DDS Header");              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following statement contains a magic number: if ((header.PixelFormat.Flags & DDS.PixelFormatFlags.FourCC) != 0 && (new FourCC('D'' 'X'' '1'' '0') == header.PixelFormat.FourCC))              {                  // Buffer must be big enough for both headers and magic value                  if (size < (Utilities.SizeOf<DDS.Header>() + sizeof (uint) + Utilities.SizeOf<DDS.HeaderDXT10>()))                      return false;                    var headerDX10 = *(DDS.HeaderDXT10*) ((byte*) headerPtr + sizeof (int) + Utilities.SizeOf<DDS.Header>());                  convFlags |= ConversionFlags.DX10;                    description.ArraySize = headerDX10.ArraySize;                  if (description.ArraySize == 0)                      throw new InvalidOperationException("Unexpected ArraySize == 0 from DDS HeaderDX10 ");                    description.Format = headerDX10.DXGIFormat;                  if (!FormatHelper.IsValid(description.Format))                      throw new InvalidOperationException("Invalid Format from DDS HeaderDX10 ");                    switch (headerDX10.ResourceDimension)                  {                      case ResourceDimension.Texture1D:                            // D3DX writes 1D textures with a fixed Height of 1                          if ((header.Flags & DDS.HeaderFlags.Height) != 0 && header.Height != 1)                              throw new InvalidOperationException("Unexpected Height != 1 from DDS HeaderDX10 ");                            description.Width = header.Width;                          description.Height = 1;                          description.Depth = 1;                          description.Dimension = TextureDimension.Texture1D;                          break;                        case ResourceDimension.Texture2D:                          if ((headerDX10.MiscFlags & ResourceOptionFlags.TextureCube) != 0)                          {                              description.ArraySize *= 6;                              description.Dimension = TextureDimension.TextureCube;                          }                          else                          {                              description.Dimension = TextureDimension.Texture2D;                          }                            description.Width = header.Width;                          description.Height = header.Height;                          description.Depth = 1;                          break;                        case ResourceDimension.Texture3D:                          if ((header.Flags & DDS.HeaderFlags.Volume) == 0)                              throw new InvalidOperationException("Texture3D missing HeaderFlags.Volume from DDS HeaderDX10");                            if (description.ArraySize > 1)                              throw new InvalidOperationException("Unexpected ArraySize > 1 for Texture3D from DDS HeaderDX10");                            description.Width = header.Width;                          description.Height = header.Height;                          description.Depth = header.Depth;                          description.Dimension = TextureDimension.Texture3D;                          break;                        default:                          throw new InvalidOperationException(string.Format("Unexpected dimension [{0}] from DDS HeaderDX10"' headerDX10.ResourceDimension));                  }              }              else              {                  description.ArraySize = 1;                    if ((header.Flags & DDS.HeaderFlags.Volume) != 0)                  {                      description.Width = header.Width;                      description.Height = header.Height;                      description.Depth = header.Depth;                      description.Dimension = TextureDimension.Texture3D;                  }                  else                  {                      if ((header.CubemapFlags & DDS.CubemapFlags.CubeMap) != 0)                      {                          // We require all six faces to be defined                          if ((header.CubemapFlags & DDS.CubemapFlags.AllFaces) != DDS.CubemapFlags.AllFaces)                              throw new InvalidOperationException("Unexpected CubeMap' expecting all faces from DDS Header");                            description.ArraySize = 6;                          description.Dimension = TextureDimension.TextureCube;                      }                      else                      {                          description.Dimension = TextureDimension.Texture2D;                      }                        description.Width = header.Width;                      description.Height = header.Height;                      description.Depth = 1;                      // Note there's no way for a legacy Direct3D 9 DDS to express a '1D' texture                  }                    description.Format = GetDXGIFormat(ref header.PixelFormat' flags' out convFlags);                    if (description.Format == Format.Unknown)                      throw new InvalidOperationException("Unsupported PixelFormat from DDS Header");              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if (description.ArraySize > 1)              {                  if ((description.ArraySize != 6) || (description.Dimension != TextureDimension.Texture2D) || (description.Dimension != TextureDimension.TextureCube))                  {                      flags |= DDSFlags.ForceDX10Ext;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if (ddpf.Size == 0)              {                  header->PixelFormat = DDS.PixelFormat.DX10;                    var ext = (DDS.HeaderDXT10*)((byte*)(header) + Utilities.SizeOf<DDS.Header>());                    Utilities.ClearMemory((IntPtr) ext' 0' Utilities.SizeOf<DDS.HeaderDXT10>());                    ext->DXGIFormat = description.Format;                  switch (description.Dimension)                  {                      case TextureDimension.Texture1D:                          ext->ResourceDimension = ResourceDimension.Texture1D;                          break;                      case TextureDimension.Texture2D:                      case TextureDimension.TextureCube:                          ext->ResourceDimension = ResourceDimension.Texture2D;                          break;                      case TextureDimension.Texture3D:                          ext->ResourceDimension = ResourceDimension.Texture3D;                          break;                    }                    if (description.Dimension == TextureDimension.TextureCube)                  {                      ext->MiscFlags |= ResourceOptionFlags.TextureCube;                      ext->ArraySize = description.ArraySize / 6;                  }                  else                  {                      ext->ArraySize = description.ArraySize;                  }              }              else              {                  header->PixelFormat = ddpf;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LoadFromDDSMemory,The following statement contains a magic number: if ((convFlags & ConversionFlags.Pal8) != 0)              {                  pal8 = (int*) ((byte*) (pSource) + offset);                  offset += (256 * sizeof (uint));              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,NewCube,The following statement contains a magic number: return new Image(CreateDescription(TextureDimension.TextureCube' width' width' 1' mipMapCount' format' 6)' dataPointer' 0' null' false);
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Load,The following statement contains a magic number: if (size > (85 * 1024))              {                  var handle = GCHandle.Alloc(buffer' GCHandleType.Pinned);                  return Load(handle.AddrOfPinnedObject()' size' false' handle);              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Load,The following statement contains a magic number: if (size > (85 * 1024))              {                  var handle = GCHandle.Alloc(buffer' GCHandleType.Pinned);                  return Load(handle.AddrOfPinnedObject()' size' false' handle);              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The following statement contains a magic number: switch (description.Dimension)              {                  case TextureDimension.Texture1D:                      if (description.Width <= 0 || description.Height != 1 || description.Depth != 1 || description.ArraySize == 0)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 1D");                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' 1' description.MipLevels);                      break;                    case TextureDimension.Texture2D:                  case TextureDimension.TextureCube:                      if (description.Width <= 0 || description.Height <= 0 || description.Depth != 1 || description.ArraySize == 0)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 2D");                        if (description.Dimension == TextureDimension.TextureCube)                      {                          if ((description.ArraySize % 6) != 0)                              throw new InvalidOperationException("TextureCube must have an arraysize = 6");                      }                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.MipLevels);                      break;                    case TextureDimension.Texture3D:                      if (description.Width <= 0 || description.Height <= 0 || description.Depth <= 0 || description.ArraySize != 1)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 3D");                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.Depth' description.MipLevels);                      break;              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = this.Width;                  hashCode = (hashCode * 397) ^ this.Height;                  hashCode = (hashCode * 397) ^ this.WidthPacked;                  hashCode = (hashCode * 397) ^ this.HeightPacked;                  hashCode = (hashCode * 397) ^ this.Depth;                  hashCode = (hashCode * 397) ^ this.RowStride;                  hashCode = (hashCode * 397) ^ this.MipmapSize;                  hashCode = (hashCode * 397) ^ this.DepthStride;                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = this.Width;                  hashCode = (hashCode * 397) ^ this.Height;                  hashCode = (hashCode * 397) ^ this.WidthPacked;                  hashCode = (hashCode * 397) ^ this.HeightPacked;                  hashCode = (hashCode * 397) ^ this.Depth;                  hashCode = (hashCode * 397) ^ this.RowStride;                  hashCode = (hashCode * 397) ^ this.MipmapSize;                  hashCode = (hashCode * 397) ^ this.DepthStride;                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = this.Width;                  hashCode = (hashCode * 397) ^ this.Height;                  hashCode = (hashCode * 397) ^ this.WidthPacked;                  hashCode = (hashCode * 397) ^ this.HeightPacked;                  hashCode = (hashCode * 397) ^ this.Depth;                  hashCode = (hashCode * 397) ^ this.RowStride;                  hashCode = (hashCode * 397) ^ this.MipmapSize;                  hashCode = (hashCode * 397) ^ this.DepthStride;                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = this.Width;                  hashCode = (hashCode * 397) ^ this.Height;                  hashCode = (hashCode * 397) ^ this.WidthPacked;                  hashCode = (hashCode * 397) ^ this.HeightPacked;                  hashCode = (hashCode * 397) ^ this.Depth;                  hashCode = (hashCode * 397) ^ this.RowStride;                  hashCode = (hashCode * 397) ^ this.MipmapSize;                  hashCode = (hashCode * 397) ^ this.DepthStride;                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = this.Width;                  hashCode = (hashCode * 397) ^ this.Height;                  hashCode = (hashCode * 397) ^ this.WidthPacked;                  hashCode = (hashCode * 397) ^ this.HeightPacked;                  hashCode = (hashCode * 397) ^ this.Depth;                  hashCode = (hashCode * 397) ^ this.RowStride;                  hashCode = (hashCode * 397) ^ this.MipmapSize;                  hashCode = (hashCode * 397) ^ this.DepthStride;                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = this.Width;                  hashCode = (hashCode * 397) ^ this.Height;                  hashCode = (hashCode * 397) ^ this.WidthPacked;                  hashCode = (hashCode * 397) ^ this.HeightPacked;                  hashCode = (hashCode * 397) ^ this.Depth;                  hashCode = (hashCode * 397) ^ this.RowStride;                  hashCode = (hashCode * 397) ^ this.MipmapSize;                  hashCode = (hashCode * 397) ^ this.DepthStride;                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = this.Width;                  hashCode = (hashCode * 397) ^ this.Height;                  hashCode = (hashCode * 397) ^ this.WidthPacked;                  hashCode = (hashCode * 397) ^ this.HeightPacked;                  hashCode = (hashCode * 397) ^ this.Depth;                  hashCode = (hashCode * 397) ^ this.RowStride;                  hashCode = (hashCode * 397) ^ this.MipmapSize;                  hashCode = (hashCode * 397) ^ this.DepthStride;                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,RenderTargetCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTargetCube.cs,NewRenderTargetDescription,The following statement contains a magic number: var desc = Texture2DBase.NewDescription(size' size' format' flags' mipCount' 6' ResourceUsage.Default);
Magic Number,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,CalculateMipMapCount,The following statement contains a magic number: int maxMipMap = 1 + (int)Math.Log(size' 2);
Magic Number,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetViewCount,The following statement contains a magic number: return GetViewIndex((ViewType)4' arrayOrDepthSize' this.Description.MipLevels);
Magic Number,SharpDX.Toolkit.Graphics,TextureViewKey,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      var hashCode = (int)ViewFormat;                      hashCode = (hashCode * 397) ^ (int)ViewType;                      hashCode = (hashCode * 397) ^ ArrayOrDepthSlice;                      hashCode = (hashCode * 397) ^ MipIndex;                      return hashCode;                  }
Magic Number,SharpDX.Toolkit.Graphics,TextureViewKey,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      var hashCode = (int)ViewFormat;                      hashCode = (hashCode * 397) ^ (int)ViewType;                      hashCode = (hashCode * 397) ^ ArrayOrDepthSlice;                      hashCode = (hashCode * 397) ^ MipIndex;                      return hashCode;                  }
Magic Number,SharpDX.Toolkit.Graphics,TextureViewKey,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      var hashCode = (int)ViewFormat;                      hashCode = (hashCode * 397) ^ (int)ViewType;                      hashCode = (hashCode * 397) ^ ArrayOrDepthSlice;                      hashCode = (hashCode * 397) ^ MipIndex;                      return hashCode;                  }
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: if (textureData.Length != 6)                  throw new ArgumentException("Invalid texture data. First dimension must be equal to 6"' "textureData");
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin(textureData[2]' ptr => dataBox3 = GetDataBox(format' size' size' 1' textureData[0]' ptr));
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin(textureData[3]' ptr => dataBox4 = GetDataBox(format' size' size' 1' textureData[0]' ptr));
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin(textureData[4]' ptr => dataBox5 = GetDataBox(format' size' size' 1' textureData[0]' ptr));
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin(textureData[5]' ptr => dataBox6 = GetDataBox(format' size' size' 1' textureData[0]' ptr));
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: if (textureData.Length != 6)                  throw new ArgumentException("Invalid texture data. First dimension must be equal to 6"' "textureData");
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,NewTextureCubeDescription,The following statement contains a magic number: var desc = NewDescription(size' size' format' flags' mipCount' 6' usage);
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: frame.SetResolution(72' 72);
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: frame.SetResolution(72' 72);
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: if (targetGuid != pfGuid)              {                  using (var source = new Bitmap(Factory' image.Width' image.Height' pfGuid' new DataRectangle(image.DataPointer' image.RowStride)' image.BufferStride))                  {                      using (var converter = new FormatConverter(Factory))                      {                          using (var palette = new Palette(Factory))                          {                              palette.Initialize(source' 256' true);                              converter.Initialize(source' targetGuid' GetWICDither(flags)' palette' 0' BitmapPaletteType.Custom);                                int bpp = GetBitsPerPixel(targetGuid);                              if (bpp == 0) throw new NotSupportedException("Unable to determine the Bpp for the target format");                                int rowPitch = (image.Width * bpp + 7) / 8;                              int slicePitch = rowPitch * image.Height;                                var temp = Utilities.AllocateMemory(slicePitch);                              try                              {                                  converter.CopyPixels(rowPitch' temp' slicePitch);                                  frame.Palette = palette;                                  frame.WritePixels(image.Height' temp' rowPitch' slicePitch);                              }                              finally                              {                                  Utilities.FreeMemory(temp);                              }                          }                      }                  }              }              else              {                  // No conversion required                  frame.WritePixels(image.Height' image.DataPointer' image.RowStride' image.BufferStride);              }
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: if (targetGuid != pfGuid)              {                  using (var source = new Bitmap(Factory' image.Width' image.Height' pfGuid' new DataRectangle(image.DataPointer' image.RowStride)' image.BufferStride))                  {                      using (var converter = new FormatConverter(Factory))                      {                          using (var palette = new Palette(Factory))                          {                              palette.Initialize(source' 256' true);                              converter.Initialize(source' targetGuid' GetWICDither(flags)' palette' 0' BitmapPaletteType.Custom);                                int bpp = GetBitsPerPixel(targetGuid);                              if (bpp == 0) throw new NotSupportedException("Unable to determine the Bpp for the target format");                                int rowPitch = (image.Width * bpp + 7) / 8;                              int slicePitch = rowPitch * image.Height;                                var temp = Utilities.AllocateMemory(slicePitch);                              try                              {                                  converter.CopyPixels(rowPitch' temp' slicePitch);                                  frame.Palette = palette;                                  frame.WritePixels(image.Height' temp' rowPitch' slicePitch);                              }                              finally                              {                                  Utilities.FreeMemory(temp);                              }                          }                      }                  }              }              else              {                  // No conversion required                  frame.WritePixels(image.Height' image.DataPointer' image.RowStride' image.BufferStride);              }
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: if (targetGuid != pfGuid)              {                  using (var source = new Bitmap(Factory' image.Width' image.Height' pfGuid' new DataRectangle(image.DataPointer' image.RowStride)' image.BufferStride))                  {                      using (var converter = new FormatConverter(Factory))                      {                          using (var palette = new Palette(Factory))                          {                              palette.Initialize(source' 256' true);                              converter.Initialize(source' targetGuid' GetWICDither(flags)' palette' 0' BitmapPaletteType.Custom);                                int bpp = GetBitsPerPixel(targetGuid);                              if (bpp == 0) throw new NotSupportedException("Unable to determine the Bpp for the target format");                                int rowPitch = (image.Width * bpp + 7) / 8;                              int slicePitch = rowPitch * image.Height;                                var temp = Utilities.AllocateMemory(slicePitch);                              try                              {                                  converter.CopyPixels(rowPitch' temp' slicePitch);                                  frame.Palette = palette;                                  frame.WritePixels(image.Height' temp' rowPitch' slicePitch);                              }                              finally                              {                                  Utilities.FreeMemory(temp);                              }                          }                      }                  }              }              else              {                  // No conversion required                  frame.WritePixels(image.Height' image.DataPointer' image.RowStride' image.BufferStride);              }
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeMultiframe,The following statement contains a magic number: if (images.Length < 2)                  throw new ArgumentException("Cannot encode to multiple frame. Image doesn't have multiple frame");
Missing Default,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key)                  {                      case Key.Left:                          this.AddRotateForce(-1 * f * this.LeftRightRotationSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Right:                          this.AddRotateForce(1 * f * this.LeftRightRotationSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Up:                          this.AddRotateForce(0' -1 * f * this.UpDownRotationSensitivity);                          e.Handled = true;                          break;                      case Key.Down:                          this.AddRotateForce(0' 1 * f * this.UpDownRotationSensitivity);                          e.Handled = true;                          break;                  }
Missing Default,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key)                  {                      case Key.Left:                          this.AddPanForce(-5 * f * this.LeftRightPanSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Right:                          this.AddPanForce(5 * f * this.LeftRightPanSensitivity' 0);                          e.Handled = true;                          break;                      case Key.Up:                          this.AddPanForce(0' -5 * f * this.UpDownPanSensitivity);                          e.Handled = true;                          break;                      case Key.Down:                          this.AddPanForce(0' 5 * f * this.UpDownPanSensitivity);                          e.Handled = true;                          break;                  }
Missing Default,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key)              {                  case Key.PageUp:                      this.AddZoomForce(-0.1 * f * this.PageUpDownZoomSensitivity);                      e.Handled = true;                      break;                  case Key.PageDown:                      this.AddZoomForce(0.1 * f * this.PageUpDownZoomSensitivity);                      e.Handled = true;                      break;                  case Key.Back:                      if (this.RestoreCameraSetting())                      {                          e.Handled = true;                      }                        break;              }
Missing Default,HelixToolkit.Wpf.SharpDX,CameraController,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key)              {                  case Key.W:                      this.AddMoveForce(0' 0' 0.1 * f * this.MoveSensitivity);                      break;                  case Key.A:                      this.AddMoveForce(-0.1 * f * this.LeftRightPanSensitivity' 0' 0);                      break;                  case Key.S:                      this.AddMoveForce(0' 0' -0.1 * f * this.MoveSensitivity);                      break;                  case Key.D:                      this.AddMoveForce(0.1 * f * this.LeftRightPanSensitivity' 0' 0);                      break;                  case Key.Z:                      this.AddMoveForce(0' -0.1 * f * this.LeftRightPanSensitivity' 0);                      break;                  case Key.Q:                      this.AddMoveForce(0' 0.1 * f * this.LeftRightPanSensitivity' 0);                      break;              }
Missing Default,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,Rotate,The following switch statement is missing a default case: switch (this.Viewport.CameraRotationMode)              {                  case CameraRotationMode.Trackball:                      this.RotateTrackball(p0' p1' rotateAround);                      break;                  case CameraRotationMode.Turntable:                      this.RotateTurntable(p1 - p0' rotateAround);                      break;                  case CameraRotationMode.Turnball:                      this.RotateTurnball(p0' p1' rotateAround);                      break;              }
Missing Default,HelixToolkit.Wpf.SharpDX,RotateHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,Started,The following switch statement is missing a default case: switch (this.CameraRotationMode)              {                  case CameraRotationMode.Trackball:                      break;                  case CameraRotationMode.Turntable:                      break;                  case CameraRotationMode.Turnball:                      this.InitTurnballRotationAxes(e.CurrentPosition);                      break;              }
Missing Default,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Zoom,The following switch statement is missing a default case: switch (this.CameraMode)                      {                          case CameraMode.Inspect:                              this.ChangeCameraDistance(delta' zoomAround);                              break;                          case CameraMode.WalkAround:                              this.Camera.Position -= this.Camera.LookDirection * delta;                              break;                      }
Missing Default,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,MoveCameraPosition,The following switch statement is missing a default case: switch (this.CameraMode)              {                  case CameraMode.Inspect:                  case CameraMode.WalkAround:                      this.Camera.Position += (x * delta.X) + (y * delta.Y) + (z * delta.Z);                      break;              }
Missing Default,HelixToolkit.Wpf.SharpDX,ZoomHandler,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ZoomByChangingCameraWidth,The following switch statement is missing a default case: switch (this.CameraMode)              {                  case CameraMode.WalkAround:                  case CameraMode.Inspect:                  case CameraMode.FixedPosition:                      this.ChangeCameraDistance(delta' zoomAround);                        // Modify the camera width                      var ocamera = this.Camera as OrthographicCamera;                      if (ocamera != null)                      {                          ocamera.Width *= Math.Pow(2.5' delta);                      }                        break;              }
Missing Default,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRender,The following switch statement is missing a default case: switch (billboardType)              {                  case BillboardType.MultipleText:                      // Use foreground shader to draw text                      effectTechnique.GetPassByIndex(0).Apply(renderContext.DeviceContext);                        // --- draw text' foreground vertex is beginning from 0.                      renderContext.DeviceContext.Draw(vertexCount' 0);                      break;                  case BillboardType.SingleText:                      if (vertexCount == 8)                      {                          var half = vertexCount / 2;                          // Use background shader to draw background first                          effectTechnique.GetPassByIndex(1).Apply(renderContext.DeviceContext);                          // --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>                          renderContext.DeviceContext.Draw(half' half);                            // Use foreground shader to draw text                          effectTechnique.GetPassByIndex(0).Apply(renderContext.DeviceContext);                            // --- draw text' foreground vertex is beginning from 0.                          renderContext.DeviceContext.Draw(half' 0);                      }                      break;                  case BillboardType.SingleImage:                      // Use foreground shader to draw text                      effectTechnique.GetPassByIndex(2).Apply(renderContext.DeviceContext);                        // --- draw text' foreground vertex is beginning from 0.                      renderContext.DeviceContext.Draw(vertexCount' 0);                      break;              }
Missing Default,HelixToolkit.Wpf.SharpDX,CoordinateSystemModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CoordinateSystemModel3D.cs,UpdateAxisColor,The following switch statement is missing a default case: switch (which)              {                  case 0:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("X"' new Vector3(14' 0' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 1:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Y"' new Vector3(0' 14' 0))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;                  case 2:                      axisBillboards[which].Geometry = new BillboardSingleText3D()                      { TextInfo = new TextInfo("Z"' new Vector3(0' 0' 14))' BackgroundColor = Color.Transparent' FontSize = 14' FontColor = color };                      break;              }
Missing Default,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following switch statement is missing a default case: switch (billboardType)                  {                      case BillboardType.SingleImage:                          // Use foreground shader to draw text                          effectTechnique.GetPassByIndex(2).Apply(renderContext.DeviceContext);                            // --- draw text' foreground vertex is beginning from 0.                          renderContext.DeviceContext.DrawInstanced(vertexCount' this.instanceInternal.Count' 0' 0);                          break;                      case BillboardType.SingleText:                          if (vertexCount == 8)                          {                              var half = vertexCount / 2;                              // Use background shader to draw background first                              effectTechnique.GetPassByIndex(1).Apply(renderContext.DeviceContext);                              // --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>                              renderContext.DeviceContext.DrawInstanced(half' this.instanceInternal.Count' half' 0);                                // Use foreground shader to draw text                              effectTechnique.GetPassByIndex(0).Apply(renderContext.DeviceContext);                                // --- draw text' foreground vertex is beginning from 0.                              renderContext.DeviceContext.DrawInstanced(half' this.instanceInternal.Count' 0' 0);                          }                          break;                  }
Missing Default,HelixToolkit.Wpf.SharpDX,CompositeModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CompositeModel3D.cs,ChildrenChanged,The following switch statement is missing a default case: switch (e.Action)                  {                      case NotifyCollectionChangedAction.Reset:                      case NotifyCollectionChangedAction.Remove:                      case NotifyCollectionChangedAction.Replace:                          foreach (Model3D item in e.OldItems)                          {                              // todo: detach?                              // yes' always                              item.Detach();                              if (item.Parent == this)                              {                                  this.RemoveLogicalChild(item);                              }                          }                          break;                  }
Missing Default,HelixToolkit.Wpf.SharpDX,CompositeModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CompositeModel3D.cs,ChildrenChanged,The following switch statement is missing a default case: switch (e.Action)                  {                      case NotifyCollectionChangedAction.Reset:                      case NotifyCollectionChangedAction.Add:                      case NotifyCollectionChangedAction.Replace:                          foreach (Model3D item in e.NewItems)                          {                              if (this.IsAttached)                              {                                  // todo: attach?                                  // yes' always                                    // where to get a refrence to renderHost?                                  // store it as private memeber of the class?                                  if (item.Parent == null)                                  {                                      this.AddLogicalChild(item);                                  }                                    item.Attach(this.renderHost);                              }                          }                          break;                  }
Missing Default,HelixToolkit.Wpf.SharpDX,Items3DControl,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\Items3DControl.cs,OnItemsChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                  case NotifyCollectionChangedAction.Replace:                      {                          if (this.ItemTemplate != null)                          {                              foreach (var item in e.NewItems)                              {                                  var element = this.ItemTemplate.LoadContent() as Element3D;                                  if (element != null)                                  {                                      element.DataContext = item;                                      this.children.Add(element);                                        var meshModel = element as IMouse3D;                                      if (meshModel != null)                                      {                                          var selectable = meshModel as ISelectable;                                          meshModel.MouseDown3D += (o' e1) =>                                          {                                              this.SelectedItem = item;                                                if (selectable != null)                                                  selectable.IsSelected = true;                                          };                                      }                                  }                                  else                                  {                                      throw new InvalidOperationException("Cannot create a Element3D from ItemTemplate.");                                  }                              }                          }                          else                          {                              foreach (var item in e.NewItems)                              {                                  var element = item as IRenderable;                                  if (element != null)                                  {                                      this.children.Add(item);                                        var meshModel = element as IMouse3D;                                      if (meshModel != null)                                      {                                          var selectable = meshModel as ISelectable;                                          meshModel.MouseDown3D += (o' e1) =>                                          {                                              this.SelectedItem = item;                                                if (selectable != null)                                                  selectable.IsSelected = true;                                          };                                      }                                  }                              }                          }                          break;                      }                  case NotifyCollectionChangedAction.Remove:                      {                          if (this.ItemTemplate != null)                          {                              int ii = 0;                              foreach (var item in e.OldItems)                              {                                  var element = this.children[e.OldStartingIndex + ii++] as IRenderable;                                  if (element != null)                                  {                                      element.Detach();                                      this.children.Remove(element);                                  }                                  else                                  {                                      throw new InvalidOperationException("Cannot remove a Element3D from Items.");                                  }                              }                          }                          else                          {                              foreach (var item in e.OldItems)                              {                                  var element = item as IRenderable;                                  if (element != null)                                  {                                      element.Detach();                                      this.children.Remove(item);                                  }                              }                          }                            break;                      }                  case NotifyCollectionChangedAction.Reset:                      {                          foreach (var item in this.children)                          {                              var element = item as IRenderable;                              if (element != null)                              {                                  element.Detach();                              }                              else                              {                                  throw new InvalidOperationException("Cannot remove a Element3D from Items.");                              }                          }                          this.children.Clear();                          break;                      }              }
Missing Default,HelixToolkit.Wpf.SharpDX,ItemsModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ItemsModel3D.cs,ItemsModel3D_CollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Reset:                      OctreeManager?.Clear();                      OctreeManager?.RequestRebuild();                      break;              }
Missing Default,HelixToolkit.Wpf.SharpDX,ItemsModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ItemsModel3D.cs,ItemsModel3D_CollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Replace:                  case NotifyCollectionChangedAction.Remove:                      if (e.OldItems != null)                      {                          foreach (var item in e.OldItems)                          {                              if (mDictionary.ContainsKey(item))                              {                                  var model = mDictionary[item];                                  if (model is GeometryModel3D)                                      OctreeManager?.RemoveItem(model as GeometryModel3D);                                  model.DataContext = null;                                  this.Children.Remove(model);                                  mDictionary.Remove(item);                              }                          }                          InvalidateRender();                      }                      break;                  case NotifyCollectionChangedAction.Reset:                      var array = this.Children.ToArray();                      foreach (var item in array)                      {                          item.DataContext = null;                          this.Children.Remove(item);                      }                      mDictionary.Clear();                      break;              }
Missing Default,HelixToolkit.Wpf.SharpDX,ItemsModel3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ItemsModel3D.cs,ItemsModel3D_CollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Reset:                      if (this.ItemsSource != null)                      {                          if (this.ItemTemplate == null)                          {                              foreach (var item in this.ItemsSource)                              {                                  var model = item as Model3D;                                  if (model != null)                                  {                                      this.Children.Add(model);                                      mDictionary.Add(item' model);                                  }                                  else                                  {                                      throw new InvalidOperationException("Cannot create a Model3D from ItemTemplate.");                                  }                              }                          }                          else                          {                              foreach (var item in this.ItemsSource)                              {                                  var model = this.ItemTemplate.LoadContent() as Model3D;                                  if (model != null)                                  {                                      model.DataContext = item;                                      this.Children.Add(model);                                      mDictionary.Add(item' model);                                  }                                  else                                  {                                      throw new InvalidOperationException("Cannot create a Model3D from ItemTemplate.");                                  }                              }                          }                      }                      InvalidateRender();                      break;                  case NotifyCollectionChangedAction.Add:                  case NotifyCollectionChangedAction.Replace:                      if (e.NewItems != null)                      {                          if (this.ItemTemplate != null)                          {                              foreach (var item in e.NewItems)                              {                                  if (mDictionary.ContainsKey(item))                                  {                                      continue;                                  }                                  var model = this.ItemTemplate.LoadContent() as Model3D;                                  if (model != null)                                  {                                      OctreeManager?.AddPendingItem(model);                                      model.DataContext = item;                                      this.Children.Add(model);                                      mDictionary.Add(item' model);                                  }                                  else                                  {                                      throw new InvalidOperationException("Cannot create a Model3D from ItemTemplate.");                                  }                              }                          }                          else                          {                              foreach (var item in e.NewItems)                              {                                  if (mDictionary.ContainsKey(item))                                  {                                      continue;                                  }                                  var model = item as Model3D;                                  if (model != null)                                  {                                      OctreeManager?.AddPendingItem(model);                                      this.Children.Add(model);                                      mDictionary.Add(item' model);                                  }                                  else                                  {                                      throw new InvalidOperationException("Cannot create a Model3D from ItemTemplate.");                                  }                              }                          }                      }                      break;              }
Missing Default,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,Read,The following switch statement is missing a default case: switch (keyword.ToLower())                          {                              // Vertex data                              case "v": // geometric vertices                                  this.AddVertex(values);                                  break;                              case "vt": // texture vertices                                  this.AddTexCoord(values);                                  break;                              case "vn": // vertex normals                                  this.AddNormal(values);                                  break;                              case "vp": // parameter space vertices                              case "cstype": // rational or non-rational forms of curve or surface type: basis matrix' Bezier' B-spline' Cardinal' Taylor                              case "degree": // degree                              case "bmat": // basis matrix                              case "step": // step size                                  // not supported                                  break;                                // Elements                              case "f": // face                                  this.AddFace(values);                                  break;                              case "p": // point                              case "l": // line                              case "curv": // curve                              case "curv2": // 2D curve                              case "surf": // surface                                  // not supported                                  break;                                // Free-form curve/surface body statements                              case "parm": // parameter name                              case "trim": // outer trimming loop (trim)                              case "hole": // inner trimming loop (hole)                              case "scrv": // special curve (scrv)                              case "sp":  // special point (sp)                              case "end": // end statement (end)                                  // not supported                                  break;                                // Connectivity between free-form surfaces                              case "con": // connect                                  // not supported                                  break;                                // Grouping                              case "g": // group name                                  this.AddGroup(values);                                  break;                              case "s": // smoothing group                                  this.SetSmoothingGroup(values);                                  break;                              case "mg": // merging group                                  break;                              case "o": // object name                                  // not supported                                  break;                                // Display/render attributes                              case "mtllib": // material library                                  this.LoadMaterialLib(values);                                  break;                              case "usemtl": // material name                                  this.EnsureNewMesh();                                    this.SetMaterial(values);                                  break;                              case "usemap": // texture map name                                  this.EnsureNewMesh();                                    break;                              case "bevel": // bevel interpolation                              case "c_interp": // color interpolation                              case "d_interp": // dissolve interpolation                              case "lod": // level of detail                              case "shadow_obj": // shadow casting                              case "trace_obj": // ray tracing                              case "ctech": // curve approximation technique                              case "stech": // surface approximation technique                                  // not supported                                  break;                          }
Missing Default,HelixToolkit.Wpf.SharpDX,ObjReader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,LoadMaterialLib,The following switch statement is missing a default case: switch (keyword.ToLower())                      {                          case "newmtl":                              if (value != null)                              {                                  if (this.Materials.ContainsKey(value))                                  {                                      currentMaterial = null;                                  }                                  else                                  {                                      currentMaterial = new MaterialDefinition();                                      this.Materials.Add(value' currentMaterial);                                  }                              }                                break;                          case "ka":                              if (currentMaterial != null && value != null)                              {                                  currentMaterial.Ambient = ColorParse(value);                              }                                break;                          case "kd":                              if (currentMaterial != null && value != null)                              {                                  currentMaterial.Diffuse = ColorParse(value);                              }                                break;                          case "ks":                              if (currentMaterial != null && value != null)                              {                                  currentMaterial.Specular = ColorParse(value);                              }                                break;                          case "ns":                              if (currentMaterial != null && value != null)                              {                                  currentMaterial.SpecularCoefficient = DoubleParse(value);                              }                                break;                          case "d":                              if (currentMaterial != null && value != null)                              {                                  currentMaterial.Dissolved = DoubleParse(value);                              }                                break;                          case "tr":                              if (!this.SkipTransparencyValues && currentMaterial != null && value != null)                              {                                  currentMaterial.Dissolved = DoubleParse(value);                              }                                break;                          case "illum":                              if (currentMaterial != null && value != null)                              {                                  currentMaterial.Illumination = int.Parse(value);                              }                                break;                          case "map_ka":                              if (currentMaterial != null)                              {                                  currentMaterial.AmbientMap = value;                              }                                break;                          case "map_kd":                              if (currentMaterial != null)                              {                                  currentMaterial.DiffuseMap = value;                              }                                break;                          case "map_ks":                              if (currentMaterial != null)                              {                                  currentMaterial.SpecularMap = value;                              }                                break;                          case "map_d":                              if (currentMaterial != null)                              {                                  currentMaterial.AlphaMap = value;                              }                                break;                          case "map_bump":                          case "bump":                              if (currentMaterial != null)                              {                                  currentMaterial.BumpMap = value;                              }                                break;                      }
Missing Default,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,CalculateDiagonals,The following switch statement is missing a default case: switch (evClass)                  {                      case PolygonPointClass.Start:                          // Just add the left Edge (depending on the sweeping direction)                          statusAndHelper.Add(new StatusHelperElement(sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));                          break;                      case PolygonPointClass.Stop:                          // Just remove the left Edge (depending on the sweeping direction)                          statusAndHelper.Remove(sweepDown ? ev.EdgeOne : ev.EdgeTwo);                          break;                      case PolygonPointClass.Regular:                          // If the Polygon is positioned on the right Side of this Event                          if (ev.Last > ev.Next)                          {                              // Replace the corresponding (old) StatusHelperElement with the new one                              statusAndHelper.Remove(sweepDown ? ev.EdgeOne : ev.EdgeTwo);                              statusAndHelper.Add(new StatusHelperElement(sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));                          }                          else                          {                              // Search Edge left of the Event and set Event as it's Helper                              she = statusAndHelper.SearchLeft(ev);                              she.Helper = ev;                          }                          break;                      case PolygonPointClass.Merge:                          // Just remove the left Edge (depending on the sweeping direction)                          statusAndHelper.Remove(sweepDown ? ev.EdgeOne : ev.EdgeTwo);                          // Search Edge left of the Event and set Event as it's Helper                          she = statusAndHelper.SearchLeft(ev);                          she.Helper = ev;                          break;                      case PolygonPointClass.Split:                          // Search Edge left of the Event                          she = statusAndHelper.SearchLeft(ev);                          // Chose diagonal from Helper of Edge to Event.                          var minP = Math.Min(she.Helper.Index' ev.Index);                          var maxP = Math.Max(she.Helper.Index' ev.Index);                          var diagonal = new Tuple<int' int>(minP' maxP);                          diagonals.Add(diagonal);                            // Replace the Helper of the StatusHelperElement by Event                          she.Helper = ev;                          // Insert the right Edge from Event                          statusAndHelper.Add(new StatusHelperElement(sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));                          break;                  }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following switch statement is missing a default case: switch ((DXGI.Format) description.Format)                  {                      case Format.B8G8R8A8_UNorm:                          description.Format = Format.R8G8B8A8_UNorm;                          convFlags |= ConversionFlags.Swizzle;                          break;                        case Format.B8G8R8X8_UNorm:                          description.Format = Format.R8G8B8A8_UNorm;                          convFlags |= ConversionFlags.Swizzle | ConversionFlags.NoAlpha;                          break;                        case Format.B8G8R8A8_Typeless:                          description.Format = Format.R8G8B8A8_Typeless;                          convFlags |= ConversionFlags.Swizzle;                          break;                        case Format.B8G8R8A8_UNorm_SRgb:                          description.Format = Format.R8G8B8A8_UNorm_SRgb;                          convFlags |= ConversionFlags.Swizzle;                          break;                        case Format.B8G8R8X8_Typeless:                          description.Format = Format.R8G8B8A8_Typeless;                          convFlags |= ConversionFlags.Swizzle | ConversionFlags.NoAlpha;                          break;                        case Format.B8G8R8X8_UNorm_SRgb:                          description.Format = Format.R8G8B8A8_UNorm_SRgb;                          convFlags |= ConversionFlags.Swizzle | ConversionFlags.NoAlpha;                          break;                  }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following switch statement is missing a default case: switch ((DXGI.Format) description.Format)                  {                      case Format.B5G6R5_UNorm:                      case Format.B5G5R5A1_UNorm:  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:  #endif                          description.Format = Format.R8G8B8A8_UNorm;                          convFlags |= ConversionFlags.Expand;                          if (description.Format == Format.B5G6R5_UNorm)                              convFlags |= ConversionFlags.NoAlpha;                          break;                  }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following switch statement is missing a default case: switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following switch statement is missing a default case: switch (description.Dimension)              {                  case TextureDimension.Texture1D:                      header->Height = description.Height;                      header->Width = header->Depth = 1;                      break;                    case TextureDimension.Texture2D:                  case TextureDimension.TextureCube:                      header->Height = description.Height;                      header->Width = description.Width;                      header->Depth = 1;                        if (description.Dimension == TextureDimension.TextureCube)                      {                          header->SurfaceFlags |= DDS.SurfaceFlags.Cubemap;                          header->CubemapFlags |= DDS.CubemapFlags.AllFaces;                      }                      break;                    case TextureDimension.Texture3D:                        header->Flags |= DDS.HeaderFlags.Volume;                      header->CubemapFlags |= DDS.CubemapFlags.Volume;                      header->Height = description.Height;                      header->Width = description.Width;                      header->Depth = description.Depth;                      break;              }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following switch statement is missing a default case: switch (description.Dimension)                  {                      case TextureDimension.Texture1D:                          ext->ResourceDimension = ResourceDimension.Texture1D;                          break;                      case TextureDimension.Texture2D:                      case TextureDimension.TextureCube:                          ext->ResourceDimension = ResourceDimension.Texture2D;                          break;                      case TextureDimension.Texture3D:                          ext->ResourceDimension = ResourceDimension.Texture3D;                          break;                    }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following switch statement is missing a default case: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following switch statement is missing a default case: switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following switch statement is missing a default case: switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following switch statement is missing a default case: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following switch statement is missing a default case: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following switch statement is missing a default case: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Missing Default,SharpDX.Toolkit.Graphics,DepthStencilBuffer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,ComputeViewFormat,The following switch statement is missing a default case: switch (format)              {                  case SharpDX.DXGI.Format.D16_UNorm:                  case DXGI.Format.R16_Float:                  case DXGI.Format.R16_Typeless:                      return DepthFormat.Depth16;                    case SharpDX.DXGI.Format.D32_Float:                  case DXGI.Format.R32_Float:                  case DXGI.Format.R32_Typeless:                      return DepthFormat.Depth32;                    case SharpDX.DXGI.Format.D24_UNorm_S8_UInt:                  case SharpDX.DXGI.Format.R24_UNorm_X8_Typeless:                      return DepthFormat.Depth24Stencil8;                    case SharpDX.DXGI.Format.D32_Float_S8X24_UInt:                  case SharpDX.DXGI.Format.R32_Float_X8X24_Typeless:                      return DepthFormat.Depth32Stencil8X24;              }
Missing Default,SharpDX.Toolkit.Graphics,GraphicsResource,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\GraphicsResource.cs,GetCpuAccessFlagsFromUsage,The following switch statement is missing a default case: switch (usage)              {                  case ResourceUsage.Dynamic:                      return CpuAccessFlags.Write;                  case ResourceUsage.Staging:                      return CpuAccessFlags.Read | CpuAccessFlags.Write;              }
Missing Default,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The following switch statement is missing a default case: switch (description.Dimension)              {                  case TextureDimension.Texture1D:                      if (description.Width <= 0 || description.Height != 1 || description.Depth != 1 || description.ArraySize == 0)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 1D");                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' 1' description.MipLevels);                      break;                    case TextureDimension.Texture2D:                  case TextureDimension.TextureCube:                      if (description.Width <= 0 || description.Height <= 0 || description.Depth != 1 || description.ArraySize == 0)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 2D");                        if (description.Dimension == TextureDimension.TextureCube)                      {                          if ((description.ArraySize % 6) != 0)                              throw new InvalidOperationException("TextureCube must have an arraysize = 6");                      }                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.MipLevels);                      break;                    case TextureDimension.Texture3D:                      if (description.Width <= 0 || description.Height <= 0 || description.Depth <= 0 || description.ArraySize != 1)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 3D");                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.Depth' description.MipLevels);                      break;              }
Missing Default,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,New,The following switch statement is missing a default case: switch (description.Dimension)                  {                      case TextureDimension.Texture1D:                          return RenderTarget1D.New(graphicsDevice' description);                      case TextureDimension.Texture2D:                          return RenderTarget2D.New(graphicsDevice' description);                      case TextureDimension.Texture3D:                          return RenderTarget3D.New(graphicsDevice' description);                      case TextureDimension.TextureCube:                          return RenderTargetCube.New(graphicsDevice' description);                  }
Missing Default,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,New,The following switch statement is missing a default case: switch (description.Dimension)                  {                      case TextureDimension.Texture1D:                          return Texture1D.New(graphicsDevice' description);                      case TextureDimension.Texture2D:                          return Texture2D.New(graphicsDevice' description);                      case TextureDimension.Texture3D:                          return Texture3D.New(graphicsDevice' description);                      case TextureDimension.TextureCube:                          return TextureCube.New(graphicsDevice' description);                  }
Missing Default,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,Load,The following switch statement is missing a default case: switch (image.Description.Dimension)                  {                      case TextureDimension.Texture1D:                          return Texture1D.New(device' image' flags' usage);                      case TextureDimension.Texture2D:                          return Texture2D.New(device' image' flags' usage);                      case TextureDimension.Texture3D:                          return Texture3D.New(device' image' flags' usage);                      case TextureDimension.TextureCube:                          return TextureCube.New(device' image' flags' usage);                  }
Missing Default,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,ToWIC,The following switch statement is missing a default case: switch (format)              {                  case SharpDX.DXGI.Format.R8G8B8A8_UNorm_SRgb:                      guid = SharpDX.WIC.PixelFormat.Format32bppRGBA;                      return true;                    case SharpDX.DXGI.Format.D32_Float:                      guid = SharpDX.WIC.PixelFormat.Format32bppGrayFloat;                      return true;                    case SharpDX.DXGI.Format.D16_UNorm:                      guid = SharpDX.WIC.PixelFormat.Format16bppGray;                      return true;                    case SharpDX.DXGI.Format.B8G8R8A8_UNorm_SRgb:                      guid = SharpDX.WIC.PixelFormat.Format32bppBGRA;                      return true;                    case SharpDX.DXGI.Format.B8G8R8X8_UNorm_SRgb:                      guid = SharpDX.WIC.PixelFormat.Format32bppBGR;                      return true;              }
Missing Default,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,DetermineFormat,The following switch statement is missing a default case: switch (format)              {                  case DXGI.Format.B8G8R8A8_UNorm: // BGRA                  case DXGI.Format.B8G8R8X8_UNorm: // BGRX                      if ((flags & WICFlags.ForceRgb) != 0)                      {                          format = DXGI.Format.R8G8B8A8_UNorm;                          pixelFormatOut = WIC.PixelFormat.Format32bppRGBA;                      }                      break;                    case DXGI.Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & WICFlags.NoX2Bias) != 0)                      {                          format = DXGI.Format.R10G10B10A2_UNorm;                          pixelFormatOut = WIC.PixelFormat.Format32bppRGBA1010102;                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                  case DXGI.Format.B5G6R5_UNorm:                      if ((flags & WICFlags.No16Bpp) != 0)                      {                          format = DXGI.Format.R8G8B8A8_UNorm;                          pixelFormatOut = WIC.PixelFormat.Format32bppRGBA;                      }                      break;                    case DXGI.Format.R1_UNorm:                      if ((flags & WICFlags.FlagsAllowMono) == 0)                      {                          // By default we want to promote a black & white to greyscale since R1 is not a generally supported D3D format                          format = DXGI.Format.R8_UNorm;                          pixelFormatOut = WIC.PixelFormat.Format8bppGray;                      }                      break;              }
