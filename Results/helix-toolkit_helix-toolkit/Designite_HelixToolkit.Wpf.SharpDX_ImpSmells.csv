Implementation smell,Namespace,Class,File,Method,Description
Long Method,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The method has 102 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitGBuffer,The method has 139 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The method has 154 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The method has 139 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMaterial,The method has 113 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,Read,The method has 142 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The method has 125 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The method has 101 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The method has 168 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,The method has 111 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The method has 140 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The method has 204 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The method has 155 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The method has 179 lines of code.
Complex Method,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,Cyclomatic complexity of the method is 60
Complex Method,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,Cyclomatic complexity of the method is 14
Complex Method,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,Render,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnApplyTemplate,Cyclomatic complexity of the method is 14
Complex Method,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnCameraChanged,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,DX11ImageSource,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DX11ImageSource.cs,SetRenderTargetDX11,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,GetBestAdapter,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,Rotate,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,Started,Cyclomatic complexity of the method is 17
Complex Method,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Zoom,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ZoomByChangingCameraWidth,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRender,Cyclomatic complexity of the method is 20
Complex Method,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,Cyclomatic complexity of the method is 15
Complex Method,HelixToolkit.Wpf.SharpDX,BillboardText3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardText3D.cs,DrawTexture,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,BuildSubTree,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTest,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindNearestPointFromPoint,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,Expand,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindNearestPointBySphereExcludeChild,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,PointGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,PointGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindNearestPointBySphereExcludeChild,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,Cyclomatic complexity of the method is 22
Complex Method,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,Read,Cyclomatic complexity of the method is 19
Complex Method,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,Cyclomatic complexity of the method is 27
Complex Method,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,Cyclomatic complexity of the method is 24
Complex Method,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadFaceSets,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,CompositeModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CompositeModel3D.cs,ChildrenChanged,Cyclomatic complexity of the method is 16
Complex Method,HelixToolkit.Wpf.SharpDX,Items3DControl,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\Items3DControl.cs,OnItemsChanged,Cyclomatic complexity of the method is 21
Complex Method,HelixToolkit.Wpf.SharpDX,Items3DControl,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\Items3DControl.cs,OnItemsSourceChanged,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf.SharpDX,ItemsModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ItemsModel3D.cs,ItemsSourceChanged,Cyclomatic complexity of the method is 13
Complex Method,HelixToolkit.Wpf.SharpDX,ItemsModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ItemsModel3D.cs,ItemsModel3D_CollectionChanged,Cyclomatic complexity of the method is 38
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,ShadowMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateGrid,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GetLineToLineDistance,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMesh,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,Read,Cyclomatic complexity of the method is 70
Complex Method,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,Cyclomatic complexity of the method is 28
Complex Method,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,LoadMaterialLib,Cyclomatic complexity of the method is 59
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormalsAndTangents,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddLoftedGeometry,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,Cyclomatic complexity of the method is 27
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangles,Cyclomatic complexity of the method is 13
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,Cyclomatic complexity of the method is 14
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,Cyclomatic complexity of the method is 15
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Append,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Simplify,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,Cyclomatic complexity of the method is 13
Complex Method,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,Cyclomatic complexity of the method is 17
Complex Method,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,CalculateDiagonals,Cyclomatic complexity of the method is 25
Complex Method,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourFacet,Cyclomatic complexity of the method is 30
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometry3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\MeshGeometry3D.cs,Merge,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX.Utilities,TokenizerHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TokenizerHelper.cs,NextToken,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX.Utilities,TokenizerHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TokenizerHelper.cs,ScanToNextToken,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,Cyclomatic complexity of the method is 12
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,GetDXGIFormat,Cyclomatic complexity of the method is 10
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,Cyclomatic complexity of the method is 68
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,Cyclomatic complexity of the method is 134
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,Cyclomatic complexity of the method is 26
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,Cyclomatic complexity of the method is 18
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,Cyclomatic complexity of the method is 8
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,Cyclomatic complexity of the method is 51
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,Cyclomatic complexity of the method is 23
Complex Method,SharpDX.Toolkit.Graphics,DepthStencilBuffer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,ComputeViewFormat,Cyclomatic complexity of the method is 17
Complex Method,SharpDX.Toolkit.Graphics,DepthStencilBuffer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,ComputeViewFormat,Cyclomatic complexity of the method is 10
Complex Method,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,Cyclomatic complexity of the method is 21
Complex Method,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,CalculateImageArray,Cyclomatic complexity of the method is 8
Complex Method,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Save,Cyclomatic complexity of the method is 29
Complex Method,SharpDX.Toolkit.Graphics,Texture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,New,Cyclomatic complexity of the method is 10
Complex Method,SharpDX.Toolkit.Graphics,Texture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetViewSliceBounds,Cyclomatic complexity of the method is 22
Complex Method,SharpDX.Toolkit.Graphics,Texture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,OnPropertyChanged,Cyclomatic complexity of the method is 12
Complex Method,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,ToWIC,Cyclomatic complexity of the method is 12
Complex Method,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,DetermineFormat,Cyclomatic complexity of the method is 21
Complex Method,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,DecodeMultiframe,Cyclomatic complexity of the method is 13
Complex Method,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,LoadFromWICMemory,Cyclomatic complexity of the method is 9
Complex Method,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,Cyclomatic complexity of the method is 10
Complex Method,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeMultiframe,Cyclomatic complexity of the method is 9
Complex Method,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,GetContainerFormatFromFileType,Cyclomatic complexity of the method is 8
Long Parameter List,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,LookAt,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,RenderUtil,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\RenderUtil.cs,CreateBuffer,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,Copy,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,FindNearest,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,BitmapExtension,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\BitmapExtension.cs,StringToBitmapSource,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,BitmapExtension,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\BitmapExtension.cs,StringToBitmapSource,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,BitmapExtension,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\BitmapExtension.cs,StringToBitmapSource,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,BillboardText3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardText3D.cs,DrawCharacter,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,AffectsRenderFrameworkPropertyMetadata,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\AffectsRenderPropertyMetadata.cs,AffectsRenderFrameworkPropertyMetadata,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,AffectsRenderFrameworkPropertyMetadata,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\AffectsRenderPropertyMetadata.cs,AffectsRenderFrameworkPropertyMetadata,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,IOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTest,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,IOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,OctreeBase,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,TreeTraversal,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTest,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,PushExistingToChild,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindSmallestNodeContainsBoundingBox,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindChildByItemBound,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,MeshGeometryOctree,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,MeshGeometryOctree,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,PointGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,PointGeometryOctree,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,PointGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,GeometryModel3DOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,GeometryModel3DOctree,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,GeometryModel3DOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,InstancingModel3DOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,InstancingModel3DOctree,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,InstancingModel3DOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,CreateMesh,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,Mouse3DEventArgs,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\GeometryModel3D.cs,Mouse3DEventArgs,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddGrid,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateGrid,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GetPointToLineDistance2D,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GetRayToLineDistance,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GetLineToLineDistance,The method has 9 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddArrow,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBox,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBox,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCone,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCone,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndices,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 6 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 10 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourFacet,The method has 7 parameters.
Long Parameter List,HelixToolkit.Wpf.SharpDX.Utilities,ConstantBufferProxy,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\BufferProxy.cs,ConstantBufferProxy,The method has 5 parameters.
Long Parameter List,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,InsideTriangle,The method has 8 parameters.
Long Parameter List,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Snip,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The method has 8 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The method has 8 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SaveToDDSStream,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Image,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New2D,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New3D,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New1D,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New2D,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New3D,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,CreateDescription,The method has 7 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The method has 8 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,SetupImageArray,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Save,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,MipMapDescription,The method has 7 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,PixelBuffer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs,PixelBuffer,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget1D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,New,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget1D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,New,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget1D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,NewRenderTargetDescription,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,New,The method has 7 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,New,The method has 8 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,NewRenderTargetDescription,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTargetCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTargetCube.cs,New,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetDataBox,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetViewSliceBounds,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The method has 7 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1DBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1DBase.cs,NewDescription,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 7 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 8 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 7 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 9 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2DBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,NewDescription,The method has 7 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 7 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 8 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 8 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 9 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3DBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3DBase.cs,NewDescription,The method has 7 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 6 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,NewTextureCubeDescription,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeMultiframe,The method has 5 parameters.
Long Parameter List,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,SaveToWICMemory,The method has 5 parameters.
Long Identifier,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the parameter billboardInstancingInputLayout is 30.
Long Identifier,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The length of the parameter containsHomogeneousCoordinates is 30.
Long Identifier,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The length of the parameter nextLineContainsVertexDimension is 31.
Long Identifier,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The length of the parameter nextLineContainsNumberOfVertices is 32.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The length of the statement  "	//// System.Diagnostics.Debug.WriteLine("OnManipulationDelta: T={0}' S={1}' R={2}' O={3}"' e.DeltaManipulation.Translation' e.DeltaManipulation.Scale' e.DeltaManipulation.Rotation' e.ManipulationOrigin); " is 203.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The length of the statement  "	//// System.Diagnostics.Debug.WriteLine(n + " Delta:" + e.DeltaManipulation.Translation + " Origin:" + e.ManipulationOrigin + " pos:" + position); " is 146.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The length of the statement  "		var zoomAroundPoint = this.zoomHandler.UnProject (e.ManipulationOrigin' this.zoomHandler.Origin' this.CameraLookDirection); " is 123.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnTimeStep,The length of the statement  "		this.rotateHandler.Rotate (this.spinningPosition' this.spinningPosition + (this.spinningSpeed * time)' this.spinningPoint3D); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnTimeStep,The length of the statement  "		this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + (this.rotationSpeed * time)' this.rotationPoint3D); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitBuffers,The length of the statement  "	this.deferredLightingVariables = new DeferredLightingVariables (renderHost.EffectsManager' renderHost.RenderTechniquesManager); " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitBuffers,The length of the statement  "	this.screenSpaceVariables = new ScreenSpaceProcessingVariables (renderHost.EffectsManager' renderHost.RenderTechniquesManager); " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The length of the statement  "		context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0); " is 137.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The length of the statement  "		context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (midX' 0' 0' 2 * midX' midY' 1)' renderTarget' 0' midX' 0' 0); " is 147.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The length of the statement  "		context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' midY' 0' midX' 2 * midY' 1)' renderTarget' 0' 0' midY' 0); " is 147.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The length of the statement  "		context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (midX' midY' 0' 2 * midX' 2 * midY' 1)' renderTarget' 0' midX' midY' 0); " is 157.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The length of the statement  "		context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0); " is 137.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The length of the statement  "		context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' 0' 0); " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The length of the statement  "		context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' midY' 0); " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The length of the statement  "		context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' midY' 0); " is 143.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderLighting,The length of the statement  "	var lights = lightsCollection.Where (l => l is Light3D).Concat (lightsCollection.Where (l => l is Light3DCollection).SelectMany (x => (x as Light3DCollection).Children.Select (xx => xx as ILight3D))); " is 200.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderLighting,The length of the statement  "		var spot = new Vector4 ((float)Math.Cos (light.OuterAngle / 360.0 * Math.PI)' (float)Math.Cos (light.InnerAngle / 360.0 * Math.PI)' (float)light.Falloff' 0); " is 157.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderLighting,The length of the statement  "		Matrix lightModelMatrix = new Matrix (baseX.X * scaleX' baseX.Y * scaleX' baseX.Z * scaleX' 0f' baseY.X * scaleYZ' baseY.Y * scaleYZ' baseY.Z * scaleYZ' 0f' baseZ.X * scaleYZ' baseZ.Y * scaleYZ' baseZ.Z * scaleYZ' 0f' (float)light.Position.X' (float)light.Position.Y' (float)light.Position.Z' 1.0f); " is 299.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderScreenSpaceAO,The length of the statement  "	this.deferredLightingVariables.vInvViewportSize.Set (new Vector4 (1.0f / (float)contxt.Canvas.ActualWidth' 1.0f / (float)contxt.Canvas.ActualHeight' 0.0f' 0.0f)); " is 162.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitGBuffer,The length of the statement  "		this.gBufferShaderResourceView [i] = new ShaderResourceView (this.device' this.gBuffer [i]' new ShaderResourceViewDescription () { " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitGBuffer,The length of the statement  "	this.gBufferDepthStencilResourceView = new ShaderResourceView (device' this.depthStencilBuffer' new ShaderResourceViewDescription () { " is 134.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitGBuffer,The length of the statement  "                this.gBufferShaderResourceView[i] = new ShaderResourceView(this.device' this.gBuffer[i]' new ShaderResourceViewDescription()" is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitGBuffer,The length of the statement  "            this.gBufferDepthStencilResourceView = new ShaderResourceView(device' depthStencilBuffer' new ShaderResourceViewDescription()" is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,ClearRenderTargetViews,The length of the statement  "	this.device.ImmediateContext.ClearDepthStencilView (this.depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 153.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitSphereBuffer,The length of the statement  "		IndexBuffer = this.device.CreateBuffer (BindFlags.IndexBuffer' sizeof(int)' meshGeometry.Indices.Array' meshGeometry.Indices.Count)' " is 132.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitConeBuffer,The length of the statement  "		IndexBuffer = this.device.CreateBuffer (BindFlags.IndexBuffer' sizeof(int)' meshGeometry.Indices.Array' meshGeometry.Indices.Count)' " is 132.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,BindQuadBuffer,The length of the statement  "	context.DeviceContext.InputAssembler.SetVertexBuffers (0' new VertexBufferBinding (this.screenQuad.VertexBuffer' Vector4.SizeInBytes' 0)); " is 138.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,BindSphereBuffer,The length of the statement  "	context.DeviceContext.InputAssembler.SetVertexBuffers (0' new VertexBufferBinding (this.screenSphere.VertexBuffer' Vector4.SizeInBytes' 0)); " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,BindConeBuffer,The length of the statement  "	context.DeviceContext.InputAssembler.SetVertexBuffers (0' new VertexBufferBinding (this.screenCone.VertexBuffer' Vector4.SizeInBytes' 0)); " is 138.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitSSBuffer,The length of the statement  "		this.ssBufferShaderResourceView [i] = new ShaderResourceView (this.device' this.ssBuffer [i]' new ShaderResourceViewDescription () { " is 132.
Long Statement,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitSSBuffer,The length of the statement  "	this.randNormalMapShaderResourceView = TextureLoader.FromFileAsShaderResourceView (device' @"./Textures/random4x4_dot3.png"); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,InvalidateRender,The length of the statement  "	//                //But this is required for mouse rotation' because it requires invalidate asap (Input priority is higher than background). " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,OnLoaded,The length of the statement  "		// https://social.msdn.microsoft.com/Forums/vstudio/en-US/9ed3d13d-0b9f-48ac-ae8d-daf0845c9e8f/bug-in-wpf-windowloaded-exception-handling?forum=wpf " is 147.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,SetDefaultColorTargets,The length of the statement  "	device.ImmediateContext.Rasterizer.SetViewport (0' 0' colorBuffer.Description.Width' colorBuffer.Description.Height' 0.0f' 1.0f); " is 129.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,SetDefaultColorTargets,The length of the statement  "	device.ImmediateContext.ClearDepthStencilView (depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 143.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,ClearRenderTarget,The length of the statement  "		device.ImmediateContext.ClearDepthStencilView (depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 143.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,Render,The length of the statement  "				RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique; " is 173.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,RenderTechniquesManagerPropertyChanged,The length of the statement  "		IsDeferredLighting = (renderTechnique == RenderTechniquesManager.RenderTechniques.Get (DeferredRenderTechniqueNames.Deferred) || renderTechnique == RenderTechniquesManager.RenderTechniques.Get (DeferredRenderTechniqueNames.GBuffer)); " is 233.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,InvalidateRender,The length of the statement  "				//But this is required for mouse rotation' because it requires invalidate asap (Input priority is higher than background). " is 122.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,OnLoaded,The length of the statement  "		// https://social.msdn.microsoft.com/Forums/vstudio/en-US/9ed3d13d-0b9f-48ac-ae8d-daf0845c9e8f/bug-in-wpf-windowloaded-exception-handling?forum=wpf " is 147.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,SetDefaultColorTargets,The length of the statement  "	device.ImmediateContext.Rasterizer.SetViewport (0' 0' colorBuffer.Description.Width' colorBuffer.Description.Height' 0.0f' 1.0f); " is 129.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,ClearRenderTarget,The length of the statement  "		//  device.ImmediateContext.ClearDepthStencilView(depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 146.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,ClearRenderTarget,The length of the statement  "		renderContext.DeviceContext.ClearDepthStencilView (depthStencilBufferView' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 147.
Long Statement,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,The length of the statement  "				RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique; " is 173.
Long Statement,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,ShowZoomRectangle,The length of the statement  "	this.rectangleAdorner = new RectangleAdorner (visual' rect' Colors.LightGray' Colors.Black' 3' 1' 10' DashStyles.Solid); " is 120.
Long Statement,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,SetDefaultGestures,The length of the statement  "	this.InputBindings.Add (new MouseBinding (ViewportCommands.ZoomExtents' new MouseGesture (MouseAction.LeftDoubleClick' ModifierKeys.Control))); " is 143.
Long Statement,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,SetDefaultGestures,The length of the statement  "	this.InputBindings.Add (new MouseBinding (ViewportCommands.Rotate' new MouseGesture (MouseAction.RightClick' ModifierKeys.None))); " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,SetDefaultGestures,The length of the statement  "	this.InputBindings.Add (new MouseBinding (ViewportCommands.Zoom' new MouseGesture (MouseAction.RightClick' ModifierKeys.Control))); " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,SetDefaultGestures,The length of the statement  "	this.InputBindings.Add (new MouseBinding (ViewportCommands.Pan' new MouseGesture (MouseAction.RightClick' ModifierKeys.Shift))); " is 128.
Long Statement,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,SetDefaultGestures,The length of the statement  "	this.InputBindings.Add (new MouseBinding (ViewportCommands.ChangeFieldOfView' new MouseGesture (MouseAction.RightClick' ModifierKeys.Alt))); " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,SetDefaultGestures,The length of the statement  "	this.InputBindings.Add (new MouseBinding (ViewportCommands.ZoomRectangle' new MouseGesture (MouseAction.RightClick' ModifierKeys.Control | ModifierKeys.Shift))); " is 161.
Long Statement,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,SetDefaultGestures,The length of the statement  "	this.InputBindings.Add (new MouseBinding (ViewportCommands.SetTarget' new MouseGesture (MouseAction.RightDoubleClick' ModifierKeys.Control))); " is 142.
Long Statement,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,SetDefaultGestures,The length of the statement  "	this.InputBindings.Add (new MouseBinding (ViewportCommands.Reset' new MouseGesture (MouseAction.MiddleDoubleClick' ModifierKeys.Control))); " is 139.
Long Statement,HelixToolkit.Wpf.SharpDX,Ray3,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Core\Ray3.cs,GetNearest,The length of the statement  "	var u = (((p3.X - this.Origin.X) * this.Direction.X) + ((p3.Y - this.Origin.Y) * this.Direction.Y) + ((p3.Z - this.Origin.Z) * this.Direction.Z)) / l; " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,Ray3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Core\Ray3D.cs,GetNearest,The length of the statement  "	double u = ((p3.X - this.Origin.X) * this.Direction.X + (p3.Y - this.Origin.Y) * this.Direction.Y + (p3.Z - this.Origin.Z) * this.Direction.Z) / l; " is 147.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The length of the statement  "		var a2 = new Vector3DAnimation (fromDirection' newDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) { " is 120.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The length of the statement  "		var a3 = new Vector3DAnimation (fromUpDirection' newUpDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) { " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,GetInfo,The length of the statement  "		sb.AppendLine (string.Format (CultureInfo.InvariantCulture' "LookDirection:\t{0:0.000}'{1:0.000}'{2:0.000}"' projectionCamera.LookDirection.X' projectionCamera.LookDirection.Y' projectionCamera.LookDirection.Z)); " is 212.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,GetInfo,The length of the statement  "		sb.AppendLine (string.Format (CultureInfo.InvariantCulture' "UpDirection:\t{0:0.000}'{1:0.000}'{2:0.000}"' projectionCamera.UpDirection.X' projectionCamera.UpDirection.Y' projectionCamera.UpDirection.Z)); " is 204.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,GetInfo,The length of the statement  "		sb.AppendLine (string.Format (CultureInfo.InvariantCulture' "Position:\t\t{0:0.000}'{1:0.000}'{2:0.000}"' projectionCamera.Position.X' projectionCamera.Position.Y' projectionCamera.Position.Z)); " is 194.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,GetInfo,The length of the statement  "		sb.AppendLine (string.Format (CultureInfo.InvariantCulture' "Target:\t\t{0:0.000}'{1:0.000}'{2:0.000}"' target.X' target.Y' target.Z)); " is 135.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,GetInfo,The length of the statement  "		sb.AppendLine (string.Format (CultureInfo.InvariantCulture' "NearPlaneDist:\t{0}"' projectionCamera.NearPlaneDistance)); " is 120.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,GetViewMatrix,The length of the statement  "		return Matrix.LookAtRH (projcam.Position.ToVector3 ()' (projcam.Position + projcam.LookDirection).ToVector3 ()' projcam.UpDirection.ToVector3 ()); " is 146.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,InverseViewMatrix,The length of the statement  "	return new Matrix (viewMatrix.M11' viewMatrix.M21' viewMatrix.M31' 0' viewMatrix.M12' viewMatrix.M22' viewMatrix.M32' 0' viewMatrix.M13' viewMatrix.M23' viewMatrix.M33' 0' -x' -y' -z' 1); " is 187.
Long Statement,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomToRectangle,The length of the statement  "	var centerRay = viewport.UnProjectToRay (new Point ((zoomRectangle.Left + zoomRectangle.Right) * 0.5' (zoomRectangle.Top + zoomRectangle.Bottom) * 0.5)); " is 153.
Long Statement,HelixToolkit.Wpf.SharpDX,DX11ImageSource,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DX11ImageSource.cs,SetRenderTargetDX11,The length of the statement  "		this.renderTarget = new Texture (DX11ImageSource.device' target.Description.Width' target.Description.Height' 1' Usage.RenderTarget' format' Pool.Default' ref handle); " is 167.
Long Statement,HelixToolkit.Wpf.SharpDX,DX11ImageSource,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DX11ImageSource.cs,StartD3D,The length of the statement  "	device = new DeviceEx (context' this.adapterIndex' DeviceType.Hardware' IntPtr.Zero' CreateFlags.HardwareVertexProcessing | CreateFlags.Multithreaded | CreateFlags.FpuPreserve' presentparams); " is 192.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,GetBestAdapter,The length of the statement  "			if ((bestAdapter == null) || (videoMemory > bestVideoMemory) || ((videoMemory == bestVideoMemory) && (systemMemory > bestSystemMemory))) { " is 138.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "		defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] { " is 168.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "		var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] { " is 195.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 128.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 128.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 128.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "		var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] { " is 191.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "		var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] { " is 170.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "		cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] { " is 172.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "		var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] { " is 173.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "		var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] { " is 181.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "		var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] { " is 212.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)' " is 131.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 128.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "			new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)' " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The length of the statement  "		//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm) " is 128.
Long Statement,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterEffect,The length of the statement  "	#            var preprocess = ShaderBytecode.Preprocess(shaderEffectString' preposessMacros.ToArray()' new IncludeHandler());" is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,TessellationEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterTessellationLayoutsAndEffects,The length of the statement  "	var tessellationInputLayout = new InputLayout (device' GetEffect (tesselation).GetTechniqueByName (TessellationRenderTechniqueNames.PNTriangles).GetPassByIndex (0).Description.Signature' new[] { " is 194.
Long Statement,HelixToolkit.Wpf.SharpDX,FpsCounter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\FpsCounter.cs,TrimFrames,The length of the statement  "	while (m_frames.Count > 10 && Math.Abs (m_frames.Last - m_frames.First) > MinimumUpdateDuration && (target > m_frames.First || m_frames.First > m_frames.Last || m_frames.IsFull ()))//the second condition happened when switching tabs' the TotalMilliseconds reset to 0 from composite rendering " is 291.
Long Statement,HelixToolkit.Wpf.SharpDX,MouseGestureHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\MouseGestureHandler.cs,SetMouseDownPoint,The length of the statement  "	if (!this.Viewport.FixedRotationPointEnabled && this.Viewport.FindNearest (this.MouseDownPoint' out nearestPoint' out normal' out visual)) { " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,OnInertiaStarting,The length of the statement  "	this.Viewport.StartSpin (4 * delta * ((double)this.Viewport.SpinReleaseTime / elapsedTime)' this.MouseDownPoint' this.rotationPoint3D); " is 135.
Long Statement,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ChangeCameraDistance,The length of the statement  "	if (newDistance > this.Viewport.ZoomDistanceLimitFar && (oldDistance < this.Viewport.ZoomDistanceLimitFar || newDistance > oldDistance)) { " is 138.
Long Statement,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ChangeCameraDistance,The length of the statement  "	if (newDistance < this.Viewport.ZoomDistanceLimitNear && (oldDistance > this.Viewport.ZoomDistanceLimitNear || newDistance < oldDistance)) { " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetViewProjectionMatrix,The length of the statement  "	return viewport.RenderContext != null ? viewport.RenderContext.ViewMatrix * viewport.RenderContext.ProjectionMatrix : viewport.Camera.GetViewProjectionMatrix (viewport.ActualWidth / viewport.ActualHeight); " is 205.
Long Statement,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetProjectionMatrix,The length of the statement  "	return viewport.RenderContext != null ? viewport.RenderContext.ProjectionMatrix : viewport.Camera.GetProjectionMatrix (viewport.ActualWidth / viewport.ActualHeight); " is 165.
Long Statement,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetViewportMatrix,The length of the statement  "	return new Matrix ((float)(viewport.ActualWidth / 2)' 0' 0' 0' 0' (float)(-viewport.ActualHeight / 2)' 0' 0' 0' 0' 1' 0' (float)((viewport.ActualWidth - 1) / 2)' (float)((viewport.ActualHeight - 1) / 2)' 0' 1); " is 210.
Long Statement,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The length of the statement  "	var target = new WriteableBitmap ((int)view.ActualWidth * m' (int)view.ActualHeight * m' 96' 96' PixelFormats.Pbgra32' null); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The length of the statement  "			var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32); " is 121.
Long Statement,HelixToolkit.Wpf.SharpDX,BitmapExtension,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\BitmapExtension.cs,ToBitmapSource,The length of the statement  "	var target = new RenderTargetBitmap ((int)(element.RenderSize.Width)' (int)(element.RenderSize.Height)' 96' 96' System.Windows.Media.PixelFormats.Pbgra32); " is 155.
Long Statement,HelixToolkit.Wpf.SharpDX,BitmapExtension,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\BitmapExtension.cs,StringToBitmapSource,The length of the statement  "	return StringToBitmapSource (str' fontSize' foreground' background' fontFamily' fontWeight' FontStyles.Normal' new Thickness (0)); " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,BitmapExtension,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\BitmapExtension.cs,MeasureString,The length of the statement  "	var formattedText = new Media.FormattedText (textBlock.Text' CultureInfo.CurrentUICulture' FlowDirection.LeftToRight' new Media.Typeface (textBlock.FontFamily' textBlock.FontStyle' textBlock.FontWeight' textBlock.FontStretch)' textBlock.FontSize' Media.Brushes.Black); " is 268.
Long Statement,HelixToolkit.Wpf.SharpDX,BitmapExtension,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\BitmapExtension.cs,MeasureString,The length of the statement  "	return new Size (formattedText.Width + textBlock.Padding.Left + textBlock.Padding.Right' formattedText.Height + textBlock.Padding.Top + textBlock.Padding.Bottom); " is 162.
Long Statement,HelixToolkit.Wpf.SharpDX,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\Matrix3DExtensions.cs,AddMatrix,The length of the statement  "	return new Matrix3D ((m1.M11 + m2.M11)' (m1.M12 + m2.M12)' (m1.M13 + m2.M13)' (m1.M14 + m2.M14)' (m1.M21 + m2.M21)' (m1.M22 + m2.M22)' (m1.M23 + m2.M23)' (m1.M24 + m2.M24)' (m1.M31 + m2.M31)' (m1.M32 + m2.M32)' (m1.M33 + m2.M33)' (m1.M34 + m2.M34)' (m1.M44 + m2.M44)' (m1.OffsetX + m2.OffsetX)' (m1.OffsetY + m2.OffsetY)' (m1.OffsetZ + m2.OffsetZ)); " is 349.
Long Statement,HelixToolkit.Wpf.SharpDX,Matrix3DExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Extensions\Matrix3DExtensions.cs,MultiplyMatrix,The length of the statement  "	return new Matrix3D (scalar * (m.M11)' scalar * (m.M12)' scalar * (m.M13)' scalar * (m.M14)' scalar * (m.M21)' scalar * (m.M22)' scalar * (m.M23)' scalar * (m.M24)' scalar * (m.M31)' scalar * (m.M32)' scalar * (m.M33)' scalar * (m.M34)' scalar * (m.M44)' scalar * (m.OffsetX)' scalar * (m.OffsetY)' scalar * (m.OffsetZ)); " is 321.
Long Statement,HelixToolkit.Wpf.SharpDX,InstanceGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\InstanceGeometryModel3D.cs,UpdateInstancesBounds,The length of the statement  "		var bound = BoundingBox.FromPoints (this.BoundsWithTransform.GetCorners ().Select (x => Vector3.TransformCoordinate (x' instanceInternal [0])).ToArray ()); " is 155.
Long Statement,HelixToolkit.Wpf.SharpDX,InstanceGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\InstanceGeometryModel3D.cs,UpdateInstancesBounds,The length of the statement  "			var b = BoundingBox.FromPoints (this.BoundsWithTransform.GetCorners ().Select (x => Vector3.TransformCoordinate (x' instance)).ToArray ()); " is 139.
Long Statement,HelixToolkit.Wpf.SharpDX,InstanceGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\InstanceGeometryModel3D.cs,CanHitTest,The length of the statement  "	return base.CanHitTest (context) && geometryInternal != null && geometryInternal.Positions != null && geometryInternal.Positions.Count > 0; " is 139.
Long Statement,HelixToolkit.Wpf.SharpDX,InstanceGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\InstanceGeometryModel3D.cs,CheckBoundingFrustum,The length of the statement  "	return !hasInstances && base.CheckBoundingFrustum (ref boundingFrustum) || boundingFrustum.Intersects (ref instancesBound); " is 123.
Long Statement,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRender,The length of the statement  "	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (0' new VertexBufferBinding (VertexBuffer.Buffer' VertexBuffer.StructureSize' 0)); " is 142.
Long Statement,HelixToolkit.Wpf.SharpDX,BoneSkinMeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BoneSkinMeshGeometryModel3D.cs,OnRender,The length of the statement  "	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (0' new VertexBufferBinding (this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0)); " is 152.
Long Statement,HelixToolkit.Wpf.SharpDX,BoneSkinMeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BoneSkinMeshGeometryModel3D.cs,OnRender,The length of the statement  "		renderContext.DeviceContext.InputAssembler.SetVertexBuffers (1' new VertexBufferBinding (this.vertexBoneParamsBuffer.Buffer' this.vertexBoneParamsBuffer.StructureSize' 0)); " is 172.
Long Statement,HelixToolkit.Wpf.SharpDX,BoneSkinMeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BoneSkinMeshGeometryModel3D.cs,OnRender,The length of the statement  "		renderContext.DeviceContext.InputAssembler.SetVertexBuffers (2' new VertexBufferBinding (this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0)); " is 156.
Long Statement,HelixToolkit.Wpf.SharpDX,BoneSkinMeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BoneSkinMeshGeometryModel3D.cs,OnRender,The length of the statement  "		renderContext.DeviceContext.DrawIndexedInstanced (this.geometryInternal.Indices.Count' this.instanceInternal.Count' 0' 0' 0); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,BoneSkinMeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BoneSkinMeshGeometryModel3D.cs,OnRender,The length of the statement  "		renderContext.DeviceContext.InputAssembler.SetVertexBuffers (0' new VertexBufferBinding (this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0)); " is 152.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The length of the statement  "	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (0' new VertexBufferBinding (VertexBuffer.Buffer' VertexBuffer.StructureSize' 0)); " is 142.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The length of the statement  "		renderContext.DeviceContext.InputAssembler.SetVertexBuffers (1' new VertexBufferBinding (this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0)); " is 156.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The length of the statement  "			renderContext.DeviceContext.InputAssembler.SetVertexBuffers (2' new VertexBufferBinding (this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0)); " is 166.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingMeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingMeshGeometryModel3D.cs,OnRender,The length of the statement  "	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (0' new VertexBufferBinding (this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0)); " is 152.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingMeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingMeshGeometryModel3D.cs,OnRender,The length of the statement  "		renderContext.DeviceContext.InputAssembler.SetVertexBuffers (1' new VertexBufferBinding (this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0)); " is 156.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingMeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingMeshGeometryModel3D.cs,OnRender,The length of the statement  "			renderContext.DeviceContext.InputAssembler.SetVertexBuffers (2' new VertexBufferBinding (this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0)); " is 166.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingMeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingMeshGeometryModel3D.cs,OnRender,The length of the statement  "		renderContext.DeviceContext.DrawIndexedInstanced (this.geometryInternal.Indices.Count' this.instanceInternal.Count' 0' 0' 0); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,ParticleStormModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ParticleStormModel3D.cs,OnRender,The length of the statement  "		context.DeviceContext.CopyStructureCount (frameConstBuffer.Buffer' ParticlePerFrame.NumParticlesOffset' BufferProxies [0].UAV); " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,OnAttach,The length of the statement  "	//    this.instanceBuffer = Buffer.Create(this.device' this.instanceArray' new BufferDescription(Matrix.SizeInBytes * this.instanceArray.Length' ResourceUsage.Dynamic' BindFlags.VertexBuffer' CpuAccessFlags.Write' ResourceOptionFlags.None' 0));                             " is 244.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,OnRender,The length of the statement  "	if (renderTechnique == renderHost.RenderTechniquesManager.RenderTechniques [TessellationRenderTechniqueNames.PNTriangles]) { " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,OnRender,The length of the statement  "	} else if (renderTechnique == renderHost.RenderTechniquesManager.RenderTechniques [TessellationRenderTechniqueNames.PNQuads]) { " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,OnRender,The length of the statement  "	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (0' new VertexBufferBinding (VertexBuffer.Buffer' VertexBuffer.StructureSize' 0)); " is 142.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "	var colors = geometry.Colors != null ? geometry.Colors.GetEnumerator () : Enumerable.Repeat (Color4.White' vertexCount).GetEnumerator (); " is 137.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "	var textureCoordinates = geometry.TextureCoordinates != null ? geometry.TextureCoordinates.GetEnumerator () : Enumerable.Repeat (Vector2.Zero' vertexCount).GetEnumerator (); " is 173.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "	var normals = geometry.Normals != null ? geometry.Normals.GetEnumerator () : Enumerable.Repeat (Vector3.Zero' vertexCount).GetEnumerator (); " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "	var tangents = geometry.Tangents != null ? geometry.Tangents.GetEnumerator () : Enumerable.Repeat (Vector3.Zero' vertexCount).GetEnumerator (); " is 143.
Long Statement,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "	var bitangents = geometry.BiTangents != null ? geometry.BiTangents.GetEnumerator () : Enumerable.Repeat (Vector3.Zero' vertexCount).GetEnumerator (); " is 149.
Long Statement,HelixToolkit.Wpf.SharpDX,PointGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PointGeometryModel3D.cs,CanHitTest,The length of the statement  "	return base.CanHitTest (context) && geometryInternal.Positions != null && geometryInternal.Positions.Count > 0 && geometryInternal is PointGeometry3D && context != null; " is 169.
Long Statement,HelixToolkit.Wpf.SharpDX,PointGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PointGeometryModel3D.cs,CheckGeometry,The length of the statement  "	if (this.geometryInternal == null || this.geometryInternal.Positions == null || this.geometryInternal.Positions.Count == 0) { " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,PointGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PointGeometryModel3D.cs,OnRender,The length of the statement  "	var pointParams = new Vector4 ((float)this.Size.Width' (float)this.Size.Height' (float)this.Figure' (float)this.FigureRatio); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,PointGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PointGeometryModel3D.cs,OnRender,The length of the statement  "	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (0' new VertexBufferBinding (this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0)); " is 152.
Long Statement,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,DrawTexture,The length of the statement  "			Texture = TextInfo.Text.StringToBitmapSource (FontSize' Media.Colors.White' Media.Colors.Black' this.FontFamily' this.FontWeight' this.FontStyle' Padding); " is 155.
Long Statement,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTest,The length of the statement  "		bool nodeHit = node.HitTestCurrentNodeExcludeChild (context' model' modelMatrix' ref rayWS' ref modelHits' ref isIntersect); " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,Expand,The length of the statement  "	var newCenter = center + new Vector3 (xDirection * Math.Abs (half.X)' yDirection * Math.Abs (half.Y)' zDirection * Math.Abs (half.Z)); " is 134.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The length of the statement  "	var bound = BoundingBox.FromPoints (Bound.GetCorners ().Select (x => Vector3.TransformCoordinate (x' modelMatrix)).ToArray ()); " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,PointGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The length of the statement  "	var bound = BoundingBox.FromPoints (Bound.GetCorners ().Select (x => Vector3.TransformCoordinate (x' modelMatrix)).ToArray ()); " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,GeometryModel3DOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The length of the statement  "	var bound = BoundingBox.FromPoints (Bound.GetCorners ().Select (x => Vector3.TransformCoordinate (x' modelMatrix)).ToArray ()); " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingModel3DOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The length of the statement  "	var bound = BoundingBox.FromPoints (Bound.GetCorners ().Select (x => Vector3.TransformCoordinate (x' modelMatrix)).ToArray ()); " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingModel3DOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The length of the statement  "			var b = BoundingBox.FromPoints (t.Item2.GetCorners ().Select (x => Vector3.TransformCoordinate (x' modelMatrix)).ToArray ()); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,InstancingModel3DOctreeManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeManager.cs,RebuildTree,The length of the statement  "	var octree = new InstancingModel3DOctree (instMatrix' model3D.BoundsWithTransform' this.Parameter' new Queue<IOctree> (256)); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The length of the statement  "		CreateMesh (positions' textureCoordinates' triangleIndices' out normals' out tangents' out bitangents' PhongMaterials.Gray); " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,BitMapSoureFromFallBack,The length of the statement  "	//List<MediaColor> colors = new List<System.Windows.Media.Color>() { MediaColor.FromArgb(fallBackColor.A' fallBackColor.R' fallBackColor.G' fallBackColor.B) }; " is 159.
Long Statement,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,BitMapSoureFromFallBack,The length of the statement  "	BitmapSource bitmap = BitmapSource.Create (10' 10' 96' 96' System.Windows.Media.PixelFormats.Indexed1' palette' pixels' stride); " is 128.
Long Statement,HelixToolkit.Wpf.SharpDX,OrthographicCamera,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Camera\OrthographicCamera.cs,CreateProjectionMatrix,The length of the statement  "		projM = Matrix.OrthoLH ((float)this.Width' (float)(this.Width / aspectRatio)' (float)this.NearPlaneDistance' Math.Min (1e15f' (float)this.FarPlaneDistance)); " is 157.
Long Statement,HelixToolkit.Wpf.SharpDX,OrthographicCamera,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Camera\OrthographicCamera.cs,CreateProjectionMatrix,The length of the statement  "		projM = Matrix.OrthoRH ((float)this.Width' (float)(this.Width / aspectRatio)' (float)this.NearPlaneDistance' Math.Min (1e15f' (float)this.FarPlaneDistance)); " is 157.
Long Statement,HelixToolkit.Wpf.SharpDX,PerspectiveCamera,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Camera\PerspectiveCamera.cs,CreateProjectionMatrix,The length of the statement  "		projM = global::SharpDX.Matrix.PerspectiveFovLH ((float)fov' (float)aspectRatio' (float)this.NearPlaneDistance' (float)this.FarPlaneDistance); " is 142.
Long Statement,HelixToolkit.Wpf.SharpDX,PerspectiveCamera,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Camera\PerspectiveCamera.cs,CreateProjectionMatrix,The length of the statement  "		projM = global::SharpDX.Matrix.PerspectiveFovRH ((float)fov' (float)aspectRatio' (float)this.NearPlaneDistance' (float)this.FarPlaneDistance); " is 142.
Long Statement,HelixToolkit.Wpf.SharpDX,ProjectionCamera,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Camera\ProjectionCamera.cs,CreateViewMatrix,The length of the statement  "		return global::SharpDX.Matrix.LookAtLH (this.Position.ToVector3 ()' (this.Position + this.LookDirection).ToVector3 ()' this.UpDirection.ToVector3 ()); " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,ProjectionCamera,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Camera\ProjectionCamera.cs,CreateViewMatrix,The length of the statement  "	return global::SharpDX.Matrix.LookAtRH (this.Position.ToVector3 ()' (this.Position + this.LookDirection).ToVector3 ()' this.UpDirection.ToVector3 ()); " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,EnvironmentMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\EnvironmentMapModel3D.cs,OnAttach,The length of the statement  "		this.vertexBuffer = Device.CreateBuffer (BindFlags.VertexBuffer' CubeVertex.SizeInBytes' this.geometry.Positions.Select ((x' ii) => new CubeVertex () { " is 151.
Long Statement,HelixToolkit.Wpf.SharpDX,EnvironmentMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\EnvironmentMapModel3D.cs,OnAttach,The length of the statement  "		this.indexBuffer = Device.CreateBuffer (BindFlags.IndexBuffer' sizeof(int)' geometry.Indices.Array' geometry.Indices.Count); " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,EnvironmentMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\EnvironmentMapModel3D.cs,OnRender,The length of the statement  "	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (0' new VertexBufferBinding (this.vertexBuffer' CubeVertex.SizeInBytes' 0)); " is 136.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnGeometryPropertyChanged,The length of the statement  "		} else if (e.PropertyName.Equals (nameof (MeshGeometry3D.Indices)) || e.PropertyName.Equals (Geometry3D.TriangleBuffer)) { " is 122.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnRender,The length of the statement  "		renderContext.DeviceContext.DrawIndexedInstanced (this.geometryInternal.Indices.Count' this.instanceInternal.Count' 0' 0' 0); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnRender,The length of the statement  "		renderContext.DeviceContext.InputAssembler.SetVertexBuffers (0' new VertexBufferBinding (this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0)); " is 152.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,CanHitTest,The length of the statement  "	return base.CanHitTest (context) && geometryInternal is MeshGeometry3D && geometryInternal.Indices != null && geometryInternal.Indices.Count > 0; " is 145.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The length of the statement  "							result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]); " is 123.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "	var colors = geometry.Colors != null ? geometry.Colors.GetEnumerator () : Enumerable.Repeat (Color4.White' vertexCount).GetEnumerator (); " is 137.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "	var textureCoordinates = geometry.TextureCoordinates != null ? geometry.TextureCoordinates.GetEnumerator () : Enumerable.Repeat (Vector2.Zero' vertexCount).GetEnumerator (); " is 173.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "	var normals = geometry.Normals != null ? geometry.Normals.GetEnumerator () : Enumerable.Repeat (Vector3.Zero' vertexCount).GetEnumerator (); " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "	var tangents = geometry.Tangents != null ? geometry.Tangents.GetEnumerator () : Enumerable.Repeat (Vector3.Zero' vertexCount).GetEnumerator (); " is 143.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,CreateDefaultVertexArray,The length of the statement  "	var bitangents = geometry.BiTangents != null ? geometry.BiTangents.GetEnumerator () : Enumerable.Repeat (Vector3.Zero' vertexCount).GetEnumerator (); " is 149.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,UpdateTextureOnly,The length of the statement  "		var textureCoordinates = geometry.TextureCoordinates != null && geometry.TextureCoordinates.Count == vertexCount ? geometry.TextureCoordinates.GetEnumerator () : Enumerable.Repeat (Vector2.Zero' vertexCount).GetEnumerator (); " is 225.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,UpdatePositionOnly,The length of the statement  "		var normals = geometry.Normals != null ? geometry.Normals.GetEnumerator () : Enumerable.Repeat (Vector3.Zero' vertexCount).GetEnumerator (); " is 140.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,UpdatePositionOnly,The length of the statement  "		var tangents = geometry.Tangents != null ? geometry.Tangents.GetEnumerator () : Enumerable.Repeat (Vector3.Zero' vertexCount).GetEnumerator (); " is 143.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,UpdatePositionOnly,The length of the statement  "		var bitangents = geometry.BiTangents != null ? geometry.BiTangents.GetEnumerator () : Enumerable.Repeat (Vector3.Zero' vertexCount).GetEnumerator (); " is 149.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,UpdateColorsOnly,The length of the statement  "		var colors = geometryInternal.Colors != null && geometryInternal.Colors.Count == vertexCount ? geometryInternal.Colors.GetEnumerator () : Enumerable.Repeat (Color4.White' vertexCount).GetEnumerator (); " is 201.
Long Statement,HelixToolkit.Wpf.SharpDX,UIManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UIManipulator3D.cs,OnOffetChanged,The length of the statement  "	//this.Position = new Point3D(this.Position.X + this.Offset.X' this.Position.Y + this.Offset.Y' this.Position.Z + this.Offset.Z); " is 129.
Long Statement,HelixToolkit.Wpf.SharpDX,UIRotateManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UIRotateManipulator3D.cs,UpdateManipulator,The length of the statement  "		var rotateTransform = new System.Windows.Media.Media3D.RotateTransform3D (new System.Windows.Media.Media3D.AxisAngleRotation3D (this.Axis.ToVector3D ()' theta)' Pivot.ToPoint3D ()); " is 181.
Long Statement,HelixToolkit.Wpf.SharpDX,Element3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\Element3D.cs,CheckAffectsRender,The length of the statement  "	// => Need to change all relevant DP's metadata to FrameworkPropertyMetadata or to a new "AffectsRenderPropertyMetadata". " is 121.
Long Statement,HelixToolkit.Wpf.SharpDX,Element3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\Element3D.cs,CheckAffectsRender,The length of the statement  "	return ((fmetadata = e.Property.GetMetadata (this)) != null && (fmetadata is IAffectsRender || (fmetadata is FrameworkPropertyMetadata && (fmetadata as FrameworkPropertyMetadata).AffectsRender))); " is 196.
Long Statement,HelixToolkit.Wpf.SharpDX,GeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\GeometryModel3D.cs,OnTransformChanged,The length of the statement  "		BoundsWithTransform = BoundingBox.FromPoints (Bounds.GetCorners ().Select (x => Vector3.TransformCoordinate (x' this.modelMatrix)).ToArray ()); " is 143.
Long Statement,HelixToolkit.Wpf.SharpDX,GeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\AbstractElements3D\GeometryModel3D.cs,CheckGeometry,The length of the statement  "	return !(this.geometryInternal == null || this.geometryInternal.Positions == null || this.geometryInternal.Positions.Count == 0 || this.geometryInternal.Indices == null || this.geometryInternal.Indices.Count == 0); " is 214.
Long Statement,HelixToolkit.Wpf.SharpDX,LineGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\LineGeometryModel3D.cs,CanHitTest,The length of the statement  "	return base.CanHitTest (context) && geometryInternal != null && geometryInternal.Positions != null && geometryInternal.Positions.Count > 0 && geometryInternal is LineGeometry3D && context != null; " is 196.
Long Statement,HelixToolkit.Wpf.SharpDX,LineGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\LineGeometryModel3D.cs,OnGeometryPropertyChanged,The length of the statement  "		} else if (e.PropertyName.Equals (nameof (LineGeometry3D.Indices)) || e.PropertyName.Equals (Geometry3D.TriangleBuffer)) { " is 122.
Long Statement,HelixToolkit.Wpf.SharpDX,LineGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\LineGeometryModel3D.cs,OnAttach,The length of the statement  "	//    var texDiffuseMapView = ShaderResourceView.FromFile(device' @"G:\Projects\Deformation Project\FrameworkWPF2012\Externals\HelixToolkit-SharpDX\Source\Examples\SharpDX.Wpf\LightingDemo\TextureCheckerboard2.jpg"); " is 216.
Long Statement,HelixToolkit.Wpf.SharpDX,LineGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\LineGeometryModel3D.cs,OnRender,The length of the statement  "			renderContext.DeviceContext.DrawIndexedInstanced (this.geometryInternal.Indices.Count' this.instanceInternal.Count' 0' 0' 0); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,LineGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\LineGeometryModel3D.cs,OnRender,The length of the statement  "		renderContext.DeviceContext.InputAssembler.SetVertexBuffers (0' new VertexBufferBinding (this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0)); " is 152.
Long Statement,HelixToolkit.Wpf.SharpDX,PointLight3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\PointLight3D.cs,OnRender,The length of the statement  "	Light3DSceneShared.LightAtt [lightIndex] = new Vector4 ((float)this.AttenuationInternal.X' (float)this.AttenuationInternal.Y' (float)this.AttenuationInternal.Z' (float)this.RangeInternal); " is 188.
Long Statement,HelixToolkit.Wpf.SharpDX,ShadowMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The length of the statement  "	this.Device.ImmediateContext.ClearDepthStencilView (depthViewSM' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 137.
Long Statement,HelixToolkit.Wpf.SharpDX,ShadowMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The length of the statement  "				light.LightProjectionMatrix = CameraExtensions.GetProjectionMatrix (lightCamera' context.Canvas.ActualWidth / context.Canvas.ActualHeight); " is 139.
Long Statement,HelixToolkit.Wpf.SharpDX,SpotLight3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\SpotLight3D.cs,CanRender,The length of the statement  "		//if (renderHost.RenderTechnique == renderHost.RenderTechniquesManager.RenderTechniques.Get(DeferredRenderTechniqueNames.Deferred) || " is 133.
Long Statement,HelixToolkit.Wpf.SharpDX,SpotLight3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\SpotLight3D.cs,CanRender,The length of the statement  "		//    renderHost.RenderTechnique == renderHost.RenderTechniquesManager.RenderTechniques.Get(DeferredRenderTechniqueNames.GBuffer)) " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,SpotLight3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\SpotLight3D.cs,OnRender,The length of the statement  "	Light3DSceneShared.LightSpots [lightIndex] = new Vector4 ((float)Math.Cos (this.OuterAngleInternal / 360.0 * Math.PI)' (float)Math.Cos (this.InnerAngleInternal / 360.0 * Math.PI)' (float)this.FalloffInternal' 0); " is 212.
Long Statement,HelixToolkit.Wpf.SharpDX,SpotLight3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\SpotLight3D.cs,OnRender,The length of the statement  "	Light3DSceneShared.LightAtt [lightIndex] = new Vector4 ((float)this.AttenuationInternal.X' (float)this.AttenuationInternal.Y' (float)this.AttenuationInternal.Z' (float)this.RangeInternal); " is 188.
Long Statement,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMesh,The length of the statement  "			this.writer.WriteLine (string.Format (CultureInfo.InvariantCulture' "v {0} {1} {2}"' p.X' this.SwitchYZ ? p.Z : p.Y' this.SwitchYZ ? -p.Y : p.Z)); " is 146.
Long Statement,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMaterial,The length of the statement  "                // "exponent" is the value for the specular exponent.  A high exponent results in a tight' concentrated highlight.  Ns values normally range from 0 to 1000." is 156.
Long Statement,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ToColorString,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "{0:F4} {1:F4} {2:F4}"' color.R / 255.0' color.G / 255.0' color.B / 255.0); " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,Read,The length of the statement  "				System.Windows.MessageBox.Show (string.Format ("Error loading object: {0}"' ex.Message)' "Error"' MessageBoxButton.OKCancel); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,ColorParse,The length of the statement  "	return System.Windows.Media.Color.FromRgb ((byte)(fields [0] * 255)' (byte)(fields [1] * 255)' (byte)(fields [2] * 255)).ToColor4 (); " is 133.
Long Statement,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,SetSmoothingGroup,The length of the statement  "			throw new FileFormatException (string.Format ("Invalid smoothing group ({0}) at line {1}."' values' this.currentLineNo)); " is 121.
Long Statement,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The length of the statement  "			throw new FileFormatException (string.Format ("Invalid texture coordinate index ({0}) on line {1}."' vti' this.currentLineNo)); " is 127.
Long Statement,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The length of the statement  "		System.Windows.MessageBox.Show (string.Format ("Error composing polygonal object: {0}"' ex.Message)' "Error"' MessageBoxButton.OKCancel); " is 137.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,GetCircle,The length of the statement  "	if ((!closed && !CircleCache.Value.TryGetValue (thetaDiv' out circle)) || (closed && !ClosedCircleCache.Value.TryGetValue (thetaDiv' out circle))) { " is 148.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The length of the statement  "	ComputeTangents (meshGeometry.Positions' meshGeometry.Normals' meshGeometry.TextureCoordinates' meshGeometry.TriangleIndices' out t1' out t2); " is 142.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "	var p1 = new Point3D ((DoubleOrSingle)boundingBox.X' (DoubleOrSingle)boundingBox.Y + (DoubleOrSingle)boundingBox.SizeY' (DoubleOrSingle)boundingBox.Z); " is 151.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "	var p2 = new Point3D ((DoubleOrSingle)boundingBox.X + (DoubleOrSingle)boundingBox.SizeX' (DoubleOrSingle)boundingBox.Y + (DoubleOrSingle)boundingBox.SizeY' (DoubleOrSingle)boundingBox.Z); " is 187.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "	var p3 = new Point3D ((DoubleOrSingle)boundingBox.X + (DoubleOrSingle)boundingBox.SizeX' (DoubleOrSingle)boundingBox.Y' (DoubleOrSingle)boundingBox.Z); " is 151.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "	var p4 = new Point3D ((DoubleOrSingle)boundingBox.X' (DoubleOrSingle)boundingBox.Y' (DoubleOrSingle)boundingBox.Z + (DoubleOrSingle)boundingBox.SizeZ); " is 151.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "	var p5 = new Point3D ((DoubleOrSingle)boundingBox.X' (DoubleOrSingle)boundingBox.Y + (DoubleOrSingle)boundingBox.SizeY' (DoubleOrSingle)boundingBox.Z + (DoubleOrSingle)boundingBox.SizeZ); " is 187.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "	var p6 = new Point3D ((DoubleOrSingle)boundingBox.X + (DoubleOrSingle)boundingBox.SizeX' (DoubleOrSingle)boundingBox.Y + (DoubleOrSingle)boundingBox.SizeY' (DoubleOrSingle)boundingBox.Z + (DoubleOrSingle)boundingBox.SizeZ); " is 223.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBoundingBox,The length of the statement  "	var p7 = new Point3D ((DoubleOrSingle)boundingBox.X + (DoubleOrSingle)boundingBox.SizeX' (DoubleOrSingle)boundingBox.Y' (DoubleOrSingle)boundingBox.Z + (DoubleOrSingle)boundingBox.SizeZ); " is 187.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBox,The length of the statement  "	this.AddBox (new Point3D ((DoubleOrSingle)(rectangle.X + (rectangle.SizeX * 0.5f))' (DoubleOrSingle)(rectangle.Y + (rectangle.SizeY * 0.5f))' (DoubleOrSingle)(rectangle.Z + (rectangle.SizeZ * 0.5f)))' (DoubleOrSingle)rectangle.SizeX' (DoubleOrSingle)rectangle.SizeY' (DoubleOrSingle)rectangle.SizeZ' faces); " is 307.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "	var radiusSphere = 0.25f * (DoubleOrSingle)Math.Sqrt (3) * (1 + (DoubleOrSingle)Math.Sqrt (5)) * (DoubleOrSingle)sideLength; " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "	var radiusFace = 0.1f * (DoubleOrSingle)Math.Sqrt (50 + 10 * (DoubleOrSingle)Math.Sqrt (5)) * (DoubleOrSingle)sideLength; " is 121.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "		var newPoint = new Point3D (radiusSphere * (DoubleOrSingle)Math.Cos (gamma)' 0' radiusSphere * (DoubleOrSingle)Math.Sin (gamma)); " is 129.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "		var newPoint = new Point3D (radiusSphere * (DoubleOrSingle)Math.Cos (gamma)' 0' radiusSphere * (DoubleOrSingle)Math.Sin (gamma)); " is 129.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "			var u = (DoubleOrSingle)Math.Atan2 (SharedFunctions.DotProduct (ref planeCTP' ref forward)' SharedFunctions.DotProduct (ref planeCTP' ref right)); " is 146.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The length of the statement  "			var p = new Point3D (center.X + (DoubleOrSingle)(radiusx * x)' center.Y + (DoubleOrSingle)(radiusy * y)' center.Z + (DoubleOrSingle)(radiusz * z)); " is 147.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshNormals,The length of the statement  "			var u = Point3D.Subtract (this.positions [index0 + (i1 * columns) + j0]' this.positions [index0 + (i0 * columns) + j0]); " is 120.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshNormals,The length of the statement  "			var v = Point3D.Subtract (this.positions [index0 + (i0 * columns) + j1]' this.positions [index0 + (i0 * columns) + j0]); " is 120.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The length of the statement  "			this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius)); " is 272.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The length of the statement  "				this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues [j])); " is 166.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The length of the statement  "				this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues [j + 1])); " is 176.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The length of the statement  "				this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues [j])); " is 166.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "			var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25)))); " is 133.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "		crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList (); " is 191.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList (); " is 251.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "				var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList (); " is 251.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "				var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0); " is 180.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The length of the statement  "				this.textureCoordinates.Add (values != null ? new Point ((DoubleOrSingle)values [i % valuesCount]' (DoubleOrSingle)j / (sectionLength - 1)) : new Point ()); " is 156.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The length of the statement  "				this.textureCoordinates.Add (values != null ? new Point ((DoubleOrSingle)values [i % valuesCount]' (DoubleOrSingle)j / (sectionLength - 1)) : new Point ()); " is 156.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Append,The length of the statement  "	this.Append (mesh.Positions' mesh.TriangleIndices' this.normals != null ? mesh.Normals : null' this.textureCoordinates != null ? mesh.TextureCoordinates : null); " is 161.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Scale,The length of the statement  "		this.Positions [i] = new Point3D (this.Positions [i].X * (DoubleOrSingle)scaleX' this.Positions [i].Y * (DoubleOrSingle)scaleY' this.Positions [i].Z * (DoubleOrSingle)scaleZ); " is 175.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Scale,The length of the statement  "			this.Normals [i] = new Vector3D (this.Normals [i].X * (DoubleOrSingle)scaleX' this.Normals [i].Y * (DoubleOrSingle)scaleY' this.Normals [i].Z * (DoubleOrSingle)scaleZ); " is 168.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The length of the statement  "	if (mesh.TextureCoordinates != null && mesh.TextureCoordinates.Count != 0 && mesh.TextureCoordinates.Count != mesh.Positions.Count) { " is 133.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The length of the statement  "		contourHelper.ContourFacet (index0' index1' index2' out positions' out normals' out textureCoordinates' out triangleIndices); " is 125.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The length of the statement  "		contourHelper.ContourFacet (mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2]' out positions' out normals' out textureCoordinates' out triangleIndices); " is 187.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,The length of the statement  "	RemoveIsolatedVertices (mesh.Positions' mesh.TriangleIndices' mesh.TextureCoordinates' mesh.Normals' out vertNew' out triNew' out textureNew' out normalNew); " is 157.
Long Statement,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,The length of the statement  "		//if (!(leftChain.Contains(top) && leftChain.Contains(newPoint) || rightChain.Contains(top) && rightChain.Contains(newPoint))) " is 126.
Long Statement,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,SplitIntoPolygons,The length of the statement  "	foreach (var edge in poly.Points.Select (p => p.EdgeTwo).Union (diagonals.Select (d => new PolygonEdge (poly.Points [d.Item1]' poly.Points [d.Item2]))).Union (diagonals.Select (d => new PolygonEdge (poly.Points [d.Item2]' poly.Points [d.Item1])))) { " is 249.
Long Statement,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,CreateNewPosition,The length of the statement  "	return new Point3D (CalculatePoint (firstPoint.X' secondPoint.X' firstSide' secondSide)' CalculatePoint (firstPoint.Y' secondPoint.Y' firstSide' secondSide)' CalculatePoint (firstPoint.Z' secondPoint.Z' firstSide' secondSide)); " is 227.
Long Statement,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,CreateNewNormal,The length of the statement  "	return new Vector3D (CalculatePoint (firstPoint.X' secondPoint.X' firstSide' secondSide)' CalculatePoint (firstPoint.Y' secondPoint.Y' firstSide' secondSide)' CalculatePoint (firstPoint.Z' secondPoint.Z' firstSide' secondSide)); " is 228.
Long Statement,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,CreateNewTexture,The length of the statement  "	return new Point (CalculatePoint (firstTexture.X' secondTexture.X' firstSide' secondSide)' CalculatePoint (firstTexture.Y' secondTexture.Y' firstSide' secondSide)); " is 164.
Long Statement,HelixToolkit.Wpf.SharpDX,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Polygon3D.cs,Flatten,The length of the statement  "	var m = new Matrix3D (backward.X' right.X' up.X' 0' backward.Y' right.Y' up.Y' 0' backward.Z' right.Z' up.Z' 0' 0' 0' 0' 1); " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,BoundingSphereExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BoundingSphereExtensions.cs,FromPoints,The length of the statement  "		throw new ArgumentOutOfRangeException ("start"' start' string.Format ("Must be in the range [0' {0}]"' points.Count - 1)); " is 122.
Long Statement,HelixToolkit.Wpf.SharpDX,VectorExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Vector3DExtensions.cs,ToMatrix3D,The length of the statement  "	return new Matrix3D ((float)m.M11' (float)m.M12' (float)m.M13' (float)m.M14' (float)m.M21' (float)m.M22' (float)m.M23' (float)m.M24' (float)m.M31' (float)m.M32' (float)m.M33' (float)m.M34' (float)m.M41' (float)m.M42' (float)m.M43' (float)m.M44); " is 245.
Long Statement,HelixToolkit.Wpf.SharpDX,VectorExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Vector3DExtensions.cs,ToVector4,The length of the statement  "	return new global::SharpDX.Vector4 ((float)matrix.OffsetX' (float)matrix.OffsetY' (float)matrix.OffsetZ' (float)matrix.M44); " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,VectorExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Vector3DExtensions.cs,ToMatrix,The length of the statement  "	return new global::SharpDX.Matrix ((float)m.M11' (float)m.M12' (float)m.M13' (float)m.M14' (float)m.M21' (float)m.M22' (float)m.M23' (float)m.M24' (float)m.M31' (float)m.M32' (float)m.M33' (float)m.M34' (float)m.OffsetX' (float)m.OffsetY' (float)m.OffsetZ' (float)m.M44); " is 271.
Long Statement,HelixToolkit.Wpf.SharpDX,VectorExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Vector3DExtensions.cs,ToMatrix,The length of the statement  "	return new global::SharpDX.Matrix ((float)m.M11' (float)m.M12' (float)m.M13' (float)m.M14' (float)m.M21' (float)m.M22' (float)m.M23' (float)m.M24' (float)m.M31' (float)m.M32' (float)m.M33' (float)m.M34' (float)m.OffsetX' (float)m.OffsetY' (float)m.OffsetZ' (float)m.M44); " is 271.
Long Statement,HelixToolkit.Wpf.SharpDX,VectorExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Vector3DExtensions.cs,ToColor,The length of the statement  "	//return System.Windows.Media.Color.FromArgb((byte)(color.Alpha * 256)' (byte)(color.Red * 256)' (byte)(color.Green * 256)' (byte)(color.Blue * 256)); " is 150.
Long Statement,HelixToolkit.Wpf.SharpDX,TextureLoader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TextureLoader.cs,FromFileAsShaderResourceView,The length of the statement  "		if (!disableAutoGenMipMap && texture.Description.MipLevels == 1)// Check if it already has mipmaps or not' if loaded DDS file' it may already has precompiled mipmaps' don't need to generate again " is 195.
Long Statement,HelixToolkit.Wpf.SharpDX,TextureLoader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TextureLoader.cs,FromMemoryAsShaderResourceView,The length of the statement  "		if (!disableAutoGenMipMap && texture.Description.MipLevels == 1)// Check if it already has mipmaps or not' if loaded DDS file' it may already has precompiled mipmaps' don't need to generate again " is 195.
Long Statement,Wpf3DTools,Trackball,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Trackball.cs,OnMouseMove,The length of the statement  "	if (e.LeftButton == MouseButtonState.Pressed && (Keyboard.IsKeyDown (Key.LeftShift) || Keyboard.IsKeyDown (Key.RightShift))) { " is 126.
Long Statement,HelixToolkit.Wpf.SharpDX.Core,Box3,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Core\Box3D.cs,Contains,The length of the statement  "	return b.Min.X >= Min.X && b.Max.X <= Max.X && b.Min.Y >= Min.Y && b.Max.Y <= Max.Y && b.Min.Z >= Min.Z && b.Max.Z <= Max.Z; " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX.Core,Box3,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Core\Box3D.cs,Union,The length of the statement  "	return new Box3 (VectorComparisonExtensions.ComponentMin (a.Min' b.Min)' VectorComparisonExtensions.ComponentMax (a.Max' b.Max)); " is 129.
Long Statement,HelixToolkit.Wpf.SharpDX.Core,Box3,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Core\Box3D.cs,Intersection,The length of the statement  "	return new Box3 (VectorComparisonExtensions.ComponentMax (a.Min' b.Min)' VectorComparisonExtensions.ComponentMin (a.Max' b.Max)); " is 129.
Long Statement,HelixToolkit.Wpf.SharpDX.Core,Color4Collection,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Color4Collection.cs,Parse,The length of the statement  "		value = new Color4 (Convert.ToSingle (th.GetCurrentToken ()' formatProvider)' Convert.ToSingle (th.NextTokenRequired ()' formatProvider)' Convert.ToSingle (th.NextTokenRequired ()' formatProvider)' Convert.ToSingle (th.NextTokenRequired ()' formatProvider)); " is 258.
Long Statement,HelixToolkit.Wpf.SharpDX.Core,Vector2Collection,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Vector2Collection.cs,Parse,The length of the statement  "		value = new Vector2 (Convert.ToSingle (th.GetCurrentToken ()' formatProvider)' Convert.ToSingle (th.NextTokenRequired ()' formatProvider)); " is 139.
Long Statement,HelixToolkit.Wpf.SharpDX.Core,Vector3Collection,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Vector3Collection.cs,Parse,The length of the statement  "		value = new Vector3 (Convert.ToSingle (th.GetCurrentToken ()' formatProvider)' Convert.ToSingle (th.NextTokenRequired ()' formatProvider)' Convert.ToSingle (th.NextTokenRequired ()' formatProvider)); " is 199.
Long Statement,HelixToolkit.Wpf.SharpDX.Utilities,TokenizerHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TokenizerHelper.cs,GetNumericListSeparator,The length of the statement  "	if ((numberFormat.NumberDecimalSeparator.Length > 0) && (numericSeparator == numberFormat.NumberDecimalSeparator [0])) { " is 120.
Long Statement,HelixToolkit.Wpf.SharpDX.Utilities,ColorConverter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TypeConverter.cs,ConvertFrom,The length of the statement  "		var result = new Color (Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)); " is 320.
Long Statement,HelixToolkit.Wpf.SharpDX.Utilities,Color4Converter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TypeConverter.cs,ConvertFrom,The length of the statement  "		var result = new Color4 (Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)); " is 321.
Long Statement,HelixToolkit.Wpf.SharpDX.Utilities,Vector2Converter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TypeConverter.cs,ConvertFrom,The length of the statement  "		var result = new Vector2 (Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)); " is 174.
Long Statement,HelixToolkit.Wpf.SharpDX.Utilities,Vector3Converter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TypeConverter.cs,ConvertFrom,The length of the statement  "		var result = new Vector3 (Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)); " is 248.
Long Statement,HelixToolkit.Wpf.SharpDX.Utilities,Vector4Converter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TypeConverter.cs,ConvertFrom,The length of the statement  "		var result = new Vector4 (Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)); " is 322.
Long Statement,HelixToolkit.Wpf.SharpDX.Utilities,QuaternionConverter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TypeConverter.cs,ConvertFrom,The length of the statement  "		var result = new Quaternion (Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)' Convert.ToSingle (th.NextTokenRequired ()' CultureInfo.InvariantCulture)); " is 325.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,GetDXGIFormat,The length of the statement  "				if (pixelFormat.RBitMask == entry.PixelFormat.RBitMask && pixelFormat.GBitMask == entry.PixelFormat.GBitMask && pixelFormat.BBitMask == entry.PixelFormat.BBitMask && pixelFormat.ABitMask == entry.PixelFormat.ABitMask) " is 217.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The length of the statement  "	if ((header.PixelFormat.Flags & DDS.PixelFormatFlags.FourCC) != 0 && (new FourCC ('D'' 'X'' '1'' '0') == header.PixelFormat.FourCC)) { " is 134.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The length of the statement  "			throw new InvalidOperationException (string.Format ("Unexpected dimension [{0}] from DDS HeaderDX10"' headerDX10.ResourceDimension)); " is 133.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The length of the statement  "		if ((description.ArraySize != 6) || (description.Dimension != TextureDimension.Texture2D) || (description.Dimension != TextureDimension.TextureCube)) { " is 151.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The length of the statement  "	Image.ComputePitch (description.Format' description.Width' description.Height' out rowPitch' out slicePitch' out newWidth' out newHeight); " is 138.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LoadFromDDSMemory,The length of the statement  "	var image = CreateImageFromDDS (pSource' offset' size - offset' mdata' (flags & DDSFlags.LegacyDword) != 0 ? Image.PitchFlags.LegacyDword : Image.PitchFlags.None' convFlags' pal8' handle); " is 188.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The length of the statement  "		else if ((convFlags & (ConversionFlags.Format565 | ConversionFlags.Format5551 | ConversionFlags.Format4444 | ConversionFlags.Format8332 | ConversionFlags.FormatA8P8)) != 0) " is 172.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The length of the statement  "	var isCopyNeeded = (convFlags & (ConversionFlags.Expand | ConversionFlags.CopyMemory)) != 0 || ((cpFlags & Image.PitchFlags.LegacyDword) != 0); " is 143.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The length of the statement  "								ExpandScanline (pDest' dpitch' pSrc' spitch' (convFlags & ConversionFlags.Format565) != 0 ? DXGI.Format.B5G6R5_UNorm : DXGI.Format.B5G5R5A1_UNorm' tflags); " is 155.
Long Statement,SharpDX.Toolkit.Graphics,DepthStencilBuffer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,GetDepthStencilView,The length of the statement  "				dsvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? DepthStencilViewDimension.Texture2DMultisampledArray : DepthStencilViewDimension.Texture2DArray; " is 170.
Long Statement,SharpDX.Toolkit.Graphics,DepthStencilBuffer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,GetDepthStencilView,The length of the statement  "				dsvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? DepthStencilViewDimension.Texture2DMultisampled : DepthStencilViewDimension.Texture2D; " is 160.
Long Statement,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New1D,The length of the statement  "	return new Image (CreateDescription (TextureDimension.Texture1D' width' 1' 1' mipMapCount' format' arraySize)' dataPointer' 0' null' false); " is 140.
Long Statement,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New2D,The length of the statement  "	return new Image (CreateDescription (TextureDimension.Texture2D' width' height' 1' mipMapCount' format' arraySize)' dataPointer' 0' null' false); " is 145.
Long Statement,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,NewCube,The length of the statement  "	return new Image (CreateDescription (TextureDimension.TextureCube' width' width' 1' mipMapCount' format' 6)' dataPointer' 0' null' false); " is 138.
Long Statement,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New3D,The length of the statement  "	return new Image (CreateDescription (TextureDimension.Texture3D' width' width' depth' mipMapCount' format' 1)' dataPointer' 0' null' false); " is 140.
Long Statement,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The length of the statement  "		description.MipLevels = Texture.CalculateMipLevels (description.Width' description.Height' description.Depth' description.MipLevels); " is 133.
Long Statement,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The length of the statement  "		int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16; " is 191.
Long Statement,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Save,The length of the statement  "		throw new ArgumentException ("Filename must have a supported image extension: dds' bmp' jpg' png' gif' tiff' wmp' tga"); " is 120.
Long Statement,SharpDX.Toolkit.Graphics,ImageDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,Equals,The length of the statement  "	return Dimension.Equals (other.Dimension) && Width == other.Width && Height == other.Height && Depth == other.Depth && ArraySize == other.ArraySize && MipLevels == other.MipLevels && Format.Equals (other.Format); " is 212.
Long Statement,SharpDX.Toolkit.Graphics,ImageDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,ToString,The length of the statement  "	return string.Format ("Dimension: {0}' Width: {1}' Height: {2}' Depth: {3}' Format: {4}' ArraySize: {5}' MipLevels: {6}"' Dimension' Width' Height' Depth' Format' ArraySize' MipLevels); " is 185.
Long Statement,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,Equals,The length of the statement  "	return this.Width == other.Width && this.Height == other.Height && this.WidthPacked == other.WidthPacked && this.HeightPacked == other.HeightPacked && this.Depth == other.Depth && this.RowStride == other.RowStride && this.MipmapSize == other.MipmapSize && this.DepthStride == other.DepthStride; " is 294.
Long Statement,SharpDX.Toolkit.Graphics,PixelBuffer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs,CopyTo,The length of the statement  "	if (this.Width != pixelBuffer.Width || this.Height != pixelBuffer.Height || PixelSize != FormatHelper.SizeOfInBytes (pixelBuffer.Format)) { " is 139.
Long Statement,SharpDX.Toolkit.Graphics,PixelBuffer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs,CopyTo,The length of the statement  "		throw new ArgumentException ("Invalid destination pixelBufferArray. Mush have same Width' Height and Format"' "pixelBuffer"); " is 125.
Long Statement,SharpDX.Toolkit.Graphics,PixelBuffer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs,GetPixels,The length of the statement  "		throw new ArgumentException (string.Format ("Invalid sizeof(T)' not a multiple of current size [{0}]in bytes "' totalSize)); " is 124.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget1D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,New,The length of the statement  "	return new RenderTarget1D (device' NewRenderTargetDescription (width' format' flags | TextureFlags.RenderTarget' mipCount' arraySize)); " is 135.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget2D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget2D.cs,GetRenderTargetView,The length of the statement  "				rtvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? RenderTargetViewDimension.Texture2DMultisampledArray : RenderTargetViewDimension.Texture2DArray; " is 170.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget2D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget2D.cs,GetRenderTargetView,The length of the statement  "				rtvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? RenderTargetViewDimension.Texture2DMultisampled : RenderTargetViewDimension.Texture2D; " is 160.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,New,The length of the statement  "	return new RenderTarget3D (device' NewRenderTargetDescription (width' height' depth' format' flags | TextureFlags.RenderTarget' mipCount)); " is 139.
Long Statement,SharpDX.Toolkit.Graphics,RenderTargetCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTargetCube.cs,New,The length of the statement  "	return new RenderTargetCube (device' NewRenderTargetDescription (size' format' flags | TextureFlags.RenderTarget' mipCount)); " is 125.
Long Statement,SharpDX.Toolkit.Graphics,Texture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,CalculatePixelDataCount,The length of the statement  "	return CalculateWidth<TData> (mipLevel) * CalculateMipSize (Description.Height' mipLevel) * CalculateMipSize (Description.Depth' mipLevel); " is 139.
Long Statement,SharpDX.Toolkit.Graphics,Texture1D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The length of the statement  "		texture = new Texture1D (device' NewDescription (width' format' flags' 1' 1' usage)' GetDataBox (format' width' 1' 1' textureData' ptr)); " is 137.
Long Statement,SharpDX.Toolkit.Graphics,Texture1DBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1DBase.cs,GetUnorderedAccessView,The length of the statement  "				Dimension = this.Description.ArraySize > 1 ? UnorderedAccessViewDimension.Texture1DArray : UnorderedAccessViewDimension.Texture1D " is 129.
Long Statement,SharpDX.Toolkit.Graphics,Texture1DBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1DBase.cs,NewDescription,The length of the statement  "	if ((desc.BindFlags & BindFlags.RenderTarget) != 0 && (desc.BindFlags & BindFlags.ShaderResource) != 0 && desc.MipLevels > 1) { " is 127.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,GetShaderResourceView,The length of the statement  "					srvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? ShaderResourceViewDimension.Texture2DMultisampledArray : ShaderResourceViewDimension.Texture2DArray; " is 174.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,GetShaderResourceView,The length of the statement  "				srvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? ShaderResourceViewDimension.Texture2DMultisampled : ShaderResourceViewDimension.Texture2D; " is 164.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,GetUnorderedAccessView,The length of the statement  "				Dimension = this.Description.ArraySize > 1 ? UnorderedAccessViewDimension.Texture2DArray : UnorderedAccessViewDimension.Texture2D " is 129.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,NewDescription,The length of the statement  "	if ((desc.BindFlags & BindFlags.RenderTarget) != 0 && (desc.BindFlags & BindFlags.ShaderResource) != 0 && desc.MipLevels > 1) { " is 127.
Long Statement,SharpDX.Toolkit.Graphics,Texture3DBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3DBase.cs,NewDescription,The length of the statement  "	if ((desc.BindFlags & BindFlags.RenderTarget) != 0 && (desc.BindFlags & BindFlags.ShaderResource) != 0 && desc.MipLevels > 1) { " is 127.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "	return new TextureCube (device' NewTextureCubeDescription (size' format' flags | TextureFlags.ShaderResource' mipCount' usage)); " is 128.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "	return new TextureCube (device' NewTextureCubeDescription (size' format' flags | TextureFlags.ShaderResource' 1' usage)' dataBox1' dataBox2' dataBox3' dataBox4' dataBox5' dataBox6); " is 181.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "	return new TextureCube (device' NewTextureCubeDescription (size' format' flags | TextureFlags.ShaderResource' 1' usage)' textureData); " is 134.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "	return new TextureCube (device' CreateTextureDescriptionFromImage (image' flags | TextureFlags.ShaderResource' usage)' image.ToDataBox ()); " is 139.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,Load,The length of the statement  "		throw new ArgumentException (string.Format ("Texture is not type of [TextureCube] but [{0}]"' texture.GetType ().Name)); " is 120.
Long Statement,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,ToStagingDescription,The length of the statement  "	copy.OptionFlags = copy.Dimension == TextureDimension.TextureCube ? ResourceOptionFlags.TextureCube : ResourceOptionFlags.None; " is 127.
Long Statement,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,Equals,The length of the statement  "	return Dimension.Equals (other.Dimension) && Width == other.Width && Height == other.Height && Depth == other.Depth && ArraySize == other.ArraySize && MipLevels == other.MipLevels && Format.Equals (other.Format) && SampleDescription.Equals (other.SampleDescription) && Usage.Equals (other.Usage) && BindFlags.Equals (other.BindFlags) && CpuAccessFlags.Equals (other.CpuAccessFlags) && OptionFlags.Equals (other.OptionFlags); " is 424.
Long Statement,SharpDX.Toolkit.Graphics,TextureView,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureView.cs,Initialize,The length of the statement  "				throw new ArgumentException ("Expecting argument to be a ShaderResourceView' RenderTargetView or DepthStencilView"' "view"); " is 124.
Long Statement,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The length of the statement  "		using (var source = new Bitmap (Factory' image.Width' image.Height' pfGuid' new DataRectangle (image.DataPointer' image.RowStride)' image.BufferStride)) { " is 154.
Complex Conditional,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,UpdateAndRender,The conditional expression  "pendingValidationCycles > 0 && !skipper.IsSkip () && surfaceD3D != null && renderRenderable != null"  is complex.
Complex Conditional,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,GetBestAdapter,The conditional expression  "(bestAdapter == null) || (videoMemory > bestVideoMemory) || ((videoMemory == bestVideoMemory) && (systemMemory > bestSystemMemory))"  is complex.
Complex Conditional,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,CreateOctants,The conditional expression  "dimensions == Vector3.Zero || (dimensions.X < minSize && dimensions.Y < minSize && dimensions.Z < minSize)"  is complex.
Complex Conditional,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,GetCircle,The conditional expression  "(!closed && !CircleCache.Value.TryGetValue (thetaDiv' out circle)) || (closed && !ClosedCircleCache.Value.TryGetValue (thetaDiv' out circle))"  is complex.
Complex Conditional,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The conditional expression  "selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1))"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,GetDXGIFormat,The conditional expression  "pixelFormat.RBitMask == entry.PixelFormat.RBitMask && pixelFormat.GBitMask == entry.PixelFormat.GBitMask && pixelFormat.BBitMask == entry.PixelFormat.BBitMask && pixelFormat.ABitMask == entry.PixelFormat.ABitMask"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The conditional expression  "description.Width <= 0 || description.Height != 1 || description.Depth != 1 || description.ArraySize == 0"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The conditional expression  "description.Width <= 0 || description.Height <= 0 || description.Depth != 1 || description.ArraySize == 0"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The conditional expression  "description.Width <= 0 || description.Height <= 0 || description.Depth <= 0 || description.ArraySize != 1"  is complex.
Virtual Method Call from Constructor,HelixToolkit.Wpf.SharpDX,DefaultRenderTechniquesManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\RenderTechniquesManager.cs,DefaultRenderTechniquesManager,The constructor "DefaultRenderTechniquesManager" calls a virtual method "InitTechniques".
Virtual Method Call from Constructor,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,DefaultEffectsManager,The constructor "DefaultEffectsManager" calls a virtual method "InitEffects".
Virtual Method Call from Constructor,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,UICompositeManipulator3D,The constructor "UICompositeManipulator3D" calls a virtual method "OnChildrenChanged".
Empty Catch Block,HelixToolkit.Wpf.SharpDX,Disposer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Disposer.cs,RemoveAndDispose,The method has an empty catch block.
Empty Catch Block,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRasterStateChanged,The method has an empty catch block.
Empty Catch Block,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRasterStateChanged,The method has an empty catch block.
Empty Catch Block,HelixToolkit.Wpf.SharpDX,PatchGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PatchGeometryModel3D.cs,OnRasterStateChanged,The method has an empty catch block.
Empty Catch Block,HelixToolkit.Wpf.SharpDX,PointGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\PointGeometryModel3D.cs,OnRasterStateChanged,The method has an empty catch block.
Empty Catch Block,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnRasterStateChanged,The method has an empty catch block.
Empty Catch Block,HelixToolkit.Wpf.SharpDX,LineGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\LineGeometryModel3D.cs,OnRasterStateChanged,The method has an empty catch block.
Empty Catch Block,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Load,The method has an empty catch block.
Empty Catch Block,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeSingleFrame,The method has an empty catch block.
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddMoveForce,The following statement contains a magic number: this.moveSpeed += delta * 40;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddPanForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.panSpeed += pan * 40;  } else {  	this.panHandler.Pan (pan);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddPanForce,The following statement contains a magic number: this.panSpeed += pan * 40;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.rotationPoint3D = this.CameraTarget;  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotationSpeed.X += dx * 40;  	this.rotationSpeed.Y += dy * 40;  } else {  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + new Vector (dx' dy)' this.CameraTarget);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.rotationPoint3D = this.CameraTarget;  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotationSpeed.X += dx * 40;  	this.rotationSpeed.Y += dy * 40;  } else {  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + new Vector (dx' dy)' this.CameraTarget);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.rotationPoint3D = this.CameraTarget;  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotationSpeed.X += dx * 40;  	this.rotationSpeed.Y += dy * 40;  } else {  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + new Vector (dx' dy)' this.CameraTarget);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.rotationPoint3D = this.CameraTarget;  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotationSpeed.X += dx * 40;  	this.rotationSpeed.Y += dy * 40;  } else {  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + new Vector (dx' dy)' this.CameraTarget);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.rotationPoint3D = this.CameraTarget;  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotationSpeed.X += dx * 40;  	this.rotationSpeed.Y += dy * 40;  } else {  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + new Vector (dx' dy)' this.CameraTarget);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.rotationPoint3D = this.CameraTarget;  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotationSpeed.X += dx * 40;  	this.rotationSpeed.Y += dy * 40;  } else {  	this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  	this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + new Vector (dx' dy)' this.CameraTarget);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationSpeed.X += dx * 40;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationSpeed.Y += dy * 40;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationPosition = new Point (this.ActualWidth / 2' this.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddZoomForce,The following statement contains a magic number: if (this.IsInertiaEnabled) {  	this.zoomPoint3D = zoomOrigin;  	this.zoomSpeed += delta * 8;  } else {  	this.zoomHandler.Zoom (delta' zoomOrigin);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,AddZoomForce,The following statement contains a magic number: this.zoomSpeed += delta * 8;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,PushCameraSetting,The following statement contains a magic number: if (this.cameraHistory.Count > 100) {  	this.cameraHistory.RemoveFirst ();  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,ShowRectangle,The following statement contains a magic number: this.rectangleAdorner = new RectangleAdorner (this.Viewport' rect' color1' color2' 3' 1' 10' DashStyles.Solid);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,ShowRectangle,The following statement contains a magic number: this.rectangleAdorner = new RectangleAdorner (this.Viewport' rect' color1' color2' 3' 1' 10' DashStyles.Solid);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationCompleted,The following statement contains a magic number: if (this.manipulatorCount == 2) {  	this.panHandler.Completed (new ManipulationEventArgs (p));  	this.zoomHandler.Completed (new ManipulationEventArgs (p));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (this.manipulatorCount != n) {  	// the number of manipulators has changed  	if (this.manipulatorCount == 1) {  		this.rotateHandler.Completed (new ManipulationEventArgs (position));  	}  	if (this.manipulatorCount == 2) {  		this.panHandler.Completed (new ManipulationEventArgs (position));  		this.zoomHandler.Completed (new ManipulationEventArgs (position));  	}  	if (n == 2) {  		this.panHandler.Started (new ManipulationEventArgs (position));  		this.zoomHandler.Started (new ManipulationEventArgs (e.ManipulationOrigin));  	} else {  		this.rotateHandler.Started (new ManipulationEventArgs (position));  	}  	// skip this event' the origin may have changed  	this.manipulatorCount = n;  	e.Handled = true;  	return;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (this.manipulatorCount != n) {  	// the number of manipulators has changed  	if (this.manipulatorCount == 1) {  		this.rotateHandler.Completed (new ManipulationEventArgs (position));  	}  	if (this.manipulatorCount == 2) {  		this.panHandler.Completed (new ManipulationEventArgs (position));  		this.zoomHandler.Completed (new ManipulationEventArgs (position));  	}  	if (n == 2) {  		this.panHandler.Started (new ManipulationEventArgs (position));  		this.zoomHandler.Started (new ManipulationEventArgs (e.ManipulationOrigin));  	} else {  		this.rotateHandler.Started (new ManipulationEventArgs (position));  	}  	// skip this event' the origin may have changed  	this.manipulatorCount = n;  	e.Handled = true;  	return;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (this.manipulatorCount == 2) {  	this.panHandler.Completed (new ManipulationEventArgs (position));  	this.zoomHandler.Completed (new ManipulationEventArgs (position));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (n == 2) {  	this.panHandler.Started (new ManipulationEventArgs (position));  	this.zoomHandler.Started (new ManipulationEventArgs (e.ManipulationOrigin));  } else {  	this.rotateHandler.Started (new ManipulationEventArgs (position));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (n == 2) {  	// two fingers pans  	this.panHandler.Delta (new ManipulationEventArgs (position));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (this.IsTouchZoomEnabled && n == 2) {  	var zoomAroundPoint = this.zoomHandler.UnProject (e.ManipulationOrigin' this.zoomHandler.Origin' this.CameraLookDirection);  	if (zoomAroundPoint != null) {  		this.zoomHandler.Zoom (1 - (e.DeltaManipulation.Scale.Length / Math.Sqrt (2))' zoomAroundPoint.Value);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (this.IsTouchZoomEnabled && n == 2) {  	var zoomAroundPoint = this.zoomHandler.UnProject (e.ManipulationOrigin' this.zoomHandler.Origin' this.CameraLookDirection);  	if (zoomAroundPoint != null) {  		this.zoomHandler.Zoom (1 - (e.DeltaManipulation.Scale.Length / Math.Sqrt (2))' zoomAroundPoint.Value);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: if (zoomAroundPoint != null) {  	this.zoomHandler.Zoom (1 - (e.DeltaManipulation.Scale.Length / Math.Sqrt (2))' zoomAroundPoint.Value);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnManipulationDelta,The following statement contains a magic number: this.zoomHandler.Zoom (1 - (e.DeltaManipulation.Scale.Length / Math.Sqrt (2))' zoomAroundPoint.Value);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: if (!shift) {  	switch (e.Key) {  	case Key.Left:  		this.AddRotateForce (-1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddRotateForce (1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddRotateForce (0' -1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddRotateForce (0' 1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	}  } else {  	switch (e.Key) {  	case Key.Left:  		this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: if (!shift) {  	switch (e.Key) {  	case Key.Left:  		this.AddRotateForce (-1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddRotateForce (1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddRotateForce (0' -1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddRotateForce (0' 1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	}  } else {  	switch (e.Key) {  	case Key.Left:  		this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: if (!shift) {  	switch (e.Key) {  	case Key.Left:  		this.AddRotateForce (-1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddRotateForce (1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddRotateForce (0' -1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddRotateForce (0' 1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	}  } else {  	switch (e.Key) {  	case Key.Left:  		this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: if (!shift) {  	switch (e.Key) {  	case Key.Left:  		this.AddRotateForce (-1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddRotateForce (1 * f * this.LeftRightRotationSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddRotateForce (0' -1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddRotateForce (0' 1 * f * this.UpDownRotationSensitivity);  		e.Handled = true;  		break;  	}  } else {  	switch (e.Key) {  	case Key.Left:  		this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Right:  		this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  		e.Handled = true;  		break;  	case Key.Up:  		this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	case Key.Down:  		this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  		e.Handled = true;  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.Left:  	this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Right:  	this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Up:  	this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  case Key.Down:  	this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.Left:  	this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Right:  	this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Up:  	this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  case Key.Down:  	this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.Left:  	this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Right:  	this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Up:  	this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  case Key.Down:  	this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.Left:  	this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Right:  	this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Up:  	this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  case Key.Down:  	this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.PageUp:  	this.AddZoomForce (-0.1 * f * this.PageUpDownZoomSensitivity);  	e.Handled = true;  	break;  case Key.PageDown:  	this.AddZoomForce (0.1 * f * this.PageUpDownZoomSensitivity);  	e.Handled = true;  	break;  case Key.Back:  	if (this.RestoreCameraSetting ()) {  		e.Handled = true;  	}  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.PageUp:  	this.AddZoomForce (-0.1 * f * this.PageUpDownZoomSensitivity);  	e.Handled = true;  	break;  case Key.PageDown:  	this.AddZoomForce (0.1 * f * this.PageUpDownZoomSensitivity);  	e.Handled = true;  	break;  case Key.Back:  	if (this.RestoreCameraSetting ()) {  		e.Handled = true;  	}  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddZoomForce (-0.1 * f * this.PageUpDownZoomSensitivity);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddZoomForce (0.1 * f * this.PageUpDownZoomSensitivity);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.W:  	this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  	break;  case Key.A:  	this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.S:  	this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  	break;  case Key.D:  	this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.Z:  	this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  case Key.Q:  	this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.W:  	this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  	break;  case Key.A:  	this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.S:  	this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  	break;  case Key.D:  	this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.Z:  	this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  case Key.Q:  	this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.W:  	this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  	break;  case Key.A:  	this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.S:  	this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  	break;  case Key.D:  	this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.Z:  	this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  case Key.Q:  	this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.W:  	this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  	break;  case Key.A:  	this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.S:  	this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  	break;  case Key.D:  	this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.Z:  	this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  case Key.Q:  	this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.W:  	this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  	break;  case Key.A:  	this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.S:  	this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  	break;  case Key.D:  	this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.Z:  	this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  case Key.Q:  	this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key) {  case Key.W:  	this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  	break;  case Key.A:  	this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.S:  	this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  	break;  case Key.D:  	this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.Z:  	this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  case Key.Q:  	this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following statement contains a magic number: this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnMouseWheel,The following statement contains a magic number: if (this.ZoomAroundMouseDownPoint) {  	var point = e.GetPosition (this);  	Point3D nearestPoint;  	Vector3D normal;  	Model3D visual;  	if (this.Viewport.FindNearest (point' out nearestPoint' out normal' out visual)) {  		this.AddZoomForce (-e.Delta * 0.001' nearestPoint);  		e.Handled = true;  		return;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnMouseWheel,The following statement contains a magic number: if (this.Viewport.FindNearest (point' out nearestPoint' out normal' out visual)) {  	this.AddZoomForce (-e.Delta * 0.001' nearestPoint);  	e.Handled = true;  	return;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnMouseWheel,The following statement contains a magic number: this.AddZoomForce (-e.Delta * 0.001' nearestPoint);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnMouseWheel,The following statement contains a magic number: this.AddZoomForce (-e.Delta * 0.001);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: factor = this.Clamp (factor' 0.2' 1);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: if (this.rotationSpeed.LengthSquared > 0.1) {  	this.rotateHandler.Rotate (this.rotationPosition' this.rotationPosition + (this.rotationSpeed * time)' this.rotationPoint3D);  	this.rotationSpeed *= factor;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: if (Math.Abs (this.panSpeed.LengthSquared) > 0.0001) {  	this.panHandler.Pan (this.panSpeed * time);  	this.panSpeed *= factor;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: if (Math.Abs (this.moveSpeed.LengthSquared) > 0.0001) {  	this.zoomHandler.MoveCameraPosition (this.moveSpeed * time);  	this.moveSpeed *= factor;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: if (Math.Abs (this.zoomSpeed) > 0.1) {  	this.zoomHandler.Zoom (this.zoomSpeed * time' this.zoomPoint3D);  	this.zoomSpeed *= factor;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitBuffers,The following statement contains a magic number: this.targetWidth = Math.Max ((int)host.ActualWidth' 100);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitBuffers,The following statement contains a magic number: this.targetHeight = Math.Max ((int)host.ActualHeight' 100);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge) {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (midX' 0' 0' 2 * midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' midY' 0' midX' 2 * midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (midX' midY' 0' 2 * midX' 2 * midY' 1)' renderTarget' 0' midX' midY' 0);  } else {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	//context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' midY' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge) {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (midX' 0' 0' 2 * midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' midY' 0' midX' 2 * midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (midX' midY' 0' 2 * midX' 2 * midY' 1)' renderTarget' 0' midX' midY' 0);  } else {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	//context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' midY' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge) {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (midX' 0' 0' 2 * midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' midY' 0' midX' 2 * midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (midX' midY' 0' 2 * midX' 2 * midY' 1)' renderTarget' 0' midX' midY' 0);  } else {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	//context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' midY' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge) {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (midX' 0' 0' 2 * midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' midY' 0' midX' 2 * midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (midX' midY' 0' 2 * midX' 2 * midY' 1)' renderTarget' 0' midX' midY' 0);  } else {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	//context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' midY' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge) {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (midX' 0' 0' 2 * midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' midY' 0' midX' 2 * midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (midX' midY' 0' 2 * midX' 2 * midY' 1)' renderTarget' 0' midX' midY' 0);  } else {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	//context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' midY' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge) {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (midX' 0' 0' 2 * midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' midY' 0' midX' 2 * midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (midX' midY' 0' 2 * midX' 2 * midY' 1)' renderTarget' 0' midX' midY' 0);  } else {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	//context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' midY' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge) {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (midX' 0' 0' 2 * midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' midY' 0' midX' 2 * midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (midX' midY' 0' 2 * midX' 2 * midY' 1)' renderTarget' 0' midX' midY' 0);  } else {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	//context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' midY' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: if (merge) {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (midX' 0' 0' 2 * midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' midY' 0' midX' 2 * midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (midX' midY' 0' 2 * midX' 2 * midY' 1)' renderTarget' 0' midX' midY' 0);  } else {  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [0]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' 0' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' 0' 0);  	//context.DeviceContext.CopySubresourceRegion(this.ssBuffer[0]' 0'  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' midY' 0);  	context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' midY' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: context.DeviceContext.CopySubresourceRegion (this.gBuffer [1]' 0' new ResourceRegion (midX' 0' 0' 2 * midX' midY' 1)' renderTarget' 0' midX' 0' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' midY' 0' midX' 2 * midY' 1)' renderTarget' 0' 0' midY' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' midY' 0' midX' 2 * midY' 1)' renderTarget' 0' 0' midY' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (midX' midY' 0' 2 * midX' 2 * midY' 1)' renderTarget' 0' midX' midY' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (midX' midY' 0' 2 * midX' 2 * midY' 1)' renderTarget' 0' midX' midY' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (midX' midY' 0' 2 * midX' 2 * midY' 1)' renderTarget' 0' midX' midY' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: context.DeviceContext.CopySubresourceRegion (this.gBuffer [2]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' 0' midY' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderGBufferOutput,The following statement contains a magic number: context.DeviceContext.CopySubresourceRegion (this.gBuffer [3]' 0' new ResourceRegion (0' 0' 0' midX' midY' 1)' renderTarget' 0' midX' midY' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderSSAO) {  	if (this.RenderPass == DeferredRenderPasses.RenderDirectDiffuse) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		// render lighting to buffer  		this.SetSSBufferTarget (1' renderContext);  		this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  		// reset default render targets render the buffer-merge pass  		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		this.BindQuadBuffer (renderContext);  		this.RenderMerge (renderContext);  		// perform FXAA pass  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else if (this.RenderPass == DeferredRenderPasses.RenderBlured) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		// render blur and merge  		this.RenderBlurPass (renderContext' renderRenderable' FXAAEnabled ? 2 : -1);  		// perform FXAA pass  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		int target = this.RenderBlurPass (renderContext' renderRenderable' 0);  		// render lighting to ping-pong buffer 1  		this.SetSSBufferTarget (1 - target' renderContext);  		this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  		// render merge-pass of buffer 0 and 1  		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		this.BindQuadBuffer (renderContext);  		this.RenderMerge (renderContext);  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// reset default render targets   		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		// render AO buffer only  		this.RenderScreenSpaceAO (renderContext);  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.BindQuadBuffer (renderContext);  			this.RenderFXAA (renderContext);  		}  	}  } else {  	// reset render targets and run lighting pass  	//this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	// set the lights  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.BindQuadBuffer (renderContext);  		this.RenderFXAA (renderContext);  	}  	#else  	            {                 // reset render targets and run lighting pass                 //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                 this.renderHost.SetDefaultRenderTargets();                 // set the lights                                      this.RenderLighting(renderContext' renderRenderable.Items.OfType<ILight3D>()); #endif  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderSSAO) {  	if (this.RenderPass == DeferredRenderPasses.RenderDirectDiffuse) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		// render lighting to buffer  		this.SetSSBufferTarget (1' renderContext);  		this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  		// reset default render targets render the buffer-merge pass  		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		this.BindQuadBuffer (renderContext);  		this.RenderMerge (renderContext);  		// perform FXAA pass  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else if (this.RenderPass == DeferredRenderPasses.RenderBlured) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		// render blur and merge  		this.RenderBlurPass (renderContext' renderRenderable' FXAAEnabled ? 2 : -1);  		// perform FXAA pass  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		int target = this.RenderBlurPass (renderContext' renderRenderable' 0);  		// render lighting to ping-pong buffer 1  		this.SetSSBufferTarget (1 - target' renderContext);  		this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  		// render merge-pass of buffer 0 and 1  		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		this.BindQuadBuffer (renderContext);  		this.RenderMerge (renderContext);  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// reset default render targets   		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		// render AO buffer only  		this.RenderScreenSpaceAO (renderContext);  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.BindQuadBuffer (renderContext);  			this.RenderFXAA (renderContext);  		}  	}  } else {  	// reset render targets and run lighting pass  	//this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	// set the lights  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.BindQuadBuffer (renderContext);  		this.RenderFXAA (renderContext);  	}  	#else  	            {                 // reset render targets and run lighting pass                 //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                 this.renderHost.SetDefaultRenderTargets();                 // set the lights                                      this.RenderLighting(renderContext' renderRenderable.Items.OfType<ILight3D>()); #endif  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderSSAO) {  	if (this.RenderPass == DeferredRenderPasses.RenderDirectDiffuse) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		// render lighting to buffer  		this.SetSSBufferTarget (1' renderContext);  		this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  		// reset default render targets render the buffer-merge pass  		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		this.BindQuadBuffer (renderContext);  		this.RenderMerge (renderContext);  		// perform FXAA pass  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else if (this.RenderPass == DeferredRenderPasses.RenderBlured) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		// render blur and merge  		this.RenderBlurPass (renderContext' renderRenderable' FXAAEnabled ? 2 : -1);  		// perform FXAA pass  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		int target = this.RenderBlurPass (renderContext' renderRenderable' 0);  		// render lighting to ping-pong buffer 1  		this.SetSSBufferTarget (1 - target' renderContext);  		this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  		// render merge-pass of buffer 0 and 1  		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		this.BindQuadBuffer (renderContext);  		this.RenderMerge (renderContext);  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// reset default render targets   		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		// render AO buffer only  		this.RenderScreenSpaceAO (renderContext);  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.BindQuadBuffer (renderContext);  			this.RenderFXAA (renderContext);  		}  	}  } else {  	// reset render targets and run lighting pass  	//this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	// set the lights  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.BindQuadBuffer (renderContext);  		this.RenderFXAA (renderContext);  	}  	#else  	            {                 // reset render targets and run lighting pass                 //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                 this.renderHost.SetDefaultRenderTargets();                 // set the lights                                      this.RenderLighting(renderContext' renderRenderable.Items.OfType<ILight3D>()); #endif  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderSSAO) {  	if (this.RenderPass == DeferredRenderPasses.RenderDirectDiffuse) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		// render lighting to buffer  		this.SetSSBufferTarget (1' renderContext);  		this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  		// reset default render targets render the buffer-merge pass  		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		this.BindQuadBuffer (renderContext);  		this.RenderMerge (renderContext);  		// perform FXAA pass  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else if (this.RenderPass == DeferredRenderPasses.RenderBlured) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		// render blur and merge  		this.RenderBlurPass (renderContext' renderRenderable' FXAAEnabled ? 2 : -1);  		// perform FXAA pass  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		int target = this.RenderBlurPass (renderContext' renderRenderable' 0);  		// render lighting to ping-pong buffer 1  		this.SetSSBufferTarget (1 - target' renderContext);  		this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  		// render merge-pass of buffer 0 and 1  		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		this.BindQuadBuffer (renderContext);  		this.RenderMerge (renderContext);  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// reset default render targets   		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		// render AO buffer only  		this.RenderScreenSpaceAO (renderContext);  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.BindQuadBuffer (renderContext);  			this.RenderFXAA (renderContext);  		}  	}  } else {  	// reset render targets and run lighting pass  	//this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	// set the lights  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.BindQuadBuffer (renderContext);  		this.RenderFXAA (renderContext);  	}  	#else  	            {                 // reset render targets and run lighting pass                 //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                 this.renderHost.SetDefaultRenderTargets();                 // set the lights                                      this.RenderLighting(renderContext' renderRenderable.Items.OfType<ILight3D>()); #endif  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderSSAO) {  	if (this.RenderPass == DeferredRenderPasses.RenderDirectDiffuse) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		// render lighting to buffer  		this.SetSSBufferTarget (1' renderContext);  		this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  		// reset default render targets render the buffer-merge pass  		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		this.BindQuadBuffer (renderContext);  		this.RenderMerge (renderContext);  		// perform FXAA pass  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else if (this.RenderPass == DeferredRenderPasses.RenderBlured) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		// render blur and merge  		this.RenderBlurPass (renderContext' renderRenderable' FXAAEnabled ? 2 : -1);  		// perform FXAA pass  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse) {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// set SSAO render target and render SSAO  		this.SetSSBufferTarget (0' renderContext);  		this.RenderScreenSpaceAO (renderContext);  		int target = this.RenderBlurPass (renderContext' renderRenderable' 0);  		// render lighting to ping-pong buffer 1  		this.SetSSBufferTarget (1 - target' renderContext);  		this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  		// render merge-pass of buffer 0 and 1  		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		this.BindQuadBuffer (renderContext);  		this.RenderMerge (renderContext);  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.RenderFXAA (renderContext);  		}  	} else {  		// bind quad geometry (good for a full screen-space pass)  		this.BindQuadBuffer (renderContext);  		// reset default render targets   		if (FXAAEnabled) {  			this.SetSSBufferTarget (2' renderContext);  		} else {  			this.renderHost.SetDefaultRenderTargets ();  		}  		// render AO buffer only  		this.RenderScreenSpaceAO (renderContext);  		if (FXAAEnabled) {  			this.renderHost.SetDefaultRenderTargets ();  			this.BindQuadBuffer (renderContext);  			this.RenderFXAA (renderContext);  		}  	}  } else {  	// reset render targets and run lighting pass  	//this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	// set the lights  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.BindQuadBuffer (renderContext);  		this.RenderFXAA (renderContext);  	}  	#else  	            {                 // reset render targets and run lighting pass                 //this.renderHost.SetDefaultColorTargets(this.depthStencilBufferView);                 this.renderHost.SetDefaultRenderTargets();                 // set the lights                                      this.RenderLighting(renderContext' renderRenderable.Items.OfType<ILight3D>()); #endif  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderPass == DeferredRenderPasses.RenderDirectDiffuse) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	// render lighting to buffer  	this.SetSSBufferTarget (1' renderContext);  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	// reset default render targets render the buffer-merge pass  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	this.BindQuadBuffer (renderContext);  	this.RenderMerge (renderContext);  	// perform FXAA pass  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else if (this.RenderPass == DeferredRenderPasses.RenderBlured) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	// render blur and merge  	this.RenderBlurPass (renderContext' renderRenderable' FXAAEnabled ? 2 : -1);  	// perform FXAA pass  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	int target = this.RenderBlurPass (renderContext' renderRenderable' 0);  	// render lighting to ping-pong buffer 1  	this.SetSSBufferTarget (1 - target' renderContext);  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	// render merge-pass of buffer 0 and 1  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	this.BindQuadBuffer (renderContext);  	this.RenderMerge (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// reset default render targets   	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	// render AO buffer only  	this.RenderScreenSpaceAO (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.BindQuadBuffer (renderContext);  		this.RenderFXAA (renderContext);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderPass == DeferredRenderPasses.RenderDirectDiffuse) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	// render lighting to buffer  	this.SetSSBufferTarget (1' renderContext);  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	// reset default render targets render the buffer-merge pass  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	this.BindQuadBuffer (renderContext);  	this.RenderMerge (renderContext);  	// perform FXAA pass  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else if (this.RenderPass == DeferredRenderPasses.RenderBlured) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	// render blur and merge  	this.RenderBlurPass (renderContext' renderRenderable' FXAAEnabled ? 2 : -1);  	// perform FXAA pass  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	int target = this.RenderBlurPass (renderContext' renderRenderable' 0);  	// render lighting to ping-pong buffer 1  	this.SetSSBufferTarget (1 - target' renderContext);  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	// render merge-pass of buffer 0 and 1  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	this.BindQuadBuffer (renderContext);  	this.RenderMerge (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// reset default render targets   	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	// render AO buffer only  	this.RenderScreenSpaceAO (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.BindQuadBuffer (renderContext);  		this.RenderFXAA (renderContext);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderPass == DeferredRenderPasses.RenderDirectDiffuse) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	// render lighting to buffer  	this.SetSSBufferTarget (1' renderContext);  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	// reset default render targets render the buffer-merge pass  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	this.BindQuadBuffer (renderContext);  	this.RenderMerge (renderContext);  	// perform FXAA pass  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else if (this.RenderPass == DeferredRenderPasses.RenderBlured) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	// render blur and merge  	this.RenderBlurPass (renderContext' renderRenderable' FXAAEnabled ? 2 : -1);  	// perform FXAA pass  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	int target = this.RenderBlurPass (renderContext' renderRenderable' 0);  	// render lighting to ping-pong buffer 1  	this.SetSSBufferTarget (1 - target' renderContext);  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	// render merge-pass of buffer 0 and 1  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	this.BindQuadBuffer (renderContext);  	this.RenderMerge (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// reset default render targets   	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	// render AO buffer only  	this.RenderScreenSpaceAO (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.BindQuadBuffer (renderContext);  		this.RenderFXAA (renderContext);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderPass == DeferredRenderPasses.RenderDirectDiffuse) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	// render lighting to buffer  	this.SetSSBufferTarget (1' renderContext);  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	// reset default render targets render the buffer-merge pass  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	this.BindQuadBuffer (renderContext);  	this.RenderMerge (renderContext);  	// perform FXAA pass  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else if (this.RenderPass == DeferredRenderPasses.RenderBlured) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	// render blur and merge  	this.RenderBlurPass (renderContext' renderRenderable' FXAAEnabled ? 2 : -1);  	// perform FXAA pass  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	int target = this.RenderBlurPass (renderContext' renderRenderable' 0);  	// render lighting to ping-pong buffer 1  	this.SetSSBufferTarget (1 - target' renderContext);  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	// render merge-pass of buffer 0 and 1  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	this.BindQuadBuffer (renderContext);  	this.RenderMerge (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// reset default render targets   	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	// render AO buffer only  	this.RenderScreenSpaceAO (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.BindQuadBuffer (renderContext);  		this.RenderFXAA (renderContext);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (FXAAEnabled) {  	this.SetSSBufferTarget (2' renderContext);  } else {  	this.renderHost.SetDefaultRenderTargets ();  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: this.SetSSBufferTarget (2' renderContext);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderPass == DeferredRenderPasses.RenderBlured) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	// render blur and merge  	this.RenderBlurPass (renderContext' renderRenderable' FXAAEnabled ? 2 : -1);  	// perform FXAA pass  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	int target = this.RenderBlurPass (renderContext' renderRenderable' 0);  	// render lighting to ping-pong buffer 1  	this.SetSSBufferTarget (1 - target' renderContext);  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	// render merge-pass of buffer 0 and 1  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	this.BindQuadBuffer (renderContext);  	this.RenderMerge (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// reset default render targets   	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	// render AO buffer only  	this.RenderScreenSpaceAO (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.BindQuadBuffer (renderContext);  		this.RenderFXAA (renderContext);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderPass == DeferredRenderPasses.RenderBlured) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	// render blur and merge  	this.RenderBlurPass (renderContext' renderRenderable' FXAAEnabled ? 2 : -1);  	// perform FXAA pass  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	int target = this.RenderBlurPass (renderContext' renderRenderable' 0);  	// render lighting to ping-pong buffer 1  	this.SetSSBufferTarget (1 - target' renderContext);  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	// render merge-pass of buffer 0 and 1  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	this.BindQuadBuffer (renderContext);  	this.RenderMerge (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// reset default render targets   	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	// render AO buffer only  	this.RenderScreenSpaceAO (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.BindQuadBuffer (renderContext);  		this.RenderFXAA (renderContext);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderPass == DeferredRenderPasses.RenderBlured) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	// render blur and merge  	this.RenderBlurPass (renderContext' renderRenderable' FXAAEnabled ? 2 : -1);  	// perform FXAA pass  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	int target = this.RenderBlurPass (renderContext' renderRenderable' 0);  	// render lighting to ping-pong buffer 1  	this.SetSSBufferTarget (1 - target' renderContext);  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	// render merge-pass of buffer 0 and 1  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	this.BindQuadBuffer (renderContext);  	this.RenderMerge (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// reset default render targets   	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	// render AO buffer only  	this.RenderScreenSpaceAO (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.BindQuadBuffer (renderContext);  		this.RenderFXAA (renderContext);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: this.RenderBlurPass (renderContext' renderRenderable' FXAAEnabled ? 2 : -1);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	int target = this.RenderBlurPass (renderContext' renderRenderable' 0);  	// render lighting to ping-pong buffer 1  	this.SetSSBufferTarget (1 - target' renderContext);  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	// render merge-pass of buffer 0 and 1  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	this.BindQuadBuffer (renderContext);  	this.RenderMerge (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// reset default render targets   	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	// render AO buffer only  	this.RenderScreenSpaceAO (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.BindQuadBuffer (renderContext);  		this.RenderFXAA (renderContext);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (this.RenderPass == DeferredRenderPasses.RenderBluredDiffuse) {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// set SSAO render target and render SSAO  	this.SetSSBufferTarget (0' renderContext);  	this.RenderScreenSpaceAO (renderContext);  	int target = this.RenderBlurPass (renderContext' renderRenderable' 0);  	// render lighting to ping-pong buffer 1  	this.SetSSBufferTarget (1 - target' renderContext);  	this.RenderLighting (renderContext' renderRenderable.Renderables.OfType<ILight3D> ());  	// render merge-pass of buffer 0 and 1  	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	this.BindQuadBuffer (renderContext);  	this.RenderMerge (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.RenderFXAA (renderContext);  	}  } else {  	// bind quad geometry (good for a full screen-space pass)  	this.BindQuadBuffer (renderContext);  	// reset default render targets   	if (FXAAEnabled) {  		this.SetSSBufferTarget (2' renderContext);  	} else {  		this.renderHost.SetDefaultRenderTargets ();  	}  	// render AO buffer only  	this.RenderScreenSpaceAO (renderContext);  	if (FXAAEnabled) {  		this.renderHost.SetDefaultRenderTargets ();  		this.BindQuadBuffer (renderContext);  		this.RenderFXAA (renderContext);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (FXAAEnabled) {  	this.SetSSBufferTarget (2' renderContext);  } else {  	this.renderHost.SetDefaultRenderTargets ();  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: this.SetSSBufferTarget (2' renderContext);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (FXAAEnabled) {  	this.SetSSBufferTarget (2' renderContext);  } else {  	this.renderHost.SetDefaultRenderTargets ();  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: this.SetSSBufferTarget (2' renderContext);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: if (FXAAEnabled) {  	this.SetSSBufferTarget (2' renderContext);  } else {  	this.renderHost.SetDefaultRenderTargets ();  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderDeferred,The following statement contains a magic number: this.SetSSBufferTarget (2' renderContext);  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderLighting,The following statement contains a magic number: foreach (SpotLight3D light in lights.Where (l => l is SpotLight3D)) {  	var lightRadius = (float)EstimateRadius (light.Attenuation);  	double phiHalfRad = light.OuterAngle / 360.0 * Math.PI;  	float scaleX = lightRadius;  	float scaleYZ = lightRadius * (float)Math.Tan (phiHalfRad);  	Vector3 baseX = light.Direction;  	baseX.Normalize ();  	Vector3 baseY' baseZ;  	MakeBasis (baseX' out baseY' out baseZ);  	var spot = new Vector4 ((float)Math.Cos (light.OuterAngle / 360.0 * Math.PI)' (float)Math.Cos (light.InnerAngle / 360.0 * Math.PI)' (float)light.Falloff' 0);  	this.deferredLightingVariables.vLightSpot.Set (ref spot);  	this.deferredLightingVariables.vLightDir.Set (baseX);  	this.deferredLightingVariables.vLightColor.Set (light.Color);  	this.deferredLightingVariables.vLightPos.Set (light.Position.ToVector4 ());  	this.deferredLightingVariables.vLightAtt.Set (light.Attenuation.ToVector4 (100f));  	Matrix lightModelMatrix = new Matrix (baseX.X * scaleX' baseX.Y * scaleX' baseX.Z * scaleX' 0f' baseY.X * scaleYZ' baseY.Y * scaleYZ' baseY.Z * scaleYZ' 0f' baseZ.X * scaleYZ' baseZ.Y * scaleYZ' baseZ.Z * scaleYZ' 0f' (float)light.Position.X' (float)light.Position.Y' (float)light.Position.Z' 1.0f);  	this.deferredLightingVariables.mLightModel.SetMatrix (lightModelMatrix);  	this.deferredLightingVariables.mLightView.SetMatrix (context.viewMatrix);  	this.deferredLightingVariables.mLightProj.SetMatrix (context.projectionMatrix);  	// --- render the geometry  	pass.Apply (context.DeviceContext);  	context.DeviceContext.DrawIndexed (this.screenCone.IndexCount' 0' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderLighting,The following statement contains a magic number: foreach (SpotLight3D light in lights.Where (l => l is SpotLight3D)) {  	var lightRadius = (float)EstimateRadius (light.Attenuation);  	double phiHalfRad = light.OuterAngle / 360.0 * Math.PI;  	float scaleX = lightRadius;  	float scaleYZ = lightRadius * (float)Math.Tan (phiHalfRad);  	Vector3 baseX = light.Direction;  	baseX.Normalize ();  	Vector3 baseY' baseZ;  	MakeBasis (baseX' out baseY' out baseZ);  	var spot = new Vector4 ((float)Math.Cos (light.OuterAngle / 360.0 * Math.PI)' (float)Math.Cos (light.InnerAngle / 360.0 * Math.PI)' (float)light.Falloff' 0);  	this.deferredLightingVariables.vLightSpot.Set (ref spot);  	this.deferredLightingVariables.vLightDir.Set (baseX);  	this.deferredLightingVariables.vLightColor.Set (light.Color);  	this.deferredLightingVariables.vLightPos.Set (light.Position.ToVector4 ());  	this.deferredLightingVariables.vLightAtt.Set (light.Attenuation.ToVector4 (100f));  	Matrix lightModelMatrix = new Matrix (baseX.X * scaleX' baseX.Y * scaleX' baseX.Z * scaleX' 0f' baseY.X * scaleYZ' baseY.Y * scaleYZ' baseY.Z * scaleYZ' 0f' baseZ.X * scaleYZ' baseZ.Y * scaleYZ' baseZ.Z * scaleYZ' 0f' (float)light.Position.X' (float)light.Position.Y' (float)light.Position.Z' 1.0f);  	this.deferredLightingVariables.mLightModel.SetMatrix (lightModelMatrix);  	this.deferredLightingVariables.mLightView.SetMatrix (context.viewMatrix);  	this.deferredLightingVariables.mLightProj.SetMatrix (context.projectionMatrix);  	// --- render the geometry  	pass.Apply (context.DeviceContext);  	context.DeviceContext.DrawIndexed (this.screenCone.IndexCount' 0' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,RenderLighting,The following statement contains a magic number: foreach (SpotLight3D light in lights.Where (l => l is SpotLight3D)) {  	var lightRadius = (float)EstimateRadius (light.Attenuation);  	double phiHalfRad = light.OuterAngle / 360.0 * Math.PI;  	float scaleX = lightRadius;  	float scaleYZ = lightRadius * (float)Math.Tan (phiHalfRad);  	Vector3 baseX = light.Direction;  	baseX.Normalize ();  	Vector3 baseY' baseZ;  	MakeBasis (baseX' out baseY' out baseZ);  	var spot = new Vector4 ((float)Math.Cos (light.OuterAngle / 360.0 * Math.PI)' (float)Math.Cos (light.InnerAngle / 360.0 * Math.PI)' (float)light.Falloff' 0);  	this.deferredLightingVariables.vLightSpot.Set (ref spot);  	this.deferredLightingVariables.vLightDir.Set (baseX);  	this.deferredLightingVariables.vLightColor.Set (light.Color);  	this.deferredLightingVariables.vLightPos.Set (light.Position.ToVector4 ());  	this.deferredLightingVariables.vLightAtt.Set (light.Attenuation.ToVector4 (100f));  	Matrix lightModelMatrix = new Matrix (baseX.X * scaleX' baseX.Y * scaleX' baseX.Z * scaleX' 0f' baseY.X * scaleYZ' baseY.Y * scaleYZ' baseY.Z * scaleYZ' 0f' baseZ.X * scaleYZ' baseZ.Y * scaleYZ' baseZ.Z * scaleYZ' 0f' (float)light.Position.X' (float)light.Position.Y' (float)light.Position.Z' 1.0f);  	this.deferredLightingVariables.mLightModel.SetMatrix (lightModelMatrix);  	this.deferredLightingVariables.mLightView.SetMatrix (context.viewMatrix);  	this.deferredLightingVariables.mLightProj.SetMatrix (context.projectionMatrix);  	// --- render the geometry  	pass.Apply (context.DeviceContext);  	context.DeviceContext.DrawIndexed (this.screenCone.IndexCount' 0' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,ClearRenderTargetViews,The following statement contains a magic number: this.device.ImmediateContext.ClearRenderTargetView (this.gBufferRenderTargetView [2]' new Color4 ());  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,ClearRenderTargetViews,The following statement contains a magic number: this.device.ImmediateContext.ClearRenderTargetView (this.gBufferRenderTargetView [3]' new Color4 ());  
Magic Number,HelixToolkit.Wpf.SharpDX,DeferredRenderer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DeferredRenderer.cs,InitConeBuffer,The following statement contains a magic number: mesh.AddCone (new Vector3 (1.0f' 0.0f' 0.0f)' new Vector3 (0.0f' 0.0f' 0.0f)' 1.0' true' 32);  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,DPFCanvas,The following statement contains a magic number: MaxRenderingDuration = TimeSpan.FromMilliseconds (20.0);  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,CreateAndBindTargets,The following statement contains a magic number: if (MSAA != MSAALevel.Disable) {  	do {  		var newSampleCount = sampleCount * 2;  		var newSampleQuality = device.CheckMultisampleQualityLevels (Format.B8G8R8A8_UNorm' newSampleCount) - 1;  		if (newSampleQuality < 0)  			break;  		sampleCount = newSampleCount;  		sampleQuality = newSampleQuality;  		if (sampleCount == (int)MSAA) {  			break;  		}  	} while (sampleCount < 32);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,CreateAndBindTargets,The following statement contains a magic number: if (MSAA != MSAALevel.Disable) {  	do {  		var newSampleCount = sampleCount * 2;  		var newSampleQuality = device.CheckMultisampleQualityLevels (Format.B8G8R8A8_UNorm' newSampleCount) - 1;  		if (newSampleQuality < 0)  			break;  		sampleCount = newSampleCount;  		sampleQuality = newSampleQuality;  		if (sampleCount == (int)MSAA) {  			break;  		}  	} while (sampleCount < 32);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,CreateAndBindTargets,The following statement contains a magic number: do {  	var newSampleCount = sampleCount * 2;  	var newSampleQuality = device.CheckMultisampleQualityLevels (Format.B8G8R8A8_UNorm' newSampleCount) - 1;  	if (newSampleQuality < 0)  		break;  	sampleCount = newSampleCount;  	sampleQuality = newSampleQuality;  	if (sampleCount == (int)MSAA) {  		break;  	}  } while (sampleCount < 32);  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,CreateAndBindTargets,The following statement contains a magic number: do {  	var newSampleCount = sampleCount * 2;  	var newSampleQuality = device.CheckMultisampleQualityLevels (Format.B8G8R8A8_UNorm' newSampleCount) - 1;  	if (newSampleQuality < 0)  		break;  	sampleCount = newSampleCount;  	sampleQuality = newSampleQuality;  	if (sampleCount == (int)MSAA) {  		break;  	}  } while (sampleCount < 32);  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,Render,The following statement contains a magic number: if (renderRenderable != null) {  	// ---------------------------------------------------------------------------  	// this part is done only if the scene is not attached  	// it is an attach and init pass for all elements in the scene-graph                  	if (!sceneAttached) {  		try {  			Light3DSceneShared.Reset ();  			sceneAttached = true;  			ClearColor = renderRenderable.BackgroundColor;  			IsShadowMapEnabled = renderRenderable.IsShadowMappingEnabled;  			RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique;  			if (renderContext != null) {  				renderContext.Dispose ();  			}  			renderContext = new RenderContext (this' EffectsManager.GetEffect (RenderTechnique)' device.ImmediateContext);  			renderContext.EnableBoundingFrustum = EnableRenderFrustum;  			if (EnableSharingModelMode && SharedModelContainer != null) {  				SharedModelContainer.CurrentRenderHost = this;  				renderRenderable.Attach (SharedModelContainer);  			} else {  				renderRenderable.Attach (this);  			}  			RenderTechniquesManager.RenderTechniques.TryGetValue (DeferredRenderTechniqueNames.GBuffer' out gbuffer);  			RenderTechniquesManager.RenderTechniques.TryGetValue (DeferredRenderTechniqueNames.Deferred' out deferred);  			if (RenderTechnique == deferred) {  				deferredRenderer.InitBuffers (this' Format.R32G32B32A32_Float);  			} else if (RenderTechnique == gbuffer) {  				deferredRenderer.InitBuffers (this' Format.B8G8R8A8_UNorm);  			}  			SetDefaultRenderTargets (false);  		} catch (Exception ex) {  			//MessageBox.Show("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");  			Debug.WriteLine ("DPFCanvas: Error attaching element: " + string.Format (ex.Message)' "Error");  			throw;  		}  	}  	renderContext.TimeStamp = timeStamp;  	// ---------------------------------------------------------------------------  	// this part is per frame  	// ---------------------------------------------------------------------------  	if (EnableSharingModelMode && SharedModelContainer != null) {  		SharedModelContainer.CurrentRenderHost = this;  	}  	ClearRenderTarget ();  	if (RenderTechnique == deferred) {  		// set G-Buffer                      		deferredRenderer.SetGBufferTargets (renderContext);  		// render G-Buffer pass                  		renderRenderable.Render (renderContext);  		// call deferred render   		deferredRenderer.RenderDeferred (renderContext' renderRenderable);  	} else if (RenderTechnique == gbuffer) {  		// set G-Buffer  		deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  		// render G-Buffer pass                      		renderRenderable.Render (renderContext);  		// reset render targets and run lighting pass                                           		#if MSAA  		deferredRenderer.RenderGBufferOutput (renderContext' ref renderTargetNMS);  		#else  		                    this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer); #endif  	} else {  		renderRenderable.Render (renderContext);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,Render,The following statement contains a magic number: if (renderRenderable != null) {  	// ---------------------------------------------------------------------------  	// this part is done only if the scene is not attached  	// it is an attach and init pass for all elements in the scene-graph                  	if (!sceneAttached) {  		try {  			Light3DSceneShared.Reset ();  			sceneAttached = true;  			ClearColor = renderRenderable.BackgroundColor;  			IsShadowMapEnabled = renderRenderable.IsShadowMappingEnabled;  			RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique;  			if (renderContext != null) {  				renderContext.Dispose ();  			}  			renderContext = new RenderContext (this' EffectsManager.GetEffect (RenderTechnique)' device.ImmediateContext);  			renderContext.EnableBoundingFrustum = EnableRenderFrustum;  			if (EnableSharingModelMode && SharedModelContainer != null) {  				SharedModelContainer.CurrentRenderHost = this;  				renderRenderable.Attach (SharedModelContainer);  			} else {  				renderRenderable.Attach (this);  			}  			RenderTechniquesManager.RenderTechniques.TryGetValue (DeferredRenderTechniqueNames.GBuffer' out gbuffer);  			RenderTechniquesManager.RenderTechniques.TryGetValue (DeferredRenderTechniqueNames.Deferred' out deferred);  			if (RenderTechnique == deferred) {  				deferredRenderer.InitBuffers (this' Format.R32G32B32A32_Float);  			} else if (RenderTechnique == gbuffer) {  				deferredRenderer.InitBuffers (this' Format.B8G8R8A8_UNorm);  			}  			SetDefaultRenderTargets (false);  		} catch (Exception ex) {  			//MessageBox.Show("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");  			Debug.WriteLine ("DPFCanvas: Error attaching element: " + string.Format (ex.Message)' "Error");  			throw;  		}  	}  	renderContext.TimeStamp = timeStamp;  	// ---------------------------------------------------------------------------  	// this part is per frame  	// ---------------------------------------------------------------------------  	if (EnableSharingModelMode && SharedModelContainer != null) {  		SharedModelContainer.CurrentRenderHost = this;  	}  	ClearRenderTarget ();  	if (RenderTechnique == deferred) {  		// set G-Buffer                      		deferredRenderer.SetGBufferTargets (renderContext);  		// render G-Buffer pass                  		renderRenderable.Render (renderContext);  		// call deferred render   		deferredRenderer.RenderDeferred (renderContext' renderRenderable);  	} else if (RenderTechnique == gbuffer) {  		// set G-Buffer  		deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  		// render G-Buffer pass                      		renderRenderable.Render (renderContext);  		// reset render targets and run lighting pass                                           		#if MSAA  		deferredRenderer.RenderGBufferOutput (renderContext' ref renderTargetNMS);  		#else  		                    this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer); #endif  	} else {  		renderRenderable.Render (renderContext);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,Render,The following statement contains a magic number: if (RenderTechnique == deferred) {  	// set G-Buffer                      	deferredRenderer.SetGBufferTargets (renderContext);  	// render G-Buffer pass                  	renderRenderable.Render (renderContext);  	// call deferred render   	deferredRenderer.RenderDeferred (renderContext' renderRenderable);  } else if (RenderTechnique == gbuffer) {  	// set G-Buffer  	deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  	// render G-Buffer pass                      	renderRenderable.Render (renderContext);  	// reset render targets and run lighting pass                                           	#if MSAA  	deferredRenderer.RenderGBufferOutput (renderContext' ref renderTargetNMS);  	#else  	                    this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer); #endif  } else {  	renderRenderable.Render (renderContext);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,Render,The following statement contains a magic number: if (RenderTechnique == deferred) {  	// set G-Buffer                      	deferredRenderer.SetGBufferTargets (renderContext);  	// render G-Buffer pass                  	renderRenderable.Render (renderContext);  	// call deferred render   	deferredRenderer.RenderDeferred (renderContext' renderRenderable);  } else if (RenderTechnique == gbuffer) {  	// set G-Buffer  	deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  	// render G-Buffer pass                      	renderRenderable.Render (renderContext);  	// reset render targets and run lighting pass                                           	#if MSAA  	deferredRenderer.RenderGBufferOutput (renderContext' ref renderTargetNMS);  	#else  	                    this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer); #endif  } else {  	renderRenderable.Render (renderContext);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,Render,The following statement contains a magic number: if (RenderTechnique == gbuffer) {  	// set G-Buffer  	deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  	// render G-Buffer pass                      	renderRenderable.Render (renderContext);  	// reset render targets and run lighting pass                                           	#if MSAA  	deferredRenderer.RenderGBufferOutput (renderContext' ref renderTargetNMS);  	#else  	                    this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer); #endif  } else {  	renderRenderable.Render (renderContext);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,Render,The following statement contains a magic number: if (RenderTechnique == gbuffer) {  	// set G-Buffer  	deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  	// render G-Buffer pass                      	renderRenderable.Render (renderContext);  	// reset render targets and run lighting pass                                           	#if MSAA  	deferredRenderer.RenderGBufferOutput (renderContext' ref renderTargetNMS);  	#else  	                    this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer); #endif  } else {  	renderRenderable.Render (renderContext);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,Render,The following statement contains a magic number: deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvas,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvas.cs,Render,The following statement contains a magic number: deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,DPFCanvasThreading,The following statement contains a magic number: MaxRenderingDuration = TimeSpan.FromMilliseconds (20.0);  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,CreateAndBindTargets,The following statement contains a magic number: if (MSAA != MSAALevel.Disable) {  	do {  		var newSampleCount = sampleCount * 2;  		var newSampleQuality = device.CheckMultisampleQualityLevels (Format.B8G8R8A8_UNorm' newSampleCount) - 1;  		if (newSampleQuality < 0)  			break;  		sampleCount = newSampleCount;  		sampleQuality = newSampleQuality;  		if (sampleCount == (int)MSAA) {  			break;  		}  	} while (sampleCount < 32);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,CreateAndBindTargets,The following statement contains a magic number: if (MSAA != MSAALevel.Disable) {  	do {  		var newSampleCount = sampleCount * 2;  		var newSampleQuality = device.CheckMultisampleQualityLevels (Format.B8G8R8A8_UNorm' newSampleCount) - 1;  		if (newSampleQuality < 0)  			break;  		sampleCount = newSampleCount;  		sampleQuality = newSampleQuality;  		if (sampleCount == (int)MSAA) {  			break;  		}  	} while (sampleCount < 32);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,CreateAndBindTargets,The following statement contains a magic number: do {  	var newSampleCount = sampleCount * 2;  	var newSampleQuality = device.CheckMultisampleQualityLevels (Format.B8G8R8A8_UNorm' newSampleCount) - 1;  	if (newSampleQuality < 0)  		break;  	sampleCount = newSampleCount;  	sampleQuality = newSampleQuality;  	if (sampleCount == (int)MSAA) {  		break;  	}  } while (sampleCount < 32);  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,CreateAndBindTargets,The following statement contains a magic number: do {  	var newSampleCount = sampleCount * 2;  	var newSampleQuality = device.CheckMultisampleQualityLevels (Format.B8G8R8A8_UNorm' newSampleCount) - 1;  	if (newSampleQuality < 0)  		break;  	sampleCount = newSampleCount;  	sampleQuality = newSampleQuality;  	if (sampleCount == (int)MSAA) {  		break;  	}  } while (sampleCount < 32);  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,The following statement contains a magic number: if (renderRenderable != null) {  	// ---------------------------------------------------------------------------  	// this part is done only if the scene is not attached  	// it is an attach and init pass for all elements in the scene-graph                  	if (!sceneAttached) {  		try {  			Light3DSceneShared.Reset ();  			sceneAttached = true;  			ClearColor = renderRenderable.BackgroundColor;  			IsShadowMapEnabled = renderRenderable.IsShadowMappingEnabled;  			RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique;  			if (renderContext != null) {  				renderContext.Dispose ();  			}  			renderContext = new RenderContext (this' EffectsManager.GetEffect (RenderTechnique)' new DeviceContext (device));  			renderContext.EnableBoundingFrustum = EnableRenderFrustum;  			if (EnableSharingModelMode && SharedModelContainer != null) {  				SharedModelContainer.CurrentRenderHost = this;  				renderRenderable.Attach (SharedModelContainer);  			} else {  				renderRenderable.Attach (this);  			}  			RenderTechniquesManager.RenderTechniques.TryGetValue (DeferredRenderTechniqueNames.GBuffer' out gbuffer);  			RenderTechniquesManager.RenderTechniques.TryGetValue (DeferredRenderTechniqueNames.Deferred' out deferred);  			if (RenderTechnique == deferred) {  				deferredRenderer.InitBuffers (this' Format.R32G32B32A32_Float);  			} else if (RenderTechnique == gbuffer) {  				deferredRenderer.InitBuffers (this' Format.B8G8R8A8_UNorm);  			}  			SetDefaultRenderTargets ();  		} catch (Exception ex) {  			//MessageBox.Show("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");  			Debug.WriteLine ("DPFCanvas: Error attaching element: " + string.Format (ex.Message)' "Error");  			throw;  		}  	}  	// ---------------------------------------------------------------------------  	// this part is per frame  	// ---------------------------------------------------------------------------  	renderContext.TimeStamp = timeStamp;  	if (EnableSharingModelMode && SharedModelContainer != null) {  		SharedModelContainer.CurrentRenderHost = this;  	} else {  		ClearRenderTarget ();  	}  	if (RenderTechnique == deferred) {  		// set G-Buffer                      		deferredRenderer.SetGBufferTargets (renderContext);  		// render G-Buffer pass                  		renderRenderable.Render (renderContext);  		// call deferred render   		deferredRenderer.RenderDeferred (renderContext' renderRenderable);  	} else if (RenderTechnique == gbuffer) {  		// set G-Buffer  		deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  		// render G-Buffer pass                      		renderRenderable.Render (renderContext);  		// reset render targets and run lighting pass                                           		#if MSAA  		deferredRenderer.RenderGBufferOutput (renderContext' ref renderTargetNMS);  		#else  		                    this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer); #endif  	} else {  		renderRenderable.Render (renderContext);  	}  	var command = renderContext.DeviceContext.FinishCommandList (true);  	mRenderThread.InvalidateD3D (command);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,The following statement contains a magic number: if (renderRenderable != null) {  	// ---------------------------------------------------------------------------  	// this part is done only if the scene is not attached  	// it is an attach and init pass for all elements in the scene-graph                  	if (!sceneAttached) {  		try {  			Light3DSceneShared.Reset ();  			sceneAttached = true;  			ClearColor = renderRenderable.BackgroundColor;  			IsShadowMapEnabled = renderRenderable.IsShadowMappingEnabled;  			RenderTechnique = renderRenderable.RenderTechnique == null ? RenderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn] : renderRenderable.RenderTechnique;  			if (renderContext != null) {  				renderContext.Dispose ();  			}  			renderContext = new RenderContext (this' EffectsManager.GetEffect (RenderTechnique)' new DeviceContext (device));  			renderContext.EnableBoundingFrustum = EnableRenderFrustum;  			if (EnableSharingModelMode && SharedModelContainer != null) {  				SharedModelContainer.CurrentRenderHost = this;  				renderRenderable.Attach (SharedModelContainer);  			} else {  				renderRenderable.Attach (this);  			}  			RenderTechniquesManager.RenderTechniques.TryGetValue (DeferredRenderTechniqueNames.GBuffer' out gbuffer);  			RenderTechniquesManager.RenderTechniques.TryGetValue (DeferredRenderTechniqueNames.Deferred' out deferred);  			if (RenderTechnique == deferred) {  				deferredRenderer.InitBuffers (this' Format.R32G32B32A32_Float);  			} else if (RenderTechnique == gbuffer) {  				deferredRenderer.InitBuffers (this' Format.B8G8R8A8_UNorm);  			}  			SetDefaultRenderTargets ();  		} catch (Exception ex) {  			//MessageBox.Show("DPFCanvas: Error attaching element: " + string.Format(ex.Message)' "Error");  			Debug.WriteLine ("DPFCanvas: Error attaching element: " + string.Format (ex.Message)' "Error");  			throw;  		}  	}  	// ---------------------------------------------------------------------------  	// this part is per frame  	// ---------------------------------------------------------------------------  	renderContext.TimeStamp = timeStamp;  	if (EnableSharingModelMode && SharedModelContainer != null) {  		SharedModelContainer.CurrentRenderHost = this;  	} else {  		ClearRenderTarget ();  	}  	if (RenderTechnique == deferred) {  		// set G-Buffer                      		deferredRenderer.SetGBufferTargets (renderContext);  		// render G-Buffer pass                  		renderRenderable.Render (renderContext);  		// call deferred render   		deferredRenderer.RenderDeferred (renderContext' renderRenderable);  	} else if (RenderTechnique == gbuffer) {  		// set G-Buffer  		deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  		// render G-Buffer pass                      		renderRenderable.Render (renderContext);  		// reset render targets and run lighting pass                                           		#if MSAA  		deferredRenderer.RenderGBufferOutput (renderContext' ref renderTargetNMS);  		#else  		                    this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer); #endif  	} else {  		renderRenderable.Render (renderContext);  	}  	var command = renderContext.DeviceContext.FinishCommandList (true);  	mRenderThread.InvalidateD3D (command);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,The following statement contains a magic number: if (RenderTechnique == deferred) {  	// set G-Buffer                      	deferredRenderer.SetGBufferTargets (renderContext);  	// render G-Buffer pass                  	renderRenderable.Render (renderContext);  	// call deferred render   	deferredRenderer.RenderDeferred (renderContext' renderRenderable);  } else if (RenderTechnique == gbuffer) {  	// set G-Buffer  	deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  	// render G-Buffer pass                      	renderRenderable.Render (renderContext);  	// reset render targets and run lighting pass                                           	#if MSAA  	deferredRenderer.RenderGBufferOutput (renderContext' ref renderTargetNMS);  	#else  	                    this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer); #endif  } else {  	renderRenderable.Render (renderContext);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,The following statement contains a magic number: if (RenderTechnique == deferred) {  	// set G-Buffer                      	deferredRenderer.SetGBufferTargets (renderContext);  	// render G-Buffer pass                  	renderRenderable.Render (renderContext);  	// call deferred render   	deferredRenderer.RenderDeferred (renderContext' renderRenderable);  } else if (RenderTechnique == gbuffer) {  	// set G-Buffer  	deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  	// render G-Buffer pass                      	renderRenderable.Render (renderContext);  	// reset render targets and run lighting pass                                           	#if MSAA  	deferredRenderer.RenderGBufferOutput (renderContext' ref renderTargetNMS);  	#else  	                    this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer); #endif  } else {  	renderRenderable.Render (renderContext);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,The following statement contains a magic number: if (RenderTechnique == gbuffer) {  	// set G-Buffer  	deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  	// render G-Buffer pass                      	renderRenderable.Render (renderContext);  	// reset render targets and run lighting pass                                           	#if MSAA  	deferredRenderer.RenderGBufferOutput (renderContext' ref renderTargetNMS);  	#else  	                    this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer); #endif  } else {  	renderRenderable.Render (renderContext);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,The following statement contains a magic number: if (RenderTechnique == gbuffer) {  	// set G-Buffer  	deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  	// render G-Buffer pass                      	renderRenderable.Render (renderContext);  	// reset render targets and run lighting pass                                           	#if MSAA  	deferredRenderer.RenderGBufferOutput (renderContext' ref renderTargetNMS);  	#else  	                    this.deferredRenderer.RenderGBufferOutput(ref this.colorBuffer); #endif  } else {  	renderRenderable.Render (renderContext);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,The following statement contains a magic number: deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  
Magic Number,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,Render,The following statement contains a magic number: deferredRenderer.SetGBufferTargets (targetWidth / 2' targetHeight / 2' renderContext);  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,ShowZoomRectangle,The following statement contains a magic number: this.rectangleAdorner = new RectangleAdorner (visual' rect' Colors.LightGray' Colors.Black' 3' 1' 10' DashStyles.Solid);  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,ShowZoomRectangle,The following statement contains a magic number: this.rectangleAdorner = new RectangleAdorner (visual' rect' Colors.LightGray' Colors.Black' 3' 1' 10' DashStyles.Solid);  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnCameraChanged,The following statement contains a magic number: if (this.coordinateView != null) {  	var pc = (System.Windows.Media.Media3D.PerspectiveCamera)this.coordinateView.Camera;  	pc.LookDirection = lookdir * 30;  	pc.Position = origin - pc.LookDirection;  	pc.UpDirection = projectionCamera.UpDirection;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnCameraChanged,The following statement contains a magic number: pc.LookDirection = lookdir * 30;  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnCameraChanged,The following statement contains a magic number: if (this.viewCubeViewport != null) {  	var pc = (System.Windows.Media.Media3D.PerspectiveCamera)this.viewCubeViewport.Camera;  	pc.LookDirection = lookdir * 20;  	pc.Position = origin - pc.LookDirection;  	pc.UpDirection = projectionCamera.UpDirection;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnCameraChanged,The following statement contains a magic number: pc.LookDirection = lookdir * 20;  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,GetPressedMouseButtons,The following statement contains a magic number: flags |= (int)Mouse.LeftButton << 20;  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,GetPressedMouseButtons,The following statement contains a magic number: flags |= (int)Mouse.RightButton << 21;  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,GetPressedMouseButtons,The following statement contains a magic number: flags |= (int)Mouse.MiddleButton << 22;  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,GetPressedMouseButtons,The following statement contains a magic number: flags |= (int)Mouse.XButton1 << 23;  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,GetPressedMouseButtons,The following statement contains a magic number: flags |= (int)Mouse.XButton2 << 24;  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnCompositionTargetRendering,The following statement contains a magic number: if (this.ShowFrameRate && this.fpsWatch.ElapsedMilliseconds > 500) {  	this.FrameRate = (int)this.FpsCounter.Value;  	this.FrameRateText = this.FrameRate + " FPS";  	this.fpsWatch.Restart ();  }  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,OnCompositionTargetRendering,The following statement contains a magic number: if (this.ShowTriangleCountInfo && this.infoFrameCounter > 100) {  	int count = this.GetTotalNumberOfTriangles ();  	this.TriangleCountInfo = string.Format ("Triangles: {0}"' count);  	this.infoFrameCounter = 0;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,ViewCubeClicked,The following statement contains a magic number: pc.AnimateTo (newPosition' e.LookDirection' e.UpDirection' 500);  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,ViewCubeViewportMouseEnter,The following statement contains a magic number: AnimateOpacity (this.viewCubeViewport' 1.0' 200);  
Magic Number,HelixToolkit.Wpf.SharpDX,Viewport3DX,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Viewport3DX.cs,ViewCubeViewportMouseLeave,The following statement contains a magic number: AnimateOpacity (this.viewCubeViewport' this.ViewCubeOpacity' 200);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new Point3DAnimation (fromPosition' newPosition' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a1.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.PositionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.PositionProperty' a1);  	var a2 = new Vector3DAnimation (fromDirection' newDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a2.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' a2);  	var a3 = new Vector3DAnimation (fromUpDirection' newUpDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a3.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' a3);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new Point3DAnimation (fromPosition' newPosition' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a1.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.PositionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.PositionProperty' a1);  	var a2 = new Vector3DAnimation (fromDirection' newDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a2.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' a2);  	var a3 = new Vector3DAnimation (fromUpDirection' newUpDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a3.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' a3);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new Point3DAnimation (fromPosition' newPosition' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a1.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.PositionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.PositionProperty' a1);  	var a2 = new Vector3DAnimation (fromDirection' newDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a2.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' a2);  	var a3 = new Vector3DAnimation (fromUpDirection' newUpDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a3.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' a3);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new Point3DAnimation (fromPosition' newPosition' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a1.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.PositionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.PositionProperty' a1);  	var a2 = new Vector3DAnimation (fromDirection' newDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a2.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' a2);  	var a3 = new Vector3DAnimation (fromUpDirection' newUpDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a3.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' a3);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new Point3DAnimation (fromPosition' newPosition' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a1.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.PositionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.PositionProperty' a1);  	var a2 = new Vector3DAnimation (fromDirection' newDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a2.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' a2);  	var a3 = new Vector3DAnimation (fromUpDirection' newUpDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a3.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' a3);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateTo,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new Point3DAnimation (fromPosition' newPosition' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a1.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.PositionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.PositionProperty' a1);  	var a2 = new Vector3DAnimation (fromDirection' newDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a2.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.LookDirectionProperty' a2);  	var a3 = new Vector3DAnimation (fromUpDirection' newUpDirection' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	a3.Completed += (s' a) => {  		camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' null);  	};  	camera.BeginAnimation (ProjectionCamera.UpDirectionProperty' a3);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateWidth,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new DoubleAnimation (fromWidth' newWidth' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	camera.BeginAnimation (OrthographicCamera.WidthProperty' a1);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,AnimateWidth,The following statement contains a magic number: if (animationTime > 0) {  	var a1 = new DoubleAnimation (fromWidth' newWidth' new Duration (TimeSpan.FromMilliseconds (animationTime))) {  		AccelerationRatio = 0.3'  		DecelerationRatio = 0.5'  		FillBehavior = FillBehavior.Stop  	};  	camera.BeginAnimation (OrthographicCamera.WidthProperty' a1);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (pdest != null) {  	projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance > 0 ? projectionSource.NearPlaneDistance : 1e-1;  	projectionDest.FarPlaneDistance = projectionSource.FarPlaneDistance;  	double fov = 45;  	if (psrc != null) {  		fov = psrc.FieldOfView;  	}  	if (osrc != null) {  		double dist = projectionSource.LookDirection.Length;  		fov = Math.Atan2 (osrc.Width / 2' dist) * (180 / Math.PI);  	}  	pdest.FieldOfView = fov;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (pdest != null) {  	projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance > 0 ? projectionSource.NearPlaneDistance : 1e-1;  	projectionDest.FarPlaneDistance = projectionSource.FarPlaneDistance;  	double fov = 45;  	if (psrc != null) {  		fov = psrc.FieldOfView;  	}  	if (osrc != null) {  		double dist = projectionSource.LookDirection.Length;  		fov = Math.Atan2 (osrc.Width / 2' dist) * (180 / Math.PI);  	}  	pdest.FieldOfView = fov;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (pdest != null) {  	projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance > 0 ? projectionSource.NearPlaneDistance : 1e-1;  	projectionDest.FarPlaneDistance = projectionSource.FarPlaneDistance;  	double fov = 45;  	if (psrc != null) {  		fov = psrc.FieldOfView;  	}  	if (osrc != null) {  		double dist = projectionSource.LookDirection.Length;  		fov = Math.Atan2 (osrc.Width / 2' dist) * (180 / Math.PI);  	}  	pdest.FieldOfView = fov;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (pdest != null) {  	projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance > 0 ? projectionSource.NearPlaneDistance : 1e-1;  	projectionDest.FarPlaneDistance = projectionSource.FarPlaneDistance;  	double fov = 45;  	if (psrc != null) {  		fov = psrc.FieldOfView;  	}  	if (osrc != null) {  		double dist = projectionSource.LookDirection.Length;  		fov = Math.Atan2 (osrc.Width / 2' dist) * (180 / Math.PI);  	}  	pdest.FieldOfView = fov;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance > 0 ? projectionSource.NearPlaneDistance : 1e-1;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (osrc != null) {  	double dist = projectionSource.LookDirection.Length;  	fov = Math.Atan2 (osrc.Width / 2' dist) * (180 / Math.PI);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (osrc != null) {  	double dist = projectionSource.LookDirection.Length;  	fov = Math.Atan2 (osrc.Width / 2' dist) * (180 / Math.PI);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: fov = Math.Atan2 (osrc.Width / 2' dist) * (180 / Math.PI);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: fov = Math.Atan2 (osrc.Width / 2' dist) * (180 / Math.PI);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (odest != null) {  	projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance;  	projectionDest.FarPlaneDistance = projectionSource.FarPlaneDistance;  	double width = 100;  	if (psrc != null) {  		double dist = projectionSource.LookDirection.Length;  		width = Math.Tan (psrc.FieldOfView / 180 * Math.PI) * 2 * dist;  	}  	if (osrc != null) {  		width = osrc.Width;  	}  	odest.Width = width;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (odest != null) {  	projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance;  	projectionDest.FarPlaneDistance = projectionSource.FarPlaneDistance;  	double width = 100;  	if (psrc != null) {  		double dist = projectionSource.LookDirection.Length;  		width = Math.Tan (psrc.FieldOfView / 180 * Math.PI) * 2 * dist;  	}  	if (osrc != null) {  		width = osrc.Width;  	}  	odest.Width = width;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (odest != null) {  	projectionDest.NearPlaneDistance = projectionSource.NearPlaneDistance;  	projectionDest.FarPlaneDistance = projectionSource.FarPlaneDistance;  	double width = 100;  	if (psrc != null) {  		double dist = projectionSource.LookDirection.Length;  		width = Math.Tan (psrc.FieldOfView / 180 * Math.PI) * 2 * dist;  	}  	if (osrc != null) {  		width = osrc.Width;  	}  	odest.Width = width;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (psrc != null) {  	double dist = projectionSource.LookDirection.Length;  	width = Math.Tan (psrc.FieldOfView / 180 * Math.PI) * 2 * dist;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: if (psrc != null) {  	double dist = projectionSource.LookDirection.Length;  	width = Math.Tan (psrc.FieldOfView / 180 * Math.PI) * 2 * dist;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: width = Math.Tan (psrc.FieldOfView / 180 * Math.PI) * 2 * dist;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,CopyTo,The following statement contains a magic number: width = Math.Tan (psrc.FieldOfView / 180 * Math.PI) * 2 * dist;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D (20' 10' 40);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D (20' 10' 40);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D (20' 10' 40);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D (-20' -10' -40);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D (-20' -10' -40);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D (-20' -10' -40);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.FieldOfView = 45;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.NearPlaneDistance = 0.1;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.FarPlaneDistance = 1000;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D (20' 10' 40);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D (20' 10' 40);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.Position = new Point3D (20' 10' 40);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D (-20' -10' -40);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D (-20' -10' -40);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3D (-20' -10' -40);  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.Width = 40;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.NearPlaneDistance = 0.1;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,Reset,The following statement contains a magic number: camera.FarPlaneDistance = 1000;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: if (camera is PerspectiveCamera) {  	var pcam = camera as PerspectiveCamera;  	double disth = radius / Math.Tan (0.5 * pcam.FieldOfView * Math.PI / 180);  	double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;  	double distv = radius / Math.Tan (0.5 * vfov * Math.PI / 180);  	double dist = Math.Max (disth' distv);  	var dir = projectionCamera.LookDirection;  	dir.Normalize ();  	LookAt (projectionCamera' center' dir * dist' animationTime);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: if (camera is PerspectiveCamera) {  	var pcam = camera as PerspectiveCamera;  	double disth = radius / Math.Tan (0.5 * pcam.FieldOfView * Math.PI / 180);  	double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;  	double distv = radius / Math.Tan (0.5 * vfov * Math.PI / 180);  	double dist = Math.Max (disth' distv);  	var dir = projectionCamera.LookDirection;  	dir.Normalize ();  	LookAt (projectionCamera' center' dir * dist' animationTime);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: if (camera is PerspectiveCamera) {  	var pcam = camera as PerspectiveCamera;  	double disth = radius / Math.Tan (0.5 * pcam.FieldOfView * Math.PI / 180);  	double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;  	double distv = radius / Math.Tan (0.5 * vfov * Math.PI / 180);  	double dist = Math.Max (disth' distv);  	var dir = projectionCamera.LookDirection;  	dir.Normalize ();  	LookAt (projectionCamera' center' dir * dist' animationTime);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: if (camera is PerspectiveCamera) {  	var pcam = camera as PerspectiveCamera;  	double disth = radius / Math.Tan (0.5 * pcam.FieldOfView * Math.PI / 180);  	double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;  	double distv = radius / Math.Tan (0.5 * vfov * Math.PI / 180);  	double dist = Math.Max (disth' distv);  	var dir = projectionCamera.LookDirection;  	dir.Normalize ();  	LookAt (projectionCamera' center' dir * dist' animationTime);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: if (camera is OrthographicCamera) {  	LookAt (projectionCamera' center' projectionCamera.LookDirection' animationTime);  	double newWidth = radius * 2;  	if (viewport.ActualWidth > viewport.ActualHeight) {  		newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;  	}  	AnimateWidth (camera as OrthographicCamera' newWidth' animationTime);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: if (camera is OrthographicCamera) {  	LookAt (projectionCamera' center' projectionCamera.LookDirection' animationTime);  	double newWidth = radius * 2;  	if (viewport.ActualWidth > viewport.ActualHeight) {  		newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;  	}  	AnimateWidth (camera as OrthographicCamera' newWidth' animationTime);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: if (viewport.ActualWidth > viewport.ActualHeight) {  	newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomExtents,The following statement contains a magic number: newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomToRectangle,The following statement contains a magic number: if (perspectiveCamera != null) {  	var distance = pcam.LookDirection.Length;  	// option 1: change distance  	var newDistance = distance * zoomRectangle.Width / viewport.ActualWidth;  	var newLookDirection = newDistance * w;  	var newPosition = perspectiveCamera.Position + ((distance - newDistance) * w);  	var newTarget = newPosition + newLookDirection;  	LookAt (pcam' newTarget' newLookDirection' 200);  	// option 2: change fov  	// double newFieldOfView = Math.Acos(Vector3D.DotProduct(u' v));  	// var newTarget = camera.Position + distance * w;  	// pcamera.FieldOfView = newFieldOfView * 180 / Math.PI;  	// LookAt(camera' newTarget' distance * w' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,CameraExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraExtensions.cs,ZoomToRectangle,The following statement contains a magic number: LookAt (pcam' newTarget' newLookDirection' 200);  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: try {  	RegisterEffect (shaderEffectString' new[] {  		// put here the techniques which you want to use with this effect  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.ParticleStorm]  	});  	var phong = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong];  	defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var instancingblinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.InstancingBlinn];  	var instancingInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.InstancingBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var boneSkinBlinn = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BoneSkinBlinn];  	var boneSkinInputLayout = new InputLayout (device' GetEffect (instancingblinn).GetTechniqueByName (DefaultRenderTechniqueNames.BoneSkinBlinn).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("BONEIDS"' 0' Format.R32G32B32A32_SInt' InputElement.AppendAligned' 1)'  		new InputElement ("BONEWEIGHTS"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	var lines = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Lines];  	var linesInputLayout = new InputLayout (device' GetEffect (lines).GetTechniqueByName (DefaultRenderTechniqueNames.Lines).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	});  	var cubeMap = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.CubeMap];  	cubeMapInputLayout = new InputLayout (device' GetEffect (cubeMap).GetTechniqueByName (DefaultRenderTechniqueNames.CubeMap).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var points = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Points];  	var pointsInputLayout = new InputLayout (device' GetEffect (points).GetTechniqueByName (DefaultRenderTechniqueNames.Points).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)  	});  	var text = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardText];  	var billboardInputLayout = new InputLayout (device' GetEffect (text).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardText).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	});  	var billboardinstancing = renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.BillboardInstancing];  	var billboardInstancingInputLayout = new InputLayout (device' GetEffect (billboardinstancing).GetTechniqueByName (DefaultRenderTechniqueNames.BillboardInstancing).GetPassByIndex (0).Description.Signature' new[] {  		new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		new InputElement ("TEXCOORD"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  		//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  		new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  		new InputElement ("COLOR"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 5' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  		new InputElement ("TEXCOORD"' 6' Format.R32G32_Float' InputElement.AppendAligned' 2' InputClassification.PerInstanceData' 1)'  	});  	//var particle = renderTechniquesManager.RenderTechniques[DefaultRenderTechniqueNames.ParticleStorm];  	//var particleLayout = new InputLayout(device' GetEffect(particle).GetTechniqueByName(DefaultRenderTechniqueNames.ParticleStorm)  	//    .GetPassByIndex(2).Description.Signature'  	//    null);  	RegisterLayout (new[] {  		cubeMap  	}' cubeMapInputLayout);  	RegisterLayout (new[] {  		lines  	}' linesInputLayout);  	RegisterLayout (new[] {  		points  	}' pointsInputLayout);  	RegisterLayout (new[] {  		text  	}' billboardInputLayout);  	RegisterLayout (new[] {  		// put here techniques which use the vertex layout below  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Phong]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Blinn]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Diffuse]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Positions]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Normals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.PerturbedNormals]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Tangents]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.TexCoords]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Colors]'  		renderTechniquesManager.RenderTechniques [DefaultRenderTechniqueNames.Wires]'  	}' defaultInputLayout);  	RegisterLayout (new[] {  		instancingblinn  	}' instancingInputLayout);  	RegisterLayout (new[] {  		boneSkinBlinn  	}' boneSkinInputLayout);  	RegisterLayout (new[] {  		billboardinstancing  	}' billboardInstancingInputLayout);  	//   RegisterLayout(new[] { particle }' particleLayout);  } catch (Exception ex) {  	Debug.WriteLine (string.Format ("Error registering effect: {0}"' ex.Message)' "Error");  	throw;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  	new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  	//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  	new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  });  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  	new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  	//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  	new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  });  
Magic Number,HelixToolkit.Wpf.SharpDX,DefaultEffectsManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Effects.cs,RegisterDefaultLayoutsAndEffects,The following statement contains a magic number: defaultInputLayout = new InputLayout (device' GetEffect (phong).GetTechniqueByName (DefaultRenderTechniqueNames.Phong).GetPassByIndex (0).Description.Signature' new[] {  	new InputElement ("POSITION"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("COLOR"' 0' Format.R32G32B32A32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("TEXCOORD"' 0' Format.R32G32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("NORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("TANGENT"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  	new InputElement ("BINORMAL"' 0' Format.R32G32B32_Float' InputElement.AppendAligned' 0)'  	//INSTANCING: die 4 texcoords sind die matrix' die mit jedem buffer reinwandern  	new InputElement ("TEXCOORD"' 1' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	new InputElement ("TEXCOORD"' 2' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	new InputElement ("TEXCOORD"' 3' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  	new InputElement ("TEXCOORD"' 4' Format.R32G32B32A32_Float' InputElement.AppendAligned' 1' InputClassification.PerInstanceData' 1)'  });  
Magic Number,HelixToolkit.Wpf.SharpDX,FpsCounter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\FpsCounter.cs,TrimFrames,The following statement contains a magic number: while (m_frames.Count > 10 && Math.Abs (m_frames.Last - m_frames.First) > MinimumUpdateDuration && (target > m_frames.First || m_frames.First > m_frames.Last || m_frames.IsFull ()))//the second condition happened when switching tabs' the TotalMilliseconds reset to 0 from composite rendering   {  	m_frames.RemoveFirst ();  }  
Magic Number,HelixToolkit.Wpf.SharpDX,FpsCounter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\FpsCounter.cs,UpdateValue,The following statement contains a magic number: if (m_frames.Count < 2) {  	Value = -1;  } else {  	var dt = m_frames.Last - m_frames.First;  	if (dt > MinimumUpdateDuration)  		Value = m_frames.Count / (dt / 1000);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,FpsCounter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\FpsCounter.cs,UpdateValue,The following statement contains a magic number: if (m_frames.Count < 2) {  	Value = -1;  } else {  	var dt = m_frames.Last - m_frames.First;  	if (dt > MinimumUpdateDuration)  		Value = m_frames.Count / (dt / 1000);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,FpsCounter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\FpsCounter.cs,UpdateValue,The following statement contains a magic number: if (dt > MinimumUpdateDuration)  	Value = m_frames.Count / (dt / 1000);  
Magic Number,HelixToolkit.Wpf.SharpDX,FpsCounter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\FpsCounter.cs,UpdateValue,The following statement contains a magic number: Value = m_frames.Count / (dt / 1000);  
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,Rotate,The following statement contains a magic number: if (Math.Abs (this.Camera.UpDirection.Length - 1) > 1e-8) {  	this.Camera.UpDirection.Normalize ();  }  
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,RotateTurnball,The following statement contains a magic number: if (this.CameraMode != CameraMode.Inspect) {  	d = 0.2;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,RotateTurnball,The following statement contains a magic number: d = 0.2;  
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,RotateTurnball,The following statement contains a magic number: if ((newUpDirection - modUpDir).Length > 1e-8) {  	newUpDirection = modUpDir;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,RotateTurntable,The following statement contains a magic number: if (this.CameraMode != CameraMode.Inspect) {  	d *= -0.2;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,RotateTurntable,The following statement contains a magic number: d *= -0.2;  
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,Started,The following statement contains a magic number: this.rotationPoint = new Point (this.Viewport.ActualWidth / 2' this.Viewport.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,Started,The following statement contains a magic number: this.rotationPoint = new Point (this.Viewport.ActualWidth / 2' this.Viewport.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,OnInertiaStarting,The following statement contains a magic number: this.Viewport.StartSpin (4 * delta * ((double)this.Viewport.SpinReleaseTime / elapsedTime)' this.MouseDownPoint' this.rotationPoint3D);  
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,InitTurnballRotationAxes,The following statement contains a magic number: if (fy > 0.8 || fy < 0.2) {  	// delta.Y = 0;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,InitTurnballRotationAxes,The following statement contains a magic number: if (fy > 0.8 || fy < 0.2) {  	// delta.Y = 0;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,InitTurnballRotationAxes,The following statement contains a magic number: if (fx > 0.8) {  	// delta.X = 0;  	this.rotationAxisY = dir;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,InitTurnballRotationAxes,The following statement contains a magic number: if (fx < 0.2) {  	// delta.X = 0;  	this.rotationAxisY = -dir;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,RotateTrackball,The following statement contains a magic number: if (axis.LengthSquared < 1e-8) {  	return;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Delta,The following statement contains a magic number: this.Zoom (delta.Y * 0.01' this.zoomPoint3D);  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Started,The following statement contains a magic number: this.zoomPoint = new Point (this.Viewport.ActualWidth / 2' this.Viewport.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Started,The following statement contains a magic number: this.zoomPoint = new Point (this.Viewport.ActualWidth / 2' this.Viewport.ActualHeight / 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Zoom,The following statement contains a magic number: if (this.Camera is PerspectiveCamera) {  	if (delta < -0.5) {  		delta = -0.5;  	}  	delta *= this.ZoomSensitivity;  	if (this.CameraMode == CameraMode.FixedPosition || this.changeFieldOfView) {  		this.Viewport.ZoomByChangingFieldOfView (delta);  	} else {  		switch (this.CameraMode) {  		case CameraMode.Inspect:  			this.ChangeCameraDistance (delta' zoomAround);  			break;  		case CameraMode.WalkAround:  			this.Camera.Position -= this.Camera.LookDirection * delta;  			break;  		}  	}  	return;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Zoom,The following statement contains a magic number: if (this.Camera is PerspectiveCamera) {  	if (delta < -0.5) {  		delta = -0.5;  	}  	delta *= this.ZoomSensitivity;  	if (this.CameraMode == CameraMode.FixedPosition || this.changeFieldOfView) {  		this.Viewport.ZoomByChangingFieldOfView (delta);  	} else {  		switch (this.CameraMode) {  		case CameraMode.Inspect:  			this.ChangeCameraDistance (delta' zoomAround);  			break;  		case CameraMode.WalkAround:  			this.Camera.Position -= this.Camera.LookDirection * delta;  			break;  		}  	}  	return;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Zoom,The following statement contains a magic number: if (delta < -0.5) {  	delta = -0.5;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Zoom,The following statement contains a magic number: if (delta < -0.5) {  	delta = -0.5;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Zoom,The following statement contains a magic number: delta = -0.5;  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ZoomByChangingCameraWidth,The following statement contains a magic number: if (delta < -0.5) {  	delta = -0.5;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ZoomByChangingCameraWidth,The following statement contains a magic number: if (delta < -0.5) {  	delta = -0.5;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ZoomByChangingCameraWidth,The following statement contains a magic number: delta = -0.5;  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ChangeCameraDistance,The following statement contains a magic number: if (relativePosition.Length < 1e-4) {  	if (delta > 0)//If Zoom out from very close distance' increase the initial relativePosition  	 {  		relativePosition.Normalize ();  		relativePosition /= 10;  	} else//If Zoom in too close' stop it.  	 {  		return;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ChangeCameraDistance,The following statement contains a magic number: if (relativePosition.Length < 1e-4) {  	if (delta > 0)//If Zoom out from very close distance' increase the initial relativePosition  	 {  		relativePosition.Normalize ();  		relativePosition /= 10;  	} else//If Zoom in too close' stop it.  	 {  		return;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ChangeCameraDistance,The following statement contains a magic number: if (delta > 0)//If Zoom out from very close distance' increase the initial relativePosition   {  	relativePosition.Normalize ();  	relativePosition /= 10;  } else//If Zoom in too close' stop it.   {  	return;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ChangeCameraDistance,The following statement contains a magic number: relativePosition /= 10;  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomRectangleHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomRectangleHandler.cs,ZoomRectangle,The following statement contains a magic number: if (rectangle.Width < 10 || rectangle.Height < 10) {  	return;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ZoomRectangleHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomRectangleHandler.cs,ZoomRectangle,The following statement contains a magic number: if (rectangle.Width < 10 || rectangle.Height < 10) {  	return;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetTotalNumberOfTriangles,The following statement contains a magic number: foreach (var item in viewport.Renderables) {  	var model = item as MeshGeometryModel3D;  	if (model != null) {  		if (model.Visibility == Visibility.Visible)  			count += model.Geometry.Indices.Count / 3;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetTotalNumberOfTriangles,The following statement contains a magic number: if (model != null) {  	if (model.Visibility == Visibility.Visible)  		count += model.Geometry.Indices.Count / 3;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetTotalNumberOfTriangles,The following statement contains a magic number: if (model.Visibility == Visibility.Visible)  	count += model.Geometry.Indices.Count / 3;  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetTotalNumberOfTriangles,The following statement contains a magic number: count += model.Geometry.Indices.Count / 3;  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetViewportMatrix,The following statement contains a magic number: return new Matrix ((float)(viewport.ActualWidth / 2)' 0' 0' 0' 0' (float)(-viewport.ActualHeight / 2)' 0' 0' 0' 0' 1' 0' (float)((viewport.ActualWidth - 1) / 2)' (float)((viewport.ActualHeight - 1) / 2)' 0' 1);  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetViewportMatrix,The following statement contains a magic number: return new Matrix ((float)(viewport.ActualWidth / 2)' 0' 0' 0' 0' (float)(-viewport.ActualHeight / 2)' 0' 0' 0' 0' 1' 0' (float)((viewport.ActualWidth - 1) / 2)' (float)((viewport.ActualHeight - 1) / 2)' 0' 1);  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetViewportMatrix,The following statement contains a magic number: return new Matrix ((float)(viewport.ActualWidth / 2)' 0' 0' 0' 0' (float)(-viewport.ActualHeight / 2)' 0' 0' 0' 0' 1' 0' (float)((viewport.ActualWidth - 1) / 2)' (float)((viewport.ActualHeight - 1) / 2)' 0' 1);  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,GetViewportMatrix,The following statement contains a magic number: return new Matrix ((float)(viewport.ActualWidth / 2)' 0' 0' 0' 0' (float)(-viewport.ActualHeight / 2)' 0' 0' 0' 0' 1' 0' (float)((viewport.ActualWidth - 1) / 2)' (float)((viewport.ActualHeight - 1) / 2)' 0' 1);  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,UnProject,The following statement contains a magic number: if (camera != null) {  	var px = (float)point2d.X;  	var py = (float)point2d.Y;  	var viewMatrix = camera.GetViewMatrix ();  	Vector3 v = new Vector3 ();  	var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	float w = (float)viewport.ActualWidth;  	float h = (float)viewport.ActualHeight;  	var aspectRatio = w / h;  	var projMatrix = camera.GetProjectionMatrix (aspectRatio);  	Vector3 zn' zf;  	v.X = (2 * px / w - 1) / projMatrix.M11;  	v.Y = -(2 * py / h - 1) / projMatrix.M22;  	v.Z = 1 / projMatrix.M33;  	Vector3.TransformCoordinate (ref v' ref matrix' out zf);  	if (camera is PerspectiveCamera) {  		zn = camera.Position.ToVector3 ();  	} else {  		v.Z = 0;  		Vector3.TransformCoordinate (ref v' ref matrix' out zn);  	}  	Vector3 r = zf - zn;  	r.Normalize ();  	return new Ray (zn' r);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,UnProject,The following statement contains a magic number: if (camera != null) {  	var px = (float)point2d.X;  	var py = (float)point2d.Y;  	var viewMatrix = camera.GetViewMatrix ();  	Vector3 v = new Vector3 ();  	var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	float w = (float)viewport.ActualWidth;  	float h = (float)viewport.ActualHeight;  	var aspectRatio = w / h;  	var projMatrix = camera.GetProjectionMatrix (aspectRatio);  	Vector3 zn' zf;  	v.X = (2 * px / w - 1) / projMatrix.M11;  	v.Y = -(2 * py / h - 1) / projMatrix.M22;  	v.Z = 1 / projMatrix.M33;  	Vector3.TransformCoordinate (ref v' ref matrix' out zf);  	if (camera is PerspectiveCamera) {  		zn = camera.Position.ToVector3 ();  	} else {  		v.Z = 0;  		Vector3.TransformCoordinate (ref v' ref matrix' out zn);  	}  	Vector3 r = zf - zn;  	r.Normalize ();  	return new Ray (zn' r);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,UnProject,The following statement contains a magic number: v.X = (2 * px / w - 1) / projMatrix.M11;  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,UnProject,The following statement contains a magic number: v.Y = -(2 * py / h - 1) / projMatrix.M22;  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < m; j++) {  		// change the camera viewport and scaling  		var pm = originalCamera.GetProjectionMatrix3D (ar);  		if (originalCamera is OrthographicCamera) {  			pm.OffsetX = m - 1 - (i * 2);  			pm.OffsetY = -(m - 1 - (j * 2));  		}  		if (originalCamera is PerspectiveCamera) {  			pm.M31 = -(m - 1 - (i * 2));  			pm.M32 = m - 1 - (j * 2);  		}  		pm.M11 *= m;  		pm.M22 *= m;  		var mc = new MatrixCamera (vm' pm);  		view.Camera = mc;  		var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  		// render background  		var backgroundRectangle = new Rectangle {  			Width = partialBitmap.Width'  			Height = partialBitmap.Height'  			Fill = background  		};  		backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  		partialBitmap.Render (backgroundRectangle);  		// render 3d  		partialBitmap.Render (view);  		// copy to the target bitmap  		CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < m; j++) {  		// change the camera viewport and scaling  		var pm = originalCamera.GetProjectionMatrix3D (ar);  		if (originalCamera is OrthographicCamera) {  			pm.OffsetX = m - 1 - (i * 2);  			pm.OffsetY = -(m - 1 - (j * 2));  		}  		if (originalCamera is PerspectiveCamera) {  			pm.M31 = -(m - 1 - (i * 2));  			pm.M32 = m - 1 - (j * 2);  		}  		pm.M11 *= m;  		pm.M22 *= m;  		var mc = new MatrixCamera (vm' pm);  		view.Camera = mc;  		var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  		// render background  		var backgroundRectangle = new Rectangle {  			Width = partialBitmap.Width'  			Height = partialBitmap.Height'  			Fill = background  		};  		backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  		partialBitmap.Render (backgroundRectangle);  		// render 3d  		partialBitmap.Render (view);  		// copy to the target bitmap  		CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < m; j++) {  		// change the camera viewport and scaling  		var pm = originalCamera.GetProjectionMatrix3D (ar);  		if (originalCamera is OrthographicCamera) {  			pm.OffsetX = m - 1 - (i * 2);  			pm.OffsetY = -(m - 1 - (j * 2));  		}  		if (originalCamera is PerspectiveCamera) {  			pm.M31 = -(m - 1 - (i * 2));  			pm.M32 = m - 1 - (j * 2);  		}  		pm.M11 *= m;  		pm.M22 *= m;  		var mc = new MatrixCamera (vm' pm);  		view.Camera = mc;  		var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  		// render background  		var backgroundRectangle = new Rectangle {  			Width = partialBitmap.Width'  			Height = partialBitmap.Height'  			Fill = background  		};  		backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  		partialBitmap.Render (backgroundRectangle);  		// render 3d  		partialBitmap.Render (view);  		// copy to the target bitmap  		CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < m; j++) {  		// change the camera viewport and scaling  		var pm = originalCamera.GetProjectionMatrix3D (ar);  		if (originalCamera is OrthographicCamera) {  			pm.OffsetX = m - 1 - (i * 2);  			pm.OffsetY = -(m - 1 - (j * 2));  		}  		if (originalCamera is PerspectiveCamera) {  			pm.M31 = -(m - 1 - (i * 2));  			pm.M32 = m - 1 - (j * 2);  		}  		pm.M11 *= m;  		pm.M22 *= m;  		var mc = new MatrixCamera (vm' pm);  		view.Camera = mc;  		var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  		// render background  		var backgroundRectangle = new Rectangle {  			Width = partialBitmap.Width'  			Height = partialBitmap.Height'  			Fill = background  		};  		backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  		partialBitmap.Render (backgroundRectangle);  		// render 3d  		partialBitmap.Render (view);  		// copy to the target bitmap  		CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < m; j++) {  		// change the camera viewport and scaling  		var pm = originalCamera.GetProjectionMatrix3D (ar);  		if (originalCamera is OrthographicCamera) {  			pm.OffsetX = m - 1 - (i * 2);  			pm.OffsetY = -(m - 1 - (j * 2));  		}  		if (originalCamera is PerspectiveCamera) {  			pm.M31 = -(m - 1 - (i * 2));  			pm.M32 = m - 1 - (j * 2);  		}  		pm.M11 *= m;  		pm.M22 *= m;  		var mc = new MatrixCamera (vm' pm);  		view.Camera = mc;  		var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  		// render background  		var backgroundRectangle = new Rectangle {  			Width = partialBitmap.Width'  			Height = partialBitmap.Height'  			Fill = background  		};  		backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  		partialBitmap.Render (backgroundRectangle);  		// render 3d  		partialBitmap.Render (view);  		// copy to the target bitmap  		CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	for (int j = 0; j < m; j++) {  		// change the camera viewport and scaling  		var pm = originalCamera.GetProjectionMatrix3D (ar);  		if (originalCamera is OrthographicCamera) {  			pm.OffsetX = m - 1 - (i * 2);  			pm.OffsetY = -(m - 1 - (j * 2));  		}  		if (originalCamera is PerspectiveCamera) {  			pm.M31 = -(m - 1 - (i * 2));  			pm.M32 = m - 1 - (j * 2);  		}  		pm.M11 *= m;  		pm.M22 *= m;  		var mc = new MatrixCamera (vm' pm);  		view.Camera = mc;  		var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  		// render background  		var backgroundRectangle = new Rectangle {  			Width = partialBitmap.Width'  			Height = partialBitmap.Height'  			Fill = background  		};  		backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  		partialBitmap.Render (backgroundRectangle);  		// render 3d  		partialBitmap.Render (view);  		// copy to the target bitmap  		CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	// change the camera viewport and scaling  	var pm = originalCamera.GetProjectionMatrix3D (ar);  	if (originalCamera is OrthographicCamera) {  		pm.OffsetX = m - 1 - (i * 2);  		pm.OffsetY = -(m - 1 - (j * 2));  	}  	if (originalCamera is PerspectiveCamera) {  		pm.M31 = -(m - 1 - (i * 2));  		pm.M32 = m - 1 - (j * 2);  	}  	pm.M11 *= m;  	pm.M22 *= m;  	var mc = new MatrixCamera (vm' pm);  	view.Camera = mc;  	var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  	// render background  	var backgroundRectangle = new Rectangle {  		Width = partialBitmap.Width'  		Height = partialBitmap.Height'  		Fill = background  	};  	backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  	partialBitmap.Render (backgroundRectangle);  	// render 3d  	partialBitmap.Render (view);  	// copy to the target bitmap  	CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	// change the camera viewport and scaling  	var pm = originalCamera.GetProjectionMatrix3D (ar);  	if (originalCamera is OrthographicCamera) {  		pm.OffsetX = m - 1 - (i * 2);  		pm.OffsetY = -(m - 1 - (j * 2));  	}  	if (originalCamera is PerspectiveCamera) {  		pm.M31 = -(m - 1 - (i * 2));  		pm.M32 = m - 1 - (j * 2);  	}  	pm.M11 *= m;  	pm.M22 *= m;  	var mc = new MatrixCamera (vm' pm);  	view.Camera = mc;  	var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  	// render background  	var backgroundRectangle = new Rectangle {  		Width = partialBitmap.Width'  		Height = partialBitmap.Height'  		Fill = background  	};  	backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  	partialBitmap.Render (backgroundRectangle);  	// render 3d  	partialBitmap.Render (view);  	// copy to the target bitmap  	CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	// change the camera viewport and scaling  	var pm = originalCamera.GetProjectionMatrix3D (ar);  	if (originalCamera is OrthographicCamera) {  		pm.OffsetX = m - 1 - (i * 2);  		pm.OffsetY = -(m - 1 - (j * 2));  	}  	if (originalCamera is PerspectiveCamera) {  		pm.M31 = -(m - 1 - (i * 2));  		pm.M32 = m - 1 - (j * 2);  	}  	pm.M11 *= m;  	pm.M22 *= m;  	var mc = new MatrixCamera (vm' pm);  	view.Camera = mc;  	var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  	// render background  	var backgroundRectangle = new Rectangle {  		Width = partialBitmap.Width'  		Height = partialBitmap.Height'  		Fill = background  	};  	backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  	partialBitmap.Render (backgroundRectangle);  	// render 3d  	partialBitmap.Render (view);  	// copy to the target bitmap  	CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	// change the camera viewport and scaling  	var pm = originalCamera.GetProjectionMatrix3D (ar);  	if (originalCamera is OrthographicCamera) {  		pm.OffsetX = m - 1 - (i * 2);  		pm.OffsetY = -(m - 1 - (j * 2));  	}  	if (originalCamera is PerspectiveCamera) {  		pm.M31 = -(m - 1 - (i * 2));  		pm.M32 = m - 1 - (j * 2);  	}  	pm.M11 *= m;  	pm.M22 *= m;  	var mc = new MatrixCamera (vm' pm);  	view.Camera = mc;  	var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  	// render background  	var backgroundRectangle = new Rectangle {  		Width = partialBitmap.Width'  		Height = partialBitmap.Height'  		Fill = background  	};  	backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  	partialBitmap.Render (backgroundRectangle);  	// render 3d  	partialBitmap.Render (view);  	// copy to the target bitmap  	CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	// change the camera viewport and scaling  	var pm = originalCamera.GetProjectionMatrix3D (ar);  	if (originalCamera is OrthographicCamera) {  		pm.OffsetX = m - 1 - (i * 2);  		pm.OffsetY = -(m - 1 - (j * 2));  	}  	if (originalCamera is PerspectiveCamera) {  		pm.M31 = -(m - 1 - (i * 2));  		pm.M32 = m - 1 - (j * 2);  	}  	pm.M11 *= m;  	pm.M22 *= m;  	var mc = new MatrixCamera (vm' pm);  	view.Camera = mc;  	var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  	// render background  	var backgroundRectangle = new Rectangle {  		Width = partialBitmap.Width'  		Height = partialBitmap.Height'  		Fill = background  	};  	backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  	partialBitmap.Render (backgroundRectangle);  	// render 3d  	partialBitmap.Render (view);  	// copy to the target bitmap  	CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: for (int j = 0; j < m; j++) {  	// change the camera viewport and scaling  	var pm = originalCamera.GetProjectionMatrix3D (ar);  	if (originalCamera is OrthographicCamera) {  		pm.OffsetX = m - 1 - (i * 2);  		pm.OffsetY = -(m - 1 - (j * 2));  	}  	if (originalCamera is PerspectiveCamera) {  		pm.M31 = -(m - 1 - (i * 2));  		pm.M32 = m - 1 - (j * 2);  	}  	pm.M11 *= m;  	pm.M22 *= m;  	var mc = new MatrixCamera (vm' pm);  	view.Camera = mc;  	var partialBitmap = new RenderTargetBitmap ((int)view.ActualWidth' (int)view.ActualHeight' 96' 96' PixelFormats.Pbgra32);  	// render background  	var backgroundRectangle = new Rectangle {  		Width = partialBitmap.Width'  		Height = partialBitmap.Height'  		Fill = background  	};  	backgroundRectangle.Arrange (new Rect (0' 0' backgroundRectangle.Width' backgroundRectangle.Height));  	partialBitmap.Render (backgroundRectangle);  	// render 3d  	partialBitmap.Render (view);  	// copy to the target bitmap  	CopyBitmap (partialBitmap' target' (int)(i * view.ActualWidth)' (int)(j * view.ActualHeight));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: if (originalCamera is OrthographicCamera) {  	pm.OffsetX = m - 1 - (i * 2);  	pm.OffsetY = -(m - 1 - (j * 2));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: if (originalCamera is OrthographicCamera) {  	pm.OffsetX = m - 1 - (i * 2);  	pm.OffsetY = -(m - 1 - (j * 2));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: pm.OffsetX = m - 1 - (i * 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: pm.OffsetY = -(m - 1 - (j * 2));  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: if (originalCamera is PerspectiveCamera) {  	pm.M31 = -(m - 1 - (i * 2));  	pm.M32 = m - 1 - (j * 2);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: if (originalCamera is PerspectiveCamera) {  	pm.M31 = -(m - 1 - (i * 2));  	pm.M32 = m - 1 - (j * 2);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: pm.M31 = -(m - 1 - (i * 2));  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,RenderBitmap,The following statement contains a magic number: pm.M32 = m - 1 - (j * 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: if (pcam != null) {  	double disth = radius / Math.Tan (0.5 * pcam.FieldOfView * Math.PI / 180);  	double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;  	double distv = radius / Math.Tan (0.5 * vfov * Math.PI / 180);  	double dist = Math.Max (disth' distv);  	var dir = pcam.LookDirection;  	dir.Normalize ();  	pcam.LookAt (center' dir * dist' animationTime);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: if (pcam != null) {  	double disth = radius / Math.Tan (0.5 * pcam.FieldOfView * Math.PI / 180);  	double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;  	double distv = radius / Math.Tan (0.5 * vfov * Math.PI / 180);  	double dist = Math.Max (disth' distv);  	var dir = pcam.LookDirection;  	dir.Normalize ();  	pcam.LookAt (center' dir * dist' animationTime);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: if (pcam != null) {  	double disth = radius / Math.Tan (0.5 * pcam.FieldOfView * Math.PI / 180);  	double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;  	double distv = radius / Math.Tan (0.5 * vfov * Math.PI / 180);  	double dist = Math.Max (disth' distv);  	var dir = pcam.LookDirection;  	dir.Normalize ();  	pcam.LookAt (center' dir * dist' animationTime);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: if (pcam != null) {  	double disth = radius / Math.Tan (0.5 * pcam.FieldOfView * Math.PI / 180);  	double vfov = pcam.FieldOfView / viewport.ActualWidth * viewport.ActualHeight;  	double distv = radius / Math.Tan (0.5 * vfov * Math.PI / 180);  	double dist = Math.Max (disth' distv);  	var dir = pcam.LookDirection;  	dir.Normalize ();  	pcam.LookAt (center' dir * dist' animationTime);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: if (ocam != null) {  	ocam.LookAt (center' ocam.LookDirection' animationTime);  	double newWidth = radius * 2;  	if (viewport.ActualWidth > viewport.ActualHeight) {  		newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;  	}  	ocam.AnimateWidth (newWidth' animationTime);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: if (ocam != null) {  	ocam.LookAt (center' ocam.LookDirection' animationTime);  	double newWidth = radius * 2;  	if (viewport.ActualWidth > viewport.ActualHeight) {  		newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;  	}  	ocam.AnimateWidth (newWidth' animationTime);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: if (viewport.ActualWidth > viewport.ActualHeight) {  	newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomExtents,The following statement contains a magic number: newWidth = radius * 2 * viewport.ActualWidth / viewport.ActualHeight;  
Magic Number,HelixToolkit.Wpf.SharpDX,ViewportExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\ViewportExtensions.cs,ZoomByChangingFieldOfView,The following statement contains a magic number: fov *= 1 + (delta * 0.5);  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null) {  	BoundingBox b = new BoundingBox ();  	var left = -g.Width / 2;  	var right = -left;  	var top = -g.Height / 2;  	var bottom = -top;  	if (FixedSize) {  		var viewportMatrix = context.ViewportMatrix;  		var projectionMatrix = context.ProjectionMatrix;  		var viewMatrix = context.ViewMatrix;  		var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  		var center = new Vector4 (g.Positions [0]' 1);  		var screenPoint = Vector4.Transform (center' visualToScreen);  		var spw = screenPoint.W;  		var spx = screenPoint.X;  		var spy = screenPoint.Y;  		var spz = screenPoint.Z / spw / projectionMatrix.M33;  		var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		var width = (float)context.ActualWidth;  		var height = (float)context.ActualHeight;  		Vector3 v = new Vector3 ();  		var x = spx + left * spw;  		var y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 bl;  		Vector3.TransformCoordinate (ref v' ref matrix' out bl);  		x = spx + right * spw;  		y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 br;  		Vector3.TransformCoordinate (ref v' ref matrix' out br);  		x = spx + right * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tr;  		Vector3.TransformCoordinate (ref v' ref matrix' out tr);  		x = spx + left * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tl;  		Vector3.TransformCoordinate (ref v' ref matrix' out tl);  		b = BoundingBox.FromPoints (new Vector3[] {  			tl'  			tr'  			bl'  			br  		});  		/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  		var center = new Vector4 (g.Positions [0]' 1);  		var viewMatrix = context.ViewMatrix;  		var vcenter = Vector4.Transform (center' viewMatrix);  		var vcX = vcenter.X;  		var vcY = vcenter.Y;  		var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  		var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  		var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  		var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  		var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		bl = Vector4.Transform (bl' invViewMatrix);  		bl /= bl.W;  		br = Vector4.Transform (br' invViewMatrix);  		br /= br.W;  		tr = Vector4.Transform (tr' invViewMatrix);  		tr /= tr.W;  		tl = Vector4.Transform (tl' invViewMatrix);  		tl /= tl.W;  		b = BoundingBox.FromPoints (new Vector3[] {  			tl.ToVector3 ()'  			tr.ToVector3 ()'  			bl.ToVector3 ()'  			br.ToVector3 ()  		});  	}  	// this all happens now in world space now:  	//Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));  	if (rayWS.Intersects (ref b)) {  		float distance;  		if (Collision.RayIntersectsBox (ref rayWS' ref b' out distance)) {  			h = true;  			result.ModelHit = this;  			result.IsValid = true;  			result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D ();  			result.Distance = distance;  			Debug.WriteLine (string.Format ("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null) {  	BoundingBox b = new BoundingBox ();  	var left = -g.Width / 2;  	var right = -left;  	var top = -g.Height / 2;  	var bottom = -top;  	if (FixedSize) {  		var viewportMatrix = context.ViewportMatrix;  		var projectionMatrix = context.ProjectionMatrix;  		var viewMatrix = context.ViewMatrix;  		var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  		var center = new Vector4 (g.Positions [0]' 1);  		var screenPoint = Vector4.Transform (center' visualToScreen);  		var spw = screenPoint.W;  		var spx = screenPoint.X;  		var spy = screenPoint.Y;  		var spz = screenPoint.Z / spw / projectionMatrix.M33;  		var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		var width = (float)context.ActualWidth;  		var height = (float)context.ActualHeight;  		Vector3 v = new Vector3 ();  		var x = spx + left * spw;  		var y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 bl;  		Vector3.TransformCoordinate (ref v' ref matrix' out bl);  		x = spx + right * spw;  		y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 br;  		Vector3.TransformCoordinate (ref v' ref matrix' out br);  		x = spx + right * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tr;  		Vector3.TransformCoordinate (ref v' ref matrix' out tr);  		x = spx + left * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tl;  		Vector3.TransformCoordinate (ref v' ref matrix' out tl);  		b = BoundingBox.FromPoints (new Vector3[] {  			tl'  			tr'  			bl'  			br  		});  		/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  		var center = new Vector4 (g.Positions [0]' 1);  		var viewMatrix = context.ViewMatrix;  		var vcenter = Vector4.Transform (center' viewMatrix);  		var vcX = vcenter.X;  		var vcY = vcenter.Y;  		var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  		var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  		var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  		var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  		var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		bl = Vector4.Transform (bl' invViewMatrix);  		bl /= bl.W;  		br = Vector4.Transform (br' invViewMatrix);  		br /= br.W;  		tr = Vector4.Transform (tr' invViewMatrix);  		tr /= tr.W;  		tl = Vector4.Transform (tl' invViewMatrix);  		tl /= tl.W;  		b = BoundingBox.FromPoints (new Vector3[] {  			tl.ToVector3 ()'  			tr.ToVector3 ()'  			bl.ToVector3 ()'  			br.ToVector3 ()  		});  	}  	// this all happens now in world space now:  	//Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));  	if (rayWS.Intersects (ref b)) {  		float distance;  		if (Collision.RayIntersectsBox (ref rayWS' ref b' out distance)) {  			h = true;  			result.ModelHit = this;  			result.IsValid = true;  			result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D ();  			result.Distance = distance;  			Debug.WriteLine (string.Format ("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null) {  	BoundingBox b = new BoundingBox ();  	var left = -g.Width / 2;  	var right = -left;  	var top = -g.Height / 2;  	var bottom = -top;  	if (FixedSize) {  		var viewportMatrix = context.ViewportMatrix;  		var projectionMatrix = context.ProjectionMatrix;  		var viewMatrix = context.ViewMatrix;  		var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  		var center = new Vector4 (g.Positions [0]' 1);  		var screenPoint = Vector4.Transform (center' visualToScreen);  		var spw = screenPoint.W;  		var spx = screenPoint.X;  		var spy = screenPoint.Y;  		var spz = screenPoint.Z / spw / projectionMatrix.M33;  		var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		var width = (float)context.ActualWidth;  		var height = (float)context.ActualHeight;  		Vector3 v = new Vector3 ();  		var x = spx + left * spw;  		var y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 bl;  		Vector3.TransformCoordinate (ref v' ref matrix' out bl);  		x = spx + right * spw;  		y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 br;  		Vector3.TransformCoordinate (ref v' ref matrix' out br);  		x = spx + right * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tr;  		Vector3.TransformCoordinate (ref v' ref matrix' out tr);  		x = spx + left * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tl;  		Vector3.TransformCoordinate (ref v' ref matrix' out tl);  		b = BoundingBox.FromPoints (new Vector3[] {  			tl'  			tr'  			bl'  			br  		});  		/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  		var center = new Vector4 (g.Positions [0]' 1);  		var viewMatrix = context.ViewMatrix;  		var vcenter = Vector4.Transform (center' viewMatrix);  		var vcX = vcenter.X;  		var vcY = vcenter.Y;  		var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  		var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  		var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  		var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  		var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		bl = Vector4.Transform (bl' invViewMatrix);  		bl /= bl.W;  		br = Vector4.Transform (br' invViewMatrix);  		br /= br.W;  		tr = Vector4.Transform (tr' invViewMatrix);  		tr /= tr.W;  		tl = Vector4.Transform (tl' invViewMatrix);  		tl /= tl.W;  		b = BoundingBox.FromPoints (new Vector3[] {  			tl.ToVector3 ()'  			tr.ToVector3 ()'  			bl.ToVector3 ()'  			br.ToVector3 ()  		});  	}  	// this all happens now in world space now:  	//Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));  	if (rayWS.Intersects (ref b)) {  		float distance;  		if (Collision.RayIntersectsBox (ref rayWS' ref b' out distance)) {  			h = true;  			result.ModelHit = this;  			result.IsValid = true;  			result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D ();  			result.Distance = distance;  			Debug.WriteLine (string.Format ("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null) {  	BoundingBox b = new BoundingBox ();  	var left = -g.Width / 2;  	var right = -left;  	var top = -g.Height / 2;  	var bottom = -top;  	if (FixedSize) {  		var viewportMatrix = context.ViewportMatrix;  		var projectionMatrix = context.ProjectionMatrix;  		var viewMatrix = context.ViewMatrix;  		var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  		var center = new Vector4 (g.Positions [0]' 1);  		var screenPoint = Vector4.Transform (center' visualToScreen);  		var spw = screenPoint.W;  		var spx = screenPoint.X;  		var spy = screenPoint.Y;  		var spz = screenPoint.Z / spw / projectionMatrix.M33;  		var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		var width = (float)context.ActualWidth;  		var height = (float)context.ActualHeight;  		Vector3 v = new Vector3 ();  		var x = spx + left * spw;  		var y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 bl;  		Vector3.TransformCoordinate (ref v' ref matrix' out bl);  		x = spx + right * spw;  		y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 br;  		Vector3.TransformCoordinate (ref v' ref matrix' out br);  		x = spx + right * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tr;  		Vector3.TransformCoordinate (ref v' ref matrix' out tr);  		x = spx + left * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tl;  		Vector3.TransformCoordinate (ref v' ref matrix' out tl);  		b = BoundingBox.FromPoints (new Vector3[] {  			tl'  			tr'  			bl'  			br  		});  		/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  		var center = new Vector4 (g.Positions [0]' 1);  		var viewMatrix = context.ViewMatrix;  		var vcenter = Vector4.Transform (center' viewMatrix);  		var vcX = vcenter.X;  		var vcY = vcenter.Y;  		var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  		var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  		var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  		var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  		var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		bl = Vector4.Transform (bl' invViewMatrix);  		bl /= bl.W;  		br = Vector4.Transform (br' invViewMatrix);  		br /= br.W;  		tr = Vector4.Transform (tr' invViewMatrix);  		tr /= tr.W;  		tl = Vector4.Transform (tl' invViewMatrix);  		tl /= tl.W;  		b = BoundingBox.FromPoints (new Vector3[] {  			tl.ToVector3 ()'  			tr.ToVector3 ()'  			bl.ToVector3 ()'  			br.ToVector3 ()  		});  	}  	// this all happens now in world space now:  	//Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));  	if (rayWS.Intersects (ref b)) {  		float distance;  		if (Collision.RayIntersectsBox (ref rayWS' ref b' out distance)) {  			h = true;  			result.ModelHit = this;  			result.IsValid = true;  			result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D ();  			result.Distance = distance;  			Debug.WriteLine (string.Format ("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null) {  	BoundingBox b = new BoundingBox ();  	var left = -g.Width / 2;  	var right = -left;  	var top = -g.Height / 2;  	var bottom = -top;  	if (FixedSize) {  		var viewportMatrix = context.ViewportMatrix;  		var projectionMatrix = context.ProjectionMatrix;  		var viewMatrix = context.ViewMatrix;  		var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  		var center = new Vector4 (g.Positions [0]' 1);  		var screenPoint = Vector4.Transform (center' visualToScreen);  		var spw = screenPoint.W;  		var spx = screenPoint.X;  		var spy = screenPoint.Y;  		var spz = screenPoint.Z / spw / projectionMatrix.M33;  		var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		var width = (float)context.ActualWidth;  		var height = (float)context.ActualHeight;  		Vector3 v = new Vector3 ();  		var x = spx + left * spw;  		var y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 bl;  		Vector3.TransformCoordinate (ref v' ref matrix' out bl);  		x = spx + right * spw;  		y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 br;  		Vector3.TransformCoordinate (ref v' ref matrix' out br);  		x = spx + right * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tr;  		Vector3.TransformCoordinate (ref v' ref matrix' out tr);  		x = spx + left * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tl;  		Vector3.TransformCoordinate (ref v' ref matrix' out tl);  		b = BoundingBox.FromPoints (new Vector3[] {  			tl'  			tr'  			bl'  			br  		});  		/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  		var center = new Vector4 (g.Positions [0]' 1);  		var viewMatrix = context.ViewMatrix;  		var vcenter = Vector4.Transform (center' viewMatrix);  		var vcX = vcenter.X;  		var vcY = vcenter.Y;  		var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  		var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  		var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  		var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  		var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		bl = Vector4.Transform (bl' invViewMatrix);  		bl /= bl.W;  		br = Vector4.Transform (br' invViewMatrix);  		br /= br.W;  		tr = Vector4.Transform (tr' invViewMatrix);  		tr /= tr.W;  		tl = Vector4.Transform (tl' invViewMatrix);  		tl /= tl.W;  		b = BoundingBox.FromPoints (new Vector3[] {  			tl.ToVector3 ()'  			tr.ToVector3 ()'  			bl.ToVector3 ()'  			br.ToVector3 ()  		});  	}  	// this all happens now in world space now:  	//Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));  	if (rayWS.Intersects (ref b)) {  		float distance;  		if (Collision.RayIntersectsBox (ref rayWS' ref b' out distance)) {  			h = true;  			result.ModelHit = this;  			result.IsValid = true;  			result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D ();  			result.Distance = distance;  			Debug.WriteLine (string.Format ("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null) {  	BoundingBox b = new BoundingBox ();  	var left = -g.Width / 2;  	var right = -left;  	var top = -g.Height / 2;  	var bottom = -top;  	if (FixedSize) {  		var viewportMatrix = context.ViewportMatrix;  		var projectionMatrix = context.ProjectionMatrix;  		var viewMatrix = context.ViewMatrix;  		var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  		var center = new Vector4 (g.Positions [0]' 1);  		var screenPoint = Vector4.Transform (center' visualToScreen);  		var spw = screenPoint.W;  		var spx = screenPoint.X;  		var spy = screenPoint.Y;  		var spz = screenPoint.Z / spw / projectionMatrix.M33;  		var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		var width = (float)context.ActualWidth;  		var height = (float)context.ActualHeight;  		Vector3 v = new Vector3 ();  		var x = spx + left * spw;  		var y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 bl;  		Vector3.TransformCoordinate (ref v' ref matrix' out bl);  		x = spx + right * spw;  		y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 br;  		Vector3.TransformCoordinate (ref v' ref matrix' out br);  		x = spx + right * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tr;  		Vector3.TransformCoordinate (ref v' ref matrix' out tr);  		x = spx + left * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tl;  		Vector3.TransformCoordinate (ref v' ref matrix' out tl);  		b = BoundingBox.FromPoints (new Vector3[] {  			tl'  			tr'  			bl'  			br  		});  		/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  		var center = new Vector4 (g.Positions [0]' 1);  		var viewMatrix = context.ViewMatrix;  		var vcenter = Vector4.Transform (center' viewMatrix);  		var vcX = vcenter.X;  		var vcY = vcenter.Y;  		var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  		var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  		var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  		var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  		var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		bl = Vector4.Transform (bl' invViewMatrix);  		bl /= bl.W;  		br = Vector4.Transform (br' invViewMatrix);  		br /= br.W;  		tr = Vector4.Transform (tr' invViewMatrix);  		tr /= tr.W;  		tl = Vector4.Transform (tl' invViewMatrix);  		tl /= tl.W;  		b = BoundingBox.FromPoints (new Vector3[] {  			tl.ToVector3 ()'  			tr.ToVector3 ()'  			bl.ToVector3 ()'  			br.ToVector3 ()  		});  	}  	// this all happens now in world space now:  	//Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));  	if (rayWS.Intersects (ref b)) {  		float distance;  		if (Collision.RayIntersectsBox (ref rayWS' ref b' out distance)) {  			h = true;  			result.ModelHit = this;  			result.IsValid = true;  			result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D ();  			result.Distance = distance;  			Debug.WriteLine (string.Format ("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null) {  	BoundingBox b = new BoundingBox ();  	var left = -g.Width / 2;  	var right = -left;  	var top = -g.Height / 2;  	var bottom = -top;  	if (FixedSize) {  		var viewportMatrix = context.ViewportMatrix;  		var projectionMatrix = context.ProjectionMatrix;  		var viewMatrix = context.ViewMatrix;  		var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  		var center = new Vector4 (g.Positions [0]' 1);  		var screenPoint = Vector4.Transform (center' visualToScreen);  		var spw = screenPoint.W;  		var spx = screenPoint.X;  		var spy = screenPoint.Y;  		var spz = screenPoint.Z / spw / projectionMatrix.M33;  		var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		var width = (float)context.ActualWidth;  		var height = (float)context.ActualHeight;  		Vector3 v = new Vector3 ();  		var x = spx + left * spw;  		var y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 bl;  		Vector3.TransformCoordinate (ref v' ref matrix' out bl);  		x = spx + right * spw;  		y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 br;  		Vector3.TransformCoordinate (ref v' ref matrix' out br);  		x = spx + right * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tr;  		Vector3.TransformCoordinate (ref v' ref matrix' out tr);  		x = spx + left * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tl;  		Vector3.TransformCoordinate (ref v' ref matrix' out tl);  		b = BoundingBox.FromPoints (new Vector3[] {  			tl'  			tr'  			bl'  			br  		});  		/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  		var center = new Vector4 (g.Positions [0]' 1);  		var viewMatrix = context.ViewMatrix;  		var vcenter = Vector4.Transform (center' viewMatrix);  		var vcX = vcenter.X;  		var vcY = vcenter.Y;  		var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  		var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  		var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  		var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  		var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		bl = Vector4.Transform (bl' invViewMatrix);  		bl /= bl.W;  		br = Vector4.Transform (br' invViewMatrix);  		br /= br.W;  		tr = Vector4.Transform (tr' invViewMatrix);  		tr /= tr.W;  		tl = Vector4.Transform (tl' invViewMatrix);  		tl /= tl.W;  		b = BoundingBox.FromPoints (new Vector3[] {  			tl.ToVector3 ()'  			tr.ToVector3 ()'  			bl.ToVector3 ()'  			br.ToVector3 ()  		});  	}  	// this all happens now in world space now:  	//Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));  	if (rayWS.Intersects (ref b)) {  		float distance;  		if (Collision.RayIntersectsBox (ref rayWS' ref b' out distance)) {  			h = true;  			result.ModelHit = this;  			result.IsValid = true;  			result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D ();  			result.Distance = distance;  			Debug.WriteLine (string.Format ("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null) {  	BoundingBox b = new BoundingBox ();  	var left = -g.Width / 2;  	var right = -left;  	var top = -g.Height / 2;  	var bottom = -top;  	if (FixedSize) {  		var viewportMatrix = context.ViewportMatrix;  		var projectionMatrix = context.ProjectionMatrix;  		var viewMatrix = context.ViewMatrix;  		var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  		var center = new Vector4 (g.Positions [0]' 1);  		var screenPoint = Vector4.Transform (center' visualToScreen);  		var spw = screenPoint.W;  		var spx = screenPoint.X;  		var spy = screenPoint.Y;  		var spz = screenPoint.Z / spw / projectionMatrix.M33;  		var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		var width = (float)context.ActualWidth;  		var height = (float)context.ActualHeight;  		Vector3 v = new Vector3 ();  		var x = spx + left * spw;  		var y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 bl;  		Vector3.TransformCoordinate (ref v' ref matrix' out bl);  		x = spx + right * spw;  		y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 br;  		Vector3.TransformCoordinate (ref v' ref matrix' out br);  		x = spx + right * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tr;  		Vector3.TransformCoordinate (ref v' ref matrix' out tr);  		x = spx + left * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tl;  		Vector3.TransformCoordinate (ref v' ref matrix' out tl);  		b = BoundingBox.FromPoints (new Vector3[] {  			tl'  			tr'  			bl'  			br  		});  		/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  		var center = new Vector4 (g.Positions [0]' 1);  		var viewMatrix = context.ViewMatrix;  		var vcenter = Vector4.Transform (center' viewMatrix);  		var vcX = vcenter.X;  		var vcY = vcenter.Y;  		var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  		var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  		var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  		var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  		var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		bl = Vector4.Transform (bl' invViewMatrix);  		bl /= bl.W;  		br = Vector4.Transform (br' invViewMatrix);  		br /= br.W;  		tr = Vector4.Transform (tr' invViewMatrix);  		tr /= tr.W;  		tl = Vector4.Transform (tl' invViewMatrix);  		tl /= tl.W;  		b = BoundingBox.FromPoints (new Vector3[] {  			tl.ToVector3 ()'  			tr.ToVector3 ()'  			bl.ToVector3 ()'  			br.ToVector3 ()  		});  	}  	// this all happens now in world space now:  	//Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));  	if (rayWS.Intersects (ref b)) {  		float distance;  		if (Collision.RayIntersectsBox (ref rayWS' ref b' out distance)) {  			h = true;  			result.ModelHit = this;  			result.IsValid = true;  			result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D ();  			result.Distance = distance;  			Debug.WriteLine (string.Format ("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null) {  	BoundingBox b = new BoundingBox ();  	var left = -g.Width / 2;  	var right = -left;  	var top = -g.Height / 2;  	var bottom = -top;  	if (FixedSize) {  		var viewportMatrix = context.ViewportMatrix;  		var projectionMatrix = context.ProjectionMatrix;  		var viewMatrix = context.ViewMatrix;  		var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  		var center = new Vector4 (g.Positions [0]' 1);  		var screenPoint = Vector4.Transform (center' visualToScreen);  		var spw = screenPoint.W;  		var spx = screenPoint.X;  		var spy = screenPoint.Y;  		var spz = screenPoint.Z / spw / projectionMatrix.M33;  		var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		var width = (float)context.ActualWidth;  		var height = (float)context.ActualHeight;  		Vector3 v = new Vector3 ();  		var x = spx + left * spw;  		var y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 bl;  		Vector3.TransformCoordinate (ref v' ref matrix' out bl);  		x = spx + right * spw;  		y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 br;  		Vector3.TransformCoordinate (ref v' ref matrix' out br);  		x = spx + right * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tr;  		Vector3.TransformCoordinate (ref v' ref matrix' out tr);  		x = spx + left * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tl;  		Vector3.TransformCoordinate (ref v' ref matrix' out tl);  		b = BoundingBox.FromPoints (new Vector3[] {  			tl'  			tr'  			bl'  			br  		});  		/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  		var center = new Vector4 (g.Positions [0]' 1);  		var viewMatrix = context.ViewMatrix;  		var vcenter = Vector4.Transform (center' viewMatrix);  		var vcX = vcenter.X;  		var vcY = vcenter.Y;  		var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  		var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  		var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  		var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  		var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		bl = Vector4.Transform (bl' invViewMatrix);  		bl /= bl.W;  		br = Vector4.Transform (br' invViewMatrix);  		br /= br.W;  		tr = Vector4.Transform (tr' invViewMatrix);  		tr /= tr.W;  		tl = Vector4.Transform (tl' invViewMatrix);  		tl /= tl.W;  		b = BoundingBox.FromPoints (new Vector3[] {  			tl.ToVector3 ()'  			tr.ToVector3 ()'  			bl.ToVector3 ()'  			br.ToVector3 ()  		});  	}  	// this all happens now in world space now:  	//Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));  	if (rayWS.Intersects (ref b)) {  		float distance;  		if (Collision.RayIntersectsBox (ref rayWS' ref b' out distance)) {  			h = true;  			result.ModelHit = this;  			result.IsValid = true;  			result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D ();  			result.Distance = distance;  			Debug.WriteLine (string.Format ("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null) {  	BoundingBox b = new BoundingBox ();  	var left = -g.Width / 2;  	var right = -left;  	var top = -g.Height / 2;  	var bottom = -top;  	if (FixedSize) {  		var viewportMatrix = context.ViewportMatrix;  		var projectionMatrix = context.ProjectionMatrix;  		var viewMatrix = context.ViewMatrix;  		var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  		var center = new Vector4 (g.Positions [0]' 1);  		var screenPoint = Vector4.Transform (center' visualToScreen);  		var spw = screenPoint.W;  		var spx = screenPoint.X;  		var spy = screenPoint.Y;  		var spz = screenPoint.Z / spw / projectionMatrix.M33;  		var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		var width = (float)context.ActualWidth;  		var height = (float)context.ActualHeight;  		Vector3 v = new Vector3 ();  		var x = spx + left * spw;  		var y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 bl;  		Vector3.TransformCoordinate (ref v' ref matrix' out bl);  		x = spx + right * spw;  		y = spy + bottom * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 br;  		Vector3.TransformCoordinate (ref v' ref matrix' out br);  		x = spx + right * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tr;  		Vector3.TransformCoordinate (ref v' ref matrix' out tr);  		x = spx + left * spw;  		y = spy + top * spw;  		v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  		v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  		v.Z = spz;  		Vector3 tl;  		Vector3.TransformCoordinate (ref v' ref matrix' out tl);  		b = BoundingBox.FromPoints (new Vector3[] {  			tl'  			tr'  			bl'  			br  		});  		/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  		var center = new Vector4 (g.Positions [0]' 1);  		var viewMatrix = context.ViewMatrix;  		var vcenter = Vector4.Transform (center' viewMatrix);  		var vcX = vcenter.X;  		var vcY = vcenter.Y;  		var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  		var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  		var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  		var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  		var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  		bl = Vector4.Transform (bl' invViewMatrix);  		bl /= bl.W;  		br = Vector4.Transform (br' invViewMatrix);  		br /= br.W;  		tr = Vector4.Transform (tr' invViewMatrix);  		tr /= tr.W;  		tl = Vector4.Transform (tl' invViewMatrix);  		tl /= tl.W;  		b = BoundingBox.FromPoints (new Vector3[] {  			tl.ToVector3 ()'  			tr.ToVector3 ()'  			bl.ToVector3 ()'  			br.ToVector3 ()  		});  	}  	// this all happens now in world space now:  	//Debug.WriteLine(string.Format("RayPosition:{0}; Direction:{1};"' rayWS.Position' rayWS.Direction));  	if (rayWS.Intersects (ref b)) {  		float distance;  		if (Collision.RayIntersectsBox (ref rayWS' ref b' out distance)) {  			h = true;  			result.ModelHit = this;  			result.IsValid = true;  			result.PointHit = (rayWS.Position + (rayWS.Direction * distance)).ToPoint3D ();  			result.Distance = distance;  			Debug.WriteLine (string.Format ("Hit; HitPoint:{0}; Bound={1}; Distance={2}"' result.PointHit' b' distance));  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (FixedSize) {  	var viewportMatrix = context.ViewportMatrix;  	var projectionMatrix = context.ProjectionMatrix;  	var viewMatrix = context.ViewMatrix;  	var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  	var center = new Vector4 (g.Positions [0]' 1);  	var screenPoint = Vector4.Transform (center' visualToScreen);  	var spw = screenPoint.W;  	var spx = screenPoint.X;  	var spy = screenPoint.Y;  	var spz = screenPoint.Z / spw / projectionMatrix.M33;  	var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	var width = (float)context.ActualWidth;  	var height = (float)context.ActualHeight;  	Vector3 v = new Vector3 ();  	var x = spx + left * spw;  	var y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 bl;  	Vector3.TransformCoordinate (ref v' ref matrix' out bl);  	x = spx + right * spw;  	y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 br;  	Vector3.TransformCoordinate (ref v' ref matrix' out br);  	x = spx + right * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tr;  	Vector3.TransformCoordinate (ref v' ref matrix' out tr);  	x = spx + left * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tl;  	Vector3.TransformCoordinate (ref v' ref matrix' out tl);  	b = BoundingBox.FromPoints (new Vector3[] {  		tl'  		tr'  		bl'  		br  	});  	/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  	var center = new Vector4 (g.Positions [0]' 1);  	var viewMatrix = context.ViewMatrix;  	var vcenter = Vector4.Transform (center' viewMatrix);  	var vcX = vcenter.X;  	var vcY = vcenter.Y;  	var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  	var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  	var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  	var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  	var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	bl = Vector4.Transform (bl' invViewMatrix);  	bl /= bl.W;  	br = Vector4.Transform (br' invViewMatrix);  	br /= br.W;  	tr = Vector4.Transform (tr' invViewMatrix);  	tr /= tr.W;  	tl = Vector4.Transform (tl' invViewMatrix);  	tl /= tl.W;  	b = BoundingBox.FromPoints (new Vector3[] {  		tl.ToVector3 ()'  		tr.ToVector3 ()'  		bl.ToVector3 ()'  		br.ToVector3 ()  	});  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (FixedSize) {  	var viewportMatrix = context.ViewportMatrix;  	var projectionMatrix = context.ProjectionMatrix;  	var viewMatrix = context.ViewMatrix;  	var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  	var center = new Vector4 (g.Positions [0]' 1);  	var screenPoint = Vector4.Transform (center' visualToScreen);  	var spw = screenPoint.W;  	var spx = screenPoint.X;  	var spy = screenPoint.Y;  	var spz = screenPoint.Z / spw / projectionMatrix.M33;  	var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	var width = (float)context.ActualWidth;  	var height = (float)context.ActualHeight;  	Vector3 v = new Vector3 ();  	var x = spx + left * spw;  	var y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 bl;  	Vector3.TransformCoordinate (ref v' ref matrix' out bl);  	x = spx + right * spw;  	y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 br;  	Vector3.TransformCoordinate (ref v' ref matrix' out br);  	x = spx + right * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tr;  	Vector3.TransformCoordinate (ref v' ref matrix' out tr);  	x = spx + left * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tl;  	Vector3.TransformCoordinate (ref v' ref matrix' out tl);  	b = BoundingBox.FromPoints (new Vector3[] {  		tl'  		tr'  		bl'  		br  	});  	/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  	var center = new Vector4 (g.Positions [0]' 1);  	var viewMatrix = context.ViewMatrix;  	var vcenter = Vector4.Transform (center' viewMatrix);  	var vcX = vcenter.X;  	var vcY = vcenter.Y;  	var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  	var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  	var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  	var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  	var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	bl = Vector4.Transform (bl' invViewMatrix);  	bl /= bl.W;  	br = Vector4.Transform (br' invViewMatrix);  	br /= br.W;  	tr = Vector4.Transform (tr' invViewMatrix);  	tr /= tr.W;  	tl = Vector4.Transform (tl' invViewMatrix);  	tl /= tl.W;  	b = BoundingBox.FromPoints (new Vector3[] {  		tl.ToVector3 ()'  		tr.ToVector3 ()'  		bl.ToVector3 ()'  		br.ToVector3 ()  	});  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (FixedSize) {  	var viewportMatrix = context.ViewportMatrix;  	var projectionMatrix = context.ProjectionMatrix;  	var viewMatrix = context.ViewMatrix;  	var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  	var center = new Vector4 (g.Positions [0]' 1);  	var screenPoint = Vector4.Transform (center' visualToScreen);  	var spw = screenPoint.W;  	var spx = screenPoint.X;  	var spy = screenPoint.Y;  	var spz = screenPoint.Z / spw / projectionMatrix.M33;  	var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	var width = (float)context.ActualWidth;  	var height = (float)context.ActualHeight;  	Vector3 v = new Vector3 ();  	var x = spx + left * spw;  	var y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 bl;  	Vector3.TransformCoordinate (ref v' ref matrix' out bl);  	x = spx + right * spw;  	y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 br;  	Vector3.TransformCoordinate (ref v' ref matrix' out br);  	x = spx + right * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tr;  	Vector3.TransformCoordinate (ref v' ref matrix' out tr);  	x = spx + left * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tl;  	Vector3.TransformCoordinate (ref v' ref matrix' out tl);  	b = BoundingBox.FromPoints (new Vector3[] {  		tl'  		tr'  		bl'  		br  	});  	/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  	var center = new Vector4 (g.Positions [0]' 1);  	var viewMatrix = context.ViewMatrix;  	var vcenter = Vector4.Transform (center' viewMatrix);  	var vcX = vcenter.X;  	var vcY = vcenter.Y;  	var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  	var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  	var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  	var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  	var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	bl = Vector4.Transform (bl' invViewMatrix);  	bl /= bl.W;  	br = Vector4.Transform (br' invViewMatrix);  	br /= br.W;  	tr = Vector4.Transform (tr' invViewMatrix);  	tr /= tr.W;  	tl = Vector4.Transform (tl' invViewMatrix);  	tl /= tl.W;  	b = BoundingBox.FromPoints (new Vector3[] {  		tl.ToVector3 ()'  		tr.ToVector3 ()'  		bl.ToVector3 ()'  		br.ToVector3 ()  	});  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (FixedSize) {  	var viewportMatrix = context.ViewportMatrix;  	var projectionMatrix = context.ProjectionMatrix;  	var viewMatrix = context.ViewMatrix;  	var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  	var center = new Vector4 (g.Positions [0]' 1);  	var screenPoint = Vector4.Transform (center' visualToScreen);  	var spw = screenPoint.W;  	var spx = screenPoint.X;  	var spy = screenPoint.Y;  	var spz = screenPoint.Z / spw / projectionMatrix.M33;  	var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	var width = (float)context.ActualWidth;  	var height = (float)context.ActualHeight;  	Vector3 v = new Vector3 ();  	var x = spx + left * spw;  	var y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 bl;  	Vector3.TransformCoordinate (ref v' ref matrix' out bl);  	x = spx + right * spw;  	y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 br;  	Vector3.TransformCoordinate (ref v' ref matrix' out br);  	x = spx + right * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tr;  	Vector3.TransformCoordinate (ref v' ref matrix' out tr);  	x = spx + left * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tl;  	Vector3.TransformCoordinate (ref v' ref matrix' out tl);  	b = BoundingBox.FromPoints (new Vector3[] {  		tl'  		tr'  		bl'  		br  	});  	/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  	var center = new Vector4 (g.Positions [0]' 1);  	var viewMatrix = context.ViewMatrix;  	var vcenter = Vector4.Transform (center' viewMatrix);  	var vcX = vcenter.X;  	var vcY = vcenter.Y;  	var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  	var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  	var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  	var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  	var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	bl = Vector4.Transform (bl' invViewMatrix);  	bl /= bl.W;  	br = Vector4.Transform (br' invViewMatrix);  	br /= br.W;  	tr = Vector4.Transform (tr' invViewMatrix);  	tr /= tr.W;  	tl = Vector4.Transform (tl' invViewMatrix);  	tl /= tl.W;  	b = BoundingBox.FromPoints (new Vector3[] {  		tl.ToVector3 ()'  		tr.ToVector3 ()'  		bl.ToVector3 ()'  		br.ToVector3 ()  	});  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (FixedSize) {  	var viewportMatrix = context.ViewportMatrix;  	var projectionMatrix = context.ProjectionMatrix;  	var viewMatrix = context.ViewMatrix;  	var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  	var center = new Vector4 (g.Positions [0]' 1);  	var screenPoint = Vector4.Transform (center' visualToScreen);  	var spw = screenPoint.W;  	var spx = screenPoint.X;  	var spy = screenPoint.Y;  	var spz = screenPoint.Z / spw / projectionMatrix.M33;  	var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	var width = (float)context.ActualWidth;  	var height = (float)context.ActualHeight;  	Vector3 v = new Vector3 ();  	var x = spx + left * spw;  	var y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 bl;  	Vector3.TransformCoordinate (ref v' ref matrix' out bl);  	x = spx + right * spw;  	y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 br;  	Vector3.TransformCoordinate (ref v' ref matrix' out br);  	x = spx + right * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tr;  	Vector3.TransformCoordinate (ref v' ref matrix' out tr);  	x = spx + left * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tl;  	Vector3.TransformCoordinate (ref v' ref matrix' out tl);  	b = BoundingBox.FromPoints (new Vector3[] {  		tl'  		tr'  		bl'  		br  	});  	/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  	var center = new Vector4 (g.Positions [0]' 1);  	var viewMatrix = context.ViewMatrix;  	var vcenter = Vector4.Transform (center' viewMatrix);  	var vcX = vcenter.X;  	var vcY = vcenter.Y;  	var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  	var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  	var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  	var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  	var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	bl = Vector4.Transform (bl' invViewMatrix);  	bl /= bl.W;  	br = Vector4.Transform (br' invViewMatrix);  	br /= br.W;  	tr = Vector4.Transform (tr' invViewMatrix);  	tr /= tr.W;  	tl = Vector4.Transform (tl' invViewMatrix);  	tl /= tl.W;  	b = BoundingBox.FromPoints (new Vector3[] {  		tl.ToVector3 ()'  		tr.ToVector3 ()'  		bl.ToVector3 ()'  		br.ToVector3 ()  	});  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (FixedSize) {  	var viewportMatrix = context.ViewportMatrix;  	var projectionMatrix = context.ProjectionMatrix;  	var viewMatrix = context.ViewMatrix;  	var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  	var center = new Vector4 (g.Positions [0]' 1);  	var screenPoint = Vector4.Transform (center' visualToScreen);  	var spw = screenPoint.W;  	var spx = screenPoint.X;  	var spy = screenPoint.Y;  	var spz = screenPoint.Z / spw / projectionMatrix.M33;  	var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	var width = (float)context.ActualWidth;  	var height = (float)context.ActualHeight;  	Vector3 v = new Vector3 ();  	var x = spx + left * spw;  	var y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 bl;  	Vector3.TransformCoordinate (ref v' ref matrix' out bl);  	x = spx + right * spw;  	y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 br;  	Vector3.TransformCoordinate (ref v' ref matrix' out br);  	x = spx + right * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tr;  	Vector3.TransformCoordinate (ref v' ref matrix' out tr);  	x = spx + left * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tl;  	Vector3.TransformCoordinate (ref v' ref matrix' out tl);  	b = BoundingBox.FromPoints (new Vector3[] {  		tl'  		tr'  		bl'  		br  	});  	/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  	var center = new Vector4 (g.Positions [0]' 1);  	var viewMatrix = context.ViewMatrix;  	var vcenter = Vector4.Transform (center' viewMatrix);  	var vcX = vcenter.X;  	var vcY = vcenter.Y;  	var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  	var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  	var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  	var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  	var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	bl = Vector4.Transform (bl' invViewMatrix);  	bl /= bl.W;  	br = Vector4.Transform (br' invViewMatrix);  	br /= br.W;  	tr = Vector4.Transform (tr' invViewMatrix);  	tr /= tr.W;  	tl = Vector4.Transform (tl' invViewMatrix);  	tl /= tl.W;  	b = BoundingBox.FromPoints (new Vector3[] {  		tl.ToVector3 ()'  		tr.ToVector3 ()'  		bl.ToVector3 ()'  		br.ToVector3 ()  	});  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (FixedSize) {  	var viewportMatrix = context.ViewportMatrix;  	var projectionMatrix = context.ProjectionMatrix;  	var viewMatrix = context.ViewMatrix;  	var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  	var center = new Vector4 (g.Positions [0]' 1);  	var screenPoint = Vector4.Transform (center' visualToScreen);  	var spw = screenPoint.W;  	var spx = screenPoint.X;  	var spy = screenPoint.Y;  	var spz = screenPoint.Z / spw / projectionMatrix.M33;  	var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	var width = (float)context.ActualWidth;  	var height = (float)context.ActualHeight;  	Vector3 v = new Vector3 ();  	var x = spx + left * spw;  	var y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 bl;  	Vector3.TransformCoordinate (ref v' ref matrix' out bl);  	x = spx + right * spw;  	y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 br;  	Vector3.TransformCoordinate (ref v' ref matrix' out br);  	x = spx + right * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tr;  	Vector3.TransformCoordinate (ref v' ref matrix' out tr);  	x = spx + left * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tl;  	Vector3.TransformCoordinate (ref v' ref matrix' out tl);  	b = BoundingBox.FromPoints (new Vector3[] {  		tl'  		tr'  		bl'  		br  	});  	/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  	var center = new Vector4 (g.Positions [0]' 1);  	var viewMatrix = context.ViewMatrix;  	var vcenter = Vector4.Transform (center' viewMatrix);  	var vcX = vcenter.X;  	var vcY = vcenter.Y;  	var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  	var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  	var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  	var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  	var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	bl = Vector4.Transform (bl' invViewMatrix);  	bl /= bl.W;  	br = Vector4.Transform (br' invViewMatrix);  	br /= br.W;  	tr = Vector4.Transform (tr' invViewMatrix);  	tr /= tr.W;  	tl = Vector4.Transform (tl' invViewMatrix);  	tl /= tl.W;  	b = BoundingBox.FromPoints (new Vector3[] {  		tl.ToVector3 ()'  		tr.ToVector3 ()'  		bl.ToVector3 ()'  		br.ToVector3 ()  	});  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: if (FixedSize) {  	var viewportMatrix = context.ViewportMatrix;  	var projectionMatrix = context.ProjectionMatrix;  	var viewMatrix = context.ViewMatrix;  	var visualToScreen = viewMatrix * projectionMatrix * viewportMatrix;  	var center = new Vector4 (g.Positions [0]' 1);  	var screenPoint = Vector4.Transform (center' visualToScreen);  	var spw = screenPoint.W;  	var spx = screenPoint.X;  	var spy = screenPoint.Y;  	var spz = screenPoint.Z / spw / projectionMatrix.M33;  	var matrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	var width = (float)context.ActualWidth;  	var height = (float)context.ActualHeight;  	Vector3 v = new Vector3 ();  	var x = spx + left * spw;  	var y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 bl;  	Vector3.TransformCoordinate (ref v' ref matrix' out bl);  	x = spx + right * spw;  	y = spy + bottom * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 br;  	Vector3.TransformCoordinate (ref v' ref matrix' out br);  	x = spx + right * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tr;  	Vector3.TransformCoordinate (ref v' ref matrix' out tr);  	x = spx + left * spw;  	y = spy + top * spw;  	v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  	v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  	v.Z = spz;  	Vector3 tl;  	Vector3.TransformCoordinate (ref v' ref matrix' out tl);  	b = BoundingBox.FromPoints (new Vector3[] {  		tl'  		tr'  		bl'  		br  	});  	/*                     var visualToScreen = viewport.GetViewProjectionMatrix() * viewport.GetViewportMatrix();                      var screenToVisual = visualToScreen.Inverted();                      var center = new Vector4(g.Positions[0]' 1);                     var screenPoint = Vector4.Transform(center' visualToScreen);                     var spw = screenPoint.W;                     var spx = screenPoint.X;                     var spy = screenPoint.Y;                     var spz = screenPoint.Z;                      //Debug.WriteLine(spw);                     // Debug.WriteLine(string.Format("Z={0}; W={1}"' spz' spw));                     var bl = new Vector4(spx + left * spw' spy + bottom * spw' spz' spw);                     bl = Vector4.Transform(bl' screenToVisual);                     bl /= bl.W;                      var br = new Vector4(spx + right * spw' spy + bottom * spw' spz' spw);                     br = Vector4.Transform(br' screenToVisual);                     br /= br.W;                      var tr = new Vector4(spx + right * spw' spy + top * spw' spz' spw);                     tr = Vector4.Transform(tr' screenToVisual);                     tr /= tr.W;                      var tl = new Vector4(spx + left * spw' spy + top * spw' spz' spw);                     tl = Vector4.Transform(tl' screenToVisual);                     tl /= tl.W;                      b = BoundingBox.FromPoints(new Vector3[] { tl.ToVector3()' tr.ToVector3()' bl.ToVector3()' br.ToVector3() });                      */} else {  	var center = new Vector4 (g.Positions [0]' 1);  	var viewMatrix = context.ViewMatrix;  	var vcenter = Vector4.Transform (center' viewMatrix);  	var vcX = vcenter.X;  	var vcY = vcenter.Y;  	var bl = new Vector4 (vcX + left' vcY + bottom' vcenter.Z' vcenter.W);  	var br = new Vector4 (vcX + right' vcY + bottom' vcenter.Z' vcenter.W);  	var tr = new Vector4 (vcX + right' vcY + top' vcenter.Z' vcenter.W);  	var tl = new Vector4 (vcX + left' vcY + top' vcenter.Z' vcenter.W);  	var invViewMatrix = CameraExtensions.InverseViewMatrix (ref viewMatrix);  	bl = Vector4.Transform (bl' invViewMatrix);  	bl /= bl.W;  	br = Vector4.Transform (br' invViewMatrix);  	br /= br.W;  	tr = Vector4.Transform (tr' invViewMatrix);  	tr /= tr.W;  	tl = Vector4.Transform (tl' invViewMatrix);  	tl /= tl.W;  	b = BoundingBox.FromPoints (new Vector3[] {  		tl.ToVector3 ()'  		tr.ToVector3 ()'  		bl.ToVector3 ()'  		br.ToVector3 ()  	});  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: v.X = (2 * x / width / spw - 1) / projectionMatrix.M11;  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnHitTest,The following statement contains a magic number: v.Y = -(2 * y / height / spw - 1) / projectionMatrix.M22;  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRender,The following statement contains a magic number: switch (billboardType) {  case BillboardType.MultipleText:  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.Draw (vertexCount' 0);  	break;  case BillboardType.SingleText:  	if (vertexCount == 8) {  		var half = vertexCount / 2;  		// Use background shader to draw background first  		effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  		// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  		renderContext.DeviceContext.Draw (half' half);  		// Use foreground shader to draw text  		effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  		// --- draw text' foreground vertex is beginning from 0.  		renderContext.DeviceContext.Draw (half' 0);  	}  	break;  case BillboardType.SingleImage:  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (2).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.Draw (vertexCount' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRender,The following statement contains a magic number: switch (billboardType) {  case BillboardType.MultipleText:  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.Draw (vertexCount' 0);  	break;  case BillboardType.SingleText:  	if (vertexCount == 8) {  		var half = vertexCount / 2;  		// Use background shader to draw background first  		effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  		// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  		renderContext.DeviceContext.Draw (half' half);  		// Use foreground shader to draw text  		effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  		// --- draw text' foreground vertex is beginning from 0.  		renderContext.DeviceContext.Draw (half' 0);  	}  	break;  case BillboardType.SingleImage:  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (2).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.Draw (vertexCount' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRender,The following statement contains a magic number: switch (billboardType) {  case BillboardType.MultipleText:  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.Draw (vertexCount' 0);  	break;  case BillboardType.SingleText:  	if (vertexCount == 8) {  		var half = vertexCount / 2;  		// Use background shader to draw background first  		effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  		// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  		renderContext.DeviceContext.Draw (half' half);  		// Use foreground shader to draw text  		effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  		// --- draw text' foreground vertex is beginning from 0.  		renderContext.DeviceContext.Draw (half' 0);  	}  	break;  case BillboardType.SingleImage:  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (2).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.Draw (vertexCount' 0);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRender,The following statement contains a magic number: if (vertexCount == 8) {  	var half = vertexCount / 2;  	// Use background shader to draw background first  	effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  	// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  	renderContext.DeviceContext.Draw (half' half);  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.Draw (half' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRender,The following statement contains a magic number: if (vertexCount == 8) {  	var half = vertexCount / 2;  	// Use background shader to draw background first  	effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  	// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  	renderContext.DeviceContext.Draw (half' half);  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.Draw (half' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRender,The following statement contains a magic number: effectTechnique.GetPassByIndex (2).Apply (renderContext.DeviceContext);  
Magic Number,HelixToolkit.Wpf.SharpDX,BoneSkinMeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BoneSkinMeshGeometryModel3D.cs,OnRender,The following statement contains a magic number: if (this.hasInstances) {  	// --- update instance buffer  	if (this.isInstanceChanged) {  		InstanceBuffer.UploadDataToBuffer (renderContext.DeviceContext' this.instanceInternal);  		this.isInstanceChanged = false;  	}  	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (2' new VertexBufferBinding (this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0));  	// --- render the geometry  	this.effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  	// --- draw                	renderContext.DeviceContext.DrawIndexedInstanced (this.geometryInternal.Indices.Count' this.instanceInternal.Count' 0' 0' 0);  	this.bHasInstances.Set (false);  } else {  	// --- bind buffer                  	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (0' new VertexBufferBinding (this.VertexBuffer.Buffer' this.VertexBuffer.StructureSize' 0));  	// --- render the geometry  	//   	var pass = this.effectTechnique.GetPassByIndex (0);  	pass.Apply (renderContext.DeviceContext);  	// --- draw  	renderContext.DeviceContext.DrawIndexed (this.geometryInternal.Indices.Count' 0' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,BoneSkinMeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BoneSkinMeshGeometryModel3D.cs,OnRender,The following statement contains a magic number: renderContext.DeviceContext.InputAssembler.SetVertexBuffers (2' new VertexBufferBinding (this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0));  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: if (this.hasInstances) {  	if (this.isInstanceChanged) {  		InstanceBuffer.UploadDataToBuffer (renderContext.DeviceContext' this.instanceInternal);  		this.isInstanceChanged = false;  	}  	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (1' new VertexBufferBinding (this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0));  	if (this.hasInstanceParams) {  		if (instanceParamArrayChanged) {  			instanceParamBuffer.UploadDataToBuffer (renderContext.DeviceContext' this.InstanceParamArray);  			this.instanceParamArrayChanged = false;  		}  		renderContext.DeviceContext.InputAssembler.SetVertexBuffers (2' new VertexBufferBinding (this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0));  	}  	switch (billboardType) {  	case BillboardType.SingleImage:  		// Use foreground shader to draw text  		effectTechnique.GetPassByIndex (2).Apply (renderContext.DeviceContext);  		// --- draw text' foreground vertex is beginning from 0.  		renderContext.DeviceContext.DrawInstanced (vertexCount' this.instanceInternal.Count' 0' 0);  		break;  	case BillboardType.SingleText:  		if (vertexCount == 8) {  			var half = vertexCount / 2;  			// Use background shader to draw background first  			effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  			// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  			renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' half' 0);  			// Use foreground shader to draw text  			effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  			// --- draw text' foreground vertex is beginning from 0.  			renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' 0' 0);  		}  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: if (this.hasInstances) {  	if (this.isInstanceChanged) {  		InstanceBuffer.UploadDataToBuffer (renderContext.DeviceContext' this.instanceInternal);  		this.isInstanceChanged = false;  	}  	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (1' new VertexBufferBinding (this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0));  	if (this.hasInstanceParams) {  		if (instanceParamArrayChanged) {  			instanceParamBuffer.UploadDataToBuffer (renderContext.DeviceContext' this.InstanceParamArray);  			this.instanceParamArrayChanged = false;  		}  		renderContext.DeviceContext.InputAssembler.SetVertexBuffers (2' new VertexBufferBinding (this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0));  	}  	switch (billboardType) {  	case BillboardType.SingleImage:  		// Use foreground shader to draw text  		effectTechnique.GetPassByIndex (2).Apply (renderContext.DeviceContext);  		// --- draw text' foreground vertex is beginning from 0.  		renderContext.DeviceContext.DrawInstanced (vertexCount' this.instanceInternal.Count' 0' 0);  		break;  	case BillboardType.SingleText:  		if (vertexCount == 8) {  			var half = vertexCount / 2;  			// Use background shader to draw background first  			effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  			// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  			renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' half' 0);  			// Use foreground shader to draw text  			effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  			// --- draw text' foreground vertex is beginning from 0.  			renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' 0' 0);  		}  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: if (this.hasInstances) {  	if (this.isInstanceChanged) {  		InstanceBuffer.UploadDataToBuffer (renderContext.DeviceContext' this.instanceInternal);  		this.isInstanceChanged = false;  	}  	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (1' new VertexBufferBinding (this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0));  	if (this.hasInstanceParams) {  		if (instanceParamArrayChanged) {  			instanceParamBuffer.UploadDataToBuffer (renderContext.DeviceContext' this.InstanceParamArray);  			this.instanceParamArrayChanged = false;  		}  		renderContext.DeviceContext.InputAssembler.SetVertexBuffers (2' new VertexBufferBinding (this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0));  	}  	switch (billboardType) {  	case BillboardType.SingleImage:  		// Use foreground shader to draw text  		effectTechnique.GetPassByIndex (2).Apply (renderContext.DeviceContext);  		// --- draw text' foreground vertex is beginning from 0.  		renderContext.DeviceContext.DrawInstanced (vertexCount' this.instanceInternal.Count' 0' 0);  		break;  	case BillboardType.SingleText:  		if (vertexCount == 8) {  			var half = vertexCount / 2;  			// Use background shader to draw background first  			effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  			// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  			renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' half' 0);  			// Use foreground shader to draw text  			effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  			// --- draw text' foreground vertex is beginning from 0.  			renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' 0' 0);  		}  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: if (this.hasInstances) {  	if (this.isInstanceChanged) {  		InstanceBuffer.UploadDataToBuffer (renderContext.DeviceContext' this.instanceInternal);  		this.isInstanceChanged = false;  	}  	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (1' new VertexBufferBinding (this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0));  	if (this.hasInstanceParams) {  		if (instanceParamArrayChanged) {  			instanceParamBuffer.UploadDataToBuffer (renderContext.DeviceContext' this.InstanceParamArray);  			this.instanceParamArrayChanged = false;  		}  		renderContext.DeviceContext.InputAssembler.SetVertexBuffers (2' new VertexBufferBinding (this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0));  	}  	switch (billboardType) {  	case BillboardType.SingleImage:  		// Use foreground shader to draw text  		effectTechnique.GetPassByIndex (2).Apply (renderContext.DeviceContext);  		// --- draw text' foreground vertex is beginning from 0.  		renderContext.DeviceContext.DrawInstanced (vertexCount' this.instanceInternal.Count' 0' 0);  		break;  	case BillboardType.SingleText:  		if (vertexCount == 8) {  			var half = vertexCount / 2;  			// Use background shader to draw background first  			effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  			// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  			renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' half' 0);  			// Use foreground shader to draw text  			effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  			// --- draw text' foreground vertex is beginning from 0.  			renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' 0' 0);  		}  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: if (this.hasInstanceParams) {  	if (instanceParamArrayChanged) {  		instanceParamBuffer.UploadDataToBuffer (renderContext.DeviceContext' this.InstanceParamArray);  		this.instanceParamArrayChanged = false;  	}  	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (2' new VertexBufferBinding (this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: renderContext.DeviceContext.InputAssembler.SetVertexBuffers (2' new VertexBufferBinding (this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0));  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: switch (billboardType) {  case BillboardType.SingleImage:  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (2).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.DrawInstanced (vertexCount' this.instanceInternal.Count' 0' 0);  	break;  case BillboardType.SingleText:  	if (vertexCount == 8) {  		var half = vertexCount / 2;  		// Use background shader to draw background first  		effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  		// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  		renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' half' 0);  		// Use foreground shader to draw text  		effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  		// --- draw text' foreground vertex is beginning from 0.  		renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' 0' 0);  	}  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: switch (billboardType) {  case BillboardType.SingleImage:  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (2).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.DrawInstanced (vertexCount' this.instanceInternal.Count' 0' 0);  	break;  case BillboardType.SingleText:  	if (vertexCount == 8) {  		var half = vertexCount / 2;  		// Use background shader to draw background first  		effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  		// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  		renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' half' 0);  		// Use foreground shader to draw text  		effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  		// --- draw text' foreground vertex is beginning from 0.  		renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' 0' 0);  	}  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: switch (billboardType) {  case BillboardType.SingleImage:  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (2).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.DrawInstanced (vertexCount' this.instanceInternal.Count' 0' 0);  	break;  case BillboardType.SingleText:  	if (vertexCount == 8) {  		var half = vertexCount / 2;  		// Use background shader to draw background first  		effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  		// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  		renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' half' 0);  		// Use foreground shader to draw text  		effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  		// --- draw text' foreground vertex is beginning from 0.  		renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' 0' 0);  	}  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: effectTechnique.GetPassByIndex (2).Apply (renderContext.DeviceContext);  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: if (vertexCount == 8) {  	var half = vertexCount / 2;  	// Use background shader to draw background first  	effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  	// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  	renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' half' 0);  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' 0' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following statement contains a magic number: if (vertexCount == 8) {  	var half = vertexCount / 2;  	// Use background shader to draw background first  	effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  	// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  	renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' half' 0);  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' 0' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingMeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingMeshGeometryModel3D.cs,OnRender,The following statement contains a magic number: if (this.hasInstances) {  	// --- update instance buffer  	if (this.isInstanceChanged) {  		BuildOctree ();  		InstanceBuffer.UploadDataToBuffer (renderContext.DeviceContext' this.instanceInternal);  		this.isInstanceChanged = false;  	}  	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (1' new VertexBufferBinding (this.InstanceBuffer.Buffer' this.InstanceBuffer.StructureSize' 0));  	if (this.hasInstanceParams) {  		if (instanceParamArrayChanged) {  			instanceParamBuffer.UploadDataToBuffer (renderContext.DeviceContext' this.InstanceParamArray);  			this.instanceParamArrayChanged = false;  		}  		renderContext.DeviceContext.InputAssembler.SetVertexBuffers (2' new VertexBufferBinding (this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0));  	}  	// --- render the geometry  	this.effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  	// --- draw  	renderContext.DeviceContext.DrawIndexedInstanced (this.geometryInternal.Indices.Count' this.instanceInternal.Count' 0' 0' 0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingMeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingMeshGeometryModel3D.cs,OnRender,The following statement contains a magic number: if (this.hasInstanceParams) {  	if (instanceParamArrayChanged) {  		instanceParamBuffer.UploadDataToBuffer (renderContext.DeviceContext' this.InstanceParamArray);  		this.instanceParamArrayChanged = false;  	}  	renderContext.DeviceContext.InputAssembler.SetVertexBuffers (2' new VertexBufferBinding (this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,InstancingMeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingMeshGeometryModel3D.cs,OnRender,The following statement contains a magic number: renderContext.DeviceContext.InputAssembler.SetVertexBuffers (2' new VertexBufferBinding (this.instanceParamBuffer.Buffer' this.instanceParamBuffer.StructureSize' 0));  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeLineGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\OctreeLineGeometryModel3D.cs,OctreeLineGeometryModel3D,The following statement contains a magic number: HitVisual.Thickness = 1.5;  
Magic Number,HelixToolkit.Wpf.SharpDX,ParticleStormModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ParticleStormModel3D.cs,OnRender,The following statement contains a magic number: if (isRestart) {  	pass = this.effectTechnique.GetPassByIndex (1);  	pass.Apply (context.DeviceContext);  	// Reset Both UAV buffers  	context.DeviceContext.ComputeShader.SetUnorderedAccessView (0' BufferProxies [0].UAV' 0);  	context.DeviceContext.ComputeShader.SetUnorderedAccessView (1' BufferProxies [1].UAV' 0);  	context.DeviceContext.ComputeShader.SetConstantBuffer (1' frameConstBuffer.Buffer);  	// Call ComputeShader to add initial particles  	context.DeviceContext.Dispatch (1' 1' 1);  	isRestart = false;  } else {  	//upload framebuffer  	context.DeviceContext.UpdateSubresource (ref parameters.frameVariables' frameConstBuffer.Buffer);  	// Get consume buffer count  	context.DeviceContext.CopyStructureCount (frameConstBuffer.Buffer' ParticlePerFrame.NumParticlesOffset' BufferProxies [0].UAV);  	// Calculate existing particles  	pass = this.effectTechnique.GetPassByIndex (1);  	pass.Apply (context.DeviceContext);  	context.DeviceContext.ComputeShader.SetUnorderedAccessView (0' BufferProxies [0].UAV);  	context.DeviceContext.ComputeShader.SetUnorderedAccessView (1' BufferProxies [1].UAV' 0);  	context.DeviceContext.ComputeShader.SetConstantBuffer (1' frameConstBuffer.Buffer);  	context.DeviceContext.Dispatch (System.Math.Max (1' parameters.particleCountInternal / 512)' 1' 1);  	// Get append buffer count  	context.DeviceContext.CopyStructureCount (particleCountGSIABuffer.Buffer' 0' BufferProxies [1].UAV);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ParticleStormModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ParticleStormModel3D.cs,OnRender,The following statement contains a magic number: context.DeviceContext.Dispatch (System.Math.Max (1' parameters.particleCountInternal / 512)' 1' 1);  
Magic Number,HelixToolkit.Wpf.SharpDX,ParticleStormModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ParticleStormModel3D.cs,OnRender,The following statement contains a magic number: pass = this.effectTechnique.GetPassByIndex (2);  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,BillboardSingleImage3D,The following statement contains a magic number: Positions = new Vector3Collection (6);  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,BillboardSingleImage3D,The following statement contains a magic number: Colors = new Color4Collection (6);  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,BillboardSingleImage3D,The following statement contains a magic number: TextureCoordinates = new Vector2Collection (6);  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleImage3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleImage3D.cs,DrawTexture,The following statement contains a magic number: mTextInfoOffsets = new List<Vector2> (4);  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,BillboardSingleText3D,The following statement contains a magic number: Positions = new Vector3Collection (12);  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,BillboardSingleText3D,The following statement contains a magic number: Colors = new Color4Collection (12);  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,BillboardSingleText3D,The following statement contains a magic number: TextureCoordinates = new Vector2Collection (12);  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,BillboardSingleText3D,The following statement contains a magic number: Positions = new Vector3Collection (12);  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,BillboardSingleText3D,The following statement contains a magic number: Colors = new Color4Collection (12);  
Magic Number,HelixToolkit.Wpf.SharpDX,BillboardSingleText3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Geometry\BillboardSingleText3D.cs,BillboardSingleText3D,The following statement contains a magic number: TextureCoordinates = new Vector2Collection (12);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,OctreeBase,The following statement contains a magic number: queue = queueCache ?? new Queue<IOctree> (64);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,CreateOctants,The following statement contains a magic number: return new BoundingBox[8] {  	new BoundingBox (minimum' center)'  	new BoundingBox (new Vector3 (center.X' minimum.Y' minimum.Z)' new Vector3 (maximum.X' center.Y' center.Z))'  	new BoundingBox (new Vector3 (center.X' minimum.Y' center.Z)' new Vector3 (maximum.X' center.Y' maximum.Z))'  	new BoundingBox (new Vector3 (minimum.X' minimum.Y' center.Z)' new Vector3 (center.X' center.Y' maximum.Z))'  	new BoundingBox (new Vector3 (minimum.X' center.Y' minimum.Z)' new Vector3 (center.X' maximum.Y' center.Z))'  	new BoundingBox (new Vector3 (center.X' center.Y' minimum.Z)' new Vector3 (maximum.X' maximum.Y' center.Z))'  	new BoundingBox (center' maximum)'  	new BoundingBox (new Vector3 (minimum.X' center.Y' center.Z)' new Vector3 (center.X' maximum.Y' maximum.Z))  };  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,BuildSubTree,The following statement contains a magic number: for (int i = 0; i < 8; ++i)  	octList [i] = new List<T> (Objects.Count / 8);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,BuildSubTree,The following statement contains a magic number: for (int i = 0; i < 8; ++i)  	octList [i] = new List<T> (Objects.Count / 8);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,BuildSubTree,The following statement contains a magic number: octList [i] = new List<T> (Objects.Count / 8);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,BuildSubTree,The following statement contains a magic number: for (int i = Objects.Count - 1; i >= 0; --i) {  	var obj = Objects [i];  	for (int x = 0; x < 8; ++x) {  		if (IsContains (Octants [x]' obj)) {  			octList [x].Add (obj);  			Objects [i] = Objects [--count];  			//Disard the existing object from location i' replaced with last valid object.  			break;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,BuildSubTree,The following statement contains a magic number: for (int x = 0; x < 8; ++x) {  	if (IsContains (Octants [x]' obj)) {  		octList [x].Add (obj);  		Objects [i] = Objects [--count];  		//Disard the existing object from location i' replaced with last valid object.  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,BuildSubTree,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {  	if (octList [i].Count != 0) {  		ChildNodes [i] = CreateNode (ref octants [i]' octList [i]);  		ActiveNodes |= (byte)(1 << i);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,SigBit,The following statement contains a magic number: if (x >= 0) {  	return (int)Math.Pow (2' Math.Ceiling (Math.Log (x) / Math.Log (2)));  } else {  	x = Math.Abs (x);  	return -(int)Math.Pow (2' Math.Ceiling (Math.Log (x) / Math.Log (2)));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,SigBit,The following statement contains a magic number: if (x >= 0) {  	return (int)Math.Pow (2' Math.Ceiling (Math.Log (x) / Math.Log (2)));  } else {  	x = Math.Abs (x);  	return -(int)Math.Pow (2' Math.Ceiling (Math.Log (x) / Math.Log (2)));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,SigBit,The following statement contains a magic number: if (x >= 0) {  	return (int)Math.Pow (2' Math.Ceiling (Math.Log (x) / Math.Log (2)));  } else {  	x = Math.Abs (x);  	return -(int)Math.Pow (2' Math.Ceiling (Math.Log (x) / Math.Log (2)));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,SigBit,The following statement contains a magic number: if (x >= 0) {  	return (int)Math.Pow (2' Math.Ceiling (Math.Log (x) / Math.Log (2)));  } else {  	x = Math.Abs (x);  	return -(int)Math.Pow (2' Math.Ceiling (Math.Log (x) / Math.Log (2)));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,SigBit,The following statement contains a magic number: return (int)Math.Pow (2' Math.Ceiling (Math.Log (x) / Math.Log (2)));  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,SigBit,The following statement contains a magic number: return (int)Math.Pow (2' Math.Ceiling (Math.Log (x) / Math.Log (2)));  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,SigBit,The following statement contains a magic number: return -(int)Math.Pow (2' Math.Ceiling (Math.Log (x) / Math.Log (2)));  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,SigBit,The following statement contains a magic number: return -(int)Math.Pow (2' Math.Ceiling (Math.Log (x) / Math.Log (2)));  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,Expand,The following statement contains a magic number: if (!oldRoot.IsEmpty) {  	int idx = -1;  	float diff = float.MaxValue;  	for (int i = 0; i < newRoot.Octants.Length; ++i) {  		var d = (newRoot.Octants [i].Minimum - rootBound.Minimum).LengthSquared ();  		if (d < diff) {  			diff = d;  			idx = i;  			if (diff < 10e-8) {  				break;  			}  		}  	}  	if (idx >= 0 && idx < newRoot.Octants.Length) {  		newRoot.ChildNodes [idx] = oldRoot;  		newRoot.Octants [idx] = oldRoot.Bound;  		newRoot.ActiveNodes |= (byte)(1 << idx);  		oldRoot.Parent = newRoot;  		succ = true;  	}  	if (!succ) {  		throw new Exception ("Expand failed.");  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,Expand,The following statement contains a magic number: for (int i = 0; i < newRoot.Octants.Length; ++i) {  	var d = (newRoot.Octants [i].Minimum - rootBound.Minimum).LengthSquared ();  	if (d < diff) {  		diff = d;  		idx = i;  		if (diff < 10e-8) {  			break;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,Expand,The following statement contains a magic number: if (d < diff) {  	diff = d;  	idx = i;  	if (diff < 10e-8) {  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeBase,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,Expand,The following statement contains a magic number: if (diff < 10e-8) {  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,MeshGeometryOctree,The following statement contains a magic number: Objects = new List<Tuple<int' BoundingBox>> (indices.Count / 3);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,MeshGeometryOctree,The following statement contains a magic number: foreach (var i in Enumerable.Range (0' indices.Count / 3)) {  	Objects.Add (new Tuple<int' BoundingBox> (i' GetBoundingBox (i)));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The following statement contains a magic number: if (rayWS.Intersects (ref bound) && (!checkBoundSphere || rayWS.Intersects (ref boundSphere))) {  	isIntersect = true;  	foreach (var t in this.Objects) {  		var idx = t.Item1 * 3;  		var t1 = Indices [idx];  		var t2 = Indices [idx + 1];  		var t3 = Indices [idx + 2];  		var v0 = Positions [t1];  		var v1 = Positions [t2];  		var v2 = Positions [t3];  		float d;  		var p0 = Vector3.TransformCoordinate (v0' modelMatrix);  		var p1 = Vector3.TransformCoordinate (v1' modelMatrix);  		var p2 = Vector3.TransformCoordinate (v2' modelMatrix);  		if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  			if (d >= 0 && d < result.Distance)// If d is NaN' the condition is false.  			 {  				result.IsValid = true;  				result.ModelHit = model;  				// transform hit-info to world space now:  				result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  				result.Distance = d;  				var n = Vector3.Cross (p1 - p0' p2 - p0);  				n.Normalize ();  				// transform hit-info to world space now:  				result.NormalAtHit = n.ToVector3D ();  				// Vector3.TransformNormal(n' m).ToVector3D();  				result.TriangleIndices = new System.Tuple<int' int' int> (t1' t2' t3);  				result.Tag = t.Item1;  				isHit = true;  			}  		}  	}  	if (isHit) {  		isHit = false;  		if (hits.Count > 0) {  			if (hits [0].Distance > result.Distance) {  				hits [0] = result;  				isHit = true;  			}  		} else {  			hits.Add (result);  			isHit = true;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The following statement contains a magic number: if (rayWS.Intersects (ref bound) && (!checkBoundSphere || rayWS.Intersects (ref boundSphere))) {  	isIntersect = true;  	foreach (var t in this.Objects) {  		var idx = t.Item1 * 3;  		var t1 = Indices [idx];  		var t2 = Indices [idx + 1];  		var t3 = Indices [idx + 2];  		var v0 = Positions [t1];  		var v1 = Positions [t2];  		var v2 = Positions [t3];  		float d;  		var p0 = Vector3.TransformCoordinate (v0' modelMatrix);  		var p1 = Vector3.TransformCoordinate (v1' modelMatrix);  		var p2 = Vector3.TransformCoordinate (v2' modelMatrix);  		if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  			if (d >= 0 && d < result.Distance)// If d is NaN' the condition is false.  			 {  				result.IsValid = true;  				result.ModelHit = model;  				// transform hit-info to world space now:  				result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  				result.Distance = d;  				var n = Vector3.Cross (p1 - p0' p2 - p0);  				n.Normalize ();  				// transform hit-info to world space now:  				result.NormalAtHit = n.ToVector3D ();  				// Vector3.TransformNormal(n' m).ToVector3D();  				result.TriangleIndices = new System.Tuple<int' int' int> (t1' t2' t3);  				result.Tag = t.Item1;  				isHit = true;  			}  		}  	}  	if (isHit) {  		isHit = false;  		if (hits.Count > 0) {  			if (hits [0].Distance > result.Distance) {  				hits [0] = result;  				isHit = true;  			}  		} else {  			hits.Add (result);  			isHit = true;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The following statement contains a magic number: foreach (var t in this.Objects) {  	var idx = t.Item1 * 3;  	var t1 = Indices [idx];  	var t2 = Indices [idx + 1];  	var t3 = Indices [idx + 2];  	var v0 = Positions [t1];  	var v1 = Positions [t2];  	var v2 = Positions [t3];  	float d;  	var p0 = Vector3.TransformCoordinate (v0' modelMatrix);  	var p1 = Vector3.TransformCoordinate (v1' modelMatrix);  	var p2 = Vector3.TransformCoordinate (v2' modelMatrix);  	if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  		if (d >= 0 && d < result.Distance)// If d is NaN' the condition is false.  		 {  			result.IsValid = true;  			result.ModelHit = model;  			// transform hit-info to world space now:  			result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  			result.Distance = d;  			var n = Vector3.Cross (p1 - p0' p2 - p0);  			n.Normalize ();  			// transform hit-info to world space now:  			result.NormalAtHit = n.ToVector3D ();  			// Vector3.TransformNormal(n' m).ToVector3D();  			result.TriangleIndices = new System.Tuple<int' int' int> (t1' t2' t3);  			result.Tag = t.Item1;  			isHit = true;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,HitTestCurrentNodeExcludeChild,The following statement contains a magic number: foreach (var t in this.Objects) {  	var idx = t.Item1 * 3;  	var t1 = Indices [idx];  	var t2 = Indices [idx + 1];  	var t3 = Indices [idx + 2];  	var v0 = Positions [t1];  	var v1 = Positions [t2];  	var v2 = Positions [t3];  	float d;  	var p0 = Vector3.TransformCoordinate (v0' modelMatrix);  	var p1 = Vector3.TransformCoordinate (v1' modelMatrix);  	var p2 = Vector3.TransformCoordinate (v2' modelMatrix);  	if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  		if (d >= 0 && d < result.Distance)// If d is NaN' the condition is false.  		 {  			result.IsValid = true;  			result.ModelHit = model;  			// transform hit-info to world space now:  			result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  			result.Distance = d;  			var n = Vector3.Cross (p1 - p0' p2 - p0);  			n.Normalize ();  			// transform hit-info to world space now:  			result.NormalAtHit = n.ToVector3D ();  			// Vector3.TransformNormal(n' m).ToVector3D();  			result.TriangleIndices = new System.Tuple<int' int' int> (t1' t2' t3);  			result.Tag = t.Item1;  			isHit = true;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindNearestPointBySphereExcludeChild,The following statement contains a magic number: if (containment == ContainmentType.Contains || containment == ContainmentType.Intersects) {  	isIntersect = true;  	foreach (var t in Objects) {  		containment = t.Item2.Contains (sphere);  		if (containment == ContainmentType.Contains || containment == ContainmentType.Intersects) {  			Vector3 cloestPoint;  			var idx = t.Item1 * 3;  			var t1 = Indices [idx];  			var t2 = Indices [idx + 1];  			var t3 = Indices [idx + 2];  			var v0 = Positions [t1];  			var v1 = Positions [t2];  			var v2 = Positions [t3];  			Collision.ClosestPointPointTriangle (ref sphere.Center' ref v0' ref v1' ref v2' out cloestPoint);  			var d = (cloestPoint - sphere.Center).Length ();  			if (tempResult.Distance > d) {  				tempResult.Distance = d;  				tempResult.IsValid = true;  				tempResult.PointHit = cloestPoint.ToPoint3D ();  				tempResult.TriangleIndices = new Tuple<int' int' int> (t1' t2' t3);  				tempResult.Tag = t.Item1;  				isHit = true;  			}  		}  	}  	if (isHit) {  		isHit = false;  		if (result.Count > 0) {  			if (result [0].Distance > tempResult.Distance) {  				result [0] = tempResult;  				isHit = true;  			}  		} else {  			result.Add (tempResult);  			isHit = true;  		}  	}  } else {  	isIntersect = false;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindNearestPointBySphereExcludeChild,The following statement contains a magic number: if (containment == ContainmentType.Contains || containment == ContainmentType.Intersects) {  	isIntersect = true;  	foreach (var t in Objects) {  		containment = t.Item2.Contains (sphere);  		if (containment == ContainmentType.Contains || containment == ContainmentType.Intersects) {  			Vector3 cloestPoint;  			var idx = t.Item1 * 3;  			var t1 = Indices [idx];  			var t2 = Indices [idx + 1];  			var t3 = Indices [idx + 2];  			var v0 = Positions [t1];  			var v1 = Positions [t2];  			var v2 = Positions [t3];  			Collision.ClosestPointPointTriangle (ref sphere.Center' ref v0' ref v1' ref v2' out cloestPoint);  			var d = (cloestPoint - sphere.Center).Length ();  			if (tempResult.Distance > d) {  				tempResult.Distance = d;  				tempResult.IsValid = true;  				tempResult.PointHit = cloestPoint.ToPoint3D ();  				tempResult.TriangleIndices = new Tuple<int' int' int> (t1' t2' t3);  				tempResult.Tag = t.Item1;  				isHit = true;  			}  		}  	}  	if (isHit) {  		isHit = false;  		if (result.Count > 0) {  			if (result [0].Distance > tempResult.Distance) {  				result [0] = tempResult;  				isHit = true;  			}  		} else {  			result.Add (tempResult);  			isHit = true;  		}  	}  } else {  	isIntersect = false;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindNearestPointBySphereExcludeChild,The following statement contains a magic number: foreach (var t in Objects) {  	containment = t.Item2.Contains (sphere);  	if (containment == ContainmentType.Contains || containment == ContainmentType.Intersects) {  		Vector3 cloestPoint;  		var idx = t.Item1 * 3;  		var t1 = Indices [idx];  		var t2 = Indices [idx + 1];  		var t3 = Indices [idx + 2];  		var v0 = Positions [t1];  		var v1 = Positions [t2];  		var v2 = Positions [t3];  		Collision.ClosestPointPointTriangle (ref sphere.Center' ref v0' ref v1' ref v2' out cloestPoint);  		var d = (cloestPoint - sphere.Center).Length ();  		if (tempResult.Distance > d) {  			tempResult.Distance = d;  			tempResult.IsValid = true;  			tempResult.PointHit = cloestPoint.ToPoint3D ();  			tempResult.TriangleIndices = new Tuple<int' int' int> (t1' t2' t3);  			tempResult.Tag = t.Item1;  			isHit = true;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindNearestPointBySphereExcludeChild,The following statement contains a magic number: foreach (var t in Objects) {  	containment = t.Item2.Contains (sphere);  	if (containment == ContainmentType.Contains || containment == ContainmentType.Intersects) {  		Vector3 cloestPoint;  		var idx = t.Item1 * 3;  		var t1 = Indices [idx];  		var t2 = Indices [idx + 1];  		var t3 = Indices [idx + 2];  		var v0 = Positions [t1];  		var v1 = Positions [t2];  		var v2 = Positions [t3];  		Collision.ClosestPointPointTriangle (ref sphere.Center' ref v0' ref v1' ref v2' out cloestPoint);  		var d = (cloestPoint - sphere.Center).Length ();  		if (tempResult.Distance > d) {  			tempResult.Distance = d;  			tempResult.IsValid = true;  			tempResult.PointHit = cloestPoint.ToPoint3D ();  			tempResult.TriangleIndices = new Tuple<int' int' int> (t1' t2' t3);  			tempResult.Tag = t.Item1;  			isHit = true;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindNearestPointBySphereExcludeChild,The following statement contains a magic number: if (containment == ContainmentType.Contains || containment == ContainmentType.Intersects) {  	Vector3 cloestPoint;  	var idx = t.Item1 * 3;  	var t1 = Indices [idx];  	var t2 = Indices [idx + 1];  	var t3 = Indices [idx + 2];  	var v0 = Positions [t1];  	var v1 = Positions [t2];  	var v2 = Positions [t3];  	Collision.ClosestPointPointTriangle (ref sphere.Center' ref v0' ref v1' ref v2' out cloestPoint);  	var d = (cloestPoint - sphere.Center).Length ();  	if (tempResult.Distance > d) {  		tempResult.Distance = d;  		tempResult.IsValid = true;  		tempResult.PointHit = cloestPoint.ToPoint3D ();  		tempResult.TriangleIndices = new Tuple<int' int' int> (t1' t2' t3);  		tempResult.Tag = t.Item1;  		isHit = true;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryOctree,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\Octree.cs,FindNearestPointBySphereExcludeChild,The following statement contains a magic number: if (containment == ContainmentType.Contains || containment == ContainmentType.Intersects) {  	Vector3 cloestPoint;  	var idx = t.Item1 * 3;  	var t1 = Indices [idx];  	var t2 = Indices [idx + 1];  	var t3 = Indices [idx + 2];  	var v0 = Positions [t1];  	var v1 = Positions [t2];  	var v2 = Positions [t3];  	Collision.ClosestPointPointTriangle (ref sphere.Center' ref v0' ref v1' ref v2' out cloestPoint);  	var d = (cloestPoint - sphere.Center).Length ();  	if (tempResult.Distance > d) {  		tempResult.Distance = d;  		tempResult.IsValid = true;  		tempResult.PointHit = cloestPoint.ToPoint3D ();  		tempResult.TriangleIndices = new Tuple<int' int' int> (t1' t2' t3);  		tempResult.Tag = t.Item1;  		isHit = true;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts [7] = box.Maximum;  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [0]' verts [2]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [0]' verts [3]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [7]' verts [4]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [7]' verts [4]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [7]' verts [5]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [7]' verts [5]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [7]' verts [6]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [7]' verts [6]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [1]' verts [6]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [1]' verts [5]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [4]' verts [2]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [4]' verts [2]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [4]' verts [3]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [4]' verts [3]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [2]' verts [6]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [2]' verts [6]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [3]' verts [5]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine (verts [3]' verts [5]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: foreach (var box in path) {  	verts [0] = box.Minimum;  	verts [1] = new Vector3 (box.Minimum.X' box.Minimum.Y' box.Maximum.Z);  	//Z  	verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  	//Y  	verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  	//X  	verts [7] = box.Maximum;  	verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  	//Z  	verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  	//Y  	verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  	//X  	builder.AddLine (verts [0]' verts [1]);  	builder.AddLine (verts [0]' verts [2]);  	builder.AddLine (verts [0]' verts [3]);  	builder.AddLine (verts [7]' verts [4]);  	builder.AddLine (verts [7]' verts [5]);  	builder.AddLine (verts [7]' verts [6]);  	builder.AddLine (verts [1]' verts [6]);  	builder.AddLine (verts [1]' verts [5]);  	builder.AddLine (verts [4]' verts [2]);  	builder.AddLine (verts [4]' verts [3]);  	builder.AddLine (verts [2]' verts [6]);  	builder.AddLine (verts [3]' verts [5]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: verts [2] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Minimum.Z);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: verts [3] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Minimum.Z);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: verts [7] = box.Maximum;  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: verts [4] = new Vector3 (box.Maximum.X' box.Maximum.Y' box.Minimum.Z);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: verts [5] = new Vector3 (box.Maximum.X' box.Minimum.Y' box.Maximum.Z);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: verts [6] = new Vector3 (box.Minimum.X' box.Maximum.Y' box.Maximum.Z);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [0]' verts [2]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [0]' verts [3]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [7]' verts [4]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [7]' verts [4]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [7]' verts [5]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [7]' verts [5]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [7]' verts [6]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [7]' verts [6]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [1]' verts [6]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [1]' verts [5]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [4]' verts [2]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [4]' verts [2]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [4]' verts [3]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [4]' verts [3]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [2]' verts [6]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [2]' verts [6]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [3]' verts [5]);  
Magic Number,HelixToolkit.Wpf.SharpDX,OctreeHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine (verts [3]' verts [5]);  
Magic Number,HelixToolkit.Wpf.SharpDX,GeometryModel3DOctreeManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeManager.cs,AddItem,The following statement contains a magic number: if (Enabled && item is GeometryModel3D) {  	var tree = mOctree;  	UpdateOctree (null);  	var model = item as GeometryModel3D;  	if (tree == null) {  		RequestRebuild ();  	} else {  		bool succeed = true;  		int counter = 0;  		while (!tree.Add (model)) {  			var direction = (model.Bounds.Minimum + model.Bounds.Maximum) - (tree.Bound.Minimum + tree.Bound.Maximum);  			tree = tree.Expand (ref direction) as GeometryModel3DOctree;  			++counter;  			if (counter > 10) {  				#if DEBUG  				throw new Exception ("Expand tree failed");  				#else  				                            succeed = false;                             break; #endif  			}  		}  		if (succeed) {  			UpdateOctree (tree);  			SubscribeBoundChangeEvent (model);  		} else {  			RequestRebuild ();  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,GeometryModel3DOctreeManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeManager.cs,AddItem,The following statement contains a magic number: if (tree == null) {  	RequestRebuild ();  } else {  	bool succeed = true;  	int counter = 0;  	while (!tree.Add (model)) {  		var direction = (model.Bounds.Minimum + model.Bounds.Maximum) - (tree.Bound.Minimum + tree.Bound.Maximum);  		tree = tree.Expand (ref direction) as GeometryModel3DOctree;  		++counter;  		if (counter > 10) {  			#if DEBUG  			throw new Exception ("Expand tree failed");  			#else  			                            succeed = false;                             break; #endif  		}  	}  	if (succeed) {  		UpdateOctree (tree);  		SubscribeBoundChangeEvent (model);  	} else {  		RequestRebuild ();  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,GeometryModel3DOctreeManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeManager.cs,AddItem,The following statement contains a magic number: while (!tree.Add (model)) {  	var direction = (model.Bounds.Minimum + model.Bounds.Maximum) - (tree.Bound.Minimum + tree.Bound.Maximum);  	tree = tree.Expand (ref direction) as GeometryModel3DOctree;  	++counter;  	if (counter > 10) {  		#if DEBUG  		throw new Exception ("Expand tree failed");  		#else  		                            succeed = false;                             break; #endif  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,GeometryModel3DOctreeManager,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OctreeManager.cs,AddItem,The following statement contains a magic number: if (counter > 10) {  	#if DEBUG  	throw new Exception ("Expand tree failed");  	#else  	                            succeed = false;                             break; #endif  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: using (var reader = new StreamReader (s)) {  	bool containsNormals = false;  	bool containsTextureCoordinates = false;  	bool containsColors = false;  	bool containsHomogeneousCoordinates = false;  	int vertexDimension = 3;  	bool nextLineContainsVertexDimension = false;  	bool nextLineContainsNumberOfVertices = false;  	int numberOfVertices = 0;  	int numberOfFaces = 0;  	// int numberOfEdges = 0;  	while (!reader.EndOfStream) {  		var line = reader.ReadLine ();  		if (line == null) {  			break;  		}  		line = line.Trim ();  		if (line.StartsWith ("#") || line.Length == 0) {  			continue;  		}  		if (nextLineContainsVertexDimension) {  			var values = GetIntValues (line);  			vertexDimension = values [0];  			nextLineContainsVertexDimension = false;  			continue;  		}  		if (line.Contains ("OFF")) {  			containsNormals = line.Contains ("N");  			containsColors = line.Contains ("C");  			containsTextureCoordinates = line.Contains ("ST");  			if (line.Contains ("4")) {  				containsHomogeneousCoordinates = true;  			}  			if (line.Contains ("n")) {  				nextLineContainsVertexDimension = true;  			}  			nextLineContainsNumberOfVertices = true;  			continue;  		}  		if (nextLineContainsNumberOfVertices) {  			var values = GetIntValues (line);  			numberOfVertices = values [0];  			numberOfFaces = values [1];  			/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  			continue;  		}  		if (this.Vertices.Count < numberOfVertices) {  			var x = new double[vertexDimension];  			var values = GetValues (line);  			int i = 0;  			for (int j = 0; j < vertexDimension; j++) {  				x [j] = values [i++];  			}  			var n = new double[vertexDimension];  			var uv = new double[2];  			double w = 0;  			if (containsHomogeneousCoordinates) {  				w = values [i++];  			}  			if (containsNormals) {  				for (int j = 0; j < vertexDimension; j++) {  					n [j] = values [i++];  				}  			}  			if (containsColors) {  				// read color  			}  			if (containsTextureCoordinates) {  				for (int j = 0; j < 2; j++) {  					uv [j] = values [i++];  				}  			}  			this.Vertices.Add (new Point3D ((float)x [0]' (float)x [1]' (float)x [2]));  			continue;  		}  		if (this.Faces.Count < numberOfFaces) {  			var values = GetIntValues (line);  			int nv = values [0];  			var vertices = new int[nv];  			for (int i = 0; i < nv; i++) {  				vertices [i] = values [i + 1];  			}  			if (containsColors) {  				// read colorspec  			}  			this.Faces.Add (vertices);  			continue;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: using (var reader = new StreamReader (s)) {  	bool containsNormals = false;  	bool containsTextureCoordinates = false;  	bool containsColors = false;  	bool containsHomogeneousCoordinates = false;  	int vertexDimension = 3;  	bool nextLineContainsVertexDimension = false;  	bool nextLineContainsNumberOfVertices = false;  	int numberOfVertices = 0;  	int numberOfFaces = 0;  	// int numberOfEdges = 0;  	while (!reader.EndOfStream) {  		var line = reader.ReadLine ();  		if (line == null) {  			break;  		}  		line = line.Trim ();  		if (line.StartsWith ("#") || line.Length == 0) {  			continue;  		}  		if (nextLineContainsVertexDimension) {  			var values = GetIntValues (line);  			vertexDimension = values [0];  			nextLineContainsVertexDimension = false;  			continue;  		}  		if (line.Contains ("OFF")) {  			containsNormals = line.Contains ("N");  			containsColors = line.Contains ("C");  			containsTextureCoordinates = line.Contains ("ST");  			if (line.Contains ("4")) {  				containsHomogeneousCoordinates = true;  			}  			if (line.Contains ("n")) {  				nextLineContainsVertexDimension = true;  			}  			nextLineContainsNumberOfVertices = true;  			continue;  		}  		if (nextLineContainsNumberOfVertices) {  			var values = GetIntValues (line);  			numberOfVertices = values [0];  			numberOfFaces = values [1];  			/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  			continue;  		}  		if (this.Vertices.Count < numberOfVertices) {  			var x = new double[vertexDimension];  			var values = GetValues (line);  			int i = 0;  			for (int j = 0; j < vertexDimension; j++) {  				x [j] = values [i++];  			}  			var n = new double[vertexDimension];  			var uv = new double[2];  			double w = 0;  			if (containsHomogeneousCoordinates) {  				w = values [i++];  			}  			if (containsNormals) {  				for (int j = 0; j < vertexDimension; j++) {  					n [j] = values [i++];  				}  			}  			if (containsColors) {  				// read color  			}  			if (containsTextureCoordinates) {  				for (int j = 0; j < 2; j++) {  					uv [j] = values [i++];  				}  			}  			this.Vertices.Add (new Point3D ((float)x [0]' (float)x [1]' (float)x [2]));  			continue;  		}  		if (this.Faces.Count < numberOfFaces) {  			var values = GetIntValues (line);  			int nv = values [0];  			var vertices = new int[nv];  			for (int i = 0; i < nv; i++) {  				vertices [i] = values [i + 1];  			}  			if (containsColors) {  				// read colorspec  			}  			this.Faces.Add (vertices);  			continue;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: using (var reader = new StreamReader (s)) {  	bool containsNormals = false;  	bool containsTextureCoordinates = false;  	bool containsColors = false;  	bool containsHomogeneousCoordinates = false;  	int vertexDimension = 3;  	bool nextLineContainsVertexDimension = false;  	bool nextLineContainsNumberOfVertices = false;  	int numberOfVertices = 0;  	int numberOfFaces = 0;  	// int numberOfEdges = 0;  	while (!reader.EndOfStream) {  		var line = reader.ReadLine ();  		if (line == null) {  			break;  		}  		line = line.Trim ();  		if (line.StartsWith ("#") || line.Length == 0) {  			continue;  		}  		if (nextLineContainsVertexDimension) {  			var values = GetIntValues (line);  			vertexDimension = values [0];  			nextLineContainsVertexDimension = false;  			continue;  		}  		if (line.Contains ("OFF")) {  			containsNormals = line.Contains ("N");  			containsColors = line.Contains ("C");  			containsTextureCoordinates = line.Contains ("ST");  			if (line.Contains ("4")) {  				containsHomogeneousCoordinates = true;  			}  			if (line.Contains ("n")) {  				nextLineContainsVertexDimension = true;  			}  			nextLineContainsNumberOfVertices = true;  			continue;  		}  		if (nextLineContainsNumberOfVertices) {  			var values = GetIntValues (line);  			numberOfVertices = values [0];  			numberOfFaces = values [1];  			/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  			continue;  		}  		if (this.Vertices.Count < numberOfVertices) {  			var x = new double[vertexDimension];  			var values = GetValues (line);  			int i = 0;  			for (int j = 0; j < vertexDimension; j++) {  				x [j] = values [i++];  			}  			var n = new double[vertexDimension];  			var uv = new double[2];  			double w = 0;  			if (containsHomogeneousCoordinates) {  				w = values [i++];  			}  			if (containsNormals) {  				for (int j = 0; j < vertexDimension; j++) {  					n [j] = values [i++];  				}  			}  			if (containsColors) {  				// read color  			}  			if (containsTextureCoordinates) {  				for (int j = 0; j < 2; j++) {  					uv [j] = values [i++];  				}  			}  			this.Vertices.Add (new Point3D ((float)x [0]' (float)x [1]' (float)x [2]));  			continue;  		}  		if (this.Faces.Count < numberOfFaces) {  			var values = GetIntValues (line);  			int nv = values [0];  			var vertices = new int[nv];  			for (int i = 0; i < nv; i++) {  				vertices [i] = values [i + 1];  			}  			if (containsColors) {  				// read colorspec  			}  			this.Faces.Add (vertices);  			continue;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: using (var reader = new StreamReader (s)) {  	bool containsNormals = false;  	bool containsTextureCoordinates = false;  	bool containsColors = false;  	bool containsHomogeneousCoordinates = false;  	int vertexDimension = 3;  	bool nextLineContainsVertexDimension = false;  	bool nextLineContainsNumberOfVertices = false;  	int numberOfVertices = 0;  	int numberOfFaces = 0;  	// int numberOfEdges = 0;  	while (!reader.EndOfStream) {  		var line = reader.ReadLine ();  		if (line == null) {  			break;  		}  		line = line.Trim ();  		if (line.StartsWith ("#") || line.Length == 0) {  			continue;  		}  		if (nextLineContainsVertexDimension) {  			var values = GetIntValues (line);  			vertexDimension = values [0];  			nextLineContainsVertexDimension = false;  			continue;  		}  		if (line.Contains ("OFF")) {  			containsNormals = line.Contains ("N");  			containsColors = line.Contains ("C");  			containsTextureCoordinates = line.Contains ("ST");  			if (line.Contains ("4")) {  				containsHomogeneousCoordinates = true;  			}  			if (line.Contains ("n")) {  				nextLineContainsVertexDimension = true;  			}  			nextLineContainsNumberOfVertices = true;  			continue;  		}  		if (nextLineContainsNumberOfVertices) {  			var values = GetIntValues (line);  			numberOfVertices = values [0];  			numberOfFaces = values [1];  			/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  			continue;  		}  		if (this.Vertices.Count < numberOfVertices) {  			var x = new double[vertexDimension];  			var values = GetValues (line);  			int i = 0;  			for (int j = 0; j < vertexDimension; j++) {  				x [j] = values [i++];  			}  			var n = new double[vertexDimension];  			var uv = new double[2];  			double w = 0;  			if (containsHomogeneousCoordinates) {  				w = values [i++];  			}  			if (containsNormals) {  				for (int j = 0; j < vertexDimension; j++) {  					n [j] = values [i++];  				}  			}  			if (containsColors) {  				// read color  			}  			if (containsTextureCoordinates) {  				for (int j = 0; j < 2; j++) {  					uv [j] = values [i++];  				}  			}  			this.Vertices.Add (new Point3D ((float)x [0]' (float)x [1]' (float)x [2]));  			continue;  		}  		if (this.Faces.Count < numberOfFaces) {  			var values = GetIntValues (line);  			int nv = values [0];  			var vertices = new int[nv];  			for (int i = 0; i < nv; i++) {  				vertices [i] = values [i + 1];  			}  			if (containsColors) {  				// read colorspec  			}  			this.Faces.Add (vertices);  			continue;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: while (!reader.EndOfStream) {  	var line = reader.ReadLine ();  	if (line == null) {  		break;  	}  	line = line.Trim ();  	if (line.StartsWith ("#") || line.Length == 0) {  		continue;  	}  	if (nextLineContainsVertexDimension) {  		var values = GetIntValues (line);  		vertexDimension = values [0];  		nextLineContainsVertexDimension = false;  		continue;  	}  	if (line.Contains ("OFF")) {  		containsNormals = line.Contains ("N");  		containsColors = line.Contains ("C");  		containsTextureCoordinates = line.Contains ("ST");  		if (line.Contains ("4")) {  			containsHomogeneousCoordinates = true;  		}  		if (line.Contains ("n")) {  			nextLineContainsVertexDimension = true;  		}  		nextLineContainsNumberOfVertices = true;  		continue;  	}  	if (nextLineContainsNumberOfVertices) {  		var values = GetIntValues (line);  		numberOfVertices = values [0];  		numberOfFaces = values [1];  		/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  		continue;  	}  	if (this.Vertices.Count < numberOfVertices) {  		var x = new double[vertexDimension];  		var values = GetValues (line);  		int i = 0;  		for (int j = 0; j < vertexDimension; j++) {  			x [j] = values [i++];  		}  		var n = new double[vertexDimension];  		var uv = new double[2];  		double w = 0;  		if (containsHomogeneousCoordinates) {  			w = values [i++];  		}  		if (containsNormals) {  			for (int j = 0; j < vertexDimension; j++) {  				n [j] = values [i++];  			}  		}  		if (containsColors) {  			// read color  		}  		if (containsTextureCoordinates) {  			for (int j = 0; j < 2; j++) {  				uv [j] = values [i++];  			}  		}  		this.Vertices.Add (new Point3D ((float)x [0]' (float)x [1]' (float)x [2]));  		continue;  	}  	if (this.Faces.Count < numberOfFaces) {  		var values = GetIntValues (line);  		int nv = values [0];  		var vertices = new int[nv];  		for (int i = 0; i < nv; i++) {  			vertices [i] = values [i + 1];  		}  		if (containsColors) {  			// read colorspec  		}  		this.Faces.Add (vertices);  		continue;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: while (!reader.EndOfStream) {  	var line = reader.ReadLine ();  	if (line == null) {  		break;  	}  	line = line.Trim ();  	if (line.StartsWith ("#") || line.Length == 0) {  		continue;  	}  	if (nextLineContainsVertexDimension) {  		var values = GetIntValues (line);  		vertexDimension = values [0];  		nextLineContainsVertexDimension = false;  		continue;  	}  	if (line.Contains ("OFF")) {  		containsNormals = line.Contains ("N");  		containsColors = line.Contains ("C");  		containsTextureCoordinates = line.Contains ("ST");  		if (line.Contains ("4")) {  			containsHomogeneousCoordinates = true;  		}  		if (line.Contains ("n")) {  			nextLineContainsVertexDimension = true;  		}  		nextLineContainsNumberOfVertices = true;  		continue;  	}  	if (nextLineContainsNumberOfVertices) {  		var values = GetIntValues (line);  		numberOfVertices = values [0];  		numberOfFaces = values [1];  		/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  		continue;  	}  	if (this.Vertices.Count < numberOfVertices) {  		var x = new double[vertexDimension];  		var values = GetValues (line);  		int i = 0;  		for (int j = 0; j < vertexDimension; j++) {  			x [j] = values [i++];  		}  		var n = new double[vertexDimension];  		var uv = new double[2];  		double w = 0;  		if (containsHomogeneousCoordinates) {  			w = values [i++];  		}  		if (containsNormals) {  			for (int j = 0; j < vertexDimension; j++) {  				n [j] = values [i++];  			}  		}  		if (containsColors) {  			// read color  		}  		if (containsTextureCoordinates) {  			for (int j = 0; j < 2; j++) {  				uv [j] = values [i++];  			}  		}  		this.Vertices.Add (new Point3D ((float)x [0]' (float)x [1]' (float)x [2]));  		continue;  	}  	if (this.Faces.Count < numberOfFaces) {  		var values = GetIntValues (line);  		int nv = values [0];  		var vertices = new int[nv];  		for (int i = 0; i < nv; i++) {  			vertices [i] = values [i + 1];  		}  		if (containsColors) {  			// read colorspec  		}  		this.Faces.Add (vertices);  		continue;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: while (!reader.EndOfStream) {  	var line = reader.ReadLine ();  	if (line == null) {  		break;  	}  	line = line.Trim ();  	if (line.StartsWith ("#") || line.Length == 0) {  		continue;  	}  	if (nextLineContainsVertexDimension) {  		var values = GetIntValues (line);  		vertexDimension = values [0];  		nextLineContainsVertexDimension = false;  		continue;  	}  	if (line.Contains ("OFF")) {  		containsNormals = line.Contains ("N");  		containsColors = line.Contains ("C");  		containsTextureCoordinates = line.Contains ("ST");  		if (line.Contains ("4")) {  			containsHomogeneousCoordinates = true;  		}  		if (line.Contains ("n")) {  			nextLineContainsVertexDimension = true;  		}  		nextLineContainsNumberOfVertices = true;  		continue;  	}  	if (nextLineContainsNumberOfVertices) {  		var values = GetIntValues (line);  		numberOfVertices = values [0];  		numberOfFaces = values [1];  		/* numberOfEdges = values[2]; */nextLineContainsNumberOfVertices = false;  		continue;  	}  	if (this.Vertices.Count < numberOfVertices) {  		var x = new double[vertexDimension];  		var values = GetValues (line);  		int i = 0;  		for (int j = 0; j < vertexDimension; j++) {  			x [j] = values [i++];  		}  		var n = new double[vertexDimension];  		var uv = new double[2];  		double w = 0;  		if (containsHomogeneousCoordinates) {  			w = values [i++];  		}  		if (containsNormals) {  			for (int j = 0; j < vertexDimension; j++) {  				n [j] = values [i++];  			}  		}  		if (containsColors) {  			// read color  		}  		if (containsTextureCoordinates) {  			for (int j = 0; j < 2; j++) {  				uv [j] = values [i++];  			}  		}  		this.Vertices.Add (new Point3D ((float)x [0]' (float)x [1]' (float)x [2]));  		continue;  	}  	if (this.Faces.Count < numberOfFaces) {  		var values = GetIntValues (line);  		int nv = values [0];  		var vertices = new int[nv];  		for (int i = 0; i < nv; i++) {  			vertices [i] = values [i + 1];  		}  		if (containsColors) {  			// read colorspec  		}  		this.Faces.Add (vertices);  		continue;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: if (this.Vertices.Count < numberOfVertices) {  	var x = new double[vertexDimension];  	var values = GetValues (line);  	int i = 0;  	for (int j = 0; j < vertexDimension; j++) {  		x [j] = values [i++];  	}  	var n = new double[vertexDimension];  	var uv = new double[2];  	double w = 0;  	if (containsHomogeneousCoordinates) {  		w = values [i++];  	}  	if (containsNormals) {  		for (int j = 0; j < vertexDimension; j++) {  			n [j] = values [i++];  		}  	}  	if (containsColors) {  		// read color  	}  	if (containsTextureCoordinates) {  		for (int j = 0; j < 2; j++) {  			uv [j] = values [i++];  		}  	}  	this.Vertices.Add (new Point3D ((float)x [0]' (float)x [1]' (float)x [2]));  	continue;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: if (this.Vertices.Count < numberOfVertices) {  	var x = new double[vertexDimension];  	var values = GetValues (line);  	int i = 0;  	for (int j = 0; j < vertexDimension; j++) {  		x [j] = values [i++];  	}  	var n = new double[vertexDimension];  	var uv = new double[2];  	double w = 0;  	if (containsHomogeneousCoordinates) {  		w = values [i++];  	}  	if (containsNormals) {  		for (int j = 0; j < vertexDimension; j++) {  			n [j] = values [i++];  		}  	}  	if (containsColors) {  		// read color  	}  	if (containsTextureCoordinates) {  		for (int j = 0; j < 2; j++) {  			uv [j] = values [i++];  		}  	}  	this.Vertices.Add (new Point3D ((float)x [0]' (float)x [1]' (float)x [2]));  	continue;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: if (this.Vertices.Count < numberOfVertices) {  	var x = new double[vertexDimension];  	var values = GetValues (line);  	int i = 0;  	for (int j = 0; j < vertexDimension; j++) {  		x [j] = values [i++];  	}  	var n = new double[vertexDimension];  	var uv = new double[2];  	double w = 0;  	if (containsHomogeneousCoordinates) {  		w = values [i++];  	}  	if (containsNormals) {  		for (int j = 0; j < vertexDimension; j++) {  			n [j] = values [i++];  		}  	}  	if (containsColors) {  		// read color  	}  	if (containsTextureCoordinates) {  		for (int j = 0; j < 2; j++) {  			uv [j] = values [i++];  		}  	}  	this.Vertices.Add (new Point3D ((float)x [0]' (float)x [1]' (float)x [2]));  	continue;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: if (containsTextureCoordinates) {  	for (int j = 0; j < 2; j++) {  		uv [j] = values [i++];  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: for (int j = 0; j < 2; j++) {  	uv [j] = values [i++];  }  
Magic Number,HelixToolkit.Wpf.SharpDX,OffReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\OffReader.cs,Load,The following statement contains a magic number: this.Vertices.Add (new Point3D ((float)x [0]' (float)x [1]' (float)x [2]));  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,Read,The following statement contains a magic number: using (var reader = new BinaryReader (s)) {  	long length = reader.BaseStream.Length;  	var headerId = this.ReadChunkId (reader);  	if (headerId != ChunkID.MAIN3DS) {  		throw new FileFormatException ("Unknown file");  	}  	int headerSize = this.ReadChunkSize (reader);  	if (headerSize != length) {  		throw new FileFormatException ("Incomplete file (file length does not match header)");  	}  	while (reader.BaseStream.Position < reader.BaseStream.Length) {  		var id = this.ReadChunkId (reader);  		int size = this.ReadChunkSize (reader);  		switch (id) {  		case ChunkID.EDIT_MATERIAL:  			this.ReadMaterial (reader' size);  			break;  		case ChunkID.EDIT_OBJECT:  			this.ReadObject (reader' size);  			break;  		case ChunkID.EDIT3DS:  		case ChunkID.OBJ_CAMERA:  		case ChunkID.OBJ_LIGHT:  		case ChunkID.OBJ_TRIMESH:  			// don't read the whole chunk' read the sub-defines...  			break;  		default:  			// download the whole chunk  			this.ReadData (reader' size - 6);  			break;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,Read,The following statement contains a magic number: while (reader.BaseStream.Position < reader.BaseStream.Length) {  	var id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	switch (id) {  	case ChunkID.EDIT_MATERIAL:  		this.ReadMaterial (reader' size);  		break;  	case ChunkID.EDIT_OBJECT:  		this.ReadObject (reader' size);  		break;  	case ChunkID.EDIT3DS:  	case ChunkID.OBJ_CAMERA:  	case ChunkID.OBJ_LIGHT:  	case ChunkID.OBJ_TRIMESH:  		// don't read the whole chunk' read the sub-defines...  		break;  	default:  		// download the whole chunk  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,Read,The following statement contains a magic number: switch (id) {  case ChunkID.EDIT_MATERIAL:  	this.ReadMaterial (reader' size);  	break;  case ChunkID.EDIT_OBJECT:  	this.ReadObject (reader' size);  	break;  case ChunkID.EDIT3DS:  case ChunkID.OBJ_CAMERA:  case ChunkID.OBJ_LIGHT:  case ChunkID.OBJ_TRIMESH:  	// don't read the whole chunk' read the sub-defines...  	break;  default:  	// download the whole chunk  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,Read,The following statement contains a magic number: this.ReadData (reader' size - 6);  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: while (total < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	total += size;  	switch (id) {  	case ChunkID.MAT_NAME01:  		name = this.ReadString (reader);  		break;  	case ChunkID.MAT_LUMINANCE:  		luminance = this.ReadColor (reader);  		break;  	case ChunkID.MAT_DIFFUSE:  		diffuse = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SPECULAR:  		specular = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SHININESS:  		byte[] bytes = this.ReadData (reader' size - 6);  		break;  	case ChunkID.MAT_MAP:  		texture = this.ReadMatMap (reader' size - 6);  		break;  	case ChunkID.MAT_MAPFILE:  		this.ReadData (reader' size - 6);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: while (total < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	total += size;  	switch (id) {  	case ChunkID.MAT_NAME01:  		name = this.ReadString (reader);  		break;  	case ChunkID.MAT_LUMINANCE:  		luminance = this.ReadColor (reader);  		break;  	case ChunkID.MAT_DIFFUSE:  		diffuse = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SPECULAR:  		specular = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SHININESS:  		byte[] bytes = this.ReadData (reader' size - 6);  		break;  	case ChunkID.MAT_MAP:  		texture = this.ReadMatMap (reader' size - 6);  		break;  	case ChunkID.MAT_MAPFILE:  		this.ReadData (reader' size - 6);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: while (total < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	total += size;  	switch (id) {  	case ChunkID.MAT_NAME01:  		name = this.ReadString (reader);  		break;  	case ChunkID.MAT_LUMINANCE:  		luminance = this.ReadColor (reader);  		break;  	case ChunkID.MAT_DIFFUSE:  		diffuse = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SPECULAR:  		specular = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SHININESS:  		byte[] bytes = this.ReadData (reader' size - 6);  		break;  	case ChunkID.MAT_MAP:  		texture = this.ReadMatMap (reader' size - 6);  		break;  	case ChunkID.MAT_MAPFILE:  		this.ReadData (reader' size - 6);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: while (total < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	total += size;  	switch (id) {  	case ChunkID.MAT_NAME01:  		name = this.ReadString (reader);  		break;  	case ChunkID.MAT_LUMINANCE:  		luminance = this.ReadColor (reader);  		break;  	case ChunkID.MAT_DIFFUSE:  		diffuse = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SPECULAR:  		specular = this.ReadColor (reader);  		break;  	case ChunkID.MAT_SHININESS:  		byte[] bytes = this.ReadData (reader' size - 6);  		break;  	case ChunkID.MAT_MAP:  		texture = this.ReadMatMap (reader' size - 6);  		break;  	case ChunkID.MAT_MAPFILE:  		this.ReadData (reader' size - 6);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id) {  case ChunkID.MAT_NAME01:  	name = this.ReadString (reader);  	break;  case ChunkID.MAT_LUMINANCE:  	luminance = this.ReadColor (reader);  	break;  case ChunkID.MAT_DIFFUSE:  	diffuse = this.ReadColor (reader);  	break;  case ChunkID.MAT_SPECULAR:  	specular = this.ReadColor (reader);  	break;  case ChunkID.MAT_SHININESS:  	byte[] bytes = this.ReadData (reader' size - 6);  	break;  case ChunkID.MAT_MAP:  	texture = this.ReadMatMap (reader' size - 6);  	break;  case ChunkID.MAT_MAPFILE:  	this.ReadData (reader' size - 6);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id) {  case ChunkID.MAT_NAME01:  	name = this.ReadString (reader);  	break;  case ChunkID.MAT_LUMINANCE:  	luminance = this.ReadColor (reader);  	break;  case ChunkID.MAT_DIFFUSE:  	diffuse = this.ReadColor (reader);  	break;  case ChunkID.MAT_SPECULAR:  	specular = this.ReadColor (reader);  	break;  case ChunkID.MAT_SHININESS:  	byte[] bytes = this.ReadData (reader' size - 6);  	break;  case ChunkID.MAT_MAP:  	texture = this.ReadMatMap (reader' size - 6);  	break;  case ChunkID.MAT_MAPFILE:  	this.ReadData (reader' size - 6);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id) {  case ChunkID.MAT_NAME01:  	name = this.ReadString (reader);  	break;  case ChunkID.MAT_LUMINANCE:  	luminance = this.ReadColor (reader);  	break;  case ChunkID.MAT_DIFFUSE:  	diffuse = this.ReadColor (reader);  	break;  case ChunkID.MAT_SPECULAR:  	specular = this.ReadColor (reader);  	break;  case ChunkID.MAT_SHININESS:  	byte[] bytes = this.ReadData (reader' size - 6);  	break;  case ChunkID.MAT_MAP:  	texture = this.ReadMatMap (reader' size - 6);  	break;  case ChunkID.MAT_MAPFILE:  	this.ReadData (reader' size - 6);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id) {  case ChunkID.MAT_NAME01:  	name = this.ReadString (reader);  	break;  case ChunkID.MAT_LUMINANCE:  	luminance = this.ReadColor (reader);  	break;  case ChunkID.MAT_DIFFUSE:  	diffuse = this.ReadColor (reader);  	break;  case ChunkID.MAT_SPECULAR:  	specular = this.ReadColor (reader);  	break;  case ChunkID.MAT_SHININESS:  	byte[] bytes = this.ReadData (reader' size - 6);  	break;  case ChunkID.MAT_MAP:  	texture = this.ReadMatMap (reader' size - 6);  	break;  case ChunkID.MAT_MAPFILE:  	this.ReadData (reader' size - 6);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: texture = this.ReadMatMap (reader' size - 6);  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: this.ReadData (reader' size - 6);  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMaterial,The following statement contains a magic number: this.ReadData (reader' size - 6);  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadObject,The following statement contains a magic number: while (total < chunkSize) {  	var id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	total += size;  	switch (id) {  	case ChunkID.OBJ_TRIMESH:  		this.ReadTriangularMesh (reader' size);  		break;  	default: {  		this.ReadData (reader' size - 6);  		break;  	}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadObject,The following statement contains a magic number: switch (id) {  case ChunkID.OBJ_TRIMESH:  	this.ReadTriangularMesh (reader' size);  	break;  default: {  	this.ReadData (reader' size - 6);  	break;  }  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadObject,The following statement contains a magic number: this.ReadData (reader' size - 6);  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	bytesRead += size;  	switch (id) {  	case ChunkID.TRI_VERTEXL:  		positions = this.ReadVertexList (reader);  		break;  	case ChunkID.TRI_FACEL1:  		faces = ReadFaceList (reader);  		size -= (faces.Count / 3 * 8) + 2;  		facesets = this.ReadFaceSets (reader' size - 6);  		break;  	case ChunkID.TRI_TEXCOORD:  		textureCoordinates = ReadTexCoords (reader);  		break;  	case ChunkID.TRI_LOCAL:  		matrix = this.ReadTransformation (reader);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	bytesRead += size;  	switch (id) {  	case ChunkID.TRI_VERTEXL:  		positions = this.ReadVertexList (reader);  		break;  	case ChunkID.TRI_FACEL1:  		faces = ReadFaceList (reader);  		size -= (faces.Count / 3 * 8) + 2;  		facesets = this.ReadFaceSets (reader' size - 6);  		break;  	case ChunkID.TRI_TEXCOORD:  		textureCoordinates = ReadTexCoords (reader);  		break;  	case ChunkID.TRI_LOCAL:  		matrix = this.ReadTransformation (reader);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	bytesRead += size;  	switch (id) {  	case ChunkID.TRI_VERTEXL:  		positions = this.ReadVertexList (reader);  		break;  	case ChunkID.TRI_FACEL1:  		faces = ReadFaceList (reader);  		size -= (faces.Count / 3 * 8) + 2;  		facesets = this.ReadFaceSets (reader' size - 6);  		break;  	case ChunkID.TRI_TEXCOORD:  		textureCoordinates = ReadTexCoords (reader);  		break;  	case ChunkID.TRI_LOCAL:  		matrix = this.ReadTransformation (reader);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	bytesRead += size;  	switch (id) {  	case ChunkID.TRI_VERTEXL:  		positions = this.ReadVertexList (reader);  		break;  	case ChunkID.TRI_FACEL1:  		faces = ReadFaceList (reader);  		size -= (faces.Count / 3 * 8) + 2;  		facesets = this.ReadFaceSets (reader' size - 6);  		break;  	case ChunkID.TRI_TEXCOORD:  		textureCoordinates = ReadTexCoords (reader);  		break;  	case ChunkID.TRI_LOCAL:  		matrix = this.ReadTransformation (reader);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: while (bytesRead < chunkSize) {  	ChunkID id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	bytesRead += size;  	switch (id) {  	case ChunkID.TRI_VERTEXL:  		positions = this.ReadVertexList (reader);  		break;  	case ChunkID.TRI_FACEL1:  		faces = ReadFaceList (reader);  		size -= (faces.Count / 3 * 8) + 2;  		facesets = this.ReadFaceSets (reader' size - 6);  		break;  	case ChunkID.TRI_TEXCOORD:  		textureCoordinates = ReadTexCoords (reader);  		break;  	case ChunkID.TRI_LOCAL:  		matrix = this.ReadTransformation (reader);  		break;  	default:  		this.ReadData (reader' size - 6);  		break;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id) {  case ChunkID.TRI_VERTEXL:  	positions = this.ReadVertexList (reader);  	break;  case ChunkID.TRI_FACEL1:  	faces = ReadFaceList (reader);  	size -= (faces.Count / 3 * 8) + 2;  	facesets = this.ReadFaceSets (reader' size - 6);  	break;  case ChunkID.TRI_TEXCOORD:  	textureCoordinates = ReadTexCoords (reader);  	break;  case ChunkID.TRI_LOCAL:  	matrix = this.ReadTransformation (reader);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id) {  case ChunkID.TRI_VERTEXL:  	positions = this.ReadVertexList (reader);  	break;  case ChunkID.TRI_FACEL1:  	faces = ReadFaceList (reader);  	size -= (faces.Count / 3 * 8) + 2;  	facesets = this.ReadFaceSets (reader' size - 6);  	break;  case ChunkID.TRI_TEXCOORD:  	textureCoordinates = ReadTexCoords (reader);  	break;  case ChunkID.TRI_LOCAL:  	matrix = this.ReadTransformation (reader);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id) {  case ChunkID.TRI_VERTEXL:  	positions = this.ReadVertexList (reader);  	break;  case ChunkID.TRI_FACEL1:  	faces = ReadFaceList (reader);  	size -= (faces.Count / 3 * 8) + 2;  	facesets = this.ReadFaceSets (reader' size - 6);  	break;  case ChunkID.TRI_TEXCOORD:  	textureCoordinates = ReadTexCoords (reader);  	break;  case ChunkID.TRI_LOCAL:  	matrix = this.ReadTransformation (reader);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id) {  case ChunkID.TRI_VERTEXL:  	positions = this.ReadVertexList (reader);  	break;  case ChunkID.TRI_FACEL1:  	faces = ReadFaceList (reader);  	size -= (faces.Count / 3 * 8) + 2;  	facesets = this.ReadFaceSets (reader' size - 6);  	break;  case ChunkID.TRI_TEXCOORD:  	textureCoordinates = ReadTexCoords (reader);  	break;  case ChunkID.TRI_LOCAL:  	matrix = this.ReadTransformation (reader);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id) {  case ChunkID.TRI_VERTEXL:  	positions = this.ReadVertexList (reader);  	break;  case ChunkID.TRI_FACEL1:  	faces = ReadFaceList (reader);  	size -= (faces.Count / 3 * 8) + 2;  	facesets = this.ReadFaceSets (reader' size - 6);  	break;  case ChunkID.TRI_TEXCOORD:  	textureCoordinates = ReadTexCoords (reader);  	break;  case ChunkID.TRI_LOCAL:  	matrix = this.ReadTransformation (reader);  	break;  default:  	this.ReadData (reader' size - 6);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: size -= (faces.Count / 3 * 8) + 2;  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: size -= (faces.Count / 3 * 8) + 2;  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: size -= (faces.Count / 3 * 8) + 2;  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: facesets = this.ReadFaceSets (reader' size - 6);  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: this.ReadData (reader' size - 6);  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ComputeNormals,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3) {  	var i1 = triangleIndices [t];  	var i2 = triangleIndices [t + 1];  	var i3 = triangleIndices [t + 2];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var p1 = v2 - v1;  	var p2 = v3 - v1;  	var n = Vector3.Cross (p1' p2);  	// angle  	p1.Normalize ();  	p2.Normalize ();  	var a = (float)Math.Acos (Vector3.Dot (p1' p2));  	n.Normalize ();  	normals [i1] += (a * n);  	normals [i2] += (a * n);  	normals [i3] += (a * n);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ComputeNormals,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3) {  	var i1 = triangleIndices [t];  	var i2 = triangleIndices [t + 1];  	var i3 = triangleIndices [t + 2];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var p1 = v2 - v1;  	var p2 = v3 - v1;  	var n = Vector3.Cross (p1' p2);  	// angle  	p1.Normalize ();  	p2.Normalize ();  	var a = (float)Math.Acos (Vector3.Dot (p1' p2));  	n.Normalize ();  	normals [i1] += (a * n);  	normals [i2] += (a * n);  	normals [i3] += (a * n);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ComputeNormals,The following statement contains a magic number: t += 3
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: foreach (int f in subFaces) {  	triangleIndices.Add (faces [f * 3]);  	triangleIndices.Add (faces [(f * 3) + 1]);  	triangleIndices.Add (faces [(f * 3) + 2]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: foreach (int f in subFaces) {  	triangleIndices.Add (faces [f * 3]);  	triangleIndices.Add (faces [(f * 3) + 1]);  	triangleIndices.Add (faces [(f * 3) + 2]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: foreach (int f in subFaces) {  	triangleIndices.Add (faces [f * 3]);  	triangleIndices.Add (faces [(f * 3) + 1]);  	triangleIndices.Add (faces [(f * 3) + 2]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: foreach (int f in subFaces) {  	triangleIndices.Add (faces [f * 3]);  	triangleIndices.Add (faces [(f * 3) + 1]);  	triangleIndices.Add (faces [(f * 3) + 2]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: triangleIndices.Add (faces [f * 3]);  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: triangleIndices.Add (faces [(f * 3) + 1]);  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: triangleIndices.Add (faces [(f * 3) + 2]);  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: triangleIndices.Add (faces [(f * 3) + 2]);  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: while (total < chunkSize) {  	var id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	total += size;  	switch (id) {  	case ChunkID.TRI_FACEMAT: {  		string name = this.ReadString (reader);  		int n = reader.ReadUInt16 ();  		var c = new List<int> ();  		for (int i = 0; i < n; i++) {  			c.Add (reader.ReadUInt16 ());  		}  		var fm = new FaceSet {  			Name = name'  			Faces = c  		};  		list.Add (fm);  		break;  	}  	case ChunkID.TRI_SMOOTH: {  		this.ReadData (reader' size - 6);  		break;  	}  	default: {  		this.ReadData (reader' size - 6);  		break;  	}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: while (total < chunkSize) {  	var id = this.ReadChunkId (reader);  	int size = this.ReadChunkSize (reader);  	total += size;  	switch (id) {  	case ChunkID.TRI_FACEMAT: {  		string name = this.ReadString (reader);  		int n = reader.ReadUInt16 ();  		var c = new List<int> ();  		for (int i = 0; i < n; i++) {  			c.Add (reader.ReadUInt16 ());  		}  		var fm = new FaceSet {  			Name = name'  			Faces = c  		};  		list.Add (fm);  		break;  	}  	case ChunkID.TRI_SMOOTH: {  		this.ReadData (reader' size - 6);  		break;  	}  	default: {  		this.ReadData (reader' size - 6);  		break;  	}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: switch (id) {  case ChunkID.TRI_FACEMAT: {  	string name = this.ReadString (reader);  	int n = reader.ReadUInt16 ();  	var c = new List<int> ();  	for (int i = 0; i < n; i++) {  		c.Add (reader.ReadUInt16 ());  	}  	var fm = new FaceSet {  		Name = name'  		Faces = c  	};  	list.Add (fm);  	break;  }  case ChunkID.TRI_SMOOTH: {  	this.ReadData (reader' size - 6);  	break;  }  default: {  	this.ReadData (reader' size - 6);  	break;  }  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: switch (id) {  case ChunkID.TRI_FACEMAT: {  	string name = this.ReadString (reader);  	int n = reader.ReadUInt16 ();  	var c = new List<int> ();  	for (int i = 0; i < n; i++) {  		c.Add (reader.ReadUInt16 ());  	}  	var fm = new FaceSet {  		Name = name'  		Faces = c  	};  	list.Add (fm);  	break;  }  case ChunkID.TRI_SMOOTH: {  	this.ReadData (reader' size - 6);  	break;  }  default: {  	this.ReadData (reader' size - 6);  	break;  }  }  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: this.ReadData (reader' size - 6);  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: this.ReadData (reader' size - 6);  
Magic Number,HelixToolkit.Wpf.SharpDX,StudioReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\StudioReader.cs,ReadMatMap,The following statement contains a magic number: size -= 14;  
Magic Number,HelixToolkit.Wpf.SharpDX,OrthographicCamera,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Camera\OrthographicCamera.cs,OrthographicCamera,The following statement contains a magic number: NearPlaneDistance = -10.0;  
Magic Number,HelixToolkit.Wpf.SharpDX,OrthographicCamera,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Camera\OrthographicCamera.cs,OrthographicCamera,The following statement contains a magic number: FarPlaneDistance = 100.0;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (g.Octree != null) {  	isHit = g.Octree.HitTest (context' this' ModelMatrix' rayWS' ref hits);  } else {  	var result = new HitTestResult ();  	result.Distance = double.MaxValue;  	if (g != null) {  		var m = this.modelMatrix;  		// put bounds to world space  		var b = BoundingBox.FromPoints (this.Bounds.GetCorners ().Select (x => Vector3.TransformCoordinate (x' m)).ToArray ());  		//var b = this.Bounds;  		// this all happens now in world space now:  		if (rayWS.Intersects (ref b)) {  			int index = 0;  			foreach (var t in g.Triangles) {  				float d;  				var p0 = Vector3.TransformCoordinate (t.P0' m);  				var p1 = Vector3.TransformCoordinate (t.P1' m);  				var p2 = Vector3.TransformCoordinate (t.P2' m);  				if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  					if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.  					 {  						result.IsValid = true;  						result.ModelHit = this;  						// transform hit-info to world space now:  						result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  						result.Distance = d;  						var n = Vector3.Cross (p1 - p0' p2 - p0);  						n.Normalize ();  						// transform hit-info to world space now:  						result.NormalAtHit = n.ToVector3D ();  						// Vector3.TransformNormal(n' m).ToVector3D();  						result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  						result.Tag = index / 3;  						isHit = true;  					}  				}  				index += 3;  			}  		}  	}  	if (isHit) {  		hits.Add (result);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (g.Octree != null) {  	isHit = g.Octree.HitTest (context' this' ModelMatrix' rayWS' ref hits);  } else {  	var result = new HitTestResult ();  	result.Distance = double.MaxValue;  	if (g != null) {  		var m = this.modelMatrix;  		// put bounds to world space  		var b = BoundingBox.FromPoints (this.Bounds.GetCorners ().Select (x => Vector3.TransformCoordinate (x' m)).ToArray ());  		//var b = this.Bounds;  		// this all happens now in world space now:  		if (rayWS.Intersects (ref b)) {  			int index = 0;  			foreach (var t in g.Triangles) {  				float d;  				var p0 = Vector3.TransformCoordinate (t.P0' m);  				var p1 = Vector3.TransformCoordinate (t.P1' m);  				var p2 = Vector3.TransformCoordinate (t.P2' m);  				if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  					if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.  					 {  						result.IsValid = true;  						result.ModelHit = this;  						// transform hit-info to world space now:  						result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  						result.Distance = d;  						var n = Vector3.Cross (p1 - p0' p2 - p0);  						n.Normalize ();  						// transform hit-info to world space now:  						result.NormalAtHit = n.ToVector3D ();  						// Vector3.TransformNormal(n' m).ToVector3D();  						result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  						result.Tag = index / 3;  						isHit = true;  					}  				}  				index += 3;  			}  		}  	}  	if (isHit) {  		hits.Add (result);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (g.Octree != null) {  	isHit = g.Octree.HitTest (context' this' ModelMatrix' rayWS' ref hits);  } else {  	var result = new HitTestResult ();  	result.Distance = double.MaxValue;  	if (g != null) {  		var m = this.modelMatrix;  		// put bounds to world space  		var b = BoundingBox.FromPoints (this.Bounds.GetCorners ().Select (x => Vector3.TransformCoordinate (x' m)).ToArray ());  		//var b = this.Bounds;  		// this all happens now in world space now:  		if (rayWS.Intersects (ref b)) {  			int index = 0;  			foreach (var t in g.Triangles) {  				float d;  				var p0 = Vector3.TransformCoordinate (t.P0' m);  				var p1 = Vector3.TransformCoordinate (t.P1' m);  				var p2 = Vector3.TransformCoordinate (t.P2' m);  				if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  					if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.  					 {  						result.IsValid = true;  						result.ModelHit = this;  						// transform hit-info to world space now:  						result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  						result.Distance = d;  						var n = Vector3.Cross (p1 - p0' p2 - p0);  						n.Normalize ();  						// transform hit-info to world space now:  						result.NormalAtHit = n.ToVector3D ();  						// Vector3.TransformNormal(n' m).ToVector3D();  						result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  						result.Tag = index / 3;  						isHit = true;  					}  				}  				index += 3;  			}  		}  	}  	if (isHit) {  		hits.Add (result);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null) {  	var m = this.modelMatrix;  	// put bounds to world space  	var b = BoundingBox.FromPoints (this.Bounds.GetCorners ().Select (x => Vector3.TransformCoordinate (x' m)).ToArray ());  	//var b = this.Bounds;  	// this all happens now in world space now:  	if (rayWS.Intersects (ref b)) {  		int index = 0;  		foreach (var t in g.Triangles) {  			float d;  			var p0 = Vector3.TransformCoordinate (t.P0' m);  			var p1 = Vector3.TransformCoordinate (t.P1' m);  			var p2 = Vector3.TransformCoordinate (t.P2' m);  			if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  				if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.  				 {  					result.IsValid = true;  					result.ModelHit = this;  					// transform hit-info to world space now:  					result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  					result.Distance = d;  					var n = Vector3.Cross (p1 - p0' p2 - p0);  					n.Normalize ();  					// transform hit-info to world space now:  					result.NormalAtHit = n.ToVector3D ();  					// Vector3.TransformNormal(n' m).ToVector3D();  					result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  					result.Tag = index / 3;  					isHit = true;  				}  			}  			index += 3;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null) {  	var m = this.modelMatrix;  	// put bounds to world space  	var b = BoundingBox.FromPoints (this.Bounds.GetCorners ().Select (x => Vector3.TransformCoordinate (x' m)).ToArray ());  	//var b = this.Bounds;  	// this all happens now in world space now:  	if (rayWS.Intersects (ref b)) {  		int index = 0;  		foreach (var t in g.Triangles) {  			float d;  			var p0 = Vector3.TransformCoordinate (t.P0' m);  			var p1 = Vector3.TransformCoordinate (t.P1' m);  			var p2 = Vector3.TransformCoordinate (t.P2' m);  			if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  				if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.  				 {  					result.IsValid = true;  					result.ModelHit = this;  					// transform hit-info to world space now:  					result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  					result.Distance = d;  					var n = Vector3.Cross (p1 - p0' p2 - p0);  					n.Normalize ();  					// transform hit-info to world space now:  					result.NormalAtHit = n.ToVector3D ();  					// Vector3.TransformNormal(n' m).ToVector3D();  					result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  					result.Tag = index / 3;  					isHit = true;  				}  			}  			index += 3;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (g != null) {  	var m = this.modelMatrix;  	// put bounds to world space  	var b = BoundingBox.FromPoints (this.Bounds.GetCorners ().Select (x => Vector3.TransformCoordinate (x' m)).ToArray ());  	//var b = this.Bounds;  	// this all happens now in world space now:  	if (rayWS.Intersects (ref b)) {  		int index = 0;  		foreach (var t in g.Triangles) {  			float d;  			var p0 = Vector3.TransformCoordinate (t.P0' m);  			var p1 = Vector3.TransformCoordinate (t.P1' m);  			var p2 = Vector3.TransformCoordinate (t.P2' m);  			if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  				if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.  				 {  					result.IsValid = true;  					result.ModelHit = this;  					// transform hit-info to world space now:  					result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  					result.Distance = d;  					var n = Vector3.Cross (p1 - p0' p2 - p0);  					n.Normalize ();  					// transform hit-info to world space now:  					result.NormalAtHit = n.ToVector3D ();  					// Vector3.TransformNormal(n' m).ToVector3D();  					result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  					result.Tag = index / 3;  					isHit = true;  				}  			}  			index += 3;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (rayWS.Intersects (ref b)) {  	int index = 0;  	foreach (var t in g.Triangles) {  		float d;  		var p0 = Vector3.TransformCoordinate (t.P0' m);  		var p1 = Vector3.TransformCoordinate (t.P1' m);  		var p2 = Vector3.TransformCoordinate (t.P2' m);  		if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  			if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.  			 {  				result.IsValid = true;  				result.ModelHit = this;  				// transform hit-info to world space now:  				result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  				result.Distance = d;  				var n = Vector3.Cross (p1 - p0' p2 - p0);  				n.Normalize ();  				// transform hit-info to world space now:  				result.NormalAtHit = n.ToVector3D ();  				// Vector3.TransformNormal(n' m).ToVector3D();  				result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  				result.Tag = index / 3;  				isHit = true;  			}  		}  		index += 3;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (rayWS.Intersects (ref b)) {  	int index = 0;  	foreach (var t in g.Triangles) {  		float d;  		var p0 = Vector3.TransformCoordinate (t.P0' m);  		var p1 = Vector3.TransformCoordinate (t.P1' m);  		var p2 = Vector3.TransformCoordinate (t.P2' m);  		if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  			if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.  			 {  				result.IsValid = true;  				result.ModelHit = this;  				// transform hit-info to world space now:  				result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  				result.Distance = d;  				var n = Vector3.Cross (p1 - p0' p2 - p0);  				n.Normalize ();  				// transform hit-info to world space now:  				result.NormalAtHit = n.ToVector3D ();  				// Vector3.TransformNormal(n' m).ToVector3D();  				result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  				result.Tag = index / 3;  				isHit = true;  			}  		}  		index += 3;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (rayWS.Intersects (ref b)) {  	int index = 0;  	foreach (var t in g.Triangles) {  		float d;  		var p0 = Vector3.TransformCoordinate (t.P0' m);  		var p1 = Vector3.TransformCoordinate (t.P1' m);  		var p2 = Vector3.TransformCoordinate (t.P2' m);  		if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  			if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.  			 {  				result.IsValid = true;  				result.ModelHit = this;  				// transform hit-info to world space now:  				result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  				result.Distance = d;  				var n = Vector3.Cross (p1 - p0' p2 - p0);  				n.Normalize ();  				// transform hit-info to world space now:  				result.NormalAtHit = n.ToVector3D ();  				// Vector3.TransformNormal(n' m).ToVector3D();  				result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  				result.Tag = index / 3;  				isHit = true;  			}  		}  		index += 3;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: foreach (var t in g.Triangles) {  	float d;  	var p0 = Vector3.TransformCoordinate (t.P0' m);  	var p1 = Vector3.TransformCoordinate (t.P1' m);  	var p2 = Vector3.TransformCoordinate (t.P2' m);  	if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  		if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.  		 {  			result.IsValid = true;  			result.ModelHit = this;  			// transform hit-info to world space now:  			result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  			result.Distance = d;  			var n = Vector3.Cross (p1 - p0' p2 - p0);  			n.Normalize ();  			// transform hit-info to world space now:  			result.NormalAtHit = n.ToVector3D ();  			// Vector3.TransformNormal(n' m).ToVector3D();  			result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  			result.Tag = index / 3;  			isHit = true;  		}  	}  	index += 3;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: foreach (var t in g.Triangles) {  	float d;  	var p0 = Vector3.TransformCoordinate (t.P0' m);  	var p1 = Vector3.TransformCoordinate (t.P1' m);  	var p2 = Vector3.TransformCoordinate (t.P2' m);  	if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  		if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.  		 {  			result.IsValid = true;  			result.ModelHit = this;  			// transform hit-info to world space now:  			result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  			result.Distance = d;  			var n = Vector3.Cross (p1 - p0' p2 - p0);  			n.Normalize ();  			// transform hit-info to world space now:  			result.NormalAtHit = n.ToVector3D ();  			// Vector3.TransformNormal(n' m).ToVector3D();  			result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  			result.Tag = index / 3;  			isHit = true;  		}  	}  	index += 3;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: foreach (var t in g.Triangles) {  	float d;  	var p0 = Vector3.TransformCoordinate (t.P0' m);  	var p1 = Vector3.TransformCoordinate (t.P1' m);  	var p2 = Vector3.TransformCoordinate (t.P2' m);  	if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  		if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.  		 {  			result.IsValid = true;  			result.ModelHit = this;  			// transform hit-info to world space now:  			result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  			result.Distance = d;  			var n = Vector3.Cross (p1 - p0' p2 - p0);  			n.Normalize ();  			// transform hit-info to world space now:  			result.NormalAtHit = n.ToVector3D ();  			// Vector3.TransformNormal(n' m).ToVector3D();  			result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  			result.Tag = index / 3;  			isHit = true;  		}  	}  	index += 3;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  	if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.  	 {  		result.IsValid = true;  		result.ModelHit = this;  		// transform hit-info to world space now:  		result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  		result.Distance = d;  		var n = Vector3.Cross (p1 - p0' p2 - p0);  		n.Normalize ();  		// transform hit-info to world space now:  		result.NormalAtHit = n.ToVector3D ();  		// Vector3.TransformNormal(n' m).ToVector3D();  		result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  		result.Tag = index / 3;  		isHit = true;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (Collision.RayIntersectsTriangle (ref rayWS' ref p0' ref p1' ref p2' out d)) {  	if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.  	 {  		result.IsValid = true;  		result.ModelHit = this;  		// transform hit-info to world space now:  		result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  		result.Distance = d;  		var n = Vector3.Cross (p1 - p0' p2 - p0);  		n.Normalize ();  		// transform hit-info to world space now:  		result.NormalAtHit = n.ToVector3D ();  		// Vector3.TransformNormal(n' m).ToVector3D();  		result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  		result.Tag = index / 3;  		isHit = true;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.   {  	result.IsValid = true;  	result.ModelHit = this;  	// transform hit-info to world space now:  	result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  	result.Distance = d;  	var n = Vector3.Cross (p1 - p0' p2 - p0);  	n.Normalize ();  	// transform hit-info to world space now:  	result.NormalAtHit = n.ToVector3D ();  	// Vector3.TransformNormal(n' m).ToVector3D();  	result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  	result.Tag = index / 3;  	isHit = true;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: if (d > 0 && d < result.Distance)// If d is NaN' the condition is false.   {  	result.IsValid = true;  	result.ModelHit = this;  	// transform hit-info to world space now:  	result.PointHit = (rayWS.Position + (rayWS.Direction * d)).ToPoint3D ();  	result.Distance = d;  	var n = Vector3.Cross (p1 - p0' p2 - p0);  	n.Normalize ();  	// transform hit-info to world space now:  	result.NormalAtHit = n.ToVector3D ();  	// Vector3.TransformNormal(n' m).ToVector3D();  	result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  	result.Tag = index / 3;  	isHit = true;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: result.TriangleIndices = new System.Tuple<int' int' int> (g.Indices [index]' g.Indices [index + 1]' g.Indices [index + 2]);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: result.Tag = index / 3;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\MeshGeometryModel3D.cs,OnHitTest,The following statement contains a magic number: index += 3;  
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,UICompositeManipulator3D,The following statement contains a magic number: this.rotateX = new UIRotateManipulator3D {  	Axis = new Vector3 (1' 0' 0)'  	Length = 0.05'  	Material = PhongMaterials.Red'  };  
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,UICompositeManipulator3D,The following statement contains a magic number: this.rotateY = new UIRotateManipulator3D {  	Axis = new Vector3 (0' 1' 0)'  	Length = 0.05'  	Material = PhongMaterials.Green  };  
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,UICompositeManipulator3D,The following statement contains a magic number: this.rotateZ = new UIRotateManipulator3D {  	Axis = new Vector3 (0' 0' 1)'  	Length = 0.05'  	Material = PhongMaterials.Blue  };  
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,OnChildrenChanged,The following statement contains a magic number: rotateY.InnerDiameter += 0.01;  
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,OnChildrenChanged,The following statement contains a magic number: rotateZ.InnerDiameter += 0.02;  
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,OnChildrenChanged,The following statement contains a magic number: rotateX.OuterDiameter = rotateX.InnerDiameter + 0.25;  
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,OnChildrenChanged,The following statement contains a magic number: rotateY.OuterDiameter = rotateY.InnerDiameter + 0.25;  
Magic Number,HelixToolkit.Wpf.SharpDX,UICompositeManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UICompositeManipulator3D.cs,OnChildrenChanged,The following statement contains a magic number: rotateZ.OuterDiameter = rotateZ.InnerDiameter + 0.25;  
Magic Number,HelixToolkit.Wpf.SharpDX,UIRotateManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UIRotateManipulator3D.cs,OnModelChanged,The following statement contains a magic number: if (this.InnerDiameter >= this.OuterDiameter)  	this.OuterDiameter = this.InnerDiameter + 0.3;  
Magic Number,HelixToolkit.Wpf.SharpDX,UIRotateManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UIRotateManipulator3D.cs,OnModelChanged,The following statement contains a magic number: this.OuterDiameter = this.InnerDiameter + 0.3;  
Magic Number,HelixToolkit.Wpf.SharpDX,UIRotateManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UIRotateManipulator3D.cs,OnModelChanged,The following statement contains a magic number: mb.AddPipe (p1' p2' this.InnerDiameter' this.OuterDiameter' 64);  
Magic Number,HelixToolkit.Wpf.SharpDX,UIRotateManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UIRotateManipulator3D.cs,UpdateManipulator,The following statement contains a magic number: if (newHit.HasValue) {  	var newHitPos = newHit.Value;  	var v = this.lastHitPosWS - position;  	var u = newHitPos - position;  	v.Normalize ();  	u.Normalize ();  	var currentAxis = Vector3.Cross (u' v);  	var mainAxis = ToWorldVec (this.Axis);  	// this.Transform.Transform(this.Axis.ToVector3D()).ToVector3();  	double sign = -Vector3.Dot (mainAxis' currentAxis);  	double theta = Math.Sign (sign) * Math.Asin (currentAxis.Length ()) / Math.PI * 180;  	this.Value += theta;  	var rotateTransform = new System.Windows.Media.Media3D.RotateTransform3D (new System.Windows.Media.Media3D.AxisAngleRotation3D (this.Axis.ToVector3D ()' theta)' Pivot.ToPoint3D ());  	// rotate target  	if (this.TargetTransform != null) {  		this.TargetTransform = rotateTransform.AppendTransform (this.TargetTransform);  	} else {  		this.Transform = rotateTransform.AppendTransform (this.Transform);  	}  	this.lastHitPosWS = newHitPos;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,UITranslateManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UITranslateManipulator3D.cs,OnModelChanged,The following statement contains a magic number: mb.AddArrow (p0' p1' this.Diameter' 2' 64);  
Magic Number,HelixToolkit.Wpf.SharpDX,UITranslateManipulator3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\UITranslateManipulator3D.cs,OnModelChanged,The following statement contains a magic number: mb.AddArrow (p0' p1' this.Diameter' 2' 64);  
Magic Number,HelixToolkit.Wpf.SharpDX,ShadowMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The following statement contains a magic number: foreach (var item in root) {  	var light = item as Light3D;  	if (light != null) {  		Camera lightCamera = null;  		//if (light is PointLightBase3D)  		//{  		//    var plight = (PointLightBase3D)light;  		//    lightCamera = new PerspectiveCamera()  		//    {  		//        Position = plight.Position'  		//        LookDirection = plight.Direction'  		//        UpDirection = Vector3.UnitY.ToVector3D()'  		//    };                          		//}  		// else   		if (light is DirectionalLight3D) {  			var dlight = (DirectionalLight3D)light;  			var dir = light.DirectionInternal.Normalized ();  			var pos = -50 * light.DirectionInternal;  			//lightCamera = new PerspectiveCamera()  			//{  			//    LookDirection = dir.ToVector3D()'  			//    Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'  			//    UpDirection = Vector3.UnitZ.ToVector3D()'                              			//    NearPlaneDistance = 1'  			//    FarPlaneDistance = 100'  			//    FieldOfView = 10'  			//};  			lightCamera = new OrthographicCamera () {  				LookDirection = dir.ToVector3D ()'  				Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D ())'  				UpDirection = Vector3.UnitZ.ToVector3D ()'  				Width = 100'  				NearPlaneDistance = 1'  				FarPlaneDistance = 500'  			};  		}  		if (lightCamera != null) {  			var sceneCamera = context.Camera;  			light.LightViewMatrix = CameraExtensions.GetViewMatrix (lightCamera);  			light.LightProjectionMatrix = CameraExtensions.GetProjectionMatrix (lightCamera' context.Canvas.ActualWidth / context.Canvas.ActualHeight);  			this.shadowPassContext.IsShadowPass = true;  			this.shadowPassContext.Camera = lightCamera;  			foreach (var e in root) {  				var smodel = e as IThrowingShadow;  				if (smodel != null) {  					if (smodel.IsThrowingShadow) {  						var model = smodel as IRenderable;  						model.Render (this.shadowPassContext);  					}  				}  			}  			context.Camera = sceneCamera;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ShadowMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The following statement contains a magic number: foreach (var item in root) {  	var light = item as Light3D;  	if (light != null) {  		Camera lightCamera = null;  		//if (light is PointLightBase3D)  		//{  		//    var plight = (PointLightBase3D)light;  		//    lightCamera = new PerspectiveCamera()  		//    {  		//        Position = plight.Position'  		//        LookDirection = plight.Direction'  		//        UpDirection = Vector3.UnitY.ToVector3D()'  		//    };                          		//}  		// else   		if (light is DirectionalLight3D) {  			var dlight = (DirectionalLight3D)light;  			var dir = light.DirectionInternal.Normalized ();  			var pos = -50 * light.DirectionInternal;  			//lightCamera = new PerspectiveCamera()  			//{  			//    LookDirection = dir.ToVector3D()'  			//    Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'  			//    UpDirection = Vector3.UnitZ.ToVector3D()'                              			//    NearPlaneDistance = 1'  			//    FarPlaneDistance = 100'  			//    FieldOfView = 10'  			//};  			lightCamera = new OrthographicCamera () {  				LookDirection = dir.ToVector3D ()'  				Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D ())'  				UpDirection = Vector3.UnitZ.ToVector3D ()'  				Width = 100'  				NearPlaneDistance = 1'  				FarPlaneDistance = 500'  			};  		}  		if (lightCamera != null) {  			var sceneCamera = context.Camera;  			light.LightViewMatrix = CameraExtensions.GetViewMatrix (lightCamera);  			light.LightProjectionMatrix = CameraExtensions.GetProjectionMatrix (lightCamera' context.Canvas.ActualWidth / context.Canvas.ActualHeight);  			this.shadowPassContext.IsShadowPass = true;  			this.shadowPassContext.Camera = lightCamera;  			foreach (var e in root) {  				var smodel = e as IThrowingShadow;  				if (smodel != null) {  					if (smodel.IsThrowingShadow) {  						var model = smodel as IRenderable;  						model.Render (this.shadowPassContext);  					}  				}  			}  			context.Camera = sceneCamera;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ShadowMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The following statement contains a magic number: foreach (var item in root) {  	var light = item as Light3D;  	if (light != null) {  		Camera lightCamera = null;  		//if (light is PointLightBase3D)  		//{  		//    var plight = (PointLightBase3D)light;  		//    lightCamera = new PerspectiveCamera()  		//    {  		//        Position = plight.Position'  		//        LookDirection = plight.Direction'  		//        UpDirection = Vector3.UnitY.ToVector3D()'  		//    };                          		//}  		// else   		if (light is DirectionalLight3D) {  			var dlight = (DirectionalLight3D)light;  			var dir = light.DirectionInternal.Normalized ();  			var pos = -50 * light.DirectionInternal;  			//lightCamera = new PerspectiveCamera()  			//{  			//    LookDirection = dir.ToVector3D()'  			//    Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'  			//    UpDirection = Vector3.UnitZ.ToVector3D()'                              			//    NearPlaneDistance = 1'  			//    FarPlaneDistance = 100'  			//    FieldOfView = 10'  			//};  			lightCamera = new OrthographicCamera () {  				LookDirection = dir.ToVector3D ()'  				Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D ())'  				UpDirection = Vector3.UnitZ.ToVector3D ()'  				Width = 100'  				NearPlaneDistance = 1'  				FarPlaneDistance = 500'  			};  		}  		if (lightCamera != null) {  			var sceneCamera = context.Camera;  			light.LightViewMatrix = CameraExtensions.GetViewMatrix (lightCamera);  			light.LightProjectionMatrix = CameraExtensions.GetProjectionMatrix (lightCamera' context.Canvas.ActualWidth / context.Canvas.ActualHeight);  			this.shadowPassContext.IsShadowPass = true;  			this.shadowPassContext.Camera = lightCamera;  			foreach (var e in root) {  				var smodel = e as IThrowingShadow;  				if (smodel != null) {  					if (smodel.IsThrowingShadow) {  						var model = smodel as IRenderable;  						model.Render (this.shadowPassContext);  					}  				}  			}  			context.Camera = sceneCamera;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ShadowMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The following statement contains a magic number: if (light != null) {  	Camera lightCamera = null;  	//if (light is PointLightBase3D)  	//{  	//    var plight = (PointLightBase3D)light;  	//    lightCamera = new PerspectiveCamera()  	//    {  	//        Position = plight.Position'  	//        LookDirection = plight.Direction'  	//        UpDirection = Vector3.UnitY.ToVector3D()'  	//    };                          	//}  	// else   	if (light is DirectionalLight3D) {  		var dlight = (DirectionalLight3D)light;  		var dir = light.DirectionInternal.Normalized ();  		var pos = -50 * light.DirectionInternal;  		//lightCamera = new PerspectiveCamera()  		//{  		//    LookDirection = dir.ToVector3D()'  		//    Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'  		//    UpDirection = Vector3.UnitZ.ToVector3D()'                              		//    NearPlaneDistance = 1'  		//    FarPlaneDistance = 100'  		//    FieldOfView = 10'  		//};  		lightCamera = new OrthographicCamera () {  			LookDirection = dir.ToVector3D ()'  			Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D ())'  			UpDirection = Vector3.UnitZ.ToVector3D ()'  			Width = 100'  			NearPlaneDistance = 1'  			FarPlaneDistance = 500'  		};  	}  	if (lightCamera != null) {  		var sceneCamera = context.Camera;  		light.LightViewMatrix = CameraExtensions.GetViewMatrix (lightCamera);  		light.LightProjectionMatrix = CameraExtensions.GetProjectionMatrix (lightCamera' context.Canvas.ActualWidth / context.Canvas.ActualHeight);  		this.shadowPassContext.IsShadowPass = true;  		this.shadowPassContext.Camera = lightCamera;  		foreach (var e in root) {  			var smodel = e as IThrowingShadow;  			if (smodel != null) {  				if (smodel.IsThrowingShadow) {  					var model = smodel as IRenderable;  					model.Render (this.shadowPassContext);  				}  			}  		}  		context.Camera = sceneCamera;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ShadowMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The following statement contains a magic number: if (light != null) {  	Camera lightCamera = null;  	//if (light is PointLightBase3D)  	//{  	//    var plight = (PointLightBase3D)light;  	//    lightCamera = new PerspectiveCamera()  	//    {  	//        Position = plight.Position'  	//        LookDirection = plight.Direction'  	//        UpDirection = Vector3.UnitY.ToVector3D()'  	//    };                          	//}  	// else   	if (light is DirectionalLight3D) {  		var dlight = (DirectionalLight3D)light;  		var dir = light.DirectionInternal.Normalized ();  		var pos = -50 * light.DirectionInternal;  		//lightCamera = new PerspectiveCamera()  		//{  		//    LookDirection = dir.ToVector3D()'  		//    Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'  		//    UpDirection = Vector3.UnitZ.ToVector3D()'                              		//    NearPlaneDistance = 1'  		//    FarPlaneDistance = 100'  		//    FieldOfView = 10'  		//};  		lightCamera = new OrthographicCamera () {  			LookDirection = dir.ToVector3D ()'  			Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D ())'  			UpDirection = Vector3.UnitZ.ToVector3D ()'  			Width = 100'  			NearPlaneDistance = 1'  			FarPlaneDistance = 500'  		};  	}  	if (lightCamera != null) {  		var sceneCamera = context.Camera;  		light.LightViewMatrix = CameraExtensions.GetViewMatrix (lightCamera);  		light.LightProjectionMatrix = CameraExtensions.GetProjectionMatrix (lightCamera' context.Canvas.ActualWidth / context.Canvas.ActualHeight);  		this.shadowPassContext.IsShadowPass = true;  		this.shadowPassContext.Camera = lightCamera;  		foreach (var e in root) {  			var smodel = e as IThrowingShadow;  			if (smodel != null) {  				if (smodel.IsThrowingShadow) {  					var model = smodel as IRenderable;  					model.Render (this.shadowPassContext);  				}  			}  		}  		context.Camera = sceneCamera;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ShadowMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The following statement contains a magic number: if (light != null) {  	Camera lightCamera = null;  	//if (light is PointLightBase3D)  	//{  	//    var plight = (PointLightBase3D)light;  	//    lightCamera = new PerspectiveCamera()  	//    {  	//        Position = plight.Position'  	//        LookDirection = plight.Direction'  	//        UpDirection = Vector3.UnitY.ToVector3D()'  	//    };                          	//}  	// else   	if (light is DirectionalLight3D) {  		var dlight = (DirectionalLight3D)light;  		var dir = light.DirectionInternal.Normalized ();  		var pos = -50 * light.DirectionInternal;  		//lightCamera = new PerspectiveCamera()  		//{  		//    LookDirection = dir.ToVector3D()'  		//    Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'  		//    UpDirection = Vector3.UnitZ.ToVector3D()'                              		//    NearPlaneDistance = 1'  		//    FarPlaneDistance = 100'  		//    FieldOfView = 10'  		//};  		lightCamera = new OrthographicCamera () {  			LookDirection = dir.ToVector3D ()'  			Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D ())'  			UpDirection = Vector3.UnitZ.ToVector3D ()'  			Width = 100'  			NearPlaneDistance = 1'  			FarPlaneDistance = 500'  		};  	}  	if (lightCamera != null) {  		var sceneCamera = context.Camera;  		light.LightViewMatrix = CameraExtensions.GetViewMatrix (lightCamera);  		light.LightProjectionMatrix = CameraExtensions.GetProjectionMatrix (lightCamera' context.Canvas.ActualWidth / context.Canvas.ActualHeight);  		this.shadowPassContext.IsShadowPass = true;  		this.shadowPassContext.Camera = lightCamera;  		foreach (var e in root) {  			var smodel = e as IThrowingShadow;  			if (smodel != null) {  				if (smodel.IsThrowingShadow) {  					var model = smodel as IRenderable;  					model.Render (this.shadowPassContext);  				}  			}  		}  		context.Camera = sceneCamera;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ShadowMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The following statement contains a magic number: if (light is DirectionalLight3D) {  	var dlight = (DirectionalLight3D)light;  	var dir = light.DirectionInternal.Normalized ();  	var pos = -50 * light.DirectionInternal;  	//lightCamera = new PerspectiveCamera()  	//{  	//    LookDirection = dir.ToVector3D()'  	//    Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'  	//    UpDirection = Vector3.UnitZ.ToVector3D()'                              	//    NearPlaneDistance = 1'  	//    FarPlaneDistance = 100'  	//    FieldOfView = 10'  	//};  	lightCamera = new OrthographicCamera () {  		LookDirection = dir.ToVector3D ()'  		Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D ())'  		UpDirection = Vector3.UnitZ.ToVector3D ()'  		Width = 100'  		NearPlaneDistance = 1'  		FarPlaneDistance = 500'  	};  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ShadowMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The following statement contains a magic number: if (light is DirectionalLight3D) {  	var dlight = (DirectionalLight3D)light;  	var dir = light.DirectionInternal.Normalized ();  	var pos = -50 * light.DirectionInternal;  	//lightCamera = new PerspectiveCamera()  	//{  	//    LookDirection = dir.ToVector3D()'  	//    Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'  	//    UpDirection = Vector3.UnitZ.ToVector3D()'                              	//    NearPlaneDistance = 1'  	//    FarPlaneDistance = 100'  	//    FieldOfView = 10'  	//};  	lightCamera = new OrthographicCamera () {  		LookDirection = dir.ToVector3D ()'  		Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D ())'  		UpDirection = Vector3.UnitZ.ToVector3D ()'  		Width = 100'  		NearPlaneDistance = 1'  		FarPlaneDistance = 500'  	};  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ShadowMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The following statement contains a magic number: if (light is DirectionalLight3D) {  	var dlight = (DirectionalLight3D)light;  	var dir = light.DirectionInternal.Normalized ();  	var pos = -50 * light.DirectionInternal;  	//lightCamera = new PerspectiveCamera()  	//{  	//    LookDirection = dir.ToVector3D()'  	//    Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D())'  	//    UpDirection = Vector3.UnitZ.ToVector3D()'                              	//    NearPlaneDistance = 1'  	//    FarPlaneDistance = 100'  	//    FieldOfView = 10'  	//};  	lightCamera = new OrthographicCamera () {  		LookDirection = dir.ToVector3D ()'  		Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D ())'  		UpDirection = Vector3.UnitZ.ToVector3D ()'  		Width = 100'  		NearPlaneDistance = 1'  		FarPlaneDistance = 500'  	};  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ShadowMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The following statement contains a magic number: lightCamera = new OrthographicCamera () {  	LookDirection = dir.ToVector3D ()'  	Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D ())'  	UpDirection = Vector3.UnitZ.ToVector3D ()'  	Width = 100'  	NearPlaneDistance = 1'  	FarPlaneDistance = 500'  };  
Magic Number,HelixToolkit.Wpf.SharpDX,ShadowMap3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\ShadowMap3D.cs,OnRender,The following statement contains a magic number: lightCamera = new OrthographicCamera () {  	LookDirection = dir.ToVector3D ()'  	Position = (System.Windows.Media.Media3D.Point3D)(pos.ToVector3D ())'  	UpDirection = Vector3.UnitZ.ToVector3D ()'  	Width = 100'  	NearPlaneDistance = 1'  	FarPlaneDistance = 500'  };  
Magic Number,HelixToolkit.Wpf.SharpDX,SpotLight3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\SpotLight3D.cs,OnRender,The following statement contains a magic number: Light3DSceneShared.LightSpots [lightIndex] = new Vector4 ((float)Math.Cos (this.OuterAngleInternal / 360.0 * Math.PI)' (float)Math.Cos (this.InnerAngleInternal / 360.0 * Math.PI)' (float)this.FalloffInternal' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,SpotLight3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Lights3D\SpotLight3D.cs,OnRender,The following statement contains a magic number: Light3DSceneShared.LightSpots [lightIndex] = new Vector4 ((float)Math.Cos (this.OuterAngleInternal / 360.0 * Math.PI)' (float)Math.Cos (this.InnerAngleInternal / 360.0 * Math.PI)' (float)this.FalloffInternal' 0);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange (new[] {  	i0 + 0'  	i0 + 4'  	i0 + 1'  	i0 + 5'  	i0 + 2'  	i0 + 6'  	i0 + 3'  	i0 + 7  });  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange (new[] {  	i0 + 0'  	i0 + 4'  	i0 + 1'  	i0 + 5'  	i0 + 2'  	i0 + 6'  	i0 + 3'  	i0 + 7  });  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange (new[] {  	i0 + 0'  	i0 + 4'  	i0 + 1'  	i0 + 5'  	i0 + 2'  	i0 + 6'  	i0 + 3'  	i0 + 7  });  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange (new[] {  	i0 + 0'  	i0 + 4'  	i0 + 1'  	i0 + 5'  	i0 + 2'  	i0 + 6'  	i0 + 3'  	i0 + 7  });  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange (new[] {  	i0 + 0'  	i0 + 4'  	i0 + 1'  	i0 + 5'  	i0 + 2'  	i0 + 6'  	i0 + 3'  	i0 + 7  });  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange (new[] {  	i0 + 0'  	i0 + 4'  	i0 + 1'  	i0 + 5'  	i0 + 2'  	i0 + 6'  	i0 + 3'  	i0 + 7  });  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddGrid,The following statement contains a magic number: if (columns < 2 || rows < 2) {  	throw new ArgumentNullException ("columns or rows too small");  }  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,AddGrid,The following statement contains a magic number: if (columns < 2 || rows < 2) {  	throw new ArgumentNullException ("columns or rows too small");  }  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [1]' cc [2]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [2]' cc [3]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [2]' cc [3]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [3]' cc [0]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [4]' cc [5]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [4]' cc [5]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [5]' cc [6]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [5]' cc [6]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [6]' cc [7]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [6]' cc [7]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [7]' cc [4]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [7]' cc [4]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [0]' cc [4]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [1]' cc [5]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [2]' cc [6]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [2]' cc [6]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [3]' cc [7]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine (cc [3]' cc [7]);  
Magic Number,HelixToolkit.Wpf.SharpDX,LineBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\LineBuilder.cs,GenerateCircle,The following statement contains a magic number: if (segments < 3) {  	throw new ArgumentNullException ("too few segments' at least 3");  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMesh,The following statement contains a magic number: if (m.Indices != null) {  	for (int i = 0; i < m.Indices.Count; i += 3) {  		int i0 = m.Indices [i];  		int i1 = m.Indices [i + 1];  		int i2 = m.Indices [i + 2];  		this.writer.WriteLine ("f {0} {1} {2}"' formatIndices (i0)' formatIndices (i1)' formatIndices (i2));  	}  	this.writer.WriteLine (string.Format ("# {0} faces"' m.Indices.Count / 3));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMesh,The following statement contains a magic number: if (m.Indices != null) {  	for (int i = 0; i < m.Indices.Count; i += 3) {  		int i0 = m.Indices [i];  		int i1 = m.Indices [i + 1];  		int i2 = m.Indices [i + 2];  		this.writer.WriteLine ("f {0} {1} {2}"' formatIndices (i0)' formatIndices (i1)' formatIndices (i2));  	}  	this.writer.WriteLine (string.Format ("# {0} faces"' m.Indices.Count / 3));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMesh,The following statement contains a magic number: if (m.Indices != null) {  	for (int i = 0; i < m.Indices.Count; i += 3) {  		int i0 = m.Indices [i];  		int i1 = m.Indices [i + 1];  		int i2 = m.Indices [i + 2];  		this.writer.WriteLine ("f {0} {1} {2}"' formatIndices (i0)' formatIndices (i1)' formatIndices (i2));  	}  	this.writer.WriteLine (string.Format ("# {0} faces"' m.Indices.Count / 3));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMesh,The following statement contains a magic number: for (int i = 0; i < m.Indices.Count; i += 3) {  	int i0 = m.Indices [i];  	int i1 = m.Indices [i + 1];  	int i2 = m.Indices [i + 2];  	this.writer.WriteLine ("f {0} {1} {2}"' formatIndices (i0)' formatIndices (i1)' formatIndices (i2));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMesh,The following statement contains a magic number: for (int i = 0; i < m.Indices.Count; i += 3) {  	int i0 = m.Indices [i];  	int i1 = m.Indices [i + 1];  	int i2 = m.Indices [i + 2];  	this.writer.WriteLine ("f {0} {1} {2}"' formatIndices (i0)' formatIndices (i1)' formatIndices (i2));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMesh,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ExportMesh,The following statement contains a magic number: this.writer.WriteLine (string.Format ("# {0} faces"' m.Indices.Count / 3));  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ToColorString,The following statement contains a magic number: return string.Format (CultureInfo.InvariantCulture' "{0:F4} {1:F4} {2:F4}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ToColorString,The following statement contains a magic number: return string.Format (CultureInfo.InvariantCulture' "{0:F4} {1:F4} {2:F4}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjExporter,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjExporter.cs,ToColorString,The following statement contains a magic number: return string.Format (CultureInfo.InvariantCulture' "{0:F4} {1:F4} {2:F4}"' color.R / 255.0' color.G / 255.0' color.B / 255.0);  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,ColorParse,The following statement contains a magic number: return System.Windows.Media.Color.FromRgb ((byte)(fields [0] * 255)' (byte)(fields [1] * 255)' (byte)(fields [2] * 255)).ToColor4 ();  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,ColorParse,The following statement contains a magic number: return System.Windows.Media.Color.FromRgb ((byte)(fields [0] * 255)' (byte)(fields [1] * 255)' (byte)(fields [2] * 255)).ToColor4 ();  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,ColorParse,The following statement contains a magic number: return System.Windows.Media.Color.FromRgb ((byte)(fields [0] * 255)' (byte)(fields [1] * 255)' (byte)(fields [2] * 255)).ToColor4 ();  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,ColorParse,The following statement contains a magic number: return System.Windows.Media.Color.FromRgb ((byte)(fields [0] * 255)' (byte)(fields [1] * 255)' (byte)(fields [2] * 255)).ToColor4 ();  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: foreach (var field in fields) {  	if (string.IsNullOrEmpty (field)) {  		continue;  	}  	var ff = field.Split ('/');  	int vi = int.Parse (ff [0]);  	int vti = ff.Length > 1 && ff [1].Length > 0 ? int.Parse (ff [1]) : int.MaxValue;  	int vni = ff.Length > 2 && ff [2].Length > 0 ? int.Parse (ff [2]) : int.MaxValue;  	// Handle relative indices (negative numbers)  	if (vi < 0) {  		vi = this.Points.Count + vi + 1;  	}  	if (vti < 0) {  		vti = this.TextureCoordinates.Count + vti + 1;  	}  	if (vni < 0) {  		vni = this.Normals.Count + vni + 1;  	}  	// Check if the indices are valid  	if (vi - 1 >= this.Points.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid vertex index ({0}) on line {1}."' vi' this.currentLineNo));  	}  	if (vti == int.MaxValue) {  		// turn off texture coordinates in the builder  		//builder.CreateTextureCoordinates = false;  		builder.TextureCoordinates = null;  	}  	if (vni == int.MaxValue) {  		// turn off normals in the builder  		//builder.CreateNormals = false;  		builder.Normals = null;  	}  	// check if the texture coordinate index is valid  	if (builder.HasTexCoords && vti - 1 >= this.TextureCoordinates.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid texture coordinate index ({0}) on line {1}."' vti' this.currentLineNo));  	}  	// check if the normal index is valid  	if (builder.HasNormals && vni - 1 >= this.Normals.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid normal index ({0}) on line {1}."' vni' this.currentLineNo));  	}  	bool addVertex = true;  	if (smoothingGroupMap != null) {  		var key = Tuple.Create (vi' vti' vni);  		int vix;  		if (smoothingGroupMap.TryGetValue (key' out vix)) {  			// use the index of a previously defined vertex  			addVertex = false;  		} else {  			// add a new vertex  			vix = positions.Count;  			smoothingGroupMap.Add (key' vix);  		}  		faceIndices.Add (vix);  	} else {  		// if smoothing is off' always add a new vertex  		faceIndices.Add (positions.Count);  	}  	if (addVertex) {  		// add vertex  		positions.Add (this.Points [vi - 1]);  		// add texture coordinate (if enabled)  		if (builder.HasTexCoords) {  			textureCoordinates.Add (this.TextureCoordinates [vti - 1]);  		}  		// add normal (if enabled)  		if (builder.HasNormals) {  			normals.Add (this.Normals [vni - 1]);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: foreach (var field in fields) {  	if (string.IsNullOrEmpty (field)) {  		continue;  	}  	var ff = field.Split ('/');  	int vi = int.Parse (ff [0]);  	int vti = ff.Length > 1 && ff [1].Length > 0 ? int.Parse (ff [1]) : int.MaxValue;  	int vni = ff.Length > 2 && ff [2].Length > 0 ? int.Parse (ff [2]) : int.MaxValue;  	// Handle relative indices (negative numbers)  	if (vi < 0) {  		vi = this.Points.Count + vi + 1;  	}  	if (vti < 0) {  		vti = this.TextureCoordinates.Count + vti + 1;  	}  	if (vni < 0) {  		vni = this.Normals.Count + vni + 1;  	}  	// Check if the indices are valid  	if (vi - 1 >= this.Points.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid vertex index ({0}) on line {1}."' vi' this.currentLineNo));  	}  	if (vti == int.MaxValue) {  		// turn off texture coordinates in the builder  		//builder.CreateTextureCoordinates = false;  		builder.TextureCoordinates = null;  	}  	if (vni == int.MaxValue) {  		// turn off normals in the builder  		//builder.CreateNormals = false;  		builder.Normals = null;  	}  	// check if the texture coordinate index is valid  	if (builder.HasTexCoords && vti - 1 >= this.TextureCoordinates.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid texture coordinate index ({0}) on line {1}."' vti' this.currentLineNo));  	}  	// check if the normal index is valid  	if (builder.HasNormals && vni - 1 >= this.Normals.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid normal index ({0}) on line {1}."' vni' this.currentLineNo));  	}  	bool addVertex = true;  	if (smoothingGroupMap != null) {  		var key = Tuple.Create (vi' vti' vni);  		int vix;  		if (smoothingGroupMap.TryGetValue (key' out vix)) {  			// use the index of a previously defined vertex  			addVertex = false;  		} else {  			// add a new vertex  			vix = positions.Count;  			smoothingGroupMap.Add (key' vix);  		}  		faceIndices.Add (vix);  	} else {  		// if smoothing is off' always add a new vertex  		faceIndices.Add (positions.Count);  	}  	if (addVertex) {  		// add vertex  		positions.Add (this.Points [vi - 1]);  		// add texture coordinate (if enabled)  		if (builder.HasTexCoords) {  			textureCoordinates.Add (this.TextureCoordinates [vti - 1]);  		}  		// add normal (if enabled)  		if (builder.HasNormals) {  			normals.Add (this.Normals [vni - 1]);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: foreach (var field in fields) {  	if (string.IsNullOrEmpty (field)) {  		continue;  	}  	var ff = field.Split ('/');  	int vi = int.Parse (ff [0]);  	int vti = ff.Length > 1 && ff [1].Length > 0 ? int.Parse (ff [1]) : int.MaxValue;  	int vni = ff.Length > 2 && ff [2].Length > 0 ? int.Parse (ff [2]) : int.MaxValue;  	// Handle relative indices (negative numbers)  	if (vi < 0) {  		vi = this.Points.Count + vi + 1;  	}  	if (vti < 0) {  		vti = this.TextureCoordinates.Count + vti + 1;  	}  	if (vni < 0) {  		vni = this.Normals.Count + vni + 1;  	}  	// Check if the indices are valid  	if (vi - 1 >= this.Points.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid vertex index ({0}) on line {1}."' vi' this.currentLineNo));  	}  	if (vti == int.MaxValue) {  		// turn off texture coordinates in the builder  		//builder.CreateTextureCoordinates = false;  		builder.TextureCoordinates = null;  	}  	if (vni == int.MaxValue) {  		// turn off normals in the builder  		//builder.CreateNormals = false;  		builder.Normals = null;  	}  	// check if the texture coordinate index is valid  	if (builder.HasTexCoords && vti - 1 >= this.TextureCoordinates.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid texture coordinate index ({0}) on line {1}."' vti' this.currentLineNo));  	}  	// check if the normal index is valid  	if (builder.HasNormals && vni - 1 >= this.Normals.Count) {  		if (this.IgnoreErrors) {  			return;  		}  		throw new FileFormatException (string.Format ("Invalid normal index ({0}) on line {1}."' vni' this.currentLineNo));  	}  	bool addVertex = true;  	if (smoothingGroupMap != null) {  		var key = Tuple.Create (vi' vti' vni);  		int vix;  		if (smoothingGroupMap.TryGetValue (key' out vix)) {  			// use the index of a previously defined vertex  			addVertex = false;  		} else {  			// add a new vertex  			vix = positions.Count;  			smoothingGroupMap.Add (key' vix);  		}  		faceIndices.Add (vix);  	} else {  		// if smoothing is off' always add a new vertex  		faceIndices.Add (positions.Count);  	}  	if (addVertex) {  		// add vertex  		positions.Add (this.Points [vi - 1]);  		// add texture coordinate (if enabled)  		if (builder.HasTexCoords) {  			textureCoordinates.Add (this.TextureCoordinates [vti - 1]);  		}  		// add normal (if enabled)  		if (builder.HasNormals) {  			normals.Add (this.Normals [vni - 1]);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: try {  	if (faceIndices.Count < 3) {  		throw new HelixToolkitException ("Polygon must have at least 3 indices!");  	}  	if (this.ModelInfo.Faces == MeshFaces.QuadPatches) {  		if (faceIndices.Count == 3) {  			faceIndices.Add (faceIndices.Last ());  			builder.AddQuad (faceIndices);  		}  		if (faceIndices.Count == 4) {  			builder.AddQuad (faceIndices);  		} else {  			// add triangles by sweep line algorithm  			builder.AddPolygonByTriangulation (faceIndices);  		}  	} else {  		if (faceIndices.Count == 3) {  			builder.AddTriangle (faceIndices);  		} else if (faceIndices.Count == 4) {  			//builder.AddQuad(faceIndices);  			builder.AddTriangleFan (faceIndices);  		} else {  			// add triangles by sweep line algorithm  			builder.AddPolygonByTriangulation (faceIndices);  		}  	}  } catch (Exception ex) {  	System.Windows.MessageBox.Show (string.Format ("Error composing polygonal object: {0}"' ex.Message)' "Error"' MessageBoxButton.OKCancel);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: try {  	if (faceIndices.Count < 3) {  		throw new HelixToolkitException ("Polygon must have at least 3 indices!");  	}  	if (this.ModelInfo.Faces == MeshFaces.QuadPatches) {  		if (faceIndices.Count == 3) {  			faceIndices.Add (faceIndices.Last ());  			builder.AddQuad (faceIndices);  		}  		if (faceIndices.Count == 4) {  			builder.AddQuad (faceIndices);  		} else {  			// add triangles by sweep line algorithm  			builder.AddPolygonByTriangulation (faceIndices);  		}  	} else {  		if (faceIndices.Count == 3) {  			builder.AddTriangle (faceIndices);  		} else if (faceIndices.Count == 4) {  			//builder.AddQuad(faceIndices);  			builder.AddTriangleFan (faceIndices);  		} else {  			// add triangles by sweep line algorithm  			builder.AddPolygonByTriangulation (faceIndices);  		}  	}  } catch (Exception ex) {  	System.Windows.MessageBox.Show (string.Format ("Error composing polygonal object: {0}"' ex.Message)' "Error"' MessageBoxButton.OKCancel);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: try {  	if (faceIndices.Count < 3) {  		throw new HelixToolkitException ("Polygon must have at least 3 indices!");  	}  	if (this.ModelInfo.Faces == MeshFaces.QuadPatches) {  		if (faceIndices.Count == 3) {  			faceIndices.Add (faceIndices.Last ());  			builder.AddQuad (faceIndices);  		}  		if (faceIndices.Count == 4) {  			builder.AddQuad (faceIndices);  		} else {  			// add triangles by sweep line algorithm  			builder.AddPolygonByTriangulation (faceIndices);  		}  	} else {  		if (faceIndices.Count == 3) {  			builder.AddTriangle (faceIndices);  		} else if (faceIndices.Count == 4) {  			//builder.AddQuad(faceIndices);  			builder.AddTriangleFan (faceIndices);  		} else {  			// add triangles by sweep line algorithm  			builder.AddPolygonByTriangulation (faceIndices);  		}  	}  } catch (Exception ex) {  	System.Windows.MessageBox.Show (string.Format ("Error composing polygonal object: {0}"' ex.Message)' "Error"' MessageBoxButton.OKCancel);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: try {  	if (faceIndices.Count < 3) {  		throw new HelixToolkitException ("Polygon must have at least 3 indices!");  	}  	if (this.ModelInfo.Faces == MeshFaces.QuadPatches) {  		if (faceIndices.Count == 3) {  			faceIndices.Add (faceIndices.Last ());  			builder.AddQuad (faceIndices);  		}  		if (faceIndices.Count == 4) {  			builder.AddQuad (faceIndices);  		} else {  			// add triangles by sweep line algorithm  			builder.AddPolygonByTriangulation (faceIndices);  		}  	} else {  		if (faceIndices.Count == 3) {  			builder.AddTriangle (faceIndices);  		} else if (faceIndices.Count == 4) {  			//builder.AddQuad(faceIndices);  			builder.AddTriangleFan (faceIndices);  		} else {  			// add triangles by sweep line algorithm  			builder.AddPolygonByTriangulation (faceIndices);  		}  	}  } catch (Exception ex) {  	System.Windows.MessageBox.Show (string.Format ("Error composing polygonal object: {0}"' ex.Message)' "Error"' MessageBoxButton.OKCancel);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: try {  	if (faceIndices.Count < 3) {  		throw new HelixToolkitException ("Polygon must have at least 3 indices!");  	}  	if (this.ModelInfo.Faces == MeshFaces.QuadPatches) {  		if (faceIndices.Count == 3) {  			faceIndices.Add (faceIndices.Last ());  			builder.AddQuad (faceIndices);  		}  		if (faceIndices.Count == 4) {  			builder.AddQuad (faceIndices);  		} else {  			// add triangles by sweep line algorithm  			builder.AddPolygonByTriangulation (faceIndices);  		}  	} else {  		if (faceIndices.Count == 3) {  			builder.AddTriangle (faceIndices);  		} else if (faceIndices.Count == 4) {  			//builder.AddQuad(faceIndices);  			builder.AddTriangleFan (faceIndices);  		} else {  			// add triangles by sweep line algorithm  			builder.AddPolygonByTriangulation (faceIndices);  		}  	}  } catch (Exception ex) {  	System.Windows.MessageBox.Show (string.Format ("Error composing polygonal object: {0}"' ex.Message)' "Error"' MessageBoxButton.OKCancel);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: if (faceIndices.Count < 3) {  	throw new HelixToolkitException ("Polygon must have at least 3 indices!");  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: if (this.ModelInfo.Faces == MeshFaces.QuadPatches) {  	if (faceIndices.Count == 3) {  		faceIndices.Add (faceIndices.Last ());  		builder.AddQuad (faceIndices);  	}  	if (faceIndices.Count == 4) {  		builder.AddQuad (faceIndices);  	} else {  		// add triangles by sweep line algorithm  		builder.AddPolygonByTriangulation (faceIndices);  	}  } else {  	if (faceIndices.Count == 3) {  		builder.AddTriangle (faceIndices);  	} else if (faceIndices.Count == 4) {  		//builder.AddQuad(faceIndices);  		builder.AddTriangleFan (faceIndices);  	} else {  		// add triangles by sweep line algorithm  		builder.AddPolygonByTriangulation (faceIndices);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: if (this.ModelInfo.Faces == MeshFaces.QuadPatches) {  	if (faceIndices.Count == 3) {  		faceIndices.Add (faceIndices.Last ());  		builder.AddQuad (faceIndices);  	}  	if (faceIndices.Count == 4) {  		builder.AddQuad (faceIndices);  	} else {  		// add triangles by sweep line algorithm  		builder.AddPolygonByTriangulation (faceIndices);  	}  } else {  	if (faceIndices.Count == 3) {  		builder.AddTriangle (faceIndices);  	} else if (faceIndices.Count == 4) {  		//builder.AddQuad(faceIndices);  		builder.AddTriangleFan (faceIndices);  	} else {  		// add triangles by sweep line algorithm  		builder.AddPolygonByTriangulation (faceIndices);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: if (this.ModelInfo.Faces == MeshFaces.QuadPatches) {  	if (faceIndices.Count == 3) {  		faceIndices.Add (faceIndices.Last ());  		builder.AddQuad (faceIndices);  	}  	if (faceIndices.Count == 4) {  		builder.AddQuad (faceIndices);  	} else {  		// add triangles by sweep line algorithm  		builder.AddPolygonByTriangulation (faceIndices);  	}  } else {  	if (faceIndices.Count == 3) {  		builder.AddTriangle (faceIndices);  	} else if (faceIndices.Count == 4) {  		//builder.AddQuad(faceIndices);  		builder.AddTriangleFan (faceIndices);  	} else {  		// add triangles by sweep line algorithm  		builder.AddPolygonByTriangulation (faceIndices);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: if (this.ModelInfo.Faces == MeshFaces.QuadPatches) {  	if (faceIndices.Count == 3) {  		faceIndices.Add (faceIndices.Last ());  		builder.AddQuad (faceIndices);  	}  	if (faceIndices.Count == 4) {  		builder.AddQuad (faceIndices);  	} else {  		// add triangles by sweep line algorithm  		builder.AddPolygonByTriangulation (faceIndices);  	}  } else {  	if (faceIndices.Count == 3) {  		builder.AddTriangle (faceIndices);  	} else if (faceIndices.Count == 4) {  		//builder.AddQuad(faceIndices);  		builder.AddTriangleFan (faceIndices);  	} else {  		// add triangles by sweep line algorithm  		builder.AddPolygonByTriangulation (faceIndices);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: if (faceIndices.Count == 3) {  	faceIndices.Add (faceIndices.Last ());  	builder.AddQuad (faceIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: if (faceIndices.Count == 4) {  	builder.AddQuad (faceIndices);  } else {  	// add triangles by sweep line algorithm  	builder.AddPolygonByTriangulation (faceIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: if (faceIndices.Count == 3) {  	builder.AddTriangle (faceIndices);  } else if (faceIndices.Count == 4) {  	//builder.AddQuad(faceIndices);  	builder.AddTriangleFan (faceIndices);  } else {  	// add triangles by sweep line algorithm  	builder.AddPolygonByTriangulation (faceIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: if (faceIndices.Count == 3) {  	builder.AddTriangle (faceIndices);  } else if (faceIndices.Count == 4) {  	//builder.AddQuad(faceIndices);  	builder.AddTriangleFan (faceIndices);  } else {  	// add triangles by sweep line algorithm  	builder.AddPolygonByTriangulation (faceIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddFace,The following statement contains a magic number: if (faceIndices.Count == 4) {  	//builder.AddQuad(faceIndices);  	builder.AddTriangleFan (faceIndices);  } else {  	// add triangles by sweep line algorithm  	builder.AddPolygonByTriangulation (faceIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddNormal,The following statement contains a magic number: if (SwitchYZ) {  	this.Normals.Add (new Vector3D ((float)fields [0]' (float)-fields [2]' (float)fields [1]));  } else {  	this.Normals.Add (new Vector3D ((float)fields [0]' (float)fields [1]' (float)fields [2]));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddNormal,The following statement contains a magic number: if (SwitchYZ) {  	this.Normals.Add (new Vector3D ((float)fields [0]' (float)-fields [2]' (float)fields [1]));  } else {  	this.Normals.Add (new Vector3D ((float)fields [0]' (float)fields [1]' (float)fields [2]));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddNormal,The following statement contains a magic number: this.Normals.Add (new Vector3D ((float)fields [0]' (float)-fields [2]' (float)fields [1]));  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddNormal,The following statement contains a magic number: this.Normals.Add (new Vector3D ((float)fields [0]' (float)fields [1]' (float)fields [2]));  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddVertex,The following statement contains a magic number: if (SwitchYZ) {  	this.Points.Add (new Point3D ((float)fields [0]' (float)-fields [2]' (float)fields [1]));  } else {  	this.Points.Add (new Point3D ((float)fields [0]' (float)fields [1]' (float)fields [2]));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddVertex,The following statement contains a magic number: if (SwitchYZ) {  	this.Points.Add (new Point3D ((float)fields [0]' (float)-fields [2]' (float)fields [1]));  } else {  	this.Points.Add (new Point3D ((float)fields [0]' (float)fields [1]' (float)fields [2]));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddVertex,The following statement contains a magic number: this.Points.Add (new Point3D ((float)fields [0]' (float)-fields [2]' (float)fields [1]));  
Magic Number,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,AddVertex,The following statement contains a magic number: this.Points.Add (new Point3D ((float)fields [0]' (float)fields [1]' (float)fields [2]));  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,GetCircle,The following statement contains a magic number: if ((!closed && !CircleCache.Value.TryGetValue (thetaDiv' out circle)) || (closed && !ClosedCircleCache.Value.TryGetValue (thetaDiv' out circle))) {  	circle = new PointCollection ();  	// Add to the cache  	if (!closed) {  		CircleCache.Value.Add (thetaDiv' circle);  	} else {  		ClosedCircleCache.Value.Add (thetaDiv' circle);  	}  	// Determine the angle steps  	var num = closed ? thetaDiv : thetaDiv - 1;  	for (int i = 0; i < thetaDiv; i++) {  		var theta = (DoubleOrSingle)Math.PI * 2 * ((DoubleOrSingle)i / num);  		circle.Add (new Point ((DoubleOrSingle)Math.Cos (theta)' -(DoubleOrSingle)Math.Sin (theta)));  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,GetCircle,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	var theta = (DoubleOrSingle)Math.PI * 2 * ((DoubleOrSingle)i / num);  	circle.Add (new Point ((DoubleOrSingle)Math.Cos (theta)' -(DoubleOrSingle)Math.Sin (theta)));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormals,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3) {  	var i1 = triangleIndices [t];  	var i2 = triangleIndices [t + 1];  	var i3 = triangleIndices [t + 2];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var p1 = v2 - v1;  	var p2 = v3 - v1;  	var n = SharedFunctions.CrossProduct (ref p1' ref p2);  	// angle  	p1.Normalize ();  	p2.Normalize ();  	var a = (float)Math.Acos (SharedFunctions.DotProduct (ref p1' ref p2));  	n.Normalize ();  	normals [i1] += (a * n);  	normals [i2] += (a * n);  	normals [i3] += (a * n);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormals,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3) {  	var i1 = triangleIndices [t];  	var i2 = triangleIndices [t + 1];  	var i3 = triangleIndices [t + 2];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var p1 = v2 - v1;  	var p2 = v3 - v1;  	var n = SharedFunctions.CrossProduct (ref p1' ref p2);  	// angle  	p1.Normalize ();  	p2.Normalize ();  	var a = (float)Math.Acos (SharedFunctions.DotProduct (ref p1' ref p2));  	n.Normalize ();  	normals [i1] += (a * n);  	normals [i2] += (a * n);  	normals [i3] += (a * n);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormals,The following statement contains a magic number: t += 3
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3) {  	var i1 = triangleIndices [t];  	var i2 = triangleIndices [t + 1];  	var i3 = triangleIndices [t + 2];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var w1 = textureCoordinates [i1];  	var w2 = textureCoordinates [i2];  	var w3 = textureCoordinates [i3];  	var x1 = v2.X - v1.X;  	var x2 = v3.X - v1.X;  	var y1 = v2.Y - v1.Y;  	var y2 = v3.Y - v1.Y;  	var z1 = v2.Z - v1.Z;  	var z2 = v3.Z - v1.Z;  	var s1 = w2.X - w1.X;  	var s2 = w3.X - w1.X;  	var t1 = w2.Y - w1.Y;  	var t2 = w3.Y - w1.Y;  	var r = 1.0f / (s1 * t2 - s2 * t1);  	var udir = new Vector3D ((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);  	tan1 [i1] += udir;  	tan1 [i2] += udir;  	tan1 [i3] += udir;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3) {  	var i1 = triangleIndices [t];  	var i2 = triangleIndices [t + 1];  	var i3 = triangleIndices [t + 2];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var w1 = textureCoordinates [i1];  	var w2 = textureCoordinates [i2];  	var w3 = textureCoordinates [i3];  	var x1 = v2.X - v1.X;  	var x2 = v3.X - v1.X;  	var y1 = v2.Y - v1.Y;  	var y2 = v3.Y - v1.Y;  	var z1 = v2.Z - v1.Z;  	var z2 = v3.Z - v1.Z;  	var s1 = w2.X - w1.X;  	var s2 = w3.X - w1.X;  	var t1 = w2.Y - w1.Y;  	var t2 = w3.Y - w1.Y;  	var r = 1.0f / (s1 * t2 - s2 * t1);  	var udir = new Vector3D ((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);  	tan1 [i1] += udir;  	tan1 [i2] += udir;  	tan1 [i3] += udir;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The following statement contains a magic number: t += 3
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: for (int t = 0; t < indices.Count; t += 4) {  	var i1 = indices [t];  	var i2 = indices [t + 1];  	var i3 = indices [t + 2];  	var i4 = indices [t + 3];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var v4 = positions [i4];  	var w1 = textureCoordinates [i1];  	var w2 = textureCoordinates [i2];  	var w3 = textureCoordinates [i3];  	var w4 = textureCoordinates [i4];  	var x1 = v2.X - v1.X;  	var x2 = v4.X - v1.X;  	var y1 = v2.Y - v1.Y;  	var y2 = v4.Y - v1.Y;  	var z1 = v2.Z - v1.Z;  	var z2 = v4.Z - v1.Z;  	var s1 = w2.X - w1.X;  	var s2 = w4.X - w1.X;  	var t1 = w2.Y - w1.Y;  	var t2 = w4.Y - w1.Y;  	var r = 1.0f / (s1 * t2 - s2 * t1);  	var udir = new Vector3D ((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);  	tan1 [i1] += udir;  	tan1 [i2] += udir;  	tan1 [i3] += udir;  	tan1 [i4] += udir;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: for (int t = 0; t < indices.Count; t += 4) {  	var i1 = indices [t];  	var i2 = indices [t + 1];  	var i3 = indices [t + 2];  	var i4 = indices [t + 3];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var v4 = positions [i4];  	var w1 = textureCoordinates [i1];  	var w2 = textureCoordinates [i2];  	var w3 = textureCoordinates [i3];  	var w4 = textureCoordinates [i4];  	var x1 = v2.X - v1.X;  	var x2 = v4.X - v1.X;  	var y1 = v2.Y - v1.Y;  	var y2 = v4.Y - v1.Y;  	var z1 = v2.Z - v1.Z;  	var z2 = v4.Z - v1.Z;  	var s1 = w2.X - w1.X;  	var s2 = w4.X - w1.X;  	var t1 = w2.Y - w1.Y;  	var t2 = w4.Y - w1.Y;  	var r = 1.0f / (s1 * t2 - s2 * t1);  	var udir = new Vector3D ((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);  	tan1 [i1] += udir;  	tan1 [i2] += udir;  	tan1 [i3] += udir;  	tan1 [i4] += udir;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: for (int t = 0; t < indices.Count; t += 4) {  	var i1 = indices [t];  	var i2 = indices [t + 1];  	var i3 = indices [t + 2];  	var i4 = indices [t + 3];  	var v1 = positions [i1];  	var v2 = positions [i2];  	var v3 = positions [i3];  	var v4 = positions [i4];  	var w1 = textureCoordinates [i1];  	var w2 = textureCoordinates [i2];  	var w3 = textureCoordinates [i3];  	var w4 = textureCoordinates [i4];  	var x1 = v2.X - v1.X;  	var x2 = v4.X - v1.X;  	var y1 = v2.Y - v1.Y;  	var y2 = v4.Y - v1.Y;  	var z1 = v2.Z - v1.Z;  	var z2 = v4.Z - v1.Z;  	var s1 = w2.X - w1.X;  	var s2 = w4.X - w1.X;  	var t1 = w2.Y - w1.Y;  	var t2 = w4.Y - w1.Y;  	var r = 1.0f / (s1 * t2 - s2 * t1);  	var udir = new Vector3D ((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);  	tan1 [i1] += udir;  	tan1 [i2] += udir;  	tan1 [i3] += udir;  	tan1 [i4] += udir;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: t += 4
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: up *= (DoubleOrSingle)height / 2;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: right *= (DoubleOrSingle)width / 2;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add (i0 + 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add (i0 + 3);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add (i0 + 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The following statement contains a magic number: this.AddCone (p1' n' diameter / 2' diameter / 2' l' false' false' thetaDiv);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The following statement contains a magic number: this.AddCone (p1' n' diameter / 2' diameter / 2' l' false' false' thetaDiv);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation (this.positions.Skip (positionsCount).Take (5).Select ((p' i) => i).ToList ());  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation (this.positions.Skip (positionsCount + 15).Select ((p' i) => 15 + i).ToList ());  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation (this.positions.Skip (positionsCount + 15).Select ((p' i) => 15 + i).ToList ());  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	// Polygon one  	var pIndices = new List<int> () {  		(i + 1) % 5 + positionsCount'  		i'  		i + 5 + positionsCount'  		(5 - i + 2) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 5 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  	// Polygon two  	pIndices = new List<int> () {  		i + 15 + positionsCount'  		i + 10 + positionsCount'  		(5 - i + 2) % 5 + 5 + positionsCount'  		(i + 1) % 5 + 10 + positionsCount'  		(i + 1) % 5 + 15 + positionsCount  	};  	this.AddPolygonByTriangulation (pIndices);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int> () {  	i + 15 + positionsCount'  	i + 10 + positionsCount'  	(5 - i + 2) % 5 + 5 + positionsCount'  	(i + 1) % 5 + 10 + positionsCount'  	(i + 1) % 5 + 15 + positionsCount  };  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEdges,The following statement contains a magic number: for (int i = 0; i < edges.Count - 1; i += 2) {  	this.AddCylinder (points [edges [i]]' points [edges [i + 1]]' diameter' thetaDiv);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEdges,The following statement contains a magic number: i += 2
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The following statement contains a magic number: for (int pi = 0; pi <= phiDiv; pi++) {  	var phi = pi * dp;  	for (int ti = 0; ti <= thetaDiv; ti++) {  		// we want to start the mesh on the x axis  		var theta = ti * dt;  		// Spherical coordinates  		// http://mathworld.wolfram.com/SphericalCoordinates.html  		var x = (DoubleOrSingle)Math.Cos (theta) * (DoubleOrSingle)Math.Sin (phi);  		var y = (DoubleOrSingle)Math.Sin (theta) * (DoubleOrSingle)Math.Sin (phi);  		var z = (DoubleOrSingle)Math.Cos (phi);  		var p = new Point3D (center.X + (DoubleOrSingle)(radiusx * x)' center.Y + (DoubleOrSingle)(radiusy * y)' center.Z + (DoubleOrSingle)(radiusz * z));  		this.positions.Add (p);  		if (this.normals != null) {  			var n = new Vector3D (x' y' z);  			this.normals.Add (n);  		}  		if (this.textureCoordinates != null) {  			var uv = new Point (theta / (2 * (DoubleOrSingle)Math.PI)' phi / (DoubleOrSingle)Math.PI);  			this.textureCoordinates.Add (uv);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The following statement contains a magic number: for (int ti = 0; ti <= thetaDiv; ti++) {  	// we want to start the mesh on the x axis  	var theta = ti * dt;  	// Spherical coordinates  	// http://mathworld.wolfram.com/SphericalCoordinates.html  	var x = (DoubleOrSingle)Math.Cos (theta) * (DoubleOrSingle)Math.Sin (phi);  	var y = (DoubleOrSingle)Math.Sin (theta) * (DoubleOrSingle)Math.Sin (phi);  	var z = (DoubleOrSingle)Math.Cos (phi);  	var p = new Point3D (center.X + (DoubleOrSingle)(radiusx * x)' center.Y + (DoubleOrSingle)(radiusy * y)' center.Z + (DoubleOrSingle)(radiusz * z));  	this.positions.Add (p);  	if (this.normals != null) {  		var n = new Vector3D (x' y' z);  		this.normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv = new Point (theta / (2 * (DoubleOrSingle)Math.PI)' phi / (DoubleOrSingle)Math.PI);  		this.textureCoordinates.Add (uv);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The following statement contains a magic number: if (this.textureCoordinates != null) {  	var uv = new Point (theta / (2 * (DoubleOrSingle)Math.PI)' phi / (DoubleOrSingle)Math.PI);  	this.textureCoordinates.Add (uv);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedGeometry,The following statement contains a magic number: foreach (var p in points) {  	var v = (xaxis * p.X) + (ydirection * p.Y);  	this.positions.Add (p0 + v);  	this.positions.Add (p1 + v);  	v.Normalize ();  	if (this.normals != null) {  		this.normals.Add (v);  		this.normals.Add (v);  	}  	if (this.textureCoordinates != null) {  		this.textureCoordinates.Add (new Point (0' 0));  		this.textureCoordinates.Add (new Point (1' 0));  	}  	int i1 = index0 + 1;  	int i2 = (index0 + 2) % np;  	int i3 = ((index0 + 2) % np) + 1;  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i3);  	this.triangleIndices.Add (i2);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedGeometry,The following statement contains a magic number: foreach (var p in points) {  	var v = (xaxis * p.X) + (ydirection * p.Y);  	this.positions.Add (p0 + v);  	this.positions.Add (p1 + v);  	v.Normalize ();  	if (this.normals != null) {  		this.normals.Add (v);  		this.normals.Add (v);  	}  	if (this.textureCoordinates != null) {  		this.textureCoordinates.Add (new Point (0' 0));  		this.textureCoordinates.Add (new Point (1' 0));  	}  	int i1 = index0 + 1;  	int i2 = (index0 + 2) % np;  	int i3 = ((index0 + 2) % np) + 1;  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i3);  	this.triangleIndices.Add (i2);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: if (points.Count % 2 != 0) {  	throw new InvalidOperationException ("The number of points should be even.");  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int i0 = index0 + (i * 2);  	int i1 = i0 + 1;  	int i2 = i0 + 3;  	int i3 = i0 + 2;  	this.triangleIndices.Add (i0);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i3);  	this.triangleIndices.Add (i0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int i0 = index0 + (i * 2);  	int i1 = i0 + 1;  	int i2 = i0 + 3;  	int i3 = i0 + 2;  	this.triangleIndices.Add (i0);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i3);  	this.triangleIndices.Add (i0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int i0 = index0 + (i * 2);  	int i1 = i0 + 1;  	int i2 = i0 + 3;  	int i3 = i0 + 2;  	this.triangleIndices.Add (i0);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i3);  	this.triangleIndices.Add (i0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The following statement contains a magic number: up *= (DoubleOrSingle)height / 2;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The following statement contains a magic number: right *= (DoubleOrSingle)sideLength / 2;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: if (innerDiameter > 0) {  	// Add the inner surface  	pc.Add (new Point (0' (DoubleOrSingle)innerDiameter / 2));  	tc.Add (1);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: pc.Add (new Point (0' (DoubleOrSingle)innerDiameter / 2));  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipes,The following statement contains a magic number: for (int i = 0; i < edges.Count - 1; i += 2) {  	this.AddCylinder ((Point3D)points [edges [i]]' (Point3D)points [edges [i + 1]]' diameter' thetaDiv);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipes,The following statement contains a magic number: i += 2
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count) {  case 3:  	this.AddTriangle (points [0]' points [1]' points [2]);  	break;  case 4:  	this.AddQuad (points [0]' points [1]' points [2]' points [3]);  	break;  default:  	this.AddTriangleFan (points);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count) {  case 3:  	this.AddTriangle (points [0]' points [1]' points [2]);  	break;  case 4:  	this.AddQuad (points [0]' points [1]' points [2]' points [3]);  	break;  default:  	this.AddTriangleFan (points);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count) {  case 3:  	this.AddTriangle (points [0]' points [1]' points [2]);  	break;  case 4:  	this.AddQuad (points [0]' points [1]' points [2]' points [3]);  	break;  default:  	this.AddTriangleFan (points);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count) {  case 3:  	this.AddTriangle (points [0]' points [1]' points [2]);  	break;  case 4:  	this.AddQuad (points [0]' points [1]' points [2]' points [3]);  	break;  default:  	this.AddTriangleFan (points);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count) {  case 3:  	this.AddTriangle (points [0]' points [1]' points [2]);  	break;  case 4:  	this.AddQuad (points [0]' points [1]' points [2]' points [3]);  	break;  default:  	this.AddTriangleFan (points);  	break;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: this.AddTriangle (points [0]' points [1]' points [2]);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: this.AddQuad (points [0]' points [1]' points [2]' points [3]);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: this.AddQuad (points [0]' points [1]' points [2]' points [3]);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: for (int i = 0; i + 2 < n; i++) {  	this.triangleIndices.Add (vertexIndices [0]);  	this.triangleIndices.Add (vertexIndices [i + 1]);  	this.triangleIndices.Add (vertexIndices [i + 2]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: for (int i = 0; i + 2 < n; i++) {  	this.triangleIndices.Add (vertexIndices [0]);  	this.triangleIndices.Add (vertexIndices [i + 1]);  	this.triangleIndices.Add (vertexIndices [i + 2]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: this.triangleIndices.Add (vertexIndices [i + 2]);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: right *= (DoubleOrSingle)sideLength / 2;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	this.triangleIndices.Add (vertexIndices [i]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add (i0 + 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add (i0 + 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add (i0 + 3);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: Debug.Assert (quadPositions.Count > 0 && quadPositions.Count % 4 == 0' "Wrong number of positions.");  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 3);  	this.triangleIndices.Add (i);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 3);  	this.triangleIndices.Add (i);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 3);  	this.triangleIndices.Add (i);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 2);  	this.triangleIndices.Add (i + 3);  	this.triangleIndices.Add (i);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: this.triangleIndices.Add (i + 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: this.triangleIndices.Add (i + 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: this.triangleIndices.Add (i + 3);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The following statement contains a magic number: if (columns < 2 || rows < 2) {  	throw new ArgumentNullException ("columns or rows too small");  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The following statement contains a magic number: if (columns < 2 || rows < 2) {  	throw new ArgumentNullException ("columns or rows too small");  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndices,The following statement contains a magic number: for (int i = 0; i < rows - 1; i++) {  	for (int j = 0; j < columns - 1; j++) {  		int ij = (i * columns) + j;  		if (!isSpherical || i > 0) {  			this.triangleIndices.Add (index0 + ij);  			this.triangleIndices.Add (index0 + ij + 1 + columns);  			this.triangleIndices.Add (index0 + ij + 1);  		}  		if (!isSpherical || i < rows - 2) {  			this.triangleIndices.Add (index0 + ij + 1 + columns);  			this.triangleIndices.Add (index0 + ij);  			this.triangleIndices.Add (index0 + ij + columns);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndices,The following statement contains a magic number: for (int j = 0; j < columns - 1; j++) {  	int ij = (i * columns) + j;  	if (!isSpherical || i > 0) {  		this.triangleIndices.Add (index0 + ij);  		this.triangleIndices.Add (index0 + ij + 1 + columns);  		this.triangleIndices.Add (index0 + ij + 1);  	}  	if (!isSpherical || i < rows - 2) {  		this.triangleIndices.Add (index0 + ij + 1 + columns);  		this.triangleIndices.Add (index0 + ij);  		this.triangleIndices.Add (index0 + ij + columns);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndices,The following statement contains a magic number: if (!isSpherical || i < rows - 2) {  	this.triangleIndices.Add (index0 + ij + 1 + columns);  	this.triangleIndices.Add (index0 + ij);  	this.triangleIndices.Add (index0 + ij + columns);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndicesFlipped,The following statement contains a magic number: for (int i = 0; i < rows - 1; i++) {  	for (int j = 0; j < columns - 1; j++) {  		int ij = (i * columns) + j;  		if (!isSpherical || i > 0) {  			this.triangleIndices.Add (index0 + ij);  			this.triangleIndices.Add (index0 + ij + 1);  			this.triangleIndices.Add (index0 + ij + 1 + columns);  		}  		if (!isSpherical || i < rows - 2) {  			this.triangleIndices.Add (index0 + ij + 1 + columns);  			this.triangleIndices.Add (index0 + ij + columns);  			this.triangleIndices.Add (index0 + ij);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndicesFlipped,The following statement contains a magic number: for (int j = 0; j < columns - 1; j++) {  	int ij = (i * columns) + j;  	if (!isSpherical || i > 0) {  		this.triangleIndices.Add (index0 + ij);  		this.triangleIndices.Add (index0 + ij + 1);  		this.triangleIndices.Add (index0 + ij + 1 + columns);  	}  	if (!isSpherical || i < rows - 2) {  		this.triangleIndices.Add (index0 + ij + 1 + columns);  		this.triangleIndices.Add (index0 + ij + columns);  		this.triangleIndices.Add (index0 + ij);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndicesFlipped,The following statement contains a magic number: if (!isSpherical || i < rows - 2) {  	this.triangleIndices.Add (index0 + ij + 1 + columns);  	this.triangleIndices.Add (index0 + ij + columns);  	this.triangleIndices.Add (index0 + ij);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: if (shareVertices) {  	int index0 = this.positions.Count;  	foreach (var v in icosahedronVertices) {  		this.positions.Add (center + (v * (DoubleOrSingle)radius));  	}  	foreach (int i in icosahedronIndices) {  		this.triangleIndices.Add (index0 + i);  	}  } else {  	for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3) {  		this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius));  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: if (shareVertices) {  	int index0 = this.positions.Count;  	foreach (var v in icosahedronVertices) {  		this.positions.Add (center + (v * (DoubleOrSingle)radius));  	}  	foreach (int i in icosahedronIndices) {  		this.triangleIndices.Add (index0 + i);  	}  } else {  	for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3) {  		this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius));  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: if (shareVertices) {  	int index0 = this.positions.Count;  	foreach (var v in icosahedronVertices) {  		this.positions.Add (center + (v * (DoubleOrSingle)radius));  	}  	foreach (int i in icosahedronIndices) {  		this.triangleIndices.Add (index0 + i);  	}  } else {  	for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3) {  		this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius));  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3) {  	this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3) {  	this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3) {  	this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: this.AddTriangle (center + (icosahedronVertices [icosahedronIndices [i]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 1]] * (DoubleOrSingle)radius)' center + (icosahedronVertices [icosahedronIndices [i + 2]] * (DoubleOrSingle)radius));  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	var w = (v * circle [i].X) + (u * circle [i].Y);  	for (int j = 0; j + 1 < n; j++) {  		// Add segment  		var q1 = origin + (direction * points [j].X) + (w * points [j].Y);  		var q2 = origin + (direction * points [j + 1].X) + (w * points [j + 1].Y);  		// TODO: should not add segment if q1==q2 (corner point)  		// const double eps = 1e-6;  		// if (Point3D.Subtract(q1' q2).LengthSquared < eps)  		// continue;  		this.positions.Add (q1);  		this.positions.Add (q2);  		if (this.normals != null) {  			var tx = points [j + 1].X - points [j].X;  			var ty = points [j + 1].Y - points [j].Y;  			var normal = (-direction * ty) + (w * tx);  			normal.Normalize ();  			this.normals.Add (normal);  			this.normals.Add (normal);  		}  		if (this.textureCoordinates != null) {  			this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues [j]));  			this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues [j + 1]));  		}  		int i0 = index0 + (i * rowNodes) + (j * 2);  		int i1 = i0 + 1;  		int i2 = index0 + ((((i + 1) * rowNodes) + (j * 2)) % totalNodes);  		int i3 = i2 + 1;  		this.triangleIndices.Add (i1);  		this.triangleIndices.Add (i0);  		this.triangleIndices.Add (i2);  		this.triangleIndices.Add (i1);  		this.triangleIndices.Add (i2);  		this.triangleIndices.Add (i3);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	var w = (v * circle [i].X) + (u * circle [i].Y);  	for (int j = 0; j + 1 < n; j++) {  		// Add segment  		var q1 = origin + (direction * points [j].X) + (w * points [j].Y);  		var q2 = origin + (direction * points [j + 1].X) + (w * points [j + 1].Y);  		// TODO: should not add segment if q1==q2 (corner point)  		// const double eps = 1e-6;  		// if (Point3D.Subtract(q1' q2).LengthSquared < eps)  		// continue;  		this.positions.Add (q1);  		this.positions.Add (q2);  		if (this.normals != null) {  			var tx = points [j + 1].X - points [j].X;  			var ty = points [j + 1].Y - points [j].Y;  			var normal = (-direction * ty) + (w * tx);  			normal.Normalize ();  			this.normals.Add (normal);  			this.normals.Add (normal);  		}  		if (this.textureCoordinates != null) {  			this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues [j]));  			this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues [j + 1]));  		}  		int i0 = index0 + (i * rowNodes) + (j * 2);  		int i1 = i0 + 1;  		int i2 = index0 + ((((i + 1) * rowNodes) + (j * 2)) % totalNodes);  		int i3 = i2 + 1;  		this.triangleIndices.Add (i1);  		this.triangleIndices.Add (i0);  		this.triangleIndices.Add (i2);  		this.triangleIndices.Add (i1);  		this.triangleIndices.Add (i2);  		this.triangleIndices.Add (i3);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: for (int j = 0; j + 1 < n; j++) {  	// Add segment  	var q1 = origin + (direction * points [j].X) + (w * points [j].Y);  	var q2 = origin + (direction * points [j + 1].X) + (w * points [j + 1].Y);  	// TODO: should not add segment if q1==q2 (corner point)  	// const double eps = 1e-6;  	// if (Point3D.Subtract(q1' q2).LengthSquared < eps)  	// continue;  	this.positions.Add (q1);  	this.positions.Add (q2);  	if (this.normals != null) {  		var tx = points [j + 1].X - points [j].X;  		var ty = points [j + 1].Y - points [j].Y;  		var normal = (-direction * ty) + (w * tx);  		normal.Normalize ();  		this.normals.Add (normal);  		this.normals.Add (normal);  	}  	if (this.textureCoordinates != null) {  		this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues [j]));  		this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues [j + 1]));  	}  	int i0 = index0 + (i * rowNodes) + (j * 2);  	int i1 = i0 + 1;  	int i2 = index0 + ((((i + 1) * rowNodes) + (j * 2)) % totalNodes);  	int i3 = i2 + 1;  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i0);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i3);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: for (int j = 0; j + 1 < n; j++) {  	// Add segment  	var q1 = origin + (direction * points [j].X) + (w * points [j].Y);  	var q2 = origin + (direction * points [j + 1].X) + (w * points [j + 1].Y);  	// TODO: should not add segment if q1==q2 (corner point)  	// const double eps = 1e-6;  	// if (Point3D.Subtract(q1' q2).LengthSquared < eps)  	// continue;  	this.positions.Add (q1);  	this.positions.Add (q2);  	if (this.normals != null) {  		var tx = points [j + 1].X - points [j].X;  		var ty = points [j + 1].Y - points [j].Y;  		var normal = (-direction * ty) + (w * tx);  		normal.Normalize ();  		this.normals.Add (normal);  		this.normals.Add (normal);  	}  	if (this.textureCoordinates != null) {  		this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues [j]));  		this.textureCoordinates.Add (new Point ((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues [j + 1]));  	}  	int i0 = index0 + (i * rowNodes) + (j * 2);  	int i1 = i0 + 1;  	int i2 = index0 + ((((i + 1) * rowNodes) + (j * 2)) % totalNodes);  	int i3 = i2 + 1;  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i0);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i3);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	var ii = (i + 1) % thetaDiv;  	for (int j = 0; j + 1 < sectionIndices.Count; j += 2) {  		var j0 = sectionIndices [j];  		var j1 = sectionIndices [j + 1];  		int i0 = index0 + (i * n) + j0;  		int i1 = index0 + (ii * n) + j0;  		int i2 = index0 + (i * n) + j1;  		int i3 = index0 + (ii * n) + j1;  		this.triangleIndices.Add (i0);  		this.triangleIndices.Add (i1);  		this.triangleIndices.Add (i3);  		this.triangleIndices.Add (i3);  		this.triangleIndices.Add (i2);  		this.triangleIndices.Add (i0);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The following statement contains a magic number: for (int j = 0; j + 1 < sectionIndices.Count; j += 2) {  	var j0 = sectionIndices [j];  	var j1 = sectionIndices [j + 1];  	int i0 = index0 + (i * n) + j0;  	int i1 = index0 + (ii * n) + j0;  	int i2 = index0 + (i * n) + j1;  	int i3 = index0 + (ii * n) + j1;  	this.triangleIndices.Add (i0);  	this.triangleIndices.Add (i1);  	this.triangleIndices.Add (i3);  	this.triangleIndices.Add (i3);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i0);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The following statement contains a magic number: j += 2
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0) {  	this.AddSphere (new Point3D ()' tubeDiameter' thetaDiv' phiDiv);  } // If the second Diameter is zero' we can't build out torus  else if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (tubeDiameter == 0.0)  	throw new HelixToolkitException ("Torus must have a Diameter bigger than 0");  // Values result in a Torus  else {  	// Points of the Cross-Section of the torus "tube"  	IList<Point> crossSectionPoints;  	// Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter  	var selfIntersecting = tubeDiameter > torusDiameter;  	if (selfIntersecting) {  		// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  		var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  		var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  		var offset = -circleAngle / 2;  		// The Cross-Section is defined by only a Segment of a Circle  		crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  	} // "normal" Torus (with a Circle as Cross-Section of the Torus  	else {  		crossSectionPoints = GetCircle (phiDiv' true);  	}  	// Transform Crosssection to real Size  	crossSectionPoints = crossSectionPoints.Select (p => new Point ((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList ();  	// Transform the Cross-Section Points to 3D Space  	var crossSection3DPoints = crossSectionPoints.Select (p => new Point3D (p.X' 0' p.Y)).ToList ();  	// Add the needed Vertex-Positions of the Torus  	for (int i = 0; i < thetaDiv; i++) {  		// Angle of the current Cross-Section in the XY-Plane  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		for (int j = 0; j < phiDiv; j++) {  			// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  			// We only need the first and last Point of the first Cross-Section once!  			if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  				continue;  			// Add the Position  			this.positions.Add (rotatedPoints [j]);  		}  	}  	// Add all Normals' if they need to be calculated  	if (this.normals != null) {  		for (int i = 0; i < thetaDiv; i++) {  			// Transform the Cross-Section as well as the Origin of the Cross-Section  			var angle = Math.PI * 2 * ((double)i / thetaDiv);  			var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  			// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  			if (selfIntersecting && i > 0) {  				rotatedPoints.RemoveAt (0);  				rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  			}  			// Transform the Center of the Cross-Section  			var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  			// Add the Normal of the Vertex  			for (int j = 0; j < rotatedPoints.Count; j++) {  				// The default Normal has the same Direction as the Vector from the Center to the Vertex  				var normal = rotatedPoints [j] - rotatedOrigin;  				normal.Normalize ();  				// If self-intersecting Torus and first Point of first Cross-Section'  				// modify Normal  				if (selfIntersecting && i == 0 && j == 0) {  					normal = new Vector3D (0' 0' -1);  				} // If self-intersecting Torus and last Point of first Cross-Section  				// modify Normal  				else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  					normal = new Vector3D (0' 0' 1);  				}  				// Add the Normal  				this.normals.Add (normal);  			}  		}  	}  	// Add all Texture Coordinates' if they need to be calculated  	if (this.textureCoordinates != null) {  		// For all Points' calculate a simple uv Coordinate  		for (int i = 0; i < thetaDiv; i++) {  			// Determine the Number of Vertices of this Cross-Section present in the positions Collection  			var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  			for (int j = 0; j < numCS; j++) {  				// Calculate u- and v- Coordinates for the Points  				var u = (DoubleOrSingle)i / thetaDiv;  				DoubleOrSingle v = 0;  				if (i > 0 && selfIntersecting)  					v = (DoubleOrSingle)(j + 1) / phiDiv;  				else  					v = (DoubleOrSingle)j / phiDiv;  				// Add the Texture-Coordinate  				this.textureCoordinates.Add (new Point (u' v));  			}  		}  	}  	// Add Triangle-Indices  	for (int i = 0; i < thetaDiv; i++) {  		// Normal non-selfintersecting Torus  		// Just add Triangle-Strips between all neighboring Cross-Sections  		if (!selfIntersecting) {  			var firstPointIdx = i * phiDiv;  			var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  			for (int j = 0; j < phiDiv; j++) {  				var jNext = (j + 1) % phiDiv;  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  			}  		} // Selfintersecting Torus  		else {  			// Add intermediate Triangles like for the non-selfintersecting Torus  			// Skip the first and last Triangles' the "Caps" will be added later  			// Determine the Index of the first Point of the first Cross-Section  			var firstPointIdx = i * (phiDiv - 2) + 1;  			firstPointIdx += i > 0 ? 1 : 0;  			// Determine the Index of the first Point of the next Cross-Section  			var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  			firstPointIdxNextCircle -= i > 0 ? 1 : 0;  			if (firstPointIdxNextCircle >= this.positions.Count) {  				firstPointIdxNextCircle %= this.positions.Count;  				firstPointIdxNextCircle++;  			}  			// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  			for (int j = 1; j < phiDiv - 2; j++) {  				this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  				this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  				this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			}  		}  	}  	// For selfintersecting Tori  	if (selfIntersecting) {  		// Add bottom Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		var verts = new List<int> ();  		verts.Add (0);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (1 + positionsCount);  			} else {  				verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  			}  		}  		verts.Add (1 + positionsCount);  		verts.Reverse ();  		AddTriangleFan (verts);  		// Add top Cap by creating a List of Vertex-Indices  		// and using them to create a Triangle-Fan  		verts = new List<int> ();  		verts.Add (phiDiv - 1 + positionsCount);  		for (int i = 0; i < thetaDiv; i++) {  			if (i == 0) {  				verts.Add (phiDiv - 2 + positionsCount);  			} else {  				verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  			}  		}  		verts.Add (phiDiv - 2 + positionsCount);  		AddTriangleFan (verts);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (selfIntersecting) {  	// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  	var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  	var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  	var offset = -circleAngle / 2;  	// The Cross-Section is defined by only a Segment of a Circle  	crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  } // "normal" Torus (with a Circle as Cross-Section of the Torus  else {  	crossSectionPoints = GetCircle (phiDiv' true);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (selfIntersecting) {  	// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  	var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  	var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  	var offset = -circleAngle / 2;  	// The Cross-Section is defined by only a Segment of a Circle  	crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  } // "normal" Torus (with a Circle as Cross-Section of the Torus  else {  	crossSectionPoints = GetCircle (phiDiv' true);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (selfIntersecting) {  	// Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck  	var angleIcoTriangle = (DoubleOrSingle)Math.Acos (1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));  	var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;  	var offset = -circleAngle / 2;  	// The Cross-Section is defined by only a Segment of a Circle  	crossSectionPoints = GetCircleSegment (phiDiv' circleAngle' offset);  } // "normal" Torus (with a Circle as Cross-Section of the Torus  else {  	crossSectionPoints = GetCircle (phiDiv' true);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	// Angle of the current Cross-Section in the XY-Plane  	var angle = Math.PI * 2 * ((double)i / thetaDiv);  	// Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter  	var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  	for (int j = 0; j < phiDiv; j++) {  		// If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.  		// We only need the first and last Point of the first Cross-Section once!  		if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))  			continue;  		// Add the Position  		this.positions.Add (rotatedPoints [j]);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (this.normals != null) {  	for (int i = 0; i < thetaDiv; i++) {  		// Transform the Cross-Section as well as the Origin of the Cross-Section  		var angle = Math.PI * 2 * ((double)i / thetaDiv);  		var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  		// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  		if (selfIntersecting && i > 0) {  			rotatedPoints.RemoveAt (0);  			rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  		}  		// Transform the Center of the Cross-Section  		var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  		// Add the Normal of the Vertex  		for (int j = 0; j < rotatedPoints.Count; j++) {  			// The default Normal has the same Direction as the Vector from the Center to the Vertex  			var normal = rotatedPoints [j] - rotatedOrigin;  			normal.Normalize ();  			// If self-intersecting Torus and first Point of first Cross-Section'  			// modify Normal  			if (selfIntersecting && i == 0 && j == 0) {  				normal = new Vector3D (0' 0' -1);  			} // If self-intersecting Torus and last Point of first Cross-Section  			// modify Normal  			else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  				normal = new Vector3D (0' 0' 1);  			}  			// Add the Normal  			this.normals.Add (normal);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	// Transform the Cross-Section as well as the Origin of the Cross-Section  	var angle = Math.PI * 2 * ((double)i / thetaDiv);  	var rotatedPoints = crossSection3DPoints.Select (p3D => new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList ();  	// We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section  	if (selfIntersecting && i > 0) {  		rotatedPoints.RemoveAt (0);  		rotatedPoints.RemoveAt (rotatedPoints.Count - 1);  	}  	// Transform the Center of the Cross-Section  	var rotatedOrigin = new Point3D ((DoubleOrSingle)Math.Cos (angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin (angle) * (DoubleOrSingle)torusDiameter * .5f' 0);  	// Add the Normal of the Vertex  	for (int j = 0; j < rotatedPoints.Count; j++) {  		// The default Normal has the same Direction as the Vector from the Center to the Vertex  		var normal = rotatedPoints [j] - rotatedOrigin;  		normal.Normalize ();  		// If self-intersecting Torus and first Point of first Cross-Section'  		// modify Normal  		if (selfIntersecting && i == 0 && j == 0) {  			normal = new Vector3D (0' 0' -1);  		} // If self-intersecting Torus and last Point of first Cross-Section  		// modify Normal  		else if (selfIntersecting && i == 0 && j == (phiDiv - 1)) {  			normal = new Vector3D (0' 0' 1);  		}  		// Add the Normal  		this.normals.Add (normal);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (this.textureCoordinates != null) {  	// For all Points' calculate a simple uv Coordinate  	for (int i = 0; i < thetaDiv; i++) {  		// Determine the Number of Vertices of this Cross-Section present in the positions Collection  		var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  		for (int j = 0; j < numCS; j++) {  			// Calculate u- and v- Coordinates for the Points  			var u = (DoubleOrSingle)i / thetaDiv;  			DoubleOrSingle v = 0;  			if (i > 0 && selfIntersecting)  				v = (DoubleOrSingle)(j + 1) / phiDiv;  			else  				v = (DoubleOrSingle)j / phiDiv;  			// Add the Texture-Coordinate  			this.textureCoordinates.Add (new Point (u' v));  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	// Determine the Number of Vertices of this Cross-Section present in the positions Collection  	var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;  	for (int j = 0; j < numCS; j++) {  		// Calculate u- and v- Coordinates for the Points  		var u = (DoubleOrSingle)i / thetaDiv;  		DoubleOrSingle v = 0;  		if (i > 0 && selfIntersecting)  			v = (DoubleOrSingle)(j + 1) / phiDiv;  		else  			v = (DoubleOrSingle)j / phiDiv;  		// Add the Texture-Coordinate  		this.textureCoordinates.Add (new Point (u' v));  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	// Normal non-selfintersecting Torus  	// Just add Triangle-Strips between all neighboring Cross-Sections  	if (!selfIntersecting) {  		var firstPointIdx = i * phiDiv;  		var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  		for (int j = 0; j < phiDiv; j++) {  			var jNext = (j + 1) % phiDiv;  			this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  			this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  		}  	} // Selfintersecting Torus  	else {  		// Add intermediate Triangles like for the non-selfintersecting Torus  		// Skip the first and last Triangles' the "Caps" will be added later  		// Determine the Index of the first Point of the first Cross-Section  		var firstPointIdx = i * (phiDiv - 2) + 1;  		firstPointIdx += i > 0 ? 1 : 0;  		// Determine the Index of the first Point of the next Cross-Section  		var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  		firstPointIdxNextCircle -= i > 0 ? 1 : 0;  		if (firstPointIdxNextCircle >= this.positions.Count) {  			firstPointIdxNextCircle %= this.positions.Count;  			firstPointIdxNextCircle++;  		}  		// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  		for (int j = 1; j < phiDiv - 2; j++) {  			this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  			this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  			this.triangleIndices.Add (firstPointIdx + j + positionsCount);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	// Normal non-selfintersecting Torus  	// Just add Triangle-Strips between all neighboring Cross-Sections  	if (!selfIntersecting) {  		var firstPointIdx = i * phiDiv;  		var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  		for (int j = 0; j < phiDiv; j++) {  			var jNext = (j + 1) % phiDiv;  			this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  			this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  		}  	} // Selfintersecting Torus  	else {  		// Add intermediate Triangles like for the non-selfintersecting Torus  		// Skip the first and last Triangles' the "Caps" will be added later  		// Determine the Index of the first Point of the first Cross-Section  		var firstPointIdx = i * (phiDiv - 2) + 1;  		firstPointIdx += i > 0 ? 1 : 0;  		// Determine the Index of the first Point of the next Cross-Section  		var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  		firstPointIdxNextCircle -= i > 0 ? 1 : 0;  		if (firstPointIdxNextCircle >= this.positions.Count) {  			firstPointIdxNextCircle %= this.positions.Count;  			firstPointIdxNextCircle++;  		}  		// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  		for (int j = 1; j < phiDiv - 2; j++) {  			this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  			this.triangleIndices.Add (firstPointIdx + j + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  			this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  			this.triangleIndices.Add (firstPointIdx + j + positionsCount);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (!selfIntersecting) {  	var firstPointIdx = i * phiDiv;  	var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  	for (int j = 0; j < phiDiv; j++) {  		var jNext = (j + 1) % phiDiv;  		this.triangleIndices.Add (firstPointIdx + j + positionsCount);  		this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  		this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  	}  } // Selfintersecting Torus  else {  	// Add intermediate Triangles like for the non-selfintersecting Torus  	// Skip the first and last Triangles' the "Caps" will be added later  	// Determine the Index of the first Point of the first Cross-Section  	var firstPointIdx = i * (phiDiv - 2) + 1;  	firstPointIdx += i > 0 ? 1 : 0;  	// Determine the Index of the first Point of the next Cross-Section  	var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  	firstPointIdxNextCircle -= i > 0 ? 1 : 0;  	if (firstPointIdxNextCircle >= this.positions.Count) {  		firstPointIdxNextCircle %= this.positions.Count;  		firstPointIdxNextCircle++;  	}  	// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  	for (int j = 1; j < phiDiv - 2; j++) {  		this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  		this.triangleIndices.Add (firstPointIdx + j + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  		this.triangleIndices.Add (firstPointIdx + j + positionsCount);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (!selfIntersecting) {  	var firstPointIdx = i * phiDiv;  	var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;  	for (int j = 0; j < phiDiv; j++) {  		var jNext = (j + 1) % phiDiv;  		this.triangleIndices.Add (firstPointIdx + j + positionsCount);  		this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  		this.triangleIndices.Add (firstPointIdx + jNext + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + jNext + positionsCount);  	}  } // Selfintersecting Torus  else {  	// Add intermediate Triangles like for the non-selfintersecting Torus  	// Skip the first and last Triangles' the "Caps" will be added later  	// Determine the Index of the first Point of the first Cross-Section  	var firstPointIdx = i * (phiDiv - 2) + 1;  	firstPointIdx += i > 0 ? 1 : 0;  	// Determine the Index of the first Point of the next Cross-Section  	var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;  	firstPointIdxNextCircle -= i > 0 ? 1 : 0;  	if (firstPointIdxNextCircle >= this.positions.Count) {  		firstPointIdxNextCircle %= this.positions.Count;  		firstPointIdxNextCircle++;  	}  	// Add Triangles between the "middle" Parts of the neighboring Cross-Sections  	for (int j = 1; j < phiDiv - 2; j++) {  		this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  		this.triangleIndices.Add (firstPointIdx + j + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  		this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  		this.triangleIndices.Add (firstPointIdx + j + positionsCount);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int j = 1; j < phiDiv - 2; j++) {  	this.triangleIndices.Add (firstPointIdx + j - 1 + positionsCount);  	this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  	this.triangleIndices.Add (firstPointIdx + j + positionsCount);  	this.triangleIndices.Add (firstPointIdxNextCircle + j - 1 + positionsCount);  	this.triangleIndices.Add (firstPointIdxNextCircle + j + positionsCount);  	this.triangleIndices.Add (firstPointIdx + j + positionsCount);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (selfIntersecting) {  	// Add bottom Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	var verts = new List<int> ();  	verts.Add (0);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (1 + positionsCount);  		} else {  			verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  		}  	}  	verts.Add (1 + positionsCount);  	verts.Reverse ();  	AddTriangleFan (verts);  	// Add top Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	verts = new List<int> ();  	verts.Add (phiDiv - 1 + positionsCount);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (phiDiv - 2 + positionsCount);  		} else {  			verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  		}  	}  	verts.Add (phiDiv - 2 + positionsCount);  	AddTriangleFan (verts);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (selfIntersecting) {  	// Add bottom Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	var verts = new List<int> ();  	verts.Add (0);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (1 + positionsCount);  		} else {  			verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  		}  	}  	verts.Add (1 + positionsCount);  	verts.Reverse ();  	AddTriangleFan (verts);  	// Add top Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	verts = new List<int> ();  	verts.Add (phiDiv - 1 + positionsCount);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (phiDiv - 2 + positionsCount);  		} else {  			verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  		}  	}  	verts.Add (phiDiv - 2 + positionsCount);  	AddTriangleFan (verts);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (selfIntersecting) {  	// Add bottom Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	var verts = new List<int> ();  	verts.Add (0);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (1 + positionsCount);  		} else {  			verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  		}  	}  	verts.Add (1 + positionsCount);  	verts.Reverse ();  	AddTriangleFan (verts);  	// Add top Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	verts = new List<int> ();  	verts.Add (phiDiv - 1 + positionsCount);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (phiDiv - 2 + positionsCount);  		} else {  			verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  		}  	}  	verts.Add (phiDiv - 2 + positionsCount);  	AddTriangleFan (verts);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (selfIntersecting) {  	// Add bottom Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	var verts = new List<int> ();  	verts.Add (0);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (1 + positionsCount);  		} else {  			verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  		}  	}  	verts.Add (1 + positionsCount);  	verts.Reverse ();  	AddTriangleFan (verts);  	// Add top Cap by creating a List of Vertex-Indices  	// and using them to create a Triangle-Fan  	verts = new List<int> ();  	verts.Add (phiDiv - 1 + positionsCount);  	for (int i = 0; i < thetaDiv; i++) {  		if (i == 0) {  			verts.Add (phiDiv - 2 + positionsCount);  		} else {  			verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  		}  	}  	verts.Add (phiDiv - 2 + positionsCount);  	AddTriangleFan (verts);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	if (i == 0) {  		verts.Add (1 + positionsCount);  	} else {  		verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (i == 0) {  	verts.Add (1 + positionsCount);  } else {  	verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: verts.Add (phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	if (i == 0) {  		verts.Add (phiDiv - 2 + positionsCount);  	} else {  		verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++) {  	if (i == 0) {  		verts.Add (phiDiv - 2 + positionsCount);  	} else {  		verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (i == 0) {  	verts.Add (phiDiv - 2 + positionsCount);  } else {  	verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (i == 0) {  	verts.Add (phiDiv - 2 + positionsCount);  } else {  	verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: verts.Add (phiDiv - 2 + positionsCount);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: verts.Add (phiDiv + i * (phiDiv - 2) - 1 + positionsCount);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: verts.Add (phiDiv - 2 + positionsCount);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	this.triangleIndices.Add (vertexIndices [i]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The following statement contains a magic number: this.triangleIndices.Add (i0 + 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = 0; i + 2 < vertices.Count; i++) {  	this.triangleIndices.Add (vertices [0]);  	this.triangleIndices.Add (vertices [i + 1]);  	this.triangleIndices.Add (vertices [i + 2]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = 0; i + 2 < vertices.Count; i++) {  	this.triangleIndices.Add (vertices [0]);  	this.triangleIndices.Add (vertices [i + 1]);  	this.triangleIndices.Add (vertices [i + 2]);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: this.triangleIndices.Add (vertices [i + 2]);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i++) {  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i++) {  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: this.triangleIndices.Add (i + 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangles,The following statement contains a magic number: if (trianglePositions.Count % 3 != 0) {  	throw new InvalidOperationException (WrongNumberOfPositions);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	if (i + 3 < indexEnd) {  		this.triangleIndices.Add (i + 1);  		this.triangleIndices.Add (i + 3);  		this.triangleIndices.Add (i + 2);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	if (i + 3 < indexEnd) {  		this.triangleIndices.Add (i + 1);  		this.triangleIndices.Add (i + 3);  		this.triangleIndices.Add (i + 2);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	if (i + 3 < indexEnd) {  		this.triangleIndices.Add (i + 1);  		this.triangleIndices.Add (i + 3);  		this.triangleIndices.Add (i + 2);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	if (i + 3 < indexEnd) {  		this.triangleIndices.Add (i + 1);  		this.triangleIndices.Add (i + 3);  		this.triangleIndices.Add (i + 2);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	if (i + 3 < indexEnd) {  		this.triangleIndices.Add (i + 1);  		this.triangleIndices.Add (i + 3);  		this.triangleIndices.Add (i + 2);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2) {  	this.triangleIndices.Add (i);  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 2);  	if (i + 3 < indexEnd) {  		this.triangleIndices.Add (i + 1);  		this.triangleIndices.Add (i + 3);  		this.triangleIndices.Add (i + 2);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: i += 2
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: this.triangleIndices.Add (i + 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: if (i + 3 < indexEnd) {  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 3);  	this.triangleIndices.Add (i + 2);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: if (i + 3 < indexEnd) {  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 3);  	this.triangleIndices.Add (i + 2);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: if (i + 3 < indexEnd) {  	this.triangleIndices.Add (i + 1);  	this.triangleIndices.Add (i + 3);  	this.triangleIndices.Add (i + 2);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: this.triangleIndices.Add (i + 3);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: this.triangleIndices.Add (i + 2);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2) {  	return;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2) {  	return;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: for (int i = 0; i < pathLength; i++) {  	var r = diameters != null ? (DoubleOrSingle)diameters [i % diametersCount] / 2 : 1;  	int i0 = i > 0 ? i - 1 : i;  	int i1 = i + 1 < pathLength ? i + 1 : i;  	var forward = path [i1] - path [i0];  	var right = SharedFunctions.CrossProduct (ref up' ref forward);  	up = SharedFunctions.CrossProduct (ref forward' ref right);  	up.Normalize ();  	right.Normalize ();  	var u = right;  	var v = up;  	//*******************************  	//*** PROPOSED SOLUTION *********  	// ** I think this will work because if path[n-1] is same point'   	// ** it is always a reflection of the current move  	// ** so reversing the last move vector should work?  	//*******************************  	if (u.IsUndefined () || v.IsUndefined ()) {  		forward = lastForward;  		forward *= -1;  		up = lastUp;  		//** Please verify that negation of "up" is correct here  		up *= -1;  		right = SharedFunctions.CrossProduct (ref up' ref forward);  		up.Normalize ();  		right.Normalize ();  		u = right;  		v = up;  	}  	lastForward = forward;  	lastUp = up;  	//*** PROPOSED SOLUTION *********  	//*******************************  	for (int j = 0; j < sectionLength; j++) {  		var w = (section [j].X * u * r) + (section [j].Y * v * r);  		var q = path [i] + w;  		this.positions.Add (q);  		if (this.normals != null) {  			w.Normalize ();  			this.normals.Add (w);  		}  		if (this.textureCoordinates != null) {  			this.textureCoordinates.Add (values != null ? new Point ((DoubleOrSingle)values [i % valuesCount]' (DoubleOrSingle)j / (sectionLength - 1)) : new Point ());  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (frontCap || backCap && path.Count > 1) {  	var normals = new Vector3D[section.Count];  	var fanTextures = new Point[section.Count];  	var count = path.Count;  	if (backCap) {  		var circleBack = Positions.Skip (Positions.Count - section.Count).Take (section.Count).Reverse ().ToArray ();  		var normal = path [count - 1] - path [count - 2];  		normal.Normalize ();  		for (int i = 0; i < normals.Length; ++i) {  			normals [i] = normal;  		}  		this.AddTriangleFan (circleBack' normals' fanTextures);  	}  	if (frontCap) {  		var circleFront = Positions.Take (section.Count).ToArray ();  		var normal = path [0] - path [1];  		normal.Normalize ();  		for (int i = 0; i < normals.Length; ++i) {  			normals [i] = normal;  		}  		this.AddTriangleFan (circleFront' normals' fanTextures);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (backCap) {  	var circleBack = Positions.Skip (Positions.Count - section.Count).Take (section.Count).Reverse ().ToArray ();  	var normal = path [count - 1] - path [count - 2];  	normal.Normalize ();  	for (int i = 0; i < normals.Length; ++i) {  		normals [i] = normal;  	}  	this.AddTriangleFan (circleBack' normals' fanTextures);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2) {  	return;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2) {  	return;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: for (int i = 0; i < pathLength; i++) {  	var radius = diameters != null ? (DoubleOrSingle)diameters [i % diametersCount] / 2 : 1;  	var theta = angles != null ? (DoubleOrSingle)angles [i % anglesCount] : 0.0;  	var ct = (DoubleOrSingle)Math.Cos (theta);  	var st = (DoubleOrSingle)Math.Sin (theta);  	int i0 = i > 0 ? i - 1 : i;  	int i1 = i + 1 < pathLength ? i + 1 : i;  	forward = path [i1] - path [i0];  	right = SharedFunctions.CrossProduct (ref up' ref forward);  	if (SharedFunctions.LengthSquared (ref right) > 1e-6f) {  		up = SharedFunctions.CrossProduct (ref forward' ref right);  	}  	up.Normalize ();  	right.Normalize ();  	for (int j = 0; j < sectionLength; j++) {  		var x = (section [j].X * ct) - (section [j].Y * st);  		var y = (section [j].X * st) + (section [j].Y * ct);  		var w = (x * right * radius) + (y * up * radius);  		var q = path [i] + w;  		this.positions.Add (q);  		if (this.normals != null) {  			w.Normalize ();  			this.normals.Add (w);  		}  		if (this.textureCoordinates != null) {  			this.textureCoordinates.Add (values != null ? new Point ((DoubleOrSingle)values [i % valuesCount]' (DoubleOrSingle)j / (sectionLength - 1)) : new Point ());  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (frontCap || backCap && path.Count > 1) {  	var normals = new Vector3D[section.Count];  	var fanTextures = new Point[section.Count];  	var count = path.Count;  	if (backCap) {  		var circleBack = Positions.Skip (Positions.Count - section.Count).Take (section.Count).Reverse ().ToArray ();  		var normal = path [count - 1] - path [count - 2];  		normal.Normalize ();  		for (int i = 0; i < normals.Length; ++i) {  			normals [i] = normal;  		}  		this.AddTriangleFan (circleBack' normals' fanTextures);  	}  	if (frontCap) {  		var circleFront = Positions.Take (section.Count).ToArray ();  		var normal = path [0] - path [1];  		normal.Normalize ();  		for (int i = 0; i < normals.Length; ++i) {  			normals [i] = normal;  		}  		this.AddTriangleFan (circleFront' normals' fanTextures);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (backCap) {  	var circleBack = Positions.Skip (Positions.Count - section.Count).Take (section.Count).Reverse ().ToArray ();  	var normal = path [count - 1] - path [count - 2];  	normal.Normalize ();  	for (int i = 0; i < normals.Length; ++i) {  		normals [i] = normal;  	}  	this.AddTriangleFan (circleBack' normals' fanTextures);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	var p0 = this.positions [this.triangleIndices [i0]];  	var p1 = this.positions [this.triangleIndices [i1]];  	var p2 = this.positions [this.triangleIndices [i2]];  	var pp0 = p - p0;  	var pp1 = p - p1;  	var pp2 = p - p2;  	var d0 = SharedFunctions.LengthSquared (ref pp0);  	var d1 = SharedFunctions.LengthSquared (ref pp1);  	var d2 = SharedFunctions.LengthSquared (ref pp2);  	var mind = Math.Min (d0' Math.Min (d1' d2));  	if (mind > eps) {  		continue;  	}  	if (d1 < eps) {  		i0 = i + 1;  		i1 = i + 2;  		i2 = i;  	}  	if (d2 < eps) {  		i0 = i + 2;  		i1 = i;  		i2 = i + 1;  	}  	p0 = this.positions [this.triangleIndices [i0]];  	p1 = this.positions [this.triangleIndices [i1]];  	p2 = this.positions [this.triangleIndices [i2]];  	// origin is the corner vertex (at index i0)  	// find the intersections between the chamfer plane and the two edges connected to the corner  	var p01 = plane.LineIntersection (p0' p1);  	var p02 = plane.LineIntersection (p0' p2);  	if (p01 == null) {  		continue;  	}  	if (p02 == null) {  		continue;  	}  	if (chamferPoints != null) {  		// add the chamfered points  		if (!chamferPoints.Contains (p01.Value)) {  			chamferPoints.Add (p01.Value);  		}  		if (!chamferPoints.Contains (p02.Value)) {  			chamferPoints.Add (p02.Value);  		}  	}  	int i01 = i0;  	// change the original triangle to use the first chamfer point  	this.positions [this.triangleIndices [i01]] = p01.Value;  	int i02 = this.positions.Count;  	this.positions.Add (p02.Value);  	// add a new triangle for the other chamfer point  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i02);  	// add a triangle connecting the chamfer points and the new corner point  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i02);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	var p0 = this.positions [this.triangleIndices [i0]];  	var p1 = this.positions [this.triangleIndices [i1]];  	var p2 = this.positions [this.triangleIndices [i2]];  	var pp0 = p - p0;  	var pp1 = p - p1;  	var pp2 = p - p2;  	var d0 = SharedFunctions.LengthSquared (ref pp0);  	var d1 = SharedFunctions.LengthSquared (ref pp1);  	var d2 = SharedFunctions.LengthSquared (ref pp2);  	var mind = Math.Min (d0' Math.Min (d1' d2));  	if (mind > eps) {  		continue;  	}  	if (d1 < eps) {  		i0 = i + 1;  		i1 = i + 2;  		i2 = i;  	}  	if (d2 < eps) {  		i0 = i + 2;  		i1 = i;  		i2 = i + 1;  	}  	p0 = this.positions [this.triangleIndices [i0]];  	p1 = this.positions [this.triangleIndices [i1]];  	p2 = this.positions [this.triangleIndices [i2]];  	// origin is the corner vertex (at index i0)  	// find the intersections between the chamfer plane and the two edges connected to the corner  	var p01 = plane.LineIntersection (p0' p1);  	var p02 = plane.LineIntersection (p0' p2);  	if (p01 == null) {  		continue;  	}  	if (p02 == null) {  		continue;  	}  	if (chamferPoints != null) {  		// add the chamfered points  		if (!chamferPoints.Contains (p01.Value)) {  			chamferPoints.Add (p01.Value);  		}  		if (!chamferPoints.Contains (p02.Value)) {  			chamferPoints.Add (p02.Value);  		}  	}  	int i01 = i0;  	// change the original triangle to use the first chamfer point  	this.positions [this.triangleIndices [i01]] = p01.Value;  	int i02 = this.positions.Count;  	this.positions.Add (p02.Value);  	// add a new triangle for the other chamfer point  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i02);  	// add a triangle connecting the chamfer points and the new corner point  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i02);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	var p0 = this.positions [this.triangleIndices [i0]];  	var p1 = this.positions [this.triangleIndices [i1]];  	var p2 = this.positions [this.triangleIndices [i2]];  	var pp0 = p - p0;  	var pp1 = p - p1;  	var pp2 = p - p2;  	var d0 = SharedFunctions.LengthSquared (ref pp0);  	var d1 = SharedFunctions.LengthSquared (ref pp1);  	var d2 = SharedFunctions.LengthSquared (ref pp2);  	var mind = Math.Min (d0' Math.Min (d1' d2));  	if (mind > eps) {  		continue;  	}  	if (d1 < eps) {  		i0 = i + 1;  		i1 = i + 2;  		i2 = i;  	}  	if (d2 < eps) {  		i0 = i + 2;  		i1 = i;  		i2 = i + 1;  	}  	p0 = this.positions [this.triangleIndices [i0]];  	p1 = this.positions [this.triangleIndices [i1]];  	p2 = this.positions [this.triangleIndices [i2]];  	// origin is the corner vertex (at index i0)  	// find the intersections between the chamfer plane and the two edges connected to the corner  	var p01 = plane.LineIntersection (p0' p1);  	var p02 = plane.LineIntersection (p0' p2);  	if (p01 == null) {  		continue;  	}  	if (p02 == null) {  		continue;  	}  	if (chamferPoints != null) {  		// add the chamfered points  		if (!chamferPoints.Contains (p01.Value)) {  			chamferPoints.Add (p01.Value);  		}  		if (!chamferPoints.Contains (p02.Value)) {  			chamferPoints.Add (p02.Value);  		}  	}  	int i01 = i0;  	// change the original triangle to use the first chamfer point  	this.positions [this.triangleIndices [i01]] = p01.Value;  	int i02 = this.positions.Count;  	this.positions.Add (p02.Value);  	// add a new triangle for the other chamfer point  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i02);  	// add a triangle connecting the chamfer points and the new corner point  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i02);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	var p0 = this.positions [this.triangleIndices [i0]];  	var p1 = this.positions [this.triangleIndices [i1]];  	var p2 = this.positions [this.triangleIndices [i2]];  	var pp0 = p - p0;  	var pp1 = p - p1;  	var pp2 = p - p2;  	var d0 = SharedFunctions.LengthSquared (ref pp0);  	var d1 = SharedFunctions.LengthSquared (ref pp1);  	var d2 = SharedFunctions.LengthSquared (ref pp2);  	var mind = Math.Min (d0' Math.Min (d1' d2));  	if (mind > eps) {  		continue;  	}  	if (d1 < eps) {  		i0 = i + 1;  		i1 = i + 2;  		i2 = i;  	}  	if (d2 < eps) {  		i0 = i + 2;  		i1 = i;  		i2 = i + 1;  	}  	p0 = this.positions [this.triangleIndices [i0]];  	p1 = this.positions [this.triangleIndices [i1]];  	p2 = this.positions [this.triangleIndices [i2]];  	// origin is the corner vertex (at index i0)  	// find the intersections between the chamfer plane and the two edges connected to the corner  	var p01 = plane.LineIntersection (p0' p1);  	var p02 = plane.LineIntersection (p0' p2);  	if (p01 == null) {  		continue;  	}  	if (p02 == null) {  		continue;  	}  	if (chamferPoints != null) {  		// add the chamfered points  		if (!chamferPoints.Contains (p01.Value)) {  			chamferPoints.Add (p01.Value);  		}  		if (!chamferPoints.Contains (p02.Value)) {  			chamferPoints.Add (p02.Value);  		}  	}  	int i01 = i0;  	// change the original triangle to use the first chamfer point  	this.positions [this.triangleIndices [i01]] = p01.Value;  	int i02 = this.positions.Count;  	this.positions.Add (p02.Value);  	// add a new triangle for the other chamfer point  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i2);  	this.triangleIndices.Add (i02);  	// add a triangle connecting the chamfer points and the new corner point  	this.triangleIndices.Add (index0);  	this.triangleIndices.Add (i01);  	this.triangleIndices.Add (i02);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: if (d1 < eps) {  	i0 = i + 1;  	i1 = i + 2;  	i2 = i;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: i1 = i + 2;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: if (d2 < eps) {  	i0 = i + 2;  	i1 = i;  	i2 = i + 1;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: i0 = i + 2;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,CheckPerformanceLimits,The following statement contains a magic number: if (this.positions.Count > 20000) {  	Trace.WriteLine (string.Format ("Too many positions ({0})."' this.positions.Count));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,CheckPerformanceLimits,The following statement contains a magic number: if (this.triangleIndices.Count > 60002) {  	Trace.WriteLine (string.Format ("Too many triangle indices ({0})."' this.triangleIndices.Count));  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,FindCornerNormal,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	var p0 = this.positions [this.triangleIndices [i0]];  	var p1 = this.positions [this.triangleIndices [i1]];  	var p2 = this.positions [this.triangleIndices [i2]];  	// check if any of the vertices are on the corner  	var pp0 = p - p0;  	var pp1 = p - p1;  	var pp2 = p - p2;  	var d0 = SharedFunctions.LengthSquared (ref pp0);  	var d1 = SharedFunctions.LengthSquared (ref pp1);  	var d2 = SharedFunctions.LengthSquared (ref pp2);  	var mind = Math.Min (d0' Math.Min (d1' d2));  	if (mind > eps) {  		continue;  	}  	// calculate the triangle normal and check if this face is already added  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var normal = SharedFunctions.CrossProduct (ref p10' ref p20);  	normal.Normalize ();  	// todo: need to use the epsilon value to compare the normals?  	if (addedNormals.Contains (normal)) {  		continue;  	}  	// todo: this does not work yet  	// double dp = 1;  	// foreach (var n in addedNormals)  	// {  	// dp = Math.Abs(Vector3D.DotProduct(n' normal) - 1);  	// if (dp < eps)  	// continue;  	// }  	// if (dp < eps)  	// {  	// continue;  	// }  	count++;  	sum += normal;  	addedNormals.Add (normal);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,FindCornerNormal,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	var p0 = this.positions [this.triangleIndices [i0]];  	var p1 = this.positions [this.triangleIndices [i1]];  	var p2 = this.positions [this.triangleIndices [i2]];  	// check if any of the vertices are on the corner  	var pp0 = p - p0;  	var pp1 = p - p1;  	var pp2 = p - p2;  	var d0 = SharedFunctions.LengthSquared (ref pp0);  	var d1 = SharedFunctions.LengthSquared (ref pp1);  	var d2 = SharedFunctions.LengthSquared (ref pp2);  	var mind = Math.Min (d0' Math.Min (d1' d2));  	if (mind > eps) {  		continue;  	}  	// calculate the triangle normal and check if this face is already added  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var normal = SharedFunctions.CrossProduct (ref p10' ref p20);  	normal.Normalize ();  	// todo: need to use the epsilon value to compare the normals?  	if (addedNormals.Contains (normal)) {  		continue;  	}  	// todo: this does not work yet  	// double dp = 1;  	// foreach (var n in addedNormals)  	// {  	// dp = Math.Abs(Vector3D.DotProduct(n' normal) - 1);  	// if (dp < eps)  	// continue;  	// }  	// if (dp < eps)  	// {  	// continue;  	// }  	count++;  	sum += normal;  	addedNormals.Add (normal);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,FindCornerNormal,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	int index0 = this.triangleIndices [i0];  	int index1 = this.triangleIndices [i1];  	int index2 = this.triangleIndices [i2];  	var p0 = this.positions [index0];  	var p1 = this.positions [index1];  	var p2 = this.positions [index2];  	p.Add (p0);  	p.Add (p1);  	p.Add (p2);  	ti.Add (i0);  	ti.Add (i1);  	ti.Add (i2);  	if (n != null) {  		n.Add (this.normals [index0]);  		n.Add (this.normals [index1]);  		n.Add (this.normals [index2]);  	}  	if (tc != null) {  		tc.Add (this.textureCoordinates [index0]);  		tc.Add (this.textureCoordinates [index1]);  		tc.Add (this.textureCoordinates [index2]);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	int index0 = this.triangleIndices [i0];  	int index1 = this.triangleIndices [i1];  	int index2 = this.triangleIndices [i2];  	var p0 = this.positions [index0];  	var p1 = this.positions [index1];  	var p2 = this.positions [index2];  	p.Add (p0);  	p.Add (p1);  	p.Add (p2);  	ti.Add (i0);  	ti.Add (i1);  	ti.Add (i2);  	if (n != null) {  		n.Add (this.normals [index0]);  		n.Add (this.normals [index1]);  		n.Add (this.normals [index2]);  	}  	if (tc != null) {  		tc.Add (this.textureCoordinates [index0]);  		tc.Add (this.textureCoordinates [index1]);  		tc.Add (this.textureCoordinates [index2]);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,NoSharedVertices,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	int i01 = ip++;  	int i12 = ip++;  	int i20 = ip++;  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = i20;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i20);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	int i01 = ip++;  	int i12 = ip++;  	int i20 = ip++;  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = i20;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i20);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	int i01 = ip++;  	int i12 = ip++;  	int i20 = ip++;  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = i20;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i20);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	int i01 = ip++;  	int i12 = ip++;  	int i20 = ip++;  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = i20;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i20);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: if (this.textureCoordinates != null) {  	var uv0 = this.TextureCoordinates [i0];  	var uv1 = this.TextureCoordinates [i0 + 1];  	var uv2 = this.TextureCoordinates [i0 + 2];  	var t01 = uv1 - uv0;  	var t12 = uv2 - uv1;  	var t20 = uv0 - uv2;  	var u01 = uv0 + (t01 * 0.5f);  	var u12 = uv1 + (t12 * 0.5f);  	var u20 = uv2 + (t20 * 0.5f);  	this.TextureCoordinates.Add (u01);  	this.TextureCoordinates.Add (u12);  	this.TextureCoordinates.Add (u20);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: this.TriangleIndices [i + 2] = i20;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3) {  	int i0 = this.TriangleIndices [i];  	int i1 = this.TriangleIndices [i + 1];  	int i2 = this.TriangleIndices [i + 2];  	var p0 = this.Positions [i0];  	var p1 = this.Positions [i1];  	var p2 = this.Positions [i2];  	var v01 = p1 - p0;  	var v12 = p2 - p1;  	var v20 = p0 - p2;  	var p01 = p0 + (v01 * 0.5f);  	var p12 = p1 + (v12 * 0.5f);  	var p20 = p2 + (v20 * 0.5f);  	var m = new Point3D ((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);  	int i01 = im + 1;  	int i12 = im + 2;  	int i20 = im + 3;  	this.Positions.Add (m);  	this.Positions.Add (p01);  	this.Positions.Add (p12);  	this.Positions.Add (p20);  	if (this.normals != null) {  		var n = this.Normals [i0];  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  		this.Normals.Add (n);  	}  	if (this.textureCoordinates != null) {  		var uv0 = this.TextureCoordinates [i0];  		var uv1 = this.TextureCoordinates [i0 + 1];  		var uv2 = this.TextureCoordinates [i0 + 2];  		var t01 = uv1 - uv0;  		var t12 = uv2 - uv1;  		var t20 = uv0 - uv2;  		var u01 = uv0 + (t01 * 0.5f);  		var u12 = uv1 + (t12 * 0.5f);  		var u20 = uv2 + (t20 * 0.5f);  		var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  		this.TextureCoordinates.Add (uvm);  		this.TextureCoordinates.Add (u01);  		this.TextureCoordinates.Add (u12);  		this.TextureCoordinates.Add (u20);  	}  	// TriangleIndices[i ] = i0;  	this.TriangleIndices [i + 1] = i01;  	this.TriangleIndices [i + 2] = im;  	this.TriangleIndices.Add (i01);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i1);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i12);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i2);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (im);  	this.TriangleIndices.Add (i20);  	this.TriangleIndices.Add (i0);  	this.TriangleIndices.Add (im);  	im += 4;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: if (this.textureCoordinates != null) {  	var uv0 = this.TextureCoordinates [i0];  	var uv1 = this.TextureCoordinates [i0 + 1];  	var uv2 = this.TextureCoordinates [i0 + 2];  	var t01 = uv1 - uv0;  	var t12 = uv2 - uv1;  	var t20 = uv0 - uv2;  	var u01 = uv0 + (t01 * 0.5f);  	var u12 = uv1 + (t12 * 0.5f);  	var u20 = uv2 + (t20 * 0.5f);  	var uvm = new Point ((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);  	this.TextureCoordinates.Add (uvm);  	this.TextureCoordinates.Add (u01);  	this.TextureCoordinates.Add (u12);  	this.TextureCoordinates.Add (u20);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: this.TriangleIndices [i + 2] = im;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: im += 4;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < triangleIndices.Count; i += 3) {  	int index0 = triangleIndices [i];  	int index1 = triangleIndices [i + 1];  	int index2 = triangleIndices [i + 2];  	var p0 = positions [index0];  	var p1 = positions [index1];  	var p2 = positions [index2];  	Vector3D u = p1 - p0;  	Vector3D v = p2 - p0;  	Vector3D w = SharedFunctions.CrossProduct (ref u' ref v);  	w.Normalize ();  	normals [index0] += w;  	normals [index1] += w;  	normals [index2] += w;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < triangleIndices.Count; i += 3) {  	int index0 = triangleIndices [i];  	int index1 = triangleIndices [i + 1];  	int index2 = triangleIndices [i + 2];  	var p0 = positions [index0];  	var p1 = positions [index1];  	var p2 = positions [index2];  	Vector3D u = p1 - p0;  	Vector3D v = p2 - p0;  	Vector3D w = SharedFunctions.CrossProduct (ref u' ref v);  	w.Normalize ();  	normals [index0] += w;  	normals [index1] += w;  	normals [index2] += w;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CalculateNormals,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (dict.ContainsKey (key)) {  			dict [key] = dict [key] + 1;  		} else {  			dict.Add (key' 1);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (dict.ContainsKey (key)) {  			dict [key] = dict [key] + 1;  		} else {  			dict.Add (key' 1);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (dict.ContainsKey (key)) {  			dict [key] = dict [key] + 1;  		} else {  			dict.Add (key' 1);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (dict.ContainsKey (key)) {  			dict [key] = dict [key] + 1;  		} else {  			dict.Add (key' 1);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int j = 0; j < 3; j++) {  	int index0 = mesh.TriangleIndices [i0 + j];  	int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  	int minIndex = Math.Min (index0' index1);  	int maxIndex = Math.Max (index1' index0);  	ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  	if (dict.ContainsKey (key)) {  		dict [key] = dict [key] + 1;  	} else {  		dict.Add (key' 1);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int j = 0; j < 3; j++) {  	int index0 = mesh.TriangleIndices [i0 + j];  	int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  	int minIndex = Math.Min (index0' index1);  	int maxIndex = Math.Max (index1' index0);  	ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  	if (dict.ContainsKey (key)) {  		dict [key] = dict [key] + 1;  	} else {  		dict.Add (key' 1);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (!dict.Contains (key)) {  			edges.Add (minIndex);  			edges.Add (maxIndex);  			dict.Add (key);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (!dict.Contains (key)) {  			edges.Add (minIndex);  			edges.Add (maxIndex);  			dict.Add (key);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (!dict.Contains (key)) {  			edges.Add (minIndex);  			edges.Add (maxIndex);  			dict.Add (key);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index1' index0);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		if (!dict.Contains (key)) {  			edges.Add (minIndex);  			edges.Add (maxIndex);  			dict.Add (key);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int j = 0; j < 3; j++) {  	int index0 = mesh.TriangleIndices [i0 + j];  	int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  	int minIndex = Math.Min (index0' index1);  	int maxIndex = Math.Max (index1' index0);  	ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  	if (!dict.Contains (key)) {  		edges.Add (minIndex);  		edges.Add (maxIndex);  		dict.Add (key);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int j = 0; j < 3; j++) {  	int index0 = mesh.TriangleIndices [i0 + j];  	int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  	int minIndex = Math.Min (index0' index1);  	int maxIndex = Math.Max (index1' index0);  	ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  	if (!dict.Contains (key)) {  		edges.Add (minIndex);  		edges.Add (maxIndex);  		dict.Add (key);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	var p0 = mesh.Positions [mesh.TriangleIndices [i0]];  	var p1 = mesh.Positions [mesh.TriangleIndices [i0 + 1]];  	var p2 = mesh.Positions [mesh.TriangleIndices [i0 + 2]];  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var n = SharedFunctions.CrossProduct (ref p10' ref p20);  	n.Normalize ();  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index0' index1);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		Vector3D value;  		if (edgeNormals.TryGetValue (key' out value)) {  			var n2 = value;  			n2.Normalize ();  			var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  			if (angle > minimumAngle) {  				edgeIndices.Add (minIndex);  				edgeIndices.Add (maxIndex);  			}  		} else {  			edgeNormals.Add (key' n);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	var p0 = mesh.Positions [mesh.TriangleIndices [i0]];  	var p1 = mesh.Positions [mesh.TriangleIndices [i0 + 1]];  	var p2 = mesh.Positions [mesh.TriangleIndices [i0 + 2]];  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var n = SharedFunctions.CrossProduct (ref p10' ref p20);  	n.Normalize ();  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index0' index1);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		Vector3D value;  		if (edgeNormals.TryGetValue (key' out value)) {  			var n2 = value;  			n2.Normalize ();  			var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  			if (angle > minimumAngle) {  				edgeIndices.Add (minIndex);  				edgeIndices.Add (maxIndex);  			}  		} else {  			edgeNormals.Add (key' n);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	var p0 = mesh.Positions [mesh.TriangleIndices [i0]];  	var p1 = mesh.Positions [mesh.TriangleIndices [i0 + 1]];  	var p2 = mesh.Positions [mesh.TriangleIndices [i0 + 2]];  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var n = SharedFunctions.CrossProduct (ref p10' ref p20);  	n.Normalize ();  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index0' index1);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		Vector3D value;  		if (edgeNormals.TryGetValue (key' out value)) {  			var n2 = value;  			n2.Normalize ();  			var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  			if (angle > minimumAngle) {  				edgeIndices.Add (minIndex);  				edgeIndices.Add (maxIndex);  			}  		} else {  			edgeNormals.Add (key' n);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	var p0 = mesh.Positions [mesh.TriangleIndices [i0]];  	var p1 = mesh.Positions [mesh.TriangleIndices [i0 + 1]];  	var p2 = mesh.Positions [mesh.TriangleIndices [i0 + 2]];  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var n = SharedFunctions.CrossProduct (ref p10' ref p20);  	n.Normalize ();  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index0' index1);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		Vector3D value;  		if (edgeNormals.TryGetValue (key' out value)) {  			var n2 = value;  			n2.Normalize ();  			var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  			if (angle > minimumAngle) {  				edgeIndices.Add (minIndex);  				edgeIndices.Add (maxIndex);  			}  		} else {  			edgeNormals.Add (key' n);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	var p0 = mesh.Positions [mesh.TriangleIndices [i0]];  	var p1 = mesh.Positions [mesh.TriangleIndices [i0 + 1]];  	var p2 = mesh.Positions [mesh.TriangleIndices [i0 + 2]];  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var n = SharedFunctions.CrossProduct (ref p10' ref p20);  	n.Normalize ();  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index0' index1);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		Vector3D value;  		if (edgeNormals.TryGetValue (key' out value)) {  			var n2 = value;  			n2.Normalize ();  			var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  			if (angle > minimumAngle) {  				edgeIndices.Add (minIndex);  				edgeIndices.Add (maxIndex);  			}  		} else {  			edgeNormals.Add (key' n);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++) {  	int i0 = i * 3;  	var p0 = mesh.Positions [mesh.TriangleIndices [i0]];  	var p1 = mesh.Positions [mesh.TriangleIndices [i0 + 1]];  	var p2 = mesh.Positions [mesh.TriangleIndices [i0 + 2]];  	var p10 = p1 - p0;  	var p20 = p2 - p0;  	var n = SharedFunctions.CrossProduct (ref p10' ref p20);  	n.Normalize ();  	for (int j = 0; j < 3; j++) {  		int index0 = mesh.TriangleIndices [i0 + j];  		int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  		int minIndex = Math.Min (index0' index1);  		int maxIndex = Math.Max (index0' index1);  		ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  		Vector3D value;  		if (edgeNormals.TryGetValue (key' out value)) {  			var n2 = value;  			n2.Normalize ();  			var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  			if (angle > minimumAngle) {  				edgeIndices.Add (minIndex);  				edgeIndices.Add (maxIndex);  			}  		} else {  			edgeNormals.Add (key' n);  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int j = 0; j < 3; j++) {  	int index0 = mesh.TriangleIndices [i0 + j];  	int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  	int minIndex = Math.Min (index0' index1);  	int maxIndex = Math.Max (index0' index1);  	ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  	Vector3D value;  	if (edgeNormals.TryGetValue (key' out value)) {  		var n2 = value;  		n2.Normalize ();  		var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  		if (angle > minimumAngle) {  			edgeIndices.Add (minIndex);  			edgeIndices.Add (maxIndex);  		}  	} else {  		edgeNormals.Add (key' n);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int j = 0; j < 3; j++) {  	int index0 = mesh.TriangleIndices [i0 + j];  	int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  	int minIndex = Math.Min (index0' index1);  	int maxIndex = Math.Max (index0' index1);  	ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  	Vector3D value;  	if (edgeNormals.TryGetValue (key' out value)) {  		var n2 = value;  		n2.Normalize ();  		var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  		if (angle > minimumAngle) {  			edgeIndices.Add (minIndex);  			edgeIndices.Add (maxIndex);  		}  	} else {  		edgeNormals.Add (key' n);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int j = 0; j < 3; j++) {  	int index0 = mesh.TriangleIndices [i0 + j];  	int index1 = mesh.TriangleIndices [i0 + ((j + 1) % 3)];  	int minIndex = Math.Min (index0' index1);  	int maxIndex = Math.Max (index0' index1);  	ulong key = CreateKey ((uint)minIndex' (uint)maxIndex);  	Vector3D value;  	if (edgeNormals.TryGetValue (key' out value)) {  		var n2 = value;  		n2.Normalize ();  		var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  		if (angle > minimumAngle) {  			edgeIndices.Add (minIndex);  			edgeIndices.Add (maxIndex);  		}  	} else {  		edgeNormals.Add (key' n);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: if (edgeNormals.TryGetValue (key' out value)) {  	var n2 = value;  	n2.Normalize ();  	var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos (SharedFunctions.DotProduct (ref n' ref n2));  	if (angle > minimumAngle) {  		edgeIndices.Add (minIndex);  		edgeIndices.Add (maxIndex);  	}  } else {  	edgeNormals.Add (key' n);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < input.TriangleIndices.Count; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	int index0 = input.TriangleIndices [i0];  	int index1 = input.TriangleIndices [i1];  	int index2 = input.TriangleIndices [i2];  	var p0 = input.Positions [index0];  	var p1 = input.Positions [index1];  	var p2 = input.Positions [index2];  	p.Add (p0);  	p.Add (p1);  	p.Add (p2);  	ti.Add (i0);  	ti.Add (i1);  	ti.Add (i2);  	if (n != null) {  		n.Add (input.Normals [index0]);  		n.Add (input.Normals [index1]);  		n.Add (input.Normals [index2]);  	}  	if (tc != null) {  		tc.Add (input.TextureCoordinates [index0]);  		tc.Add (input.TextureCoordinates [index1]);  		tc.Add (input.TextureCoordinates [index2]);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < input.TriangleIndices.Count; i += 3) {  	int i0 = i;  	int i1 = i + 1;  	int i2 = i + 2;  	int index0 = input.TriangleIndices [i0];  	int index1 = input.TriangleIndices [i1];  	int index2 = input.TriangleIndices [i2];  	var p0 = input.Positions [index0];  	var p1 = input.Positions [index1];  	var p2 = input.Positions [index2];  	p.Add (p0);  	p.Add (p1);  	p.Add (p2);  	ti.Add (i0);  	ti.Add (i1);  	ti.Add (i2);  	if (n != null) {  		n.Add (input.Normals [index0]);  		n.Add (input.Normals [index1]);  		n.Add (input.Normals [index2]);  	}  	if (tc != null) {  		tc.Add (input.TextureCoordinates [index0]);  		tc.Add (input.TextureCoordinates [index1]);  		tc.Add (input.TextureCoordinates [index2]);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: if (mesh.TriangleIndices.Count % 3 != 0) {  	sb.AppendLine ("TriangleIndices not complete");  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i++) {  	int index = mesh.TriangleIndices [i];  	if (index < 0 || index >= mesh.Positions.Count) {  		sb.AppendFormat ("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);  		sb.AppendLine ();  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i++) {  	int index = mesh.TriangleIndices [i];  	if (index < 0 || index >= mesh.Positions.Count) {  		sb.AppendFormat ("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);  		sb.AppendLine ();  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: if (index < 0 || index >= mesh.Positions.Count) {  	sb.AppendFormat ("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);  	sb.AppendLine ();  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: if (index < 0 || index >= mesh.Positions.Count) {  	sb.AppendFormat ("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);  	sb.AppendLine ();  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: sb.AppendFormat ("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: sb.AppendFormat ("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The following statement contains a magic number: for (var i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	var index0 = mesh.TriangleIndices [i];  	var index1 = mesh.TriangleIndices [i + 1];  	var index2 = mesh.TriangleIndices [i + 2];  	Point3D[] positions;  	Vector3D[] normals;  	Point[] textureCoordinates;  	int[] triangleIndices;  	contourHelper.ContourFacet (index0' index1' index2' out positions' out normals' out textureCoordinates' out triangleIndices);  	foreach (var p in positions) {  		meshBuilder.Positions.Add (p);  	}  	foreach (var tc in textureCoordinates) {  		meshBuilder.TextureCoordinates.Add (tc);  	}  	foreach (var n in normals) {  		meshBuilder.Normals.Add (n);  	}  	foreach (var ti in triangleIndices) {  		meshBuilder.TriangleIndices.Add (ti);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The following statement contains a magic number: for (var i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	var index0 = mesh.TriangleIndices [i];  	var index1 = mesh.TriangleIndices [i + 1];  	var index2 = mesh.TriangleIndices [i + 2];  	Point3D[] positions;  	Vector3D[] normals;  	Point[] textureCoordinates;  	int[] triangleIndices;  	contourHelper.ContourFacet (index0' index1' index2' out positions' out normals' out textureCoordinates' out triangleIndices);  	foreach (var p in positions) {  		meshBuilder.Positions.Add (p);  	}  	foreach (var tc in textureCoordinates) {  		meshBuilder.TextureCoordinates.Add (tc);  	}  	foreach (var n in normals) {  		meshBuilder.Normals.Add (n);  	}  	foreach (var ti in triangleIndices) {  		meshBuilder.TriangleIndices.Add (ti);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	Point3D[] positions;  	Vector3D[] normals;  	Point[] textureCoordinates;  	int[] triangleIndices;  	contourHelper.ContourFacet (mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2]' out positions' out normals' out textureCoordinates' out triangleIndices);  	segments.AddRange (positions);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3) {  	Point3D[] positions;  	Vector3D[] normals;  	Point[] textureCoordinates;  	int[] triangleIndices;  	contourHelper.ContourFacet (mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2]' out positions' out normals' out textureCoordinates' out triangleIndices);  	segments.AddRange (positions);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The following statement contains a magic number: i += 3
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The following statement contains a magic number: contourHelper.ContourFacet (mesh.TriangleIndices [i]' mesh.TriangleIndices [i + 1]' mesh.TriangleIndices [i + 2]' out positions' out normals' out textureCoordinates' out triangleIndices);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0) {  	if (curveCount > 0) {  		// Find a segment that is connected to the head of the contour  		segment1 = FindConnectedSegment (segments' curve [0]' eps);  		if (segment1 >= 0) {  			if (segment1 % 2 == 1) {  				curve.Insert (0' segments [segment1 - 1]);  				segments.RemoveAt (segment1 - 1);  				segments.RemoveAt (segment1 - 1);  			} else {  				curve.Insert (0' segments [segment1 + 1]);  				segments.RemoveAt (segment1);  				segments.RemoveAt (segment1);  			}  			curveCount++;  			segmentCount -= 2;  		}  		// Find a segment that is connected to the tail of the contour  		segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  		if (segment2 >= 0) {  			if (segment2 % 2 == 1) {  				curve.Add (segments [segment2 - 1]);  				segments.RemoveAt (segment2 - 1);  				segments.RemoveAt (segment2 - 1);  			} else {  				curve.Add (segments [segment2 + 1]);  				segments.RemoveAt (segment2);  				segments.RemoveAt (segment2);  			}  			curveCount++;  			segmentCount -= 2;  		}  	}  	if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  		if (curveCount > 0) {  			yield return curve;  			curve = new List<Point3D> ();  			curveCount = 0;  		}  		if (segmentCount > 0) {  			curve.Add (segments [0]);  			curve.Add (segments [1]);  			curveCount += 2;  			segments.RemoveAt (0);  			segments.RemoveAt (0);  			segmentCount -= 2;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0) {  	if (curveCount > 0) {  		// Find a segment that is connected to the head of the contour  		segment1 = FindConnectedSegment (segments' curve [0]' eps);  		if (segment1 >= 0) {  			if (segment1 % 2 == 1) {  				curve.Insert (0' segments [segment1 - 1]);  				segments.RemoveAt (segment1 - 1);  				segments.RemoveAt (segment1 - 1);  			} else {  				curve.Insert (0' segments [segment1 + 1]);  				segments.RemoveAt (segment1);  				segments.RemoveAt (segment1);  			}  			curveCount++;  			segmentCount -= 2;  		}  		// Find a segment that is connected to the tail of the contour  		segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  		if (segment2 >= 0) {  			if (segment2 % 2 == 1) {  				curve.Add (segments [segment2 - 1]);  				segments.RemoveAt (segment2 - 1);  				segments.RemoveAt (segment2 - 1);  			} else {  				curve.Add (segments [segment2 + 1]);  				segments.RemoveAt (segment2);  				segments.RemoveAt (segment2);  			}  			curveCount++;  			segmentCount -= 2;  		}  	}  	if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  		if (curveCount > 0) {  			yield return curve;  			curve = new List<Point3D> ();  			curveCount = 0;  		}  		if (segmentCount > 0) {  			curve.Add (segments [0]);  			curve.Add (segments [1]);  			curveCount += 2;  			segments.RemoveAt (0);  			segments.RemoveAt (0);  			segmentCount -= 2;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0) {  	if (curveCount > 0) {  		// Find a segment that is connected to the head of the contour  		segment1 = FindConnectedSegment (segments' curve [0]' eps);  		if (segment1 >= 0) {  			if (segment1 % 2 == 1) {  				curve.Insert (0' segments [segment1 - 1]);  				segments.RemoveAt (segment1 - 1);  				segments.RemoveAt (segment1 - 1);  			} else {  				curve.Insert (0' segments [segment1 + 1]);  				segments.RemoveAt (segment1);  				segments.RemoveAt (segment1);  			}  			curveCount++;  			segmentCount -= 2;  		}  		// Find a segment that is connected to the tail of the contour  		segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  		if (segment2 >= 0) {  			if (segment2 % 2 == 1) {  				curve.Add (segments [segment2 - 1]);  				segments.RemoveAt (segment2 - 1);  				segments.RemoveAt (segment2 - 1);  			} else {  				curve.Add (segments [segment2 + 1]);  				segments.RemoveAt (segment2);  				segments.RemoveAt (segment2);  			}  			curveCount++;  			segmentCount -= 2;  		}  	}  	if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  		if (curveCount > 0) {  			yield return curve;  			curve = new List<Point3D> ();  			curveCount = 0;  		}  		if (segmentCount > 0) {  			curve.Add (segments [0]);  			curve.Add (segments [1]);  			curveCount += 2;  			segments.RemoveAt (0);  			segments.RemoveAt (0);  			segmentCount -= 2;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0) {  	if (curveCount > 0) {  		// Find a segment that is connected to the head of the contour  		segment1 = FindConnectedSegment (segments' curve [0]' eps);  		if (segment1 >= 0) {  			if (segment1 % 2 == 1) {  				curve.Insert (0' segments [segment1 - 1]);  				segments.RemoveAt (segment1 - 1);  				segments.RemoveAt (segment1 - 1);  			} else {  				curve.Insert (0' segments [segment1 + 1]);  				segments.RemoveAt (segment1);  				segments.RemoveAt (segment1);  			}  			curveCount++;  			segmentCount -= 2;  		}  		// Find a segment that is connected to the tail of the contour  		segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  		if (segment2 >= 0) {  			if (segment2 % 2 == 1) {  				curve.Add (segments [segment2 - 1]);  				segments.RemoveAt (segment2 - 1);  				segments.RemoveAt (segment2 - 1);  			} else {  				curve.Add (segments [segment2 + 1]);  				segments.RemoveAt (segment2);  				segments.RemoveAt (segment2);  			}  			curveCount++;  			segmentCount -= 2;  		}  	}  	if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  		if (curveCount > 0) {  			yield return curve;  			curve = new List<Point3D> ();  			curveCount = 0;  		}  		if (segmentCount > 0) {  			curve.Add (segments [0]);  			curve.Add (segments [1]);  			curveCount += 2;  			segments.RemoveAt (0);  			segments.RemoveAt (0);  			segmentCount -= 2;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0) {  	if (curveCount > 0) {  		// Find a segment that is connected to the head of the contour  		segment1 = FindConnectedSegment (segments' curve [0]' eps);  		if (segment1 >= 0) {  			if (segment1 % 2 == 1) {  				curve.Insert (0' segments [segment1 - 1]);  				segments.RemoveAt (segment1 - 1);  				segments.RemoveAt (segment1 - 1);  			} else {  				curve.Insert (0' segments [segment1 + 1]);  				segments.RemoveAt (segment1);  				segments.RemoveAt (segment1);  			}  			curveCount++;  			segmentCount -= 2;  		}  		// Find a segment that is connected to the tail of the contour  		segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  		if (segment2 >= 0) {  			if (segment2 % 2 == 1) {  				curve.Add (segments [segment2 - 1]);  				segments.RemoveAt (segment2 - 1);  				segments.RemoveAt (segment2 - 1);  			} else {  				curve.Add (segments [segment2 + 1]);  				segments.RemoveAt (segment2);  				segments.RemoveAt (segment2);  			}  			curveCount++;  			segmentCount -= 2;  		}  	}  	if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  		if (curveCount > 0) {  			yield return curve;  			curve = new List<Point3D> ();  			curveCount = 0;  		}  		if (segmentCount > 0) {  			curve.Add (segments [0]);  			curve.Add (segments [1]);  			curveCount += 2;  			segments.RemoveAt (0);  			segments.RemoveAt (0);  			segmentCount -= 2;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0) {  	if (curveCount > 0) {  		// Find a segment that is connected to the head of the contour  		segment1 = FindConnectedSegment (segments' curve [0]' eps);  		if (segment1 >= 0) {  			if (segment1 % 2 == 1) {  				curve.Insert (0' segments [segment1 - 1]);  				segments.RemoveAt (segment1 - 1);  				segments.RemoveAt (segment1 - 1);  			} else {  				curve.Insert (0' segments [segment1 + 1]);  				segments.RemoveAt (segment1);  				segments.RemoveAt (segment1);  			}  			curveCount++;  			segmentCount -= 2;  		}  		// Find a segment that is connected to the tail of the contour  		segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  		if (segment2 >= 0) {  			if (segment2 % 2 == 1) {  				curve.Add (segments [segment2 - 1]);  				segments.RemoveAt (segment2 - 1);  				segments.RemoveAt (segment2 - 1);  			} else {  				curve.Add (segments [segment2 + 1]);  				segments.RemoveAt (segment2);  				segments.RemoveAt (segment2);  			}  			curveCount++;  			segmentCount -= 2;  		}  	}  	if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  		if (curveCount > 0) {  			yield return curve;  			curve = new List<Point3D> ();  			curveCount = 0;  		}  		if (segmentCount > 0) {  			curve.Add (segments [0]);  			curve.Add (segments [1]);  			curveCount += 2;  			segments.RemoveAt (0);  			segments.RemoveAt (0);  			segmentCount -= 2;  		}  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (curveCount > 0) {  	// Find a segment that is connected to the head of the contour  	segment1 = FindConnectedSegment (segments' curve [0]' eps);  	if (segment1 >= 0) {  		if (segment1 % 2 == 1) {  			curve.Insert (0' segments [segment1 - 1]);  			segments.RemoveAt (segment1 - 1);  			segments.RemoveAt (segment1 - 1);  		} else {  			curve.Insert (0' segments [segment1 + 1]);  			segments.RemoveAt (segment1);  			segments.RemoveAt (segment1);  		}  		curveCount++;  		segmentCount -= 2;  	}  	// Find a segment that is connected to the tail of the contour  	segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  	if (segment2 >= 0) {  		if (segment2 % 2 == 1) {  			curve.Add (segments [segment2 - 1]);  			segments.RemoveAt (segment2 - 1);  			segments.RemoveAt (segment2 - 1);  		} else {  			curve.Add (segments [segment2 + 1]);  			segments.RemoveAt (segment2);  			segments.RemoveAt (segment2);  		}  		curveCount++;  		segmentCount -= 2;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (curveCount > 0) {  	// Find a segment that is connected to the head of the contour  	segment1 = FindConnectedSegment (segments' curve [0]' eps);  	if (segment1 >= 0) {  		if (segment1 % 2 == 1) {  			curve.Insert (0' segments [segment1 - 1]);  			segments.RemoveAt (segment1 - 1);  			segments.RemoveAt (segment1 - 1);  		} else {  			curve.Insert (0' segments [segment1 + 1]);  			segments.RemoveAt (segment1);  			segments.RemoveAt (segment1);  		}  		curveCount++;  		segmentCount -= 2;  	}  	// Find a segment that is connected to the tail of the contour  	segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  	if (segment2 >= 0) {  		if (segment2 % 2 == 1) {  			curve.Add (segments [segment2 - 1]);  			segments.RemoveAt (segment2 - 1);  			segments.RemoveAt (segment2 - 1);  		} else {  			curve.Add (segments [segment2 + 1]);  			segments.RemoveAt (segment2);  			segments.RemoveAt (segment2);  		}  		curveCount++;  		segmentCount -= 2;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (curveCount > 0) {  	// Find a segment that is connected to the head of the contour  	segment1 = FindConnectedSegment (segments' curve [0]' eps);  	if (segment1 >= 0) {  		if (segment1 % 2 == 1) {  			curve.Insert (0' segments [segment1 - 1]);  			segments.RemoveAt (segment1 - 1);  			segments.RemoveAt (segment1 - 1);  		} else {  			curve.Insert (0' segments [segment1 + 1]);  			segments.RemoveAt (segment1);  			segments.RemoveAt (segment1);  		}  		curveCount++;  		segmentCount -= 2;  	}  	// Find a segment that is connected to the tail of the contour  	segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  	if (segment2 >= 0) {  		if (segment2 % 2 == 1) {  			curve.Add (segments [segment2 - 1]);  			segments.RemoveAt (segment2 - 1);  			segments.RemoveAt (segment2 - 1);  		} else {  			curve.Add (segments [segment2 + 1]);  			segments.RemoveAt (segment2);  			segments.RemoveAt (segment2);  		}  		curveCount++;  		segmentCount -= 2;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (curveCount > 0) {  	// Find a segment that is connected to the head of the contour  	segment1 = FindConnectedSegment (segments' curve [0]' eps);  	if (segment1 >= 0) {  		if (segment1 % 2 == 1) {  			curve.Insert (0' segments [segment1 - 1]);  			segments.RemoveAt (segment1 - 1);  			segments.RemoveAt (segment1 - 1);  		} else {  			curve.Insert (0' segments [segment1 + 1]);  			segments.RemoveAt (segment1);  			segments.RemoveAt (segment1);  		}  		curveCount++;  		segmentCount -= 2;  	}  	// Find a segment that is connected to the tail of the contour  	segment2 = FindConnectedSegment (segments' curve [curveCount - 1]' eps);  	if (segment2 >= 0) {  		if (segment2 % 2 == 1) {  			curve.Add (segments [segment2 - 1]);  			segments.RemoveAt (segment2 - 1);  			segments.RemoveAt (segment2 - 1);  		} else {  			curve.Add (segments [segment2 + 1]);  			segments.RemoveAt (segment2);  			segments.RemoveAt (segment2);  		}  		curveCount++;  		segmentCount -= 2;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segment1 >= 0) {  	if (segment1 % 2 == 1) {  		curve.Insert (0' segments [segment1 - 1]);  		segments.RemoveAt (segment1 - 1);  		segments.RemoveAt (segment1 - 1);  	} else {  		curve.Insert (0' segments [segment1 + 1]);  		segments.RemoveAt (segment1);  		segments.RemoveAt (segment1);  	}  	curveCount++;  	segmentCount -= 2;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segment1 >= 0) {  	if (segment1 % 2 == 1) {  		curve.Insert (0' segments [segment1 - 1]);  		segments.RemoveAt (segment1 - 1);  		segments.RemoveAt (segment1 - 1);  	} else {  		curve.Insert (0' segments [segment1 + 1]);  		segments.RemoveAt (segment1);  		segments.RemoveAt (segment1);  	}  	curveCount++;  	segmentCount -= 2;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segment1 % 2 == 1) {  	curve.Insert (0' segments [segment1 - 1]);  	segments.RemoveAt (segment1 - 1);  	segments.RemoveAt (segment1 - 1);  } else {  	curve.Insert (0' segments [segment1 + 1]);  	segments.RemoveAt (segment1);  	segments.RemoveAt (segment1);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: segmentCount -= 2;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segment2 >= 0) {  	if (segment2 % 2 == 1) {  		curve.Add (segments [segment2 - 1]);  		segments.RemoveAt (segment2 - 1);  		segments.RemoveAt (segment2 - 1);  	} else {  		curve.Add (segments [segment2 + 1]);  		segments.RemoveAt (segment2);  		segments.RemoveAt (segment2);  	}  	curveCount++;  	segmentCount -= 2;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segment2 >= 0) {  	if (segment2 % 2 == 1) {  		curve.Add (segments [segment2 - 1]);  		segments.RemoveAt (segment2 - 1);  		segments.RemoveAt (segment2 - 1);  	} else {  		curve.Add (segments [segment2 + 1]);  		segments.RemoveAt (segment2);  		segments.RemoveAt (segment2);  	}  	curveCount++;  	segmentCount -= 2;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segment2 % 2 == 1) {  	curve.Add (segments [segment2 - 1]);  	segments.RemoveAt (segment2 - 1);  	segments.RemoveAt (segment2 - 1);  } else {  	curve.Add (segments [segment2 + 1]);  	segments.RemoveAt (segment2);  	segments.RemoveAt (segment2);  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: segmentCount -= 2;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  	if (curveCount > 0) {  		yield return curve;  		curve = new List<Point3D> ();  		curveCount = 0;  	}  	if (segmentCount > 0) {  		curve.Add (segments [0]);  		curve.Add (segments [1]);  		curveCount += 2;  		segments.RemoveAt (0);  		segments.RemoveAt (0);  		segmentCount -= 2;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if ((segment1 < 0 && segment2 < 0) || segmentCount == 0) {  	if (curveCount > 0) {  		yield return curve;  		curve = new List<Point3D> ();  		curveCount = 0;  	}  	if (segmentCount > 0) {  		curve.Add (segments [0]);  		curve.Add (segments [1]);  		curveCount += 2;  		segments.RemoveAt (0);  		segments.RemoveAt (0);  		segmentCount -= 2;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segmentCount > 0) {  	curve.Add (segments [0]);  	curve.Add (segments [1]);  	curveCount += 2;  	segments.RemoveAt (0);  	segments.RemoveAt (0);  	segmentCount -= 2;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: if (segmentCount > 0) {  	curve.Add (segments [0]);  	curve.Add (segments [1]);  	curveCount += 2;  	segments.RemoveAt (0);  	segments.RemoveAt (0);  	segmentCount -= 2;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: curveCount += 2;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: segmentCount -= 2;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CreateKey,The following statement contains a magic number: return ((ulong)i0 << 32) + i1;  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i0 = (uint)(key >> 32);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i1 = (uint)((key << 32) >> 32);  
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i1 = (uint)((key << 32) >> 32);  
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)  	return null;  else if (count == 3) {  	if (!didReverse) {  		return new Int32Collection {  			0'  			1'  			2  		};  	} else {  		return new Int32Collection {  			2'  			1'  			1  		};  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)  	return null;  else if (count == 3) {  	if (!didReverse) {  		return new Int32Collection {  			0'  			1'  			2  		};  	} else {  		return new Int32Collection {  			2'  			1'  			1  		};  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)  	return null;  else if (count == 3) {  	if (!didReverse) {  		return new Int32Collection {  			0'  			1'  			2  		};  	} else {  		return new Int32Collection {  			2'  			1'  			1  		};  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)  	return null;  else if (count == 3) {  	if (!didReverse) {  		return new Int32Collection {  			0'  			1'  			2  		};  	} else {  		return new Int32Collection {  			2'  			1'  			1  		};  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count == 3) {  	if (!didReverse) {  		return new Int32Collection {  			0'  			1'  			2  		};  	} else {  		return new Int32Collection {  			2'  			1'  			1  		};  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count == 3) {  	if (!didReverse) {  		return new Int32Collection {  			0'  			1'  			2  		};  	} else {  		return new Int32Collection {  			2'  			1'  			1  		};  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count == 3) {  	if (!didReverse) {  		return new Int32Collection {  			0'  			1'  			2  		};  	} else {  		return new Int32Collection {  			2'  			1'  			1  		};  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (!didReverse) {  	return new Int32Collection {  		0'  		1'  		2  	};  } else {  	return new Int32Collection {  		2'  		1'  		1  	};  }  
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (!didReverse) {  	return new Int32Collection {  		0'  		1'  		2  	};  } else {  	return new Int32Collection {  		2'  		1'  		1  	};  }  
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: return new Int32Collection {  	0'  	1'  	2  };  
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: return new Int32Collection {  	2'  	1'  	1  };  
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,The following statement contains a magic number: for (int i = 2; i < pointCnt; i++) {  	// The current Point  	var newPoint = events [i];  	var top = pointStack.Peek ();  	// If the new Point is not on the same side as the last Point on the Stack  	//if (!(leftChain.Contains(top) && leftChain.Contains(newPoint) || rightChain.Contains(top) && rightChain.Contains(newPoint)))  	if (!(top.Last == newPoint || top.Next == newPoint)) {  		// Determine this Point's Chain (left or right)  		if (left.Next == newPoint) {  			left = newPoint;  		} else if (right.Last == newPoint) {  			right = newPoint;  		}  		// Third triangle Point  		var p2 = top;  		// While there is a Point on the Stack  		while (pointStack.Count != 0) {  			// Pop and set the third Point  			top = pointStack.Pop ();  			p2 = top;  			if (pointStack.Count != 0) {  				// Pop again  				top = pointStack.Pop ();  				// Add to the result. The Order is depending on the Side  				if (left == newPoint) {  					result.Add (newPoint.Index);  					result.Add (p2.Index);  					result.Add (top.Index);  				} else {  					result.Add (newPoint.Index);  					result.Add (top.Index);  					result.Add (p2.Index);  				}  			}  			// If more Points are on the Stack'  			// Push the Point back again' to be able to form the Triangles  			if (pointStack.Count != 0)  				pointStack.Push (top);  		}  		// Push the last to Points on the Stack  		pointStack.Push (events [i - 1]);  		pointStack.Push (newPoint);  	} // If the newPoint is on the same Side (i.e. Chain)  	else {  		// Get to Point on the Stack  		top = pointStack.Pop ();  		var p2 = top;  		// Determine this Point's Chain (left or right)  		if (left.Next == newPoint && right.Last == newPoint) {  			if (top.Last == newPoint)  				right = newPoint;  			else if (top.Next == newPoint)  				left = newPoint;  			else  				throw new Exception ("Triangulation error");  		} else if (left.Next == newPoint) {  			left = newPoint;  		} else if (right.Last == newPoint) {  			right = newPoint;  		}  		while (pointStack.Count != 0) {  			// If the Triangle is possible' add it to the result (Point Order depends on the Side)  			if (right == newPoint && IsCCW (new List<Point> {  				newPoint.Point'  				p2.Point'  				pointStack.Peek ().Point  			})) {  				top = pointStack.Pop ();  				result.Add (newPoint.Index);  				result.Add (p2.Index);  				result.Add (top.Index);  				p2 = top;  			} else if (left == newPoint && !IsCCW (new List<Point> {  				newPoint.Point'  				p2.Point'  				pointStack.Peek ().Point  			})) {  				top = pointStack.Pop ();  				result.Add (newPoint.Index);  				result.Add (top.Index);  				result.Add (p2.Index);  				p2 = top;  			} // No Triangle possible' just leave the Loop  			else  				break;  		}  		// Push the last two Points on the Stack  		pointStack.Push (p2);  		pointStack.Push (newPoint);  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourHelper,The following statement contains a magic number: this.normals = hasNormals ? new Vector3D[3] : null;  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourHelper,The following statement contains a magic number: this.textures = hasTextureCoordinates ? new Point[3] : null;  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,GetContourFacet,The following statement contains a magic number: if (this.IsSideAlone (2)) {  	return this.sides [2] > 0 ? ContourFacetResult.TwoOnly : ContourFacetResult.ZeroAndOne;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,GetContourFacet,The following statement contains a magic number: if (this.IsSideAlone (2)) {  	return this.sides [2] > 0 ? ContourFacetResult.TwoOnly : ContourFacetResult.ZeroAndOne;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,GetContourFacet,The following statement contains a magic number: return this.sides [2] > 0 ? ContourFacetResult.TwoOnly : ContourFacetResult.ZeroAndOne;  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.indices [2] = index2;  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.points [2] = this.meshPositions [index2];  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: if (this.normals != null) {  	this.normals [0] = this.meshNormals [index0];  	this.normals [1] = this.meshNormals [index1];  	this.normals [2] = this.meshNormals [index2];  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.normals [2] = this.meshNormals [index2];  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: if (this.textures != null) {  	this.textures [0] = this.meshTextureCoordinates [index0];  	this.textures [1] = this.meshTextureCoordinates [index1];  	this.textures [2] = this.meshTextureCoordinates [index2];  }  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.textures [2] = this.meshTextureCoordinates [index2];  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides [2] = (this.a * this.points [2].X) + (this.b * this.points [2].Y) + (this.c * this.points [2].Z) + this.d;  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides [2] = (this.a * this.points [2].X) + (this.b * this.points [2].Y) + (this.c * this.points [2].Z) + this.d;  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides [2] = (this.a * this.points [2].X) + (this.b * this.points [2].Y) + (this.c * this.points [2].Z) + this.d;  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides [2] = (this.a * this.points [2].X) + (this.b * this.points [2].Y) + (this.c * this.points [2].Z) + this.d;  
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,AllSidesBelowContour,The following statement contains a magic number: return this.sides [0] >= 0 && this.sides [1] >= 0 && this.sides [2] >= 0;  
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Polygon3D.cs,GetNormal,The following statement contains a magic number: if (this.Points.Count < 3) {  	throw new InvalidOperationException ("At least three points required in the polygon to find a normal.");  }  
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Polygon3D.cs,GetNormal,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++) {  	var n = Vector3D.Cross (v1' this.Points [i] - this.Points [0]);  	if (n.LengthSquared () > 1e-8) {  		n.Normalize ();  		return n;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Polygon3D.cs,GetNormal,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++) {  	var n = Vector3D.Cross (v1' this.Points [i] - this.Points [0]);  	if (n.LengthSquared () > 1e-8) {  		n.Normalize ();  		return n;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Polygon3D.cs,GetNormal,The following statement contains a magic number: if (n.LengthSquared () > 1e-8) {  	n.Normalize ();  	return n;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Polygon3D.cs,IsPlanar,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++) {  	var n = Vector3D.Cross (v1' this.Points [i] - this.Points [0]);  	n.Normalize ();  	if (i == 2) {  		normal = n;  	} else if (Math.Abs (Vector3D.Dot (n' normal) - 1) > 1e-8) {  		return false;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Polygon3D.cs,IsPlanar,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++) {  	var n = Vector3D.Cross (v1' this.Points [i] - this.Points [0]);  	n.Normalize ();  	if (i == 2) {  		normal = n;  	} else if (Math.Abs (Vector3D.Dot (n' normal) - 1) > 1e-8) {  		return false;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Polygon3D.cs,IsPlanar,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++) {  	var n = Vector3D.Cross (v1' this.Points [i] - this.Points [0]);  	n.Normalize ();  	if (i == 2) {  		normal = n;  	} else if (Math.Abs (Vector3D.Dot (n' normal) - 1) > 1e-8) {  		return false;  	}  }  
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Polygon3D.cs,IsPlanar,The following statement contains a magic number: if (i == 2) {  	normal = n;  } else if (Math.Abs (Vector3D.Dot (n' normal) - 1) > 1e-8) {  	return false;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Polygon3D.cs,IsPlanar,The following statement contains a magic number: if (i == 2) {  	normal = n;  } else if (Math.Abs (Vector3D.Dot (n' normal) - 1) > 1e-8) {  	return false;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Polygon3D.cs,IsPlanar,The following statement contains a magic number: if (Math.Abs (Vector3D.Dot (n' normal) - 1) > 1e-8) {  	return false;  }  
Magic Number,HelixToolkit.Wpf.SharpDX,VectorExtensions,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Vector3DExtensions.cs,FindAnyPerpendicular,The following statement contains a magic number: if (u.LengthSquared () < 1e-3) {  	u = Vector3.Cross (new Vector3 (1' 0' 0)' n);  }  
Magic Number,HelixToolkit.Wpf.SharpDX.Helpers,EventSkipper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Helpers\EventSkipper.cs,IsSkip,The following statement contains a magic number: if (lag < Threshold) {  	return true;  } else {  	lag = Math.Min (lag - Threshold' Threshold - 2);  	return false;  }  
Magic Number,HelixToolkit.Wpf.SharpDX.Helpers,EventSkipper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Helpers\EventSkipper.cs,IsSkip,The following statement contains a magic number: lag = Math.Min (lag - Threshold' Threshold - 2);  
Magic Number,Wpf3DTools,Trackball,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Trackball.cs,Pan,The following statement contains a magic number: _translate.OffsetX += changeVector.X * .1;  
Magic Number,Wpf3DTools,Trackball,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Trackball.cs,Pan,The following statement contains a magic number: _translate.OffsetY -= changeVector.Y * .1;  
Magic Number,Wpf3DTools,Trackball,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\Trackball.cs,Pan,The following statement contains a magic number: _translate.OffsetZ += changeVector.Z * .1;  
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: if (n < 3) {  	return null;  }  
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: for (int v = nv - 1; nv > 2;) {  	// if we loop' it is probably a non-simple polygon  	if (0 >= (count--)) {  		// ERROR - probable bad polygon!  		return null;  	}  	// three consecutive vertices in current polygon' <u'v'w>  	int u = v;  	if (nv <= u) {  		u = 0;  		// previous  	}  	v = u + 1;  	if (nv <= v) {  		v = 0;  		// new v  	}  	int w = v + 1;  	if (nv <= w) {  		w = 0;  		// next  	}  	if (Snip (contour' u' v' w' nv' V)) {  		int s' t;  		// true names of the vertices  		int a = V [u];  		int b = V [v];  		int c = V [w];  		// output Triangle  		result.Add (a);  		result.Add (b);  		result.Add (c);  		// remove v from remaining polygon  		for (s = v' t = v + 1; t < nv; s++' t++) {  			V [s] = V [t];  		}  		nv--;  		// resest error detection counter  		count = 2 * nv;  	}  }  
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: for (int v = nv - 1; nv > 2;) {  	// if we loop' it is probably a non-simple polygon  	if (0 >= (count--)) {  		// ERROR - probable bad polygon!  		return null;  	}  	// three consecutive vertices in current polygon' <u'v'w>  	int u = v;  	if (nv <= u) {  		u = 0;  		// previous  	}  	v = u + 1;  	if (nv <= v) {  		v = 0;  		// new v  	}  	int w = v + 1;  	if (nv <= w) {  		w = 0;  		// next  	}  	if (Snip (contour' u' v' w' nv' V)) {  		int s' t;  		// true names of the vertices  		int a = V [u];  		int b = V [v];  		int c = V [w];  		// output Triangle  		result.Add (a);  		result.Add (b);  		result.Add (c);  		// remove v from remaining polygon  		for (s = v' t = v + 1; t < nv; s++' t++) {  			V [s] = V [t];  		}  		nv--;  		// resest error detection counter  		count = 2 * nv;  	}  }  
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: if (Snip (contour' u' v' w' nv' V)) {  	int s' t;  	// true names of the vertices  	int a = V [u];  	int b = V [v];  	int c = V [w];  	// output Triangle  	result.Add (a);  	result.Add (b);  	result.Add (c);  	// remove v from remaining polygon  	for (s = v' t = v + 1; t < nv; s++' t++) {  		V [s] = V [t];  	}  	nv--;  	// resest error detection counter  	count = 2 * nv;  }  
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: count = 2 * nv;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following statement contains a magic number: if ((header.PixelFormat.Flags & DDS.PixelFormatFlags.FourCC) != 0 && (new FourCC ('D'' 'X'' '1'' '0') == header.PixelFormat.FourCC)) {  	// Buffer must be big enough for both headers and magic value  	if (size < (Utilities.SizeOf<DDS.Header> () + sizeof(uint) + Utilities.SizeOf<DDS.HeaderDXT10> ()))  		return false;  	var headerDX10 = *(DDS.HeaderDXT10*)((byte*)headerPtr + sizeof(int) + Utilities.SizeOf<DDS.Header> ());  	convFlags |= ConversionFlags.DX10;  	description.ArraySize = headerDX10.ArraySize;  	if (description.ArraySize == 0)  		throw new InvalidOperationException ("Unexpected ArraySize == 0 from DDS HeaderDX10 ");  	description.Format = headerDX10.DXGIFormat;  	if (!FormatHelper.IsValid (description.Format))  		throw new InvalidOperationException ("Invalid Format from DDS HeaderDX10 ");  	switch (headerDX10.ResourceDimension) {  	case ResourceDimension.Texture1D:  		// D3DX writes 1D textures with a fixed Height of 1  		if ((header.Flags & DDS.HeaderFlags.Height) != 0 && header.Height != 1)  			throw new InvalidOperationException ("Unexpected Height != 1 from DDS HeaderDX10 ");  		description.Width = header.Width;  		description.Height = 1;  		description.Depth = 1;  		description.Dimension = TextureDimension.Texture1D;  		break;  	case ResourceDimension.Texture2D:  		if ((headerDX10.MiscFlags & ResourceOptionFlags.TextureCube) != 0) {  			description.ArraySize *= 6;  			description.Dimension = TextureDimension.TextureCube;  		} else {  			description.Dimension = TextureDimension.Texture2D;  		}  		description.Width = header.Width;  		description.Height = header.Height;  		description.Depth = 1;  		break;  	case ResourceDimension.Texture3D:  		if ((header.Flags & DDS.HeaderFlags.Volume) == 0)  			throw new InvalidOperationException ("Texture3D missing HeaderFlags.Volume from DDS HeaderDX10");  		if (description.ArraySize > 1)  			throw new InvalidOperationException ("Unexpected ArraySize > 1 for Texture3D from DDS HeaderDX10");  		description.Width = header.Width;  		description.Height = header.Height;  		description.Depth = header.Depth;  		description.Dimension = TextureDimension.Texture3D;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Unexpected dimension [{0}] from DDS HeaderDX10"' headerDX10.ResourceDimension));  	}  } else {  	description.ArraySize = 1;  	if ((header.Flags & DDS.HeaderFlags.Volume) != 0) {  		description.Width = header.Width;  		description.Height = header.Height;  		description.Depth = header.Depth;  		description.Dimension = TextureDimension.Texture3D;  	} else {  		if ((header.CubemapFlags & DDS.CubemapFlags.CubeMap) != 0) {  			// We require all six faces to be defined  			if ((header.CubemapFlags & DDS.CubemapFlags.AllFaces) != DDS.CubemapFlags.AllFaces)  				throw new InvalidOperationException ("Unexpected CubeMap' expecting all faces from DDS Header");  			description.ArraySize = 6;  			description.Dimension = TextureDimension.TextureCube;  		} else {  			description.Dimension = TextureDimension.Texture2D;  		}  		description.Width = header.Width;  		description.Height = header.Height;  		description.Depth = 1;  		// Note there's no way for a legacy Direct3D 9 DDS to express a '1D' texture  	}  	description.Format = GetDXGIFormat (ref header.PixelFormat' flags' out convFlags);  	if (description.Format == Format.Unknown)  		throw new InvalidOperationException ("Unsupported PixelFormat from DDS Header");  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following statement contains a magic number: if ((header.PixelFormat.Flags & DDS.PixelFormatFlags.FourCC) != 0 && (new FourCC ('D'' 'X'' '1'' '0') == header.PixelFormat.FourCC)) {  	// Buffer must be big enough for both headers and magic value  	if (size < (Utilities.SizeOf<DDS.Header> () + sizeof(uint) + Utilities.SizeOf<DDS.HeaderDXT10> ()))  		return false;  	var headerDX10 = *(DDS.HeaderDXT10*)((byte*)headerPtr + sizeof(int) + Utilities.SizeOf<DDS.Header> ());  	convFlags |= ConversionFlags.DX10;  	description.ArraySize = headerDX10.ArraySize;  	if (description.ArraySize == 0)  		throw new InvalidOperationException ("Unexpected ArraySize == 0 from DDS HeaderDX10 ");  	description.Format = headerDX10.DXGIFormat;  	if (!FormatHelper.IsValid (description.Format))  		throw new InvalidOperationException ("Invalid Format from DDS HeaderDX10 ");  	switch (headerDX10.ResourceDimension) {  	case ResourceDimension.Texture1D:  		// D3DX writes 1D textures with a fixed Height of 1  		if ((header.Flags & DDS.HeaderFlags.Height) != 0 && header.Height != 1)  			throw new InvalidOperationException ("Unexpected Height != 1 from DDS HeaderDX10 ");  		description.Width = header.Width;  		description.Height = 1;  		description.Depth = 1;  		description.Dimension = TextureDimension.Texture1D;  		break;  	case ResourceDimension.Texture2D:  		if ((headerDX10.MiscFlags & ResourceOptionFlags.TextureCube) != 0) {  			description.ArraySize *= 6;  			description.Dimension = TextureDimension.TextureCube;  		} else {  			description.Dimension = TextureDimension.Texture2D;  		}  		description.Width = header.Width;  		description.Height = header.Height;  		description.Depth = 1;  		break;  	case ResourceDimension.Texture3D:  		if ((header.Flags & DDS.HeaderFlags.Volume) == 0)  			throw new InvalidOperationException ("Texture3D missing HeaderFlags.Volume from DDS HeaderDX10");  		if (description.ArraySize > 1)  			throw new InvalidOperationException ("Unexpected ArraySize > 1 for Texture3D from DDS HeaderDX10");  		description.Width = header.Width;  		description.Height = header.Height;  		description.Depth = header.Depth;  		description.Dimension = TextureDimension.Texture3D;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Unexpected dimension [{0}] from DDS HeaderDX10"' headerDX10.ResourceDimension));  	}  } else {  	description.ArraySize = 1;  	if ((header.Flags & DDS.HeaderFlags.Volume) != 0) {  		description.Width = header.Width;  		description.Height = header.Height;  		description.Depth = header.Depth;  		description.Dimension = TextureDimension.Texture3D;  	} else {  		if ((header.CubemapFlags & DDS.CubemapFlags.CubeMap) != 0) {  			// We require all six faces to be defined  			if ((header.CubemapFlags & DDS.CubemapFlags.AllFaces) != DDS.CubemapFlags.AllFaces)  				throw new InvalidOperationException ("Unexpected CubeMap' expecting all faces from DDS Header");  			description.ArraySize = 6;  			description.Dimension = TextureDimension.TextureCube;  		} else {  			description.Dimension = TextureDimension.Texture2D;  		}  		description.Width = header.Width;  		description.Height = header.Height;  		description.Depth = 1;  		// Note there's no way for a legacy Direct3D 9 DDS to express a '1D' texture  	}  	description.Format = GetDXGIFormat (ref header.PixelFormat' flags' out convFlags);  	if (description.Format == Format.Unknown)  		throw new InvalidOperationException ("Unsupported PixelFormat from DDS Header");  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following statement contains a magic number: switch (headerDX10.ResourceDimension) {  case ResourceDimension.Texture1D:  	// D3DX writes 1D textures with a fixed Height of 1  	if ((header.Flags & DDS.HeaderFlags.Height) != 0 && header.Height != 1)  		throw new InvalidOperationException ("Unexpected Height != 1 from DDS HeaderDX10 ");  	description.Width = header.Width;  	description.Height = 1;  	description.Depth = 1;  	description.Dimension = TextureDimension.Texture1D;  	break;  case ResourceDimension.Texture2D:  	if ((headerDX10.MiscFlags & ResourceOptionFlags.TextureCube) != 0) {  		description.ArraySize *= 6;  		description.Dimension = TextureDimension.TextureCube;  	} else {  		description.Dimension = TextureDimension.Texture2D;  	}  	description.Width = header.Width;  	description.Height = header.Height;  	description.Depth = 1;  	break;  case ResourceDimension.Texture3D:  	if ((header.Flags & DDS.HeaderFlags.Volume) == 0)  		throw new InvalidOperationException ("Texture3D missing HeaderFlags.Volume from DDS HeaderDX10");  	if (description.ArraySize > 1)  		throw new InvalidOperationException ("Unexpected ArraySize > 1 for Texture3D from DDS HeaderDX10");  	description.Width = header.Width;  	description.Height = header.Height;  	description.Depth = header.Depth;  	description.Dimension = TextureDimension.Texture3D;  	break;  default:  	throw new InvalidOperationException (string.Format ("Unexpected dimension [{0}] from DDS HeaderDX10"' headerDX10.ResourceDimension));  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following statement contains a magic number: if ((headerDX10.MiscFlags & ResourceOptionFlags.TextureCube) != 0) {  	description.ArraySize *= 6;  	description.Dimension = TextureDimension.TextureCube;  } else {  	description.Dimension = TextureDimension.Texture2D;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following statement contains a magic number: description.ArraySize *= 6;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following statement contains a magic number: if ((header.Flags & DDS.HeaderFlags.Volume) != 0) {  	description.Width = header.Width;  	description.Height = header.Height;  	description.Depth = header.Depth;  	description.Dimension = TextureDimension.Texture3D;  } else {  	if ((header.CubemapFlags & DDS.CubemapFlags.CubeMap) != 0) {  		// We require all six faces to be defined  		if ((header.CubemapFlags & DDS.CubemapFlags.AllFaces) != DDS.CubemapFlags.AllFaces)  			throw new InvalidOperationException ("Unexpected CubeMap' expecting all faces from DDS Header");  		description.ArraySize = 6;  		description.Dimension = TextureDimension.TextureCube;  	} else {  		description.Dimension = TextureDimension.Texture2D;  	}  	description.Width = header.Width;  	description.Height = header.Height;  	description.Depth = 1;  	// Note there's no way for a legacy Direct3D 9 DDS to express a '1D' texture  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following statement contains a magic number: if ((header.CubemapFlags & DDS.CubemapFlags.CubeMap) != 0) {  	// We require all six faces to be defined  	if ((header.CubemapFlags & DDS.CubemapFlags.AllFaces) != DDS.CubemapFlags.AllFaces)  		throw new InvalidOperationException ("Unexpected CubeMap' expecting all faces from DDS Header");  	description.ArraySize = 6;  	description.Dimension = TextureDimension.TextureCube;  } else {  	description.Dimension = TextureDimension.Texture2D;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following statement contains a magic number: description.ArraySize = 6;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if (description.ArraySize > 1) {  	if ((description.ArraySize != 6) || (description.Dimension != TextureDimension.Texture2D) || (description.Dimension != TextureDimension.TextureCube)) {  		flags |= DDSFlags.ForceDX10Ext;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((description.ArraySize != 6) || (description.Dimension != TextureDimension.Texture2D) || (description.Dimension != TextureDimension.TextureCube)) {  	flags |= DDSFlags.ForceDX10Ext;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0) {  	switch (description.Format) {  	case Format.R8G8B8A8_UNorm:  		ddpf = DDS.PixelFormat.A8B8G8R8;  		break;  	case Format.R16G16_UNorm:  		ddpf = DDS.PixelFormat.G16R16;  		break;  	case Format.R8G8_UNorm:  		ddpf = DDS.PixelFormat.A8L8;  		break;  	case Format.R16_UNorm:  		ddpf = DDS.PixelFormat.L16;  		break;  	case Format.R8_UNorm:  		ddpf = DDS.PixelFormat.L8;  		break;  	case Format.A8_UNorm:  		ddpf = DDS.PixelFormat.A8;  		break;  	case Format.R8G8_B8G8_UNorm:  		ddpf = DDS.PixelFormat.R8G8_B8G8;  		break;  	case Format.G8R8_G8B8_UNorm:  		ddpf = DDS.PixelFormat.G8R8_G8B8;  		break;  	case Format.BC1_UNorm:  		ddpf = DDS.PixelFormat.DXT1;  		break;  	case Format.BC2_UNorm:  		ddpf = DDS.PixelFormat.DXT3;  		break;  	case Format.BC3_UNorm:  		ddpf = DDS.PixelFormat.DXT5;  		break;  	case Format.BC4_UNorm:  		ddpf = DDS.PixelFormat.BC4_UNorm;  		break;  	case Format.BC4_SNorm:  		ddpf = DDS.PixelFormat.BC4_SNorm;  		break;  	case Format.BC5_UNorm:  		ddpf = DDS.PixelFormat.BC5_UNorm;  		break;  	case Format.BC5_SNorm:  		ddpf = DDS.PixelFormat.BC5_SNorm;  		break;  	case Format.B5G6R5_UNorm:  		ddpf = DDS.PixelFormat.R5G6B5;  		break;  	case Format.B5G5R5A1_UNorm:  		ddpf = DDS.PixelFormat.A1R5G5B5;  		break;  	case Format.B8G8R8A8_UNorm:  		ddpf = DDS.PixelFormat.A8R8G8B8;  		break;  	// DXGI 1.1  	case Format.B8G8R8X8_UNorm:  		ddpf = DDS.PixelFormat.X8R8G8B8;  		break;  	// DXGI 1.1  	#if DIRECTX11_1  	                    case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  	// Legacy D3DX formats using D3DFMT enum value as FourCC  	case Format.R32G32B32A32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 116;  		// D3DFMT_A32B32G32R32F  		break;  	case Format.R16G16B16A16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 113;  		// D3DFMT_A16B16G16R16F  		break;  	case Format.R16G16B16A16_UNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 36;  		// D3DFMT_A16B16G16R16  		break;  	case Format.R16G16B16A16_SNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 110;  		// D3DFMT_Q16W16V16U16  		break;  	case Format.R32G32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 115;  		// D3DFMT_G32R32F  		break;  	case Format.R16G16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 112;  		// D3DFMT_G16R16F  		break;  	case Format.R32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 114;  		// D3DFMT_R32F  		break;  	case Format.R16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 111;  		// D3DFMT_R16F  		break;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0) {  	switch (description.Format) {  	case Format.R8G8B8A8_UNorm:  		ddpf = DDS.PixelFormat.A8B8G8R8;  		break;  	case Format.R16G16_UNorm:  		ddpf = DDS.PixelFormat.G16R16;  		break;  	case Format.R8G8_UNorm:  		ddpf = DDS.PixelFormat.A8L8;  		break;  	case Format.R16_UNorm:  		ddpf = DDS.PixelFormat.L16;  		break;  	case Format.R8_UNorm:  		ddpf = DDS.PixelFormat.L8;  		break;  	case Format.A8_UNorm:  		ddpf = DDS.PixelFormat.A8;  		break;  	case Format.R8G8_B8G8_UNorm:  		ddpf = DDS.PixelFormat.R8G8_B8G8;  		break;  	case Format.G8R8_G8B8_UNorm:  		ddpf = DDS.PixelFormat.G8R8_G8B8;  		break;  	case Format.BC1_UNorm:  		ddpf = DDS.PixelFormat.DXT1;  		break;  	case Format.BC2_UNorm:  		ddpf = DDS.PixelFormat.DXT3;  		break;  	case Format.BC3_UNorm:  		ddpf = DDS.PixelFormat.DXT5;  		break;  	case Format.BC4_UNorm:  		ddpf = DDS.PixelFormat.BC4_UNorm;  		break;  	case Format.BC4_SNorm:  		ddpf = DDS.PixelFormat.BC4_SNorm;  		break;  	case Format.BC5_UNorm:  		ddpf = DDS.PixelFormat.BC5_UNorm;  		break;  	case Format.BC5_SNorm:  		ddpf = DDS.PixelFormat.BC5_SNorm;  		break;  	case Format.B5G6R5_UNorm:  		ddpf = DDS.PixelFormat.R5G6B5;  		break;  	case Format.B5G5R5A1_UNorm:  		ddpf = DDS.PixelFormat.A1R5G5B5;  		break;  	case Format.B8G8R8A8_UNorm:  		ddpf = DDS.PixelFormat.A8R8G8B8;  		break;  	// DXGI 1.1  	case Format.B8G8R8X8_UNorm:  		ddpf = DDS.PixelFormat.X8R8G8B8;  		break;  	// DXGI 1.1  	#if DIRECTX11_1  	                    case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  	// Legacy D3DX formats using D3DFMT enum value as FourCC  	case Format.R32G32B32A32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 116;  		// D3DFMT_A32B32G32R32F  		break;  	case Format.R16G16B16A16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 113;  		// D3DFMT_A16B16G16R16F  		break;  	case Format.R16G16B16A16_UNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 36;  		// D3DFMT_A16B16G16R16  		break;  	case Format.R16G16B16A16_SNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 110;  		// D3DFMT_Q16W16V16U16  		break;  	case Format.R32G32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 115;  		// D3DFMT_G32R32F  		break;  	case Format.R16G16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 112;  		// D3DFMT_G16R16F  		break;  	case Format.R32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 114;  		// D3DFMT_R32F  		break;  	case Format.R16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 111;  		// D3DFMT_R16F  		break;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0) {  	switch (description.Format) {  	case Format.R8G8B8A8_UNorm:  		ddpf = DDS.PixelFormat.A8B8G8R8;  		break;  	case Format.R16G16_UNorm:  		ddpf = DDS.PixelFormat.G16R16;  		break;  	case Format.R8G8_UNorm:  		ddpf = DDS.PixelFormat.A8L8;  		break;  	case Format.R16_UNorm:  		ddpf = DDS.PixelFormat.L16;  		break;  	case Format.R8_UNorm:  		ddpf = DDS.PixelFormat.L8;  		break;  	case Format.A8_UNorm:  		ddpf = DDS.PixelFormat.A8;  		break;  	case Format.R8G8_B8G8_UNorm:  		ddpf = DDS.PixelFormat.R8G8_B8G8;  		break;  	case Format.G8R8_G8B8_UNorm:  		ddpf = DDS.PixelFormat.G8R8_G8B8;  		break;  	case Format.BC1_UNorm:  		ddpf = DDS.PixelFormat.DXT1;  		break;  	case Format.BC2_UNorm:  		ddpf = DDS.PixelFormat.DXT3;  		break;  	case Format.BC3_UNorm:  		ddpf = DDS.PixelFormat.DXT5;  		break;  	case Format.BC4_UNorm:  		ddpf = DDS.PixelFormat.BC4_UNorm;  		break;  	case Format.BC4_SNorm:  		ddpf = DDS.PixelFormat.BC4_SNorm;  		break;  	case Format.BC5_UNorm:  		ddpf = DDS.PixelFormat.BC5_UNorm;  		break;  	case Format.BC5_SNorm:  		ddpf = DDS.PixelFormat.BC5_SNorm;  		break;  	case Format.B5G6R5_UNorm:  		ddpf = DDS.PixelFormat.R5G6B5;  		break;  	case Format.B5G5R5A1_UNorm:  		ddpf = DDS.PixelFormat.A1R5G5B5;  		break;  	case Format.B8G8R8A8_UNorm:  		ddpf = DDS.PixelFormat.A8R8G8B8;  		break;  	// DXGI 1.1  	case Format.B8G8R8X8_UNorm:  		ddpf = DDS.PixelFormat.X8R8G8B8;  		break;  	// DXGI 1.1  	#if DIRECTX11_1  	                    case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  	// Legacy D3DX formats using D3DFMT enum value as FourCC  	case Format.R32G32B32A32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 116;  		// D3DFMT_A32B32G32R32F  		break;  	case Format.R16G16B16A16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 113;  		// D3DFMT_A16B16G16R16F  		break;  	case Format.R16G16B16A16_UNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 36;  		// D3DFMT_A16B16G16R16  		break;  	case Format.R16G16B16A16_SNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 110;  		// D3DFMT_Q16W16V16U16  		break;  	case Format.R32G32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 115;  		// D3DFMT_G32R32F  		break;  	case Format.R16G16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 112;  		// D3DFMT_G16R16F  		break;  	case Format.R32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 114;  		// D3DFMT_R32F  		break;  	case Format.R16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 111;  		// D3DFMT_R16F  		break;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0) {  	switch (description.Format) {  	case Format.R8G8B8A8_UNorm:  		ddpf = DDS.PixelFormat.A8B8G8R8;  		break;  	case Format.R16G16_UNorm:  		ddpf = DDS.PixelFormat.G16R16;  		break;  	case Format.R8G8_UNorm:  		ddpf = DDS.PixelFormat.A8L8;  		break;  	case Format.R16_UNorm:  		ddpf = DDS.PixelFormat.L16;  		break;  	case Format.R8_UNorm:  		ddpf = DDS.PixelFormat.L8;  		break;  	case Format.A8_UNorm:  		ddpf = DDS.PixelFormat.A8;  		break;  	case Format.R8G8_B8G8_UNorm:  		ddpf = DDS.PixelFormat.R8G8_B8G8;  		break;  	case Format.G8R8_G8B8_UNorm:  		ddpf = DDS.PixelFormat.G8R8_G8B8;  		break;  	case Format.BC1_UNorm:  		ddpf = DDS.PixelFormat.DXT1;  		break;  	case Format.BC2_UNorm:  		ddpf = DDS.PixelFormat.DXT3;  		break;  	case Format.BC3_UNorm:  		ddpf = DDS.PixelFormat.DXT5;  		break;  	case Format.BC4_UNorm:  		ddpf = DDS.PixelFormat.BC4_UNorm;  		break;  	case Format.BC4_SNorm:  		ddpf = DDS.PixelFormat.BC4_SNorm;  		break;  	case Format.BC5_UNorm:  		ddpf = DDS.PixelFormat.BC5_UNorm;  		break;  	case Format.BC5_SNorm:  		ddpf = DDS.PixelFormat.BC5_SNorm;  		break;  	case Format.B5G6R5_UNorm:  		ddpf = DDS.PixelFormat.R5G6B5;  		break;  	case Format.B5G5R5A1_UNorm:  		ddpf = DDS.PixelFormat.A1R5G5B5;  		break;  	case Format.B8G8R8A8_UNorm:  		ddpf = DDS.PixelFormat.A8R8G8B8;  		break;  	// DXGI 1.1  	case Format.B8G8R8X8_UNorm:  		ddpf = DDS.PixelFormat.X8R8G8B8;  		break;  	// DXGI 1.1  	#if DIRECTX11_1  	                    case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  	// Legacy D3DX formats using D3DFMT enum value as FourCC  	case Format.R32G32B32A32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 116;  		// D3DFMT_A32B32G32R32F  		break;  	case Format.R16G16B16A16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 113;  		// D3DFMT_A16B16G16R16F  		break;  	case Format.R16G16B16A16_UNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 36;  		// D3DFMT_A16B16G16R16  		break;  	case Format.R16G16B16A16_SNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 110;  		// D3DFMT_Q16W16V16U16  		break;  	case Format.R32G32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 115;  		// D3DFMT_G32R32F  		break;  	case Format.R16G16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 112;  		// D3DFMT_G16R16F  		break;  	case Format.R32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 114;  		// D3DFMT_R32F  		break;  	case Format.R16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 111;  		// D3DFMT_R16F  		break;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0) {  	switch (description.Format) {  	case Format.R8G8B8A8_UNorm:  		ddpf = DDS.PixelFormat.A8B8G8R8;  		break;  	case Format.R16G16_UNorm:  		ddpf = DDS.PixelFormat.G16R16;  		break;  	case Format.R8G8_UNorm:  		ddpf = DDS.PixelFormat.A8L8;  		break;  	case Format.R16_UNorm:  		ddpf = DDS.PixelFormat.L16;  		break;  	case Format.R8_UNorm:  		ddpf = DDS.PixelFormat.L8;  		break;  	case Format.A8_UNorm:  		ddpf = DDS.PixelFormat.A8;  		break;  	case Format.R8G8_B8G8_UNorm:  		ddpf = DDS.PixelFormat.R8G8_B8G8;  		break;  	case Format.G8R8_G8B8_UNorm:  		ddpf = DDS.PixelFormat.G8R8_G8B8;  		break;  	case Format.BC1_UNorm:  		ddpf = DDS.PixelFormat.DXT1;  		break;  	case Format.BC2_UNorm:  		ddpf = DDS.PixelFormat.DXT3;  		break;  	case Format.BC3_UNorm:  		ddpf = DDS.PixelFormat.DXT5;  		break;  	case Format.BC4_UNorm:  		ddpf = DDS.PixelFormat.BC4_UNorm;  		break;  	case Format.BC4_SNorm:  		ddpf = DDS.PixelFormat.BC4_SNorm;  		break;  	case Format.BC5_UNorm:  		ddpf = DDS.PixelFormat.BC5_UNorm;  		break;  	case Format.BC5_SNorm:  		ddpf = DDS.PixelFormat.BC5_SNorm;  		break;  	case Format.B5G6R5_UNorm:  		ddpf = DDS.PixelFormat.R5G6B5;  		break;  	case Format.B5G5R5A1_UNorm:  		ddpf = DDS.PixelFormat.A1R5G5B5;  		break;  	case Format.B8G8R8A8_UNorm:  		ddpf = DDS.PixelFormat.A8R8G8B8;  		break;  	// DXGI 1.1  	case Format.B8G8R8X8_UNorm:  		ddpf = DDS.PixelFormat.X8R8G8B8;  		break;  	// DXGI 1.1  	#if DIRECTX11_1  	                    case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  	// Legacy D3DX formats using D3DFMT enum value as FourCC  	case Format.R32G32B32A32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 116;  		// D3DFMT_A32B32G32R32F  		break;  	case Format.R16G16B16A16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 113;  		// D3DFMT_A16B16G16R16F  		break;  	case Format.R16G16B16A16_UNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 36;  		// D3DFMT_A16B16G16R16  		break;  	case Format.R16G16B16A16_SNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 110;  		// D3DFMT_Q16W16V16U16  		break;  	case Format.R32G32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 115;  		// D3DFMT_G32R32F  		break;  	case Format.R16G16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 112;  		// D3DFMT_G16R16F  		break;  	case Format.R32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 114;  		// D3DFMT_R32F  		break;  	case Format.R16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 111;  		// D3DFMT_R16F  		break;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0) {  	switch (description.Format) {  	case Format.R8G8B8A8_UNorm:  		ddpf = DDS.PixelFormat.A8B8G8R8;  		break;  	case Format.R16G16_UNorm:  		ddpf = DDS.PixelFormat.G16R16;  		break;  	case Format.R8G8_UNorm:  		ddpf = DDS.PixelFormat.A8L8;  		break;  	case Format.R16_UNorm:  		ddpf = DDS.PixelFormat.L16;  		break;  	case Format.R8_UNorm:  		ddpf = DDS.PixelFormat.L8;  		break;  	case Format.A8_UNorm:  		ddpf = DDS.PixelFormat.A8;  		break;  	case Format.R8G8_B8G8_UNorm:  		ddpf = DDS.PixelFormat.R8G8_B8G8;  		break;  	case Format.G8R8_G8B8_UNorm:  		ddpf = DDS.PixelFormat.G8R8_G8B8;  		break;  	case Format.BC1_UNorm:  		ddpf = DDS.PixelFormat.DXT1;  		break;  	case Format.BC2_UNorm:  		ddpf = DDS.PixelFormat.DXT3;  		break;  	case Format.BC3_UNorm:  		ddpf = DDS.PixelFormat.DXT5;  		break;  	case Format.BC4_UNorm:  		ddpf = DDS.PixelFormat.BC4_UNorm;  		break;  	case Format.BC4_SNorm:  		ddpf = DDS.PixelFormat.BC4_SNorm;  		break;  	case Format.BC5_UNorm:  		ddpf = DDS.PixelFormat.BC5_UNorm;  		break;  	case Format.BC5_SNorm:  		ddpf = DDS.PixelFormat.BC5_SNorm;  		break;  	case Format.B5G6R5_UNorm:  		ddpf = DDS.PixelFormat.R5G6B5;  		break;  	case Format.B5G5R5A1_UNorm:  		ddpf = DDS.PixelFormat.A1R5G5B5;  		break;  	case Format.B8G8R8A8_UNorm:  		ddpf = DDS.PixelFormat.A8R8G8B8;  		break;  	// DXGI 1.1  	case Format.B8G8R8X8_UNorm:  		ddpf = DDS.PixelFormat.X8R8G8B8;  		break;  	// DXGI 1.1  	#if DIRECTX11_1  	                    case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  	// Legacy D3DX formats using D3DFMT enum value as FourCC  	case Format.R32G32B32A32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 116;  		// D3DFMT_A32B32G32R32F  		break;  	case Format.R16G16B16A16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 113;  		// D3DFMT_A16B16G16R16F  		break;  	case Format.R16G16B16A16_UNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 36;  		// D3DFMT_A16B16G16R16  		break;  	case Format.R16G16B16A16_SNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 110;  		// D3DFMT_Q16W16V16U16  		break;  	case Format.R32G32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 115;  		// D3DFMT_G32R32F  		break;  	case Format.R16G16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 112;  		// D3DFMT_G16R16F  		break;  	case Format.R32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 114;  		// D3DFMT_R32F  		break;  	case Format.R16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 111;  		// D3DFMT_R16F  		break;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0) {  	switch (description.Format) {  	case Format.R8G8B8A8_UNorm:  		ddpf = DDS.PixelFormat.A8B8G8R8;  		break;  	case Format.R16G16_UNorm:  		ddpf = DDS.PixelFormat.G16R16;  		break;  	case Format.R8G8_UNorm:  		ddpf = DDS.PixelFormat.A8L8;  		break;  	case Format.R16_UNorm:  		ddpf = DDS.PixelFormat.L16;  		break;  	case Format.R8_UNorm:  		ddpf = DDS.PixelFormat.L8;  		break;  	case Format.A8_UNorm:  		ddpf = DDS.PixelFormat.A8;  		break;  	case Format.R8G8_B8G8_UNorm:  		ddpf = DDS.PixelFormat.R8G8_B8G8;  		break;  	case Format.G8R8_G8B8_UNorm:  		ddpf = DDS.PixelFormat.G8R8_G8B8;  		break;  	case Format.BC1_UNorm:  		ddpf = DDS.PixelFormat.DXT1;  		break;  	case Format.BC2_UNorm:  		ddpf = DDS.PixelFormat.DXT3;  		break;  	case Format.BC3_UNorm:  		ddpf = DDS.PixelFormat.DXT5;  		break;  	case Format.BC4_UNorm:  		ddpf = DDS.PixelFormat.BC4_UNorm;  		break;  	case Format.BC4_SNorm:  		ddpf = DDS.PixelFormat.BC4_SNorm;  		break;  	case Format.BC5_UNorm:  		ddpf = DDS.PixelFormat.BC5_UNorm;  		break;  	case Format.BC5_SNorm:  		ddpf = DDS.PixelFormat.BC5_SNorm;  		break;  	case Format.B5G6R5_UNorm:  		ddpf = DDS.PixelFormat.R5G6B5;  		break;  	case Format.B5G5R5A1_UNorm:  		ddpf = DDS.PixelFormat.A1R5G5B5;  		break;  	case Format.B8G8R8A8_UNorm:  		ddpf = DDS.PixelFormat.A8R8G8B8;  		break;  	// DXGI 1.1  	case Format.B8G8R8X8_UNorm:  		ddpf = DDS.PixelFormat.X8R8G8B8;  		break;  	// DXGI 1.1  	#if DIRECTX11_1  	                    case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  	// Legacy D3DX formats using D3DFMT enum value as FourCC  	case Format.R32G32B32A32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 116;  		// D3DFMT_A32B32G32R32F  		break;  	case Format.R16G16B16A16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 113;  		// D3DFMT_A16B16G16R16F  		break;  	case Format.R16G16B16A16_UNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 36;  		// D3DFMT_A16B16G16R16  		break;  	case Format.R16G16B16A16_SNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 110;  		// D3DFMT_Q16W16V16U16  		break;  	case Format.R32G32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 115;  		// D3DFMT_G32R32F  		break;  	case Format.R16G16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 112;  		// D3DFMT_G16R16F  		break;  	case Format.R32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 114;  		// D3DFMT_R32F  		break;  	case Format.R16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 111;  		// D3DFMT_R16F  		break;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0) {  	switch (description.Format) {  	case Format.R8G8B8A8_UNorm:  		ddpf = DDS.PixelFormat.A8B8G8R8;  		break;  	case Format.R16G16_UNorm:  		ddpf = DDS.PixelFormat.G16R16;  		break;  	case Format.R8G8_UNorm:  		ddpf = DDS.PixelFormat.A8L8;  		break;  	case Format.R16_UNorm:  		ddpf = DDS.PixelFormat.L16;  		break;  	case Format.R8_UNorm:  		ddpf = DDS.PixelFormat.L8;  		break;  	case Format.A8_UNorm:  		ddpf = DDS.PixelFormat.A8;  		break;  	case Format.R8G8_B8G8_UNorm:  		ddpf = DDS.PixelFormat.R8G8_B8G8;  		break;  	case Format.G8R8_G8B8_UNorm:  		ddpf = DDS.PixelFormat.G8R8_G8B8;  		break;  	case Format.BC1_UNorm:  		ddpf = DDS.PixelFormat.DXT1;  		break;  	case Format.BC2_UNorm:  		ddpf = DDS.PixelFormat.DXT3;  		break;  	case Format.BC3_UNorm:  		ddpf = DDS.PixelFormat.DXT5;  		break;  	case Format.BC4_UNorm:  		ddpf = DDS.PixelFormat.BC4_UNorm;  		break;  	case Format.BC4_SNorm:  		ddpf = DDS.PixelFormat.BC4_SNorm;  		break;  	case Format.BC5_UNorm:  		ddpf = DDS.PixelFormat.BC5_UNorm;  		break;  	case Format.BC5_SNorm:  		ddpf = DDS.PixelFormat.BC5_SNorm;  		break;  	case Format.B5G6R5_UNorm:  		ddpf = DDS.PixelFormat.R5G6B5;  		break;  	case Format.B5G5R5A1_UNorm:  		ddpf = DDS.PixelFormat.A1R5G5B5;  		break;  	case Format.B8G8R8A8_UNorm:  		ddpf = DDS.PixelFormat.A8R8G8B8;  		break;  	// DXGI 1.1  	case Format.B8G8R8X8_UNorm:  		ddpf = DDS.PixelFormat.X8R8G8B8;  		break;  	// DXGI 1.1  	#if DIRECTX11_1  	                    case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  	// Legacy D3DX formats using D3DFMT enum value as FourCC  	case Format.R32G32B32A32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 116;  		// D3DFMT_A32B32G32R32F  		break;  	case Format.R16G16B16A16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 113;  		// D3DFMT_A16B16G16R16F  		break;  	case Format.R16G16B16A16_UNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 36;  		// D3DFMT_A16B16G16R16  		break;  	case Format.R16G16B16A16_SNorm:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 110;  		// D3DFMT_Q16W16V16U16  		break;  	case Format.R32G32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 115;  		// D3DFMT_G32R32F  		break;  	case Format.R16G16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 112;  		// D3DFMT_G16R16F  		break;  	case Format.R32_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 114;  		// D3DFMT_R32F  		break;  	case Format.R16_Float:  		ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  		ddpf.Flags = DDS.PixelFormatFlags.FourCC;  		ddpf.FourCC = 111;  		// D3DFMT_R16F  		break;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format) {  case Format.R8G8B8A8_UNorm:  	ddpf = DDS.PixelFormat.A8B8G8R8;  	break;  case Format.R16G16_UNorm:  	ddpf = DDS.PixelFormat.G16R16;  	break;  case Format.R8G8_UNorm:  	ddpf = DDS.PixelFormat.A8L8;  	break;  case Format.R16_UNorm:  	ddpf = DDS.PixelFormat.L16;  	break;  case Format.R8_UNorm:  	ddpf = DDS.PixelFormat.L8;  	break;  case Format.A8_UNorm:  	ddpf = DDS.PixelFormat.A8;  	break;  case Format.R8G8_B8G8_UNorm:  	ddpf = DDS.PixelFormat.R8G8_B8G8;  	break;  case Format.G8R8_G8B8_UNorm:  	ddpf = DDS.PixelFormat.G8R8_G8B8;  	break;  case Format.BC1_UNorm:  	ddpf = DDS.PixelFormat.DXT1;  	break;  case Format.BC2_UNorm:  	ddpf = DDS.PixelFormat.DXT3;  	break;  case Format.BC3_UNorm:  	ddpf = DDS.PixelFormat.DXT5;  	break;  case Format.BC4_UNorm:  	ddpf = DDS.PixelFormat.BC4_UNorm;  	break;  case Format.BC4_SNorm:  	ddpf = DDS.PixelFormat.BC4_SNorm;  	break;  case Format.BC5_UNorm:  	ddpf = DDS.PixelFormat.BC5_UNorm;  	break;  case Format.BC5_SNorm:  	ddpf = DDS.PixelFormat.BC5_SNorm;  	break;  case Format.B5G6R5_UNorm:  	ddpf = DDS.PixelFormat.R5G6B5;  	break;  case Format.B5G5R5A1_UNorm:  	ddpf = DDS.PixelFormat.A1R5G5B5;  	break;  case Format.B8G8R8A8_UNorm:  	ddpf = DDS.PixelFormat.A8R8G8B8;  	break;  // DXGI 1.1  case Format.B8G8R8X8_UNorm:  	ddpf = DDS.PixelFormat.X8R8G8B8;  	break;  // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  // Legacy D3DX formats using D3DFMT enum value as FourCC  case Format.R32G32B32A32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 116;  	// D3DFMT_A32B32G32R32F  	break;  case Format.R16G16B16A16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 113;  	// D3DFMT_A16B16G16R16F  	break;  case Format.R16G16B16A16_UNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 36;  	// D3DFMT_A16B16G16R16  	break;  case Format.R16G16B16A16_SNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 110;  	// D3DFMT_Q16W16V16U16  	break;  case Format.R32G32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 115;  	// D3DFMT_G32R32F  	break;  case Format.R16G16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 112;  	// D3DFMT_G16R16F  	break;  case Format.R32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 114;  	// D3DFMT_R32F  	break;  case Format.R16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 111;  	// D3DFMT_R16F  	break;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format) {  case Format.R8G8B8A8_UNorm:  	ddpf = DDS.PixelFormat.A8B8G8R8;  	break;  case Format.R16G16_UNorm:  	ddpf = DDS.PixelFormat.G16R16;  	break;  case Format.R8G8_UNorm:  	ddpf = DDS.PixelFormat.A8L8;  	break;  case Format.R16_UNorm:  	ddpf = DDS.PixelFormat.L16;  	break;  case Format.R8_UNorm:  	ddpf = DDS.PixelFormat.L8;  	break;  case Format.A8_UNorm:  	ddpf = DDS.PixelFormat.A8;  	break;  case Format.R8G8_B8G8_UNorm:  	ddpf = DDS.PixelFormat.R8G8_B8G8;  	break;  case Format.G8R8_G8B8_UNorm:  	ddpf = DDS.PixelFormat.G8R8_G8B8;  	break;  case Format.BC1_UNorm:  	ddpf = DDS.PixelFormat.DXT1;  	break;  case Format.BC2_UNorm:  	ddpf = DDS.PixelFormat.DXT3;  	break;  case Format.BC3_UNorm:  	ddpf = DDS.PixelFormat.DXT5;  	break;  case Format.BC4_UNorm:  	ddpf = DDS.PixelFormat.BC4_UNorm;  	break;  case Format.BC4_SNorm:  	ddpf = DDS.PixelFormat.BC4_SNorm;  	break;  case Format.BC5_UNorm:  	ddpf = DDS.PixelFormat.BC5_UNorm;  	break;  case Format.BC5_SNorm:  	ddpf = DDS.PixelFormat.BC5_SNorm;  	break;  case Format.B5G6R5_UNorm:  	ddpf = DDS.PixelFormat.R5G6B5;  	break;  case Format.B5G5R5A1_UNorm:  	ddpf = DDS.PixelFormat.A1R5G5B5;  	break;  case Format.B8G8R8A8_UNorm:  	ddpf = DDS.PixelFormat.A8R8G8B8;  	break;  // DXGI 1.1  case Format.B8G8R8X8_UNorm:  	ddpf = DDS.PixelFormat.X8R8G8B8;  	break;  // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  // Legacy D3DX formats using D3DFMT enum value as FourCC  case Format.R32G32B32A32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 116;  	// D3DFMT_A32B32G32R32F  	break;  case Format.R16G16B16A16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 113;  	// D3DFMT_A16B16G16R16F  	break;  case Format.R16G16B16A16_UNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 36;  	// D3DFMT_A16B16G16R16  	break;  case Format.R16G16B16A16_SNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 110;  	// D3DFMT_Q16W16V16U16  	break;  case Format.R32G32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 115;  	// D3DFMT_G32R32F  	break;  case Format.R16G16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 112;  	// D3DFMT_G16R16F  	break;  case Format.R32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 114;  	// D3DFMT_R32F  	break;  case Format.R16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 111;  	// D3DFMT_R16F  	break;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format) {  case Format.R8G8B8A8_UNorm:  	ddpf = DDS.PixelFormat.A8B8G8R8;  	break;  case Format.R16G16_UNorm:  	ddpf = DDS.PixelFormat.G16R16;  	break;  case Format.R8G8_UNorm:  	ddpf = DDS.PixelFormat.A8L8;  	break;  case Format.R16_UNorm:  	ddpf = DDS.PixelFormat.L16;  	break;  case Format.R8_UNorm:  	ddpf = DDS.PixelFormat.L8;  	break;  case Format.A8_UNorm:  	ddpf = DDS.PixelFormat.A8;  	break;  case Format.R8G8_B8G8_UNorm:  	ddpf = DDS.PixelFormat.R8G8_B8G8;  	break;  case Format.G8R8_G8B8_UNorm:  	ddpf = DDS.PixelFormat.G8R8_G8B8;  	break;  case Format.BC1_UNorm:  	ddpf = DDS.PixelFormat.DXT1;  	break;  case Format.BC2_UNorm:  	ddpf = DDS.PixelFormat.DXT3;  	break;  case Format.BC3_UNorm:  	ddpf = DDS.PixelFormat.DXT5;  	break;  case Format.BC4_UNorm:  	ddpf = DDS.PixelFormat.BC4_UNorm;  	break;  case Format.BC4_SNorm:  	ddpf = DDS.PixelFormat.BC4_SNorm;  	break;  case Format.BC5_UNorm:  	ddpf = DDS.PixelFormat.BC5_UNorm;  	break;  case Format.BC5_SNorm:  	ddpf = DDS.PixelFormat.BC5_SNorm;  	break;  case Format.B5G6R5_UNorm:  	ddpf = DDS.PixelFormat.R5G6B5;  	break;  case Format.B5G5R5A1_UNorm:  	ddpf = DDS.PixelFormat.A1R5G5B5;  	break;  case Format.B8G8R8A8_UNorm:  	ddpf = DDS.PixelFormat.A8R8G8B8;  	break;  // DXGI 1.1  case Format.B8G8R8X8_UNorm:  	ddpf = DDS.PixelFormat.X8R8G8B8;  	break;  // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  // Legacy D3DX formats using D3DFMT enum value as FourCC  case Format.R32G32B32A32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 116;  	// D3DFMT_A32B32G32R32F  	break;  case Format.R16G16B16A16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 113;  	// D3DFMT_A16B16G16R16F  	break;  case Format.R16G16B16A16_UNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 36;  	// D3DFMT_A16B16G16R16  	break;  case Format.R16G16B16A16_SNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 110;  	// D3DFMT_Q16W16V16U16  	break;  case Format.R32G32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 115;  	// D3DFMT_G32R32F  	break;  case Format.R16G16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 112;  	// D3DFMT_G16R16F  	break;  case Format.R32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 114;  	// D3DFMT_R32F  	break;  case Format.R16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 111;  	// D3DFMT_R16F  	break;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format) {  case Format.R8G8B8A8_UNorm:  	ddpf = DDS.PixelFormat.A8B8G8R8;  	break;  case Format.R16G16_UNorm:  	ddpf = DDS.PixelFormat.G16R16;  	break;  case Format.R8G8_UNorm:  	ddpf = DDS.PixelFormat.A8L8;  	break;  case Format.R16_UNorm:  	ddpf = DDS.PixelFormat.L16;  	break;  case Format.R8_UNorm:  	ddpf = DDS.PixelFormat.L8;  	break;  case Format.A8_UNorm:  	ddpf = DDS.PixelFormat.A8;  	break;  case Format.R8G8_B8G8_UNorm:  	ddpf = DDS.PixelFormat.R8G8_B8G8;  	break;  case Format.G8R8_G8B8_UNorm:  	ddpf = DDS.PixelFormat.G8R8_G8B8;  	break;  case Format.BC1_UNorm:  	ddpf = DDS.PixelFormat.DXT1;  	break;  case Format.BC2_UNorm:  	ddpf = DDS.PixelFormat.DXT3;  	break;  case Format.BC3_UNorm:  	ddpf = DDS.PixelFormat.DXT5;  	break;  case Format.BC4_UNorm:  	ddpf = DDS.PixelFormat.BC4_UNorm;  	break;  case Format.BC4_SNorm:  	ddpf = DDS.PixelFormat.BC4_SNorm;  	break;  case Format.BC5_UNorm:  	ddpf = DDS.PixelFormat.BC5_UNorm;  	break;  case Format.BC5_SNorm:  	ddpf = DDS.PixelFormat.BC5_SNorm;  	break;  case Format.B5G6R5_UNorm:  	ddpf = DDS.PixelFormat.R5G6B5;  	break;  case Format.B5G5R5A1_UNorm:  	ddpf = DDS.PixelFormat.A1R5G5B5;  	break;  case Format.B8G8R8A8_UNorm:  	ddpf = DDS.PixelFormat.A8R8G8B8;  	break;  // DXGI 1.1  case Format.B8G8R8X8_UNorm:  	ddpf = DDS.PixelFormat.X8R8G8B8;  	break;  // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  // Legacy D3DX formats using D3DFMT enum value as FourCC  case Format.R32G32B32A32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 116;  	// D3DFMT_A32B32G32R32F  	break;  case Format.R16G16B16A16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 113;  	// D3DFMT_A16B16G16R16F  	break;  case Format.R16G16B16A16_UNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 36;  	// D3DFMT_A16B16G16R16  	break;  case Format.R16G16B16A16_SNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 110;  	// D3DFMT_Q16W16V16U16  	break;  case Format.R32G32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 115;  	// D3DFMT_G32R32F  	break;  case Format.R16G16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 112;  	// D3DFMT_G16R16F  	break;  case Format.R32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 114;  	// D3DFMT_R32F  	break;  case Format.R16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 111;  	// D3DFMT_R16F  	break;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format) {  case Format.R8G8B8A8_UNorm:  	ddpf = DDS.PixelFormat.A8B8G8R8;  	break;  case Format.R16G16_UNorm:  	ddpf = DDS.PixelFormat.G16R16;  	break;  case Format.R8G8_UNorm:  	ddpf = DDS.PixelFormat.A8L8;  	break;  case Format.R16_UNorm:  	ddpf = DDS.PixelFormat.L16;  	break;  case Format.R8_UNorm:  	ddpf = DDS.PixelFormat.L8;  	break;  case Format.A8_UNorm:  	ddpf = DDS.PixelFormat.A8;  	break;  case Format.R8G8_B8G8_UNorm:  	ddpf = DDS.PixelFormat.R8G8_B8G8;  	break;  case Format.G8R8_G8B8_UNorm:  	ddpf = DDS.PixelFormat.G8R8_G8B8;  	break;  case Format.BC1_UNorm:  	ddpf = DDS.PixelFormat.DXT1;  	break;  case Format.BC2_UNorm:  	ddpf = DDS.PixelFormat.DXT3;  	break;  case Format.BC3_UNorm:  	ddpf = DDS.PixelFormat.DXT5;  	break;  case Format.BC4_UNorm:  	ddpf = DDS.PixelFormat.BC4_UNorm;  	break;  case Format.BC4_SNorm:  	ddpf = DDS.PixelFormat.BC4_SNorm;  	break;  case Format.BC5_UNorm:  	ddpf = DDS.PixelFormat.BC5_UNorm;  	break;  case Format.BC5_SNorm:  	ddpf = DDS.PixelFormat.BC5_SNorm;  	break;  case Format.B5G6R5_UNorm:  	ddpf = DDS.PixelFormat.R5G6B5;  	break;  case Format.B5G5R5A1_UNorm:  	ddpf = DDS.PixelFormat.A1R5G5B5;  	break;  case Format.B8G8R8A8_UNorm:  	ddpf = DDS.PixelFormat.A8R8G8B8;  	break;  // DXGI 1.1  case Format.B8G8R8X8_UNorm:  	ddpf = DDS.PixelFormat.X8R8G8B8;  	break;  // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  // Legacy D3DX formats using D3DFMT enum value as FourCC  case Format.R32G32B32A32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 116;  	// D3DFMT_A32B32G32R32F  	break;  case Format.R16G16B16A16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 113;  	// D3DFMT_A16B16G16R16F  	break;  case Format.R16G16B16A16_UNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 36;  	// D3DFMT_A16B16G16R16  	break;  case Format.R16G16B16A16_SNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 110;  	// D3DFMT_Q16W16V16U16  	break;  case Format.R32G32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 115;  	// D3DFMT_G32R32F  	break;  case Format.R16G16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 112;  	// D3DFMT_G16R16F  	break;  case Format.R32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 114;  	// D3DFMT_R32F  	break;  case Format.R16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 111;  	// D3DFMT_R16F  	break;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format) {  case Format.R8G8B8A8_UNorm:  	ddpf = DDS.PixelFormat.A8B8G8R8;  	break;  case Format.R16G16_UNorm:  	ddpf = DDS.PixelFormat.G16R16;  	break;  case Format.R8G8_UNorm:  	ddpf = DDS.PixelFormat.A8L8;  	break;  case Format.R16_UNorm:  	ddpf = DDS.PixelFormat.L16;  	break;  case Format.R8_UNorm:  	ddpf = DDS.PixelFormat.L8;  	break;  case Format.A8_UNorm:  	ddpf = DDS.PixelFormat.A8;  	break;  case Format.R8G8_B8G8_UNorm:  	ddpf = DDS.PixelFormat.R8G8_B8G8;  	break;  case Format.G8R8_G8B8_UNorm:  	ddpf = DDS.PixelFormat.G8R8_G8B8;  	break;  case Format.BC1_UNorm:  	ddpf = DDS.PixelFormat.DXT1;  	break;  case Format.BC2_UNorm:  	ddpf = DDS.PixelFormat.DXT3;  	break;  case Format.BC3_UNorm:  	ddpf = DDS.PixelFormat.DXT5;  	break;  case Format.BC4_UNorm:  	ddpf = DDS.PixelFormat.BC4_UNorm;  	break;  case Format.BC4_SNorm:  	ddpf = DDS.PixelFormat.BC4_SNorm;  	break;  case Format.BC5_UNorm:  	ddpf = DDS.PixelFormat.BC5_UNorm;  	break;  case Format.BC5_SNorm:  	ddpf = DDS.PixelFormat.BC5_SNorm;  	break;  case Format.B5G6R5_UNorm:  	ddpf = DDS.PixelFormat.R5G6B5;  	break;  case Format.B5G5R5A1_UNorm:  	ddpf = DDS.PixelFormat.A1R5G5B5;  	break;  case Format.B8G8R8A8_UNorm:  	ddpf = DDS.PixelFormat.A8R8G8B8;  	break;  // DXGI 1.1  case Format.B8G8R8X8_UNorm:  	ddpf = DDS.PixelFormat.X8R8G8B8;  	break;  // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  // Legacy D3DX formats using D3DFMT enum value as FourCC  case Format.R32G32B32A32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 116;  	// D3DFMT_A32B32G32R32F  	break;  case Format.R16G16B16A16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 113;  	// D3DFMT_A16B16G16R16F  	break;  case Format.R16G16B16A16_UNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 36;  	// D3DFMT_A16B16G16R16  	break;  case Format.R16G16B16A16_SNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 110;  	// D3DFMT_Q16W16V16U16  	break;  case Format.R32G32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 115;  	// D3DFMT_G32R32F  	break;  case Format.R16G16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 112;  	// D3DFMT_G16R16F  	break;  case Format.R32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 114;  	// D3DFMT_R32F  	break;  case Format.R16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 111;  	// D3DFMT_R16F  	break;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format) {  case Format.R8G8B8A8_UNorm:  	ddpf = DDS.PixelFormat.A8B8G8R8;  	break;  case Format.R16G16_UNorm:  	ddpf = DDS.PixelFormat.G16R16;  	break;  case Format.R8G8_UNorm:  	ddpf = DDS.PixelFormat.A8L8;  	break;  case Format.R16_UNorm:  	ddpf = DDS.PixelFormat.L16;  	break;  case Format.R8_UNorm:  	ddpf = DDS.PixelFormat.L8;  	break;  case Format.A8_UNorm:  	ddpf = DDS.PixelFormat.A8;  	break;  case Format.R8G8_B8G8_UNorm:  	ddpf = DDS.PixelFormat.R8G8_B8G8;  	break;  case Format.G8R8_G8B8_UNorm:  	ddpf = DDS.PixelFormat.G8R8_G8B8;  	break;  case Format.BC1_UNorm:  	ddpf = DDS.PixelFormat.DXT1;  	break;  case Format.BC2_UNorm:  	ddpf = DDS.PixelFormat.DXT3;  	break;  case Format.BC3_UNorm:  	ddpf = DDS.PixelFormat.DXT5;  	break;  case Format.BC4_UNorm:  	ddpf = DDS.PixelFormat.BC4_UNorm;  	break;  case Format.BC4_SNorm:  	ddpf = DDS.PixelFormat.BC4_SNorm;  	break;  case Format.BC5_UNorm:  	ddpf = DDS.PixelFormat.BC5_UNorm;  	break;  case Format.BC5_SNorm:  	ddpf = DDS.PixelFormat.BC5_SNorm;  	break;  case Format.B5G6R5_UNorm:  	ddpf = DDS.PixelFormat.R5G6B5;  	break;  case Format.B5G5R5A1_UNorm:  	ddpf = DDS.PixelFormat.A1R5G5B5;  	break;  case Format.B8G8R8A8_UNorm:  	ddpf = DDS.PixelFormat.A8R8G8B8;  	break;  // DXGI 1.1  case Format.B8G8R8X8_UNorm:  	ddpf = DDS.PixelFormat.X8R8G8B8;  	break;  // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  // Legacy D3DX formats using D3DFMT enum value as FourCC  case Format.R32G32B32A32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 116;  	// D3DFMT_A32B32G32R32F  	break;  case Format.R16G16B16A16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 113;  	// D3DFMT_A16B16G16R16F  	break;  case Format.R16G16B16A16_UNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 36;  	// D3DFMT_A16B16G16R16  	break;  case Format.R16G16B16A16_SNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 110;  	// D3DFMT_Q16W16V16U16  	break;  case Format.R32G32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 115;  	// D3DFMT_G32R32F  	break;  case Format.R16G16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 112;  	// D3DFMT_G16R16F  	break;  case Format.R32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 114;  	// D3DFMT_R32F  	break;  case Format.R16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 111;  	// D3DFMT_R16F  	break;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format) {  case Format.R8G8B8A8_UNorm:  	ddpf = DDS.PixelFormat.A8B8G8R8;  	break;  case Format.R16G16_UNorm:  	ddpf = DDS.PixelFormat.G16R16;  	break;  case Format.R8G8_UNorm:  	ddpf = DDS.PixelFormat.A8L8;  	break;  case Format.R16_UNorm:  	ddpf = DDS.PixelFormat.L16;  	break;  case Format.R8_UNorm:  	ddpf = DDS.PixelFormat.L8;  	break;  case Format.A8_UNorm:  	ddpf = DDS.PixelFormat.A8;  	break;  case Format.R8G8_B8G8_UNorm:  	ddpf = DDS.PixelFormat.R8G8_B8G8;  	break;  case Format.G8R8_G8B8_UNorm:  	ddpf = DDS.PixelFormat.G8R8_G8B8;  	break;  case Format.BC1_UNorm:  	ddpf = DDS.PixelFormat.DXT1;  	break;  case Format.BC2_UNorm:  	ddpf = DDS.PixelFormat.DXT3;  	break;  case Format.BC3_UNorm:  	ddpf = DDS.PixelFormat.DXT5;  	break;  case Format.BC4_UNorm:  	ddpf = DDS.PixelFormat.BC4_UNorm;  	break;  case Format.BC4_SNorm:  	ddpf = DDS.PixelFormat.BC4_SNorm;  	break;  case Format.BC5_UNorm:  	ddpf = DDS.PixelFormat.BC5_UNorm;  	break;  case Format.BC5_SNorm:  	ddpf = DDS.PixelFormat.BC5_SNorm;  	break;  case Format.B5G6R5_UNorm:  	ddpf = DDS.PixelFormat.R5G6B5;  	break;  case Format.B5G5R5A1_UNorm:  	ddpf = DDS.PixelFormat.A1R5G5B5;  	break;  case Format.B8G8R8A8_UNorm:  	ddpf = DDS.PixelFormat.A8R8G8B8;  	break;  // DXGI 1.1  case Format.B8G8R8X8_UNorm:  	ddpf = DDS.PixelFormat.X8R8G8B8;  	break;  // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  // Legacy D3DX formats using D3DFMT enum value as FourCC  case Format.R32G32B32A32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 116;  	// D3DFMT_A32B32G32R32F  	break;  case Format.R16G16B16A16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 113;  	// D3DFMT_A16B16G16R16F  	break;  case Format.R16G16B16A16_UNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 36;  	// D3DFMT_A16B16G16R16  	break;  case Format.R16G16B16A16_SNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 110;  	// D3DFMT_Q16W16V16U16  	break;  case Format.R32G32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 115;  	// D3DFMT_G32R32F  	break;  case Format.R16G16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 112;  	// D3DFMT_G16R16F  	break;  case Format.R32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 114;  	// D3DFMT_R32F  	break;  case Format.R16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 111;  	// D3DFMT_R16F  	break;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: ddpf.FourCC = 116;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: ddpf.FourCC = 113;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: ddpf.FourCC = 36;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: ddpf.FourCC = 110;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: ddpf.FourCC = 115;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: ddpf.FourCC = 112;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: ddpf.FourCC = 114;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: ddpf.FourCC = 111;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if (ddpf.Size == 0) {  	header->PixelFormat = DDS.PixelFormat.DX10;  	var ext = (DDS.HeaderDXT10*)((byte*)(header) + Utilities.SizeOf<DDS.Header> ());  	Utilities.ClearMemory ((IntPtr)ext' 0' Utilities.SizeOf<DDS.HeaderDXT10> ());  	ext->DXGIFormat = description.Format;  	switch (description.Dimension) {  	case TextureDimension.Texture1D:  		ext->ResourceDimension = ResourceDimension.Texture1D;  		break;  	case TextureDimension.Texture2D:  	case TextureDimension.TextureCube:  		ext->ResourceDimension = ResourceDimension.Texture2D;  		break;  	case TextureDimension.Texture3D:  		ext->ResourceDimension = ResourceDimension.Texture3D;  		break;  	}  	if (description.Dimension == TextureDimension.TextureCube) {  		ext->MiscFlags |= ResourceOptionFlags.TextureCube;  		ext->ArraySize = description.ArraySize / 6;  	} else {  		ext->ArraySize = description.ArraySize;  	}  } else {  	header->PixelFormat = ddpf;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if (description.Dimension == TextureDimension.TextureCube) {  	ext->MiscFlags |= ResourceOptionFlags.TextureCube;  	ext->ArraySize = description.ArraySize / 6;  } else {  	ext->ArraySize = description.ArraySize;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: ext->ArraySize = description.ArraySize / 6;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  	// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  	int t1 = (*(sPtr) << 16);  	int t2 = (*(sPtr + 1) << 8);  	int t3 = *(sPtr + 2);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  	sPtr += 3;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  	// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  	int t1 = (*(sPtr) << 16);  	int t2 = (*(sPtr + 1) << 8);  	int t3 = *(sPtr + 2);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  	sPtr += 3;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  	// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  	int t1 = (*(sPtr) << 16);  	int t2 = (*(sPtr + 1) << 8);  	int t3 = *(sPtr + 2);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  	sPtr += 3;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  	// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  	int t1 = (*(sPtr) << 16);  	int t2 = (*(sPtr + 1) << 8);  	int t3 = *(sPtr + 2);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  	sPtr += 3;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  	// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  	int t1 = (*(sPtr) << 16);  	int t2 = (*(sPtr + 1) << 8);  	int t3 = *(sPtr + 2);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  	sPtr += 3;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  	// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  	int t1 = (*(sPtr) << 16);  	int t2 = (*(sPtr + 1) << 8);  	int t3 = *(sPtr + 2);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  	sPtr += 3;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: icount += 3
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: ocount += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: sPtr += 3;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  	int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  	int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  	int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  	int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  	int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  	int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  	int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  	int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  	int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  	int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  	int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  	int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  	int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  	int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  	int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  	int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  	int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  	int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  	int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  	int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  	*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: ocount += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  	byte t = *(sPtr++);  	var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  	var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  	var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  	*(dPtr++) = (short)(t1 | t2 | t3);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  	byte t = *(sPtr++);  	var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  	var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  	var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  	*(dPtr++) = (short)(t1 | t2 | t3);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  	byte t = *(sPtr++);  	var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  	var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  	var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  	*(dPtr++) = (short)(t1 | t2 | t3);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  	byte t = *(sPtr++);  	var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  	var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  	var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  	*(dPtr++) = (short)(t1 | t2 | t3);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  	byte t = *(sPtr++);  	var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  	var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  	var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  	*(dPtr++) = (short)(t1 | t2 | t3);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  	byte t = *(sPtr++);  	var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  	var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  	var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  	*(dPtr++) = (short)(t1 | t2 | t3);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: ocount += 2
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  	uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  	uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  	uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  	uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  	uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  	uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  	uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  	uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  	uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  	uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  	uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  	uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  	uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  	uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  	uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  	uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  	uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  	uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  	uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  	uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  	uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  	uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  	uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  	uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: icount += 2
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: ocount += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	*(dPtr++) = pal8 [t];  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: ocount += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)pal8 [t & 0xff];  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)pal8 [t & 0xff];  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)pal8 [t & 0xff];  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  	*(dPtr++) = (int)(t1 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: icount += 2
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: ocount += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  // DXGI_1_2_FORMATS  case Format.R8G8B8A8_UNorm:  	// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  			*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  // DXGI_1_2_FORMATS  case Format.R8G8B8A8_UNorm:  	// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  			*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  // DXGI_1_2_FORMATS  case Format.R8G8B8A8_UNorm:  	// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  			*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  // DXGI_1_2_FORMATS  case Format.R8G8B8A8_UNorm:  	// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  			*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  // DXGI_1_2_FORMATS  case Format.R8G8B8A8_UNorm:  	// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  			*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (outFormat) {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  // DXGI_1_2_FORMATS  case Format.R8G8B8A8_UNorm:  	// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  			*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  		}  	}  	return true;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  	*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  	*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  	*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  	*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  	*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  	byte t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  	*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: ocount += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: *(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: *(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  	uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  	uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  	uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  	uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  	uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  	uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  	uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  	uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  	uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  	uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  	uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  	uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  	uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  	uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  	uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  	uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  	uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  	uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	short t = *(sPtr++);  	uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  	uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  	uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  	uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  	*(dPtr++) = (int)(t1 | t2 | t3 | ta);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: icount += 2
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: ocount += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LoadFromDDSMemory,The following statement contains a magic number: if ((convFlags & ConversionFlags.Pal8) != 0) {  	pal8 = (int*)((byte*)(pSource) + offset);  	offset += (256 * sizeof(uint));  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LoadFromDDSMemory,The following statement contains a magic number: offset += (256 * sizeof(uint));  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  	uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	*(dPtr++) = t1 | t2 | t3 | 0xff000000;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  	uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	*(dPtr++) = t1 | t2 | t3 | 0xff000000;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  	uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	*(dPtr++) = t1 | t2 | t3 | 0xff000000;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  	uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	*(dPtr++) = t1 | t2 | t3 | 0xff000000;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  	uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	*(dPtr++) = t1 | t2 | t3 | 0xff000000;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  	uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	*(dPtr++) = t1 | t2 | t3 | 0xff000000;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  	uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	*(dPtr++) = t1 | t2 | t3 | 0xff000000;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  	uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	*(dPtr++) = t1 | t2 | t3 | 0xff000000;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: icount += 2
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: ocount += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  	uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  	uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  	uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  	uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  	uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  	uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  	ushort t = *(sPtr++);  	uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  	uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  	uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  	uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: icount += 2
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: ocount += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0) {  	switch (format) {  	//-----------------------------------------------------------------------------  	case Format.R32G32B32A32_Typeless:  	case Format.R32G32B32A32_Float:  	case Format.R32G32B32A32_UInt:  	case Format.R32G32B32A32_SInt:  		{  			uint alpha;  			if (format == Format.R32G32B32A32_Float)  				alpha = 0x3f800000;  			else if (format == Format.R32G32B32A32_SInt)  				alpha = 0x7fffffff;  			else  				alpha = 0xffffffff;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 16) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 16) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R16G16B16A16_Typeless:  	case Format.R16G16B16A16_Float:  	case Format.R16G16B16A16_UNorm:  	case Format.R16G16B16A16_UInt:  	case Format.R16G16B16A16_SNorm:  	case Format.R16G16B16A16_SInt:  		{  			ushort alpha;  			if (format == Format.R16G16B16A16_Float)  				alpha = 0x3c00;  			else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  				alpha = 0x7fff;  			else  				alpha = 0xffff;  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 8) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 8) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R10G10B10A2_Typeless:  	case Format.R10G10B10A2_UNorm:  	case Format.R10G10B10A2_UInt:  	case Format.R10G10B10_Xr_Bias_A2_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					*dPtr |= 0xC0000000;  					++dPtr;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					*(dPtr++) = *(sPtr++) | 0xC0000000;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R8G8B8A8_Typeless:  	case Format.R8G8B8A8_UNorm:  	case Format.R8G8B8A8_UNorm_SRgb:  	case Format.R8G8B8A8_UInt:  	case Format.R8G8B8A8_SNorm:  	case Format.R8G8B8A8_SInt:  	case Format.B8G8R8A8_UNorm:  	case Format.B8G8R8A8_Typeless:  	case Format.B8G8R8A8_UNorm_SRgb:  		{  			uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					uint t = *dPtr & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					uint t = *(sPtr++) & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.B5G5R5A1_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 2) {  					*(dPtr++) |= 0x8000;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 2) {  					*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.A8_UNorm:  		Utilities.ClearMemory (pDestination' 0xff' outSize);  		return;  	#if DIRECTX11_1  	                    //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  	// DXGI_1_2_FORMATS  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0) {  	switch (format) {  	//-----------------------------------------------------------------------------  	case Format.R32G32B32A32_Typeless:  	case Format.R32G32B32A32_Float:  	case Format.R32G32B32A32_UInt:  	case Format.R32G32B32A32_SInt:  		{  			uint alpha;  			if (format == Format.R32G32B32A32_Float)  				alpha = 0x3f800000;  			else if (format == Format.R32G32B32A32_SInt)  				alpha = 0x7fffffff;  			else  				alpha = 0xffffffff;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 16) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 16) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R16G16B16A16_Typeless:  	case Format.R16G16B16A16_Float:  	case Format.R16G16B16A16_UNorm:  	case Format.R16G16B16A16_UInt:  	case Format.R16G16B16A16_SNorm:  	case Format.R16G16B16A16_SInt:  		{  			ushort alpha;  			if (format == Format.R16G16B16A16_Float)  				alpha = 0x3c00;  			else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  				alpha = 0x7fff;  			else  				alpha = 0xffff;  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 8) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 8) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R10G10B10A2_Typeless:  	case Format.R10G10B10A2_UNorm:  	case Format.R10G10B10A2_UInt:  	case Format.R10G10B10_Xr_Bias_A2_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					*dPtr |= 0xC0000000;  					++dPtr;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					*(dPtr++) = *(sPtr++) | 0xC0000000;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R8G8B8A8_Typeless:  	case Format.R8G8B8A8_UNorm:  	case Format.R8G8B8A8_UNorm_SRgb:  	case Format.R8G8B8A8_UInt:  	case Format.R8G8B8A8_SNorm:  	case Format.R8G8B8A8_SInt:  	case Format.B8G8R8A8_UNorm:  	case Format.B8G8R8A8_Typeless:  	case Format.B8G8R8A8_UNorm_SRgb:  		{  			uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					uint t = *dPtr & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					uint t = *(sPtr++) & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.B5G5R5A1_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 2) {  					*(dPtr++) |= 0x8000;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 2) {  					*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.A8_UNorm:  		Utilities.ClearMemory (pDestination' 0xff' outSize);  		return;  	#if DIRECTX11_1  	                    //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  	// DXGI_1_2_FORMATS  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0) {  	switch (format) {  	//-----------------------------------------------------------------------------  	case Format.R32G32B32A32_Typeless:  	case Format.R32G32B32A32_Float:  	case Format.R32G32B32A32_UInt:  	case Format.R32G32B32A32_SInt:  		{  			uint alpha;  			if (format == Format.R32G32B32A32_Float)  				alpha = 0x3f800000;  			else if (format == Format.R32G32B32A32_SInt)  				alpha = 0x7fffffff;  			else  				alpha = 0xffffffff;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 16) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 16) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R16G16B16A16_Typeless:  	case Format.R16G16B16A16_Float:  	case Format.R16G16B16A16_UNorm:  	case Format.R16G16B16A16_UInt:  	case Format.R16G16B16A16_SNorm:  	case Format.R16G16B16A16_SInt:  		{  			ushort alpha;  			if (format == Format.R16G16B16A16_Float)  				alpha = 0x3c00;  			else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  				alpha = 0x7fff;  			else  				alpha = 0xffff;  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 8) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 8) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R10G10B10A2_Typeless:  	case Format.R10G10B10A2_UNorm:  	case Format.R10G10B10A2_UInt:  	case Format.R10G10B10_Xr_Bias_A2_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					*dPtr |= 0xC0000000;  					++dPtr;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					*(dPtr++) = *(sPtr++) | 0xC0000000;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R8G8B8A8_Typeless:  	case Format.R8G8B8A8_UNorm:  	case Format.R8G8B8A8_UNorm_SRgb:  	case Format.R8G8B8A8_UInt:  	case Format.R8G8B8A8_SNorm:  	case Format.R8G8B8A8_SInt:  	case Format.B8G8R8A8_UNorm:  	case Format.B8G8R8A8_Typeless:  	case Format.B8G8R8A8_UNorm_SRgb:  		{  			uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					uint t = *dPtr & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					uint t = *(sPtr++) & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.B5G5R5A1_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 2) {  					*(dPtr++) |= 0x8000;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 2) {  					*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.A8_UNorm:  		Utilities.ClearMemory (pDestination' 0xff' outSize);  		return;  	#if DIRECTX11_1  	                    //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  	// DXGI_1_2_FORMATS  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0) {  	switch (format) {  	//-----------------------------------------------------------------------------  	case Format.R32G32B32A32_Typeless:  	case Format.R32G32B32A32_Float:  	case Format.R32G32B32A32_UInt:  	case Format.R32G32B32A32_SInt:  		{  			uint alpha;  			if (format == Format.R32G32B32A32_Float)  				alpha = 0x3f800000;  			else if (format == Format.R32G32B32A32_SInt)  				alpha = 0x7fffffff;  			else  				alpha = 0xffffffff;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 16) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 16) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R16G16B16A16_Typeless:  	case Format.R16G16B16A16_Float:  	case Format.R16G16B16A16_UNorm:  	case Format.R16G16B16A16_UInt:  	case Format.R16G16B16A16_SNorm:  	case Format.R16G16B16A16_SInt:  		{  			ushort alpha;  			if (format == Format.R16G16B16A16_Float)  				alpha = 0x3c00;  			else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  				alpha = 0x7fff;  			else  				alpha = 0xffff;  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 8) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 8) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R10G10B10A2_Typeless:  	case Format.R10G10B10A2_UNorm:  	case Format.R10G10B10A2_UInt:  	case Format.R10G10B10_Xr_Bias_A2_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					*dPtr |= 0xC0000000;  					++dPtr;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					*(dPtr++) = *(sPtr++) | 0xC0000000;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R8G8B8A8_Typeless:  	case Format.R8G8B8A8_UNorm:  	case Format.R8G8B8A8_UNorm_SRgb:  	case Format.R8G8B8A8_UInt:  	case Format.R8G8B8A8_SNorm:  	case Format.R8G8B8A8_SInt:  	case Format.B8G8R8A8_UNorm:  	case Format.B8G8R8A8_Typeless:  	case Format.B8G8R8A8_UNorm_SRgb:  		{  			uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					uint t = *dPtr & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					uint t = *(sPtr++) & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.B5G5R5A1_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 2) {  					*(dPtr++) |= 0x8000;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 2) {  					*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.A8_UNorm:  		Utilities.ClearMemory (pDestination' 0xff' outSize);  		return;  	#if DIRECTX11_1  	                    //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  	// DXGI_1_2_FORMATS  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0) {  	switch (format) {  	//-----------------------------------------------------------------------------  	case Format.R32G32B32A32_Typeless:  	case Format.R32G32B32A32_Float:  	case Format.R32G32B32A32_UInt:  	case Format.R32G32B32A32_SInt:  		{  			uint alpha;  			if (format == Format.R32G32B32A32_Float)  				alpha = 0x3f800000;  			else if (format == Format.R32G32B32A32_SInt)  				alpha = 0x7fffffff;  			else  				alpha = 0xffffffff;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 16) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 16) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R16G16B16A16_Typeless:  	case Format.R16G16B16A16_Float:  	case Format.R16G16B16A16_UNorm:  	case Format.R16G16B16A16_UInt:  	case Format.R16G16B16A16_SNorm:  	case Format.R16G16B16A16_SInt:  		{  			ushort alpha;  			if (format == Format.R16G16B16A16_Float)  				alpha = 0x3c00;  			else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  				alpha = 0x7fff;  			else  				alpha = 0xffff;  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 8) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 8) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R10G10B10A2_Typeless:  	case Format.R10G10B10A2_UNorm:  	case Format.R10G10B10A2_UInt:  	case Format.R10G10B10_Xr_Bias_A2_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					*dPtr |= 0xC0000000;  					++dPtr;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					*(dPtr++) = *(sPtr++) | 0xC0000000;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R8G8B8A8_Typeless:  	case Format.R8G8B8A8_UNorm:  	case Format.R8G8B8A8_UNorm_SRgb:  	case Format.R8G8B8A8_UInt:  	case Format.R8G8B8A8_SNorm:  	case Format.R8G8B8A8_SInt:  	case Format.B8G8R8A8_UNorm:  	case Format.B8G8R8A8_Typeless:  	case Format.B8G8R8A8_UNorm_SRgb:  		{  			uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					uint t = *dPtr & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					uint t = *(sPtr++) & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.B5G5R5A1_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 2) {  					*(dPtr++) |= 0x8000;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 2) {  					*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.A8_UNorm:  		Utilities.ClearMemory (pDestination' 0xff' outSize);  		return;  	#if DIRECTX11_1  	                    //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  	// DXGI_1_2_FORMATS  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0) {  	switch (format) {  	//-----------------------------------------------------------------------------  	case Format.R32G32B32A32_Typeless:  	case Format.R32G32B32A32_Float:  	case Format.R32G32B32A32_UInt:  	case Format.R32G32B32A32_SInt:  		{  			uint alpha;  			if (format == Format.R32G32B32A32_Float)  				alpha = 0x3f800000;  			else if (format == Format.R32G32B32A32_SInt)  				alpha = 0x7fffffff;  			else  				alpha = 0xffffffff;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 16) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 16) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R16G16B16A16_Typeless:  	case Format.R16G16B16A16_Float:  	case Format.R16G16B16A16_UNorm:  	case Format.R16G16B16A16_UInt:  	case Format.R16G16B16A16_SNorm:  	case Format.R16G16B16A16_SInt:  		{  			ushort alpha;  			if (format == Format.R16G16B16A16_Float)  				alpha = 0x3c00;  			else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  				alpha = 0x7fff;  			else  				alpha = 0xffff;  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 8) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 8) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R10G10B10A2_Typeless:  	case Format.R10G10B10A2_UNorm:  	case Format.R10G10B10A2_UInt:  	case Format.R10G10B10_Xr_Bias_A2_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					*dPtr |= 0xC0000000;  					++dPtr;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					*(dPtr++) = *(sPtr++) | 0xC0000000;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R8G8B8A8_Typeless:  	case Format.R8G8B8A8_UNorm:  	case Format.R8G8B8A8_UNorm_SRgb:  	case Format.R8G8B8A8_UInt:  	case Format.R8G8B8A8_SNorm:  	case Format.R8G8B8A8_SInt:  	case Format.B8G8R8A8_UNorm:  	case Format.B8G8R8A8_Typeless:  	case Format.B8G8R8A8_UNorm_SRgb:  		{  			uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					uint t = *dPtr & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					uint t = *(sPtr++) & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.B5G5R5A1_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 2) {  					*(dPtr++) |= 0x8000;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 2) {  					*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.A8_UNorm:  		Utilities.ClearMemory (pDestination' 0xff' outSize);  		return;  	#if DIRECTX11_1  	                    //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  	// DXGI_1_2_FORMATS  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0) {  	switch (format) {  	//-----------------------------------------------------------------------------  	case Format.R32G32B32A32_Typeless:  	case Format.R32G32B32A32_Float:  	case Format.R32G32B32A32_UInt:  	case Format.R32G32B32A32_SInt:  		{  			uint alpha;  			if (format == Format.R32G32B32A32_Float)  				alpha = 0x3f800000;  			else if (format == Format.R32G32B32A32_SInt)  				alpha = 0x7fffffff;  			else  				alpha = 0xffffffff;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 16) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 16) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R16G16B16A16_Typeless:  	case Format.R16G16B16A16_Float:  	case Format.R16G16B16A16_UNorm:  	case Format.R16G16B16A16_UInt:  	case Format.R16G16B16A16_SNorm:  	case Format.R16G16B16A16_SInt:  		{  			ushort alpha;  			if (format == Format.R16G16B16A16_Float)  				alpha = 0x3c00;  			else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  				alpha = 0x7fff;  			else  				alpha = 0xffff;  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 8) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 8) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R10G10B10A2_Typeless:  	case Format.R10G10B10A2_UNorm:  	case Format.R10G10B10A2_UInt:  	case Format.R10G10B10_Xr_Bias_A2_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					*dPtr |= 0xC0000000;  					++dPtr;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					*(dPtr++) = *(sPtr++) | 0xC0000000;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R8G8B8A8_Typeless:  	case Format.R8G8B8A8_UNorm:  	case Format.R8G8B8A8_UNorm_SRgb:  	case Format.R8G8B8A8_UInt:  	case Format.R8G8B8A8_SNorm:  	case Format.R8G8B8A8_SInt:  	case Format.B8G8R8A8_UNorm:  	case Format.B8G8R8A8_Typeless:  	case Format.B8G8R8A8_UNorm_SRgb:  		{  			uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					uint t = *dPtr & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					uint t = *(sPtr++) & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.B5G5R5A1_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 2) {  					*(dPtr++) |= 0x8000;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 2) {  					*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.A8_UNorm:  		Utilities.ClearMemory (pDestination' 0xff' outSize);  		return;  	#if DIRECTX11_1  	                    //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  	// DXGI_1_2_FORMATS  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0) {  	switch (format) {  	//-----------------------------------------------------------------------------  	case Format.R32G32B32A32_Typeless:  	case Format.R32G32B32A32_Float:  	case Format.R32G32B32A32_UInt:  	case Format.R32G32B32A32_SInt:  		{  			uint alpha;  			if (format == Format.R32G32B32A32_Float)  				alpha = 0x3f800000;  			else if (format == Format.R32G32B32A32_SInt)  				alpha = 0x7fffffff;  			else  				alpha = 0xffffffff;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 16) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 16) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R16G16B16A16_Typeless:  	case Format.R16G16B16A16_Float:  	case Format.R16G16B16A16_UNorm:  	case Format.R16G16B16A16_UInt:  	case Format.R16G16B16A16_SNorm:  	case Format.R16G16B16A16_SInt:  		{  			ushort alpha;  			if (format == Format.R16G16B16A16_Float)  				alpha = 0x3c00;  			else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  				alpha = 0x7fff;  			else  				alpha = 0xffff;  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 8) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 8) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R10G10B10A2_Typeless:  	case Format.R10G10B10A2_UNorm:  	case Format.R10G10B10A2_UInt:  	case Format.R10G10B10_Xr_Bias_A2_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					*dPtr |= 0xC0000000;  					++dPtr;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					*(dPtr++) = *(sPtr++) | 0xC0000000;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R8G8B8A8_Typeless:  	case Format.R8G8B8A8_UNorm:  	case Format.R8G8B8A8_UNorm_SRgb:  	case Format.R8G8B8A8_UInt:  	case Format.R8G8B8A8_SNorm:  	case Format.R8G8B8A8_SInt:  	case Format.B8G8R8A8_UNorm:  	case Format.B8G8R8A8_Typeless:  	case Format.B8G8R8A8_UNorm_SRgb:  		{  			uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					uint t = *dPtr & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					uint t = *(sPtr++) & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.B5G5R5A1_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 2) {  					*(dPtr++) |= 0x8000;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 2) {  					*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.A8_UNorm:  		Utilities.ClearMemory (pDestination' 0xff' outSize);  		return;  	#if DIRECTX11_1  	                    //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  	// DXGI_1_2_FORMATS  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0) {  	switch (format) {  	//-----------------------------------------------------------------------------  	case Format.R32G32B32A32_Typeless:  	case Format.R32G32B32A32_Float:  	case Format.R32G32B32A32_UInt:  	case Format.R32G32B32A32_SInt:  		{  			uint alpha;  			if (format == Format.R32G32B32A32_Float)  				alpha = 0x3f800000;  			else if (format == Format.R32G32B32A32_SInt)  				alpha = 0x7fffffff;  			else  				alpha = 0xffffffff;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 16) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 16) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R16G16B16A16_Typeless:  	case Format.R16G16B16A16_Float:  	case Format.R16G16B16A16_UNorm:  	case Format.R16G16B16A16_UInt:  	case Format.R16G16B16A16_SNorm:  	case Format.R16G16B16A16_SInt:  		{  			ushort alpha;  			if (format == Format.R16G16B16A16_Float)  				alpha = 0x3c00;  			else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  				alpha = 0x7fff;  			else  				alpha = 0xffff;  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 8) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 8) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R10G10B10A2_Typeless:  	case Format.R10G10B10A2_UNorm:  	case Format.R10G10B10A2_UInt:  	case Format.R10G10B10_Xr_Bias_A2_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					*dPtr |= 0xC0000000;  					++dPtr;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					*(dPtr++) = *(sPtr++) | 0xC0000000;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R8G8B8A8_Typeless:  	case Format.R8G8B8A8_UNorm:  	case Format.R8G8B8A8_UNorm_SRgb:  	case Format.R8G8B8A8_UInt:  	case Format.R8G8B8A8_SNorm:  	case Format.R8G8B8A8_SInt:  	case Format.B8G8R8A8_UNorm:  	case Format.B8G8R8A8_Typeless:  	case Format.B8G8R8A8_UNorm_SRgb:  		{  			uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					uint t = *dPtr & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					uint t = *(sPtr++) & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.B5G5R5A1_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 2) {  					*(dPtr++) |= 0x8000;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 2) {  					*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.A8_UNorm:  		Utilities.ClearMemory (pDestination' 0xff' outSize);  		return;  	#if DIRECTX11_1  	                    //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  	// DXGI_1_2_FORMATS  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0) {  	switch (format) {  	//-----------------------------------------------------------------------------  	case Format.R32G32B32A32_Typeless:  	case Format.R32G32B32A32_Float:  	case Format.R32G32B32A32_UInt:  	case Format.R32G32B32A32_SInt:  		{  			uint alpha;  			if (format == Format.R32G32B32A32_Float)  				alpha = 0x3f800000;  			else if (format == Format.R32G32B32A32_SInt)  				alpha = 0x7fffffff;  			else  				alpha = 0xffffffff;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 16) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 16) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R16G16B16A16_Typeless:  	case Format.R16G16B16A16_Float:  	case Format.R16G16B16A16_UNorm:  	case Format.R16G16B16A16_UInt:  	case Format.R16G16B16A16_SNorm:  	case Format.R16G16B16A16_SInt:  		{  			ushort alpha;  			if (format == Format.R16G16B16A16_Float)  				alpha = 0x3c00;  			else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  				alpha = 0x7fff;  			else  				alpha = 0xffff;  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 8) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 8) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R10G10B10A2_Typeless:  	case Format.R10G10B10A2_UNorm:  	case Format.R10G10B10A2_UInt:  	case Format.R10G10B10_Xr_Bias_A2_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					*dPtr |= 0xC0000000;  					++dPtr;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					*(dPtr++) = *(sPtr++) | 0xC0000000;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R8G8B8A8_Typeless:  	case Format.R8G8B8A8_UNorm:  	case Format.R8G8B8A8_UNorm_SRgb:  	case Format.R8G8B8A8_UInt:  	case Format.R8G8B8A8_SNorm:  	case Format.R8G8B8A8_SInt:  	case Format.B8G8R8A8_UNorm:  	case Format.B8G8R8A8_Typeless:  	case Format.B8G8R8A8_UNorm_SRgb:  		{  			uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					uint t = *dPtr & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					uint t = *(sPtr++) & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.B5G5R5A1_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 2) {  					*(dPtr++) |= 0x8000;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 2) {  					*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.A8_UNorm:  		Utilities.ClearMemory (pDestination' 0xff' outSize);  		return;  	#if DIRECTX11_1  	                    //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  	// DXGI_1_2_FORMATS  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0) {  	switch (format) {  	//-----------------------------------------------------------------------------  	case Format.R32G32B32A32_Typeless:  	case Format.R32G32B32A32_Float:  	case Format.R32G32B32A32_UInt:  	case Format.R32G32B32A32_SInt:  		{  			uint alpha;  			if (format == Format.R32G32B32A32_Float)  				alpha = 0x3f800000;  			else if (format == Format.R32G32B32A32_SInt)  				alpha = 0x7fffffff;  			else  				alpha = 0xffffffff;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 16) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 16) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R16G16B16A16_Typeless:  	case Format.R16G16B16A16_Float:  	case Format.R16G16B16A16_UNorm:  	case Format.R16G16B16A16_UInt:  	case Format.R16G16B16A16_SNorm:  	case Format.R16G16B16A16_SInt:  		{  			ushort alpha;  			if (format == Format.R16G16B16A16_Float)  				alpha = 0x3c00;  			else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  				alpha = 0x7fff;  			else  				alpha = 0xffff;  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 8) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 8) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R10G10B10A2_Typeless:  	case Format.R10G10B10A2_UNorm:  	case Format.R10G10B10A2_UInt:  	case Format.R10G10B10_Xr_Bias_A2_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					*dPtr |= 0xC0000000;  					++dPtr;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					*(dPtr++) = *(sPtr++) | 0xC0000000;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R8G8B8A8_Typeless:  	case Format.R8G8B8A8_UNorm:  	case Format.R8G8B8A8_UNorm_SRgb:  	case Format.R8G8B8A8_UInt:  	case Format.R8G8B8A8_SNorm:  	case Format.R8G8B8A8_SInt:  	case Format.B8G8R8A8_UNorm:  	case Format.B8G8R8A8_Typeless:  	case Format.B8G8R8A8_UNorm_SRgb:  		{  			uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					uint t = *dPtr & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					uint t = *(sPtr++) & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.B5G5R5A1_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 2) {  					*(dPtr++) |= 0x8000;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 2) {  					*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.A8_UNorm:  		Utilities.ClearMemory (pDestination' 0xff' outSize);  		return;  	#if DIRECTX11_1  	                    //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  	// DXGI_1_2_FORMATS  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0) {  	switch (format) {  	//-----------------------------------------------------------------------------  	case Format.R32G32B32A32_Typeless:  	case Format.R32G32B32A32_Float:  	case Format.R32G32B32A32_UInt:  	case Format.R32G32B32A32_SInt:  		{  			uint alpha;  			if (format == Format.R32G32B32A32_Float)  				alpha = 0x3f800000;  			else if (format == Format.R32G32B32A32_SInt)  				alpha = 0x7fffffff;  			else  				alpha = 0xffffffff;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 16) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 16) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R16G16B16A16_Typeless:  	case Format.R16G16B16A16_Float:  	case Format.R16G16B16A16_UNorm:  	case Format.R16G16B16A16_UInt:  	case Format.R16G16B16A16_SNorm:  	case Format.R16G16B16A16_SInt:  		{  			ushort alpha;  			if (format == Format.R16G16B16A16_Float)  				alpha = 0x3c00;  			else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  				alpha = 0x7fff;  			else  				alpha = 0xffff;  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 8) {  					dPtr += 3;  					*(dPtr++) = alpha;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 8) {  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = *(sPtr++);  					*(dPtr++) = alpha;  					sPtr++;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R10G10B10A2_Typeless:  	case Format.R10G10B10A2_UNorm:  	case Format.R10G10B10A2_UInt:  	case Format.R10G10B10_Xr_Bias_A2_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					*dPtr |= 0xC0000000;  					++dPtr;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					*(dPtr++) = *(sPtr++) | 0xC0000000;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.R8G8B8A8_Typeless:  	case Format.R8G8B8A8_UNorm:  	case Format.R8G8B8A8_UNorm_SRgb:  	case Format.R8G8B8A8_UInt:  	case Format.R8G8B8A8_SNorm:  	case Format.R8G8B8A8_SInt:  	case Format.B8G8R8A8_UNorm:  	case Format.B8G8R8A8_Typeless:  	case Format.B8G8R8A8_UNorm_SRgb:  		{  			uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  			if (pDestination == pSource) {  				var dPtr = (uint*)(pDestination);  				for (int count = 0; count < outSize; count += 4) {  					uint t = *dPtr & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			} else {  				var sPtr = (uint*)(pSource);  				var dPtr = (uint*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 4) {  					uint t = *(sPtr++) & 0xFFFFFF;  					t |= alpha;  					*(dPtr++) = t;  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.B5G5R5A1_UNorm:  		{  			if (pDestination == pSource) {  				var dPtr = (ushort*)(pDestination);  				for (int count = 0; count < outSize; count += 2) {  					*(dPtr++) |= 0x8000;  				}  			} else {  				var sPtr = (ushort*)(pSource);  				var dPtr = (ushort*)(pDestination);  				int size = Math.Min (outSize' inSize);  				for (int count = 0; count < size; count += 2) {  					*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  				}  			}  		}  		return;  	//-----------------------------------------------------------------------------  	case Format.A8_UNorm:  		Utilities.ClearMemory (pDestination' 0xff' outSize);  		return;  	#if DIRECTX11_1  	                    //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  	// DXGI_1_2_FORMATS  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format) {  //-----------------------------------------------------------------------------  case Format.R32G32B32A32_Typeless:  case Format.R32G32B32A32_Float:  case Format.R32G32B32A32_UInt:  case Format.R32G32B32A32_SInt:  	{  		uint alpha;  		if (format == Format.R32G32B32A32_Float)  			alpha = 0x3f800000;  		else if (format == Format.R32G32B32A32_SInt)  			alpha = 0x7fffffff;  		else  			alpha = 0xffffffff;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 16) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 16) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R16G16B16A16_Typeless:  case Format.R16G16B16A16_Float:  case Format.R16G16B16A16_UNorm:  case Format.R16G16B16A16_UInt:  case Format.R16G16B16A16_SNorm:  case Format.R16G16B16A16_SInt:  	{  		ushort alpha;  		if (format == Format.R16G16B16A16_Float)  			alpha = 0x3c00;  		else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  			alpha = 0x7fff;  		else  			alpha = 0xffff;  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 8) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 8) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				*dPtr |= 0xC0000000;  				++dPtr;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				*(dPtr++) = *(sPtr++) | 0xC0000000;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.R8G8B8A8_UInt:  case Format.R8G8B8A8_SNorm:  case Format.R8G8B8A8_SInt:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  	{  		uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++) & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.B5G5R5A1_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 2) {  				*(dPtr++) |= 0x8000;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 2) {  				*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.A8_UNorm:  	Utilities.ClearMemory (pDestination' 0xff' outSize);  	return;  #if DIRECTX11_1                      //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format) {  //-----------------------------------------------------------------------------  case Format.R32G32B32A32_Typeless:  case Format.R32G32B32A32_Float:  case Format.R32G32B32A32_UInt:  case Format.R32G32B32A32_SInt:  	{  		uint alpha;  		if (format == Format.R32G32B32A32_Float)  			alpha = 0x3f800000;  		else if (format == Format.R32G32B32A32_SInt)  			alpha = 0x7fffffff;  		else  			alpha = 0xffffffff;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 16) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 16) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R16G16B16A16_Typeless:  case Format.R16G16B16A16_Float:  case Format.R16G16B16A16_UNorm:  case Format.R16G16B16A16_UInt:  case Format.R16G16B16A16_SNorm:  case Format.R16G16B16A16_SInt:  	{  		ushort alpha;  		if (format == Format.R16G16B16A16_Float)  			alpha = 0x3c00;  		else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  			alpha = 0x7fff;  		else  			alpha = 0xffff;  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 8) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 8) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				*dPtr |= 0xC0000000;  				++dPtr;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				*(dPtr++) = *(sPtr++) | 0xC0000000;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.R8G8B8A8_UInt:  case Format.R8G8B8A8_SNorm:  case Format.R8G8B8A8_SInt:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  	{  		uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++) & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.B5G5R5A1_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 2) {  				*(dPtr++) |= 0x8000;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 2) {  				*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.A8_UNorm:  	Utilities.ClearMemory (pDestination' 0xff' outSize);  	return;  #if DIRECTX11_1                      //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format) {  //-----------------------------------------------------------------------------  case Format.R32G32B32A32_Typeless:  case Format.R32G32B32A32_Float:  case Format.R32G32B32A32_UInt:  case Format.R32G32B32A32_SInt:  	{  		uint alpha;  		if (format == Format.R32G32B32A32_Float)  			alpha = 0x3f800000;  		else if (format == Format.R32G32B32A32_SInt)  			alpha = 0x7fffffff;  		else  			alpha = 0xffffffff;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 16) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 16) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R16G16B16A16_Typeless:  case Format.R16G16B16A16_Float:  case Format.R16G16B16A16_UNorm:  case Format.R16G16B16A16_UInt:  case Format.R16G16B16A16_SNorm:  case Format.R16G16B16A16_SInt:  	{  		ushort alpha;  		if (format == Format.R16G16B16A16_Float)  			alpha = 0x3c00;  		else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  			alpha = 0x7fff;  		else  			alpha = 0xffff;  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 8) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 8) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				*dPtr |= 0xC0000000;  				++dPtr;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				*(dPtr++) = *(sPtr++) | 0xC0000000;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.R8G8B8A8_UInt:  case Format.R8G8B8A8_SNorm:  case Format.R8G8B8A8_SInt:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  	{  		uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++) & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.B5G5R5A1_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 2) {  				*(dPtr++) |= 0x8000;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 2) {  				*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.A8_UNorm:  	Utilities.ClearMemory (pDestination' 0xff' outSize);  	return;  #if DIRECTX11_1                      //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format) {  //-----------------------------------------------------------------------------  case Format.R32G32B32A32_Typeless:  case Format.R32G32B32A32_Float:  case Format.R32G32B32A32_UInt:  case Format.R32G32B32A32_SInt:  	{  		uint alpha;  		if (format == Format.R32G32B32A32_Float)  			alpha = 0x3f800000;  		else if (format == Format.R32G32B32A32_SInt)  			alpha = 0x7fffffff;  		else  			alpha = 0xffffffff;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 16) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 16) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R16G16B16A16_Typeless:  case Format.R16G16B16A16_Float:  case Format.R16G16B16A16_UNorm:  case Format.R16G16B16A16_UInt:  case Format.R16G16B16A16_SNorm:  case Format.R16G16B16A16_SInt:  	{  		ushort alpha;  		if (format == Format.R16G16B16A16_Float)  			alpha = 0x3c00;  		else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  			alpha = 0x7fff;  		else  			alpha = 0xffff;  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 8) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 8) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				*dPtr |= 0xC0000000;  				++dPtr;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				*(dPtr++) = *(sPtr++) | 0xC0000000;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.R8G8B8A8_UInt:  case Format.R8G8B8A8_SNorm:  case Format.R8G8B8A8_SInt:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  	{  		uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++) & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.B5G5R5A1_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 2) {  				*(dPtr++) |= 0x8000;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 2) {  				*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.A8_UNorm:  	Utilities.ClearMemory (pDestination' 0xff' outSize);  	return;  #if DIRECTX11_1                      //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format) {  //-----------------------------------------------------------------------------  case Format.R32G32B32A32_Typeless:  case Format.R32G32B32A32_Float:  case Format.R32G32B32A32_UInt:  case Format.R32G32B32A32_SInt:  	{  		uint alpha;  		if (format == Format.R32G32B32A32_Float)  			alpha = 0x3f800000;  		else if (format == Format.R32G32B32A32_SInt)  			alpha = 0x7fffffff;  		else  			alpha = 0xffffffff;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 16) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 16) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R16G16B16A16_Typeless:  case Format.R16G16B16A16_Float:  case Format.R16G16B16A16_UNorm:  case Format.R16G16B16A16_UInt:  case Format.R16G16B16A16_SNorm:  case Format.R16G16B16A16_SInt:  	{  		ushort alpha;  		if (format == Format.R16G16B16A16_Float)  			alpha = 0x3c00;  		else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  			alpha = 0x7fff;  		else  			alpha = 0xffff;  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 8) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 8) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				*dPtr |= 0xC0000000;  				++dPtr;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				*(dPtr++) = *(sPtr++) | 0xC0000000;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.R8G8B8A8_UInt:  case Format.R8G8B8A8_SNorm:  case Format.R8G8B8A8_SInt:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  	{  		uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++) & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.B5G5R5A1_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 2) {  				*(dPtr++) |= 0x8000;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 2) {  				*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.A8_UNorm:  	Utilities.ClearMemory (pDestination' 0xff' outSize);  	return;  #if DIRECTX11_1                      //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format) {  //-----------------------------------------------------------------------------  case Format.R32G32B32A32_Typeless:  case Format.R32G32B32A32_Float:  case Format.R32G32B32A32_UInt:  case Format.R32G32B32A32_SInt:  	{  		uint alpha;  		if (format == Format.R32G32B32A32_Float)  			alpha = 0x3f800000;  		else if (format == Format.R32G32B32A32_SInt)  			alpha = 0x7fffffff;  		else  			alpha = 0xffffffff;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 16) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 16) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R16G16B16A16_Typeless:  case Format.R16G16B16A16_Float:  case Format.R16G16B16A16_UNorm:  case Format.R16G16B16A16_UInt:  case Format.R16G16B16A16_SNorm:  case Format.R16G16B16A16_SInt:  	{  		ushort alpha;  		if (format == Format.R16G16B16A16_Float)  			alpha = 0x3c00;  		else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  			alpha = 0x7fff;  		else  			alpha = 0xffff;  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 8) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 8) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				*dPtr |= 0xC0000000;  				++dPtr;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				*(dPtr++) = *(sPtr++) | 0xC0000000;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.R8G8B8A8_UInt:  case Format.R8G8B8A8_SNorm:  case Format.R8G8B8A8_SInt:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  	{  		uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++) & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.B5G5R5A1_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 2) {  				*(dPtr++) |= 0x8000;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 2) {  				*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.A8_UNorm:  	Utilities.ClearMemory (pDestination' 0xff' outSize);  	return;  #if DIRECTX11_1                      //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format) {  //-----------------------------------------------------------------------------  case Format.R32G32B32A32_Typeless:  case Format.R32G32B32A32_Float:  case Format.R32G32B32A32_UInt:  case Format.R32G32B32A32_SInt:  	{  		uint alpha;  		if (format == Format.R32G32B32A32_Float)  			alpha = 0x3f800000;  		else if (format == Format.R32G32B32A32_SInt)  			alpha = 0x7fffffff;  		else  			alpha = 0xffffffff;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 16) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 16) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R16G16B16A16_Typeless:  case Format.R16G16B16A16_Float:  case Format.R16G16B16A16_UNorm:  case Format.R16G16B16A16_UInt:  case Format.R16G16B16A16_SNorm:  case Format.R16G16B16A16_SInt:  	{  		ushort alpha;  		if (format == Format.R16G16B16A16_Float)  			alpha = 0x3c00;  		else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  			alpha = 0x7fff;  		else  			alpha = 0xffff;  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 8) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 8) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				*dPtr |= 0xC0000000;  				++dPtr;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				*(dPtr++) = *(sPtr++) | 0xC0000000;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.R8G8B8A8_UInt:  case Format.R8G8B8A8_SNorm:  case Format.R8G8B8A8_SInt:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  	{  		uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++) & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.B5G5R5A1_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 2) {  				*(dPtr++) |= 0x8000;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 2) {  				*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.A8_UNorm:  	Utilities.ClearMemory (pDestination' 0xff' outSize);  	return;  #if DIRECTX11_1                      //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format) {  //-----------------------------------------------------------------------------  case Format.R32G32B32A32_Typeless:  case Format.R32G32B32A32_Float:  case Format.R32G32B32A32_UInt:  case Format.R32G32B32A32_SInt:  	{  		uint alpha;  		if (format == Format.R32G32B32A32_Float)  			alpha = 0x3f800000;  		else if (format == Format.R32G32B32A32_SInt)  			alpha = 0x7fffffff;  		else  			alpha = 0xffffffff;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 16) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 16) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R16G16B16A16_Typeless:  case Format.R16G16B16A16_Float:  case Format.R16G16B16A16_UNorm:  case Format.R16G16B16A16_UInt:  case Format.R16G16B16A16_SNorm:  case Format.R16G16B16A16_SInt:  	{  		ushort alpha;  		if (format == Format.R16G16B16A16_Float)  			alpha = 0x3c00;  		else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  			alpha = 0x7fff;  		else  			alpha = 0xffff;  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 8) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 8) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				*dPtr |= 0xC0000000;  				++dPtr;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				*(dPtr++) = *(sPtr++) | 0xC0000000;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.R8G8B8A8_UInt:  case Format.R8G8B8A8_SNorm:  case Format.R8G8B8A8_SInt:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  	{  		uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++) & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.B5G5R5A1_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 2) {  				*(dPtr++) |= 0x8000;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 2) {  				*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.A8_UNorm:  	Utilities.ClearMemory (pDestination' 0xff' outSize);  	return;  #if DIRECTX11_1                      //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format) {  //-----------------------------------------------------------------------------  case Format.R32G32B32A32_Typeless:  case Format.R32G32B32A32_Float:  case Format.R32G32B32A32_UInt:  case Format.R32G32B32A32_SInt:  	{  		uint alpha;  		if (format == Format.R32G32B32A32_Float)  			alpha = 0x3f800000;  		else if (format == Format.R32G32B32A32_SInt)  			alpha = 0x7fffffff;  		else  			alpha = 0xffffffff;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 16) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 16) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R16G16B16A16_Typeless:  case Format.R16G16B16A16_Float:  case Format.R16G16B16A16_UNorm:  case Format.R16G16B16A16_UInt:  case Format.R16G16B16A16_SNorm:  case Format.R16G16B16A16_SInt:  	{  		ushort alpha;  		if (format == Format.R16G16B16A16_Float)  			alpha = 0x3c00;  		else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  			alpha = 0x7fff;  		else  			alpha = 0xffff;  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 8) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 8) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				*dPtr |= 0xC0000000;  				++dPtr;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				*(dPtr++) = *(sPtr++) | 0xC0000000;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.R8G8B8A8_UInt:  case Format.R8G8B8A8_SNorm:  case Format.R8G8B8A8_SInt:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  	{  		uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++) & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.B5G5R5A1_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 2) {  				*(dPtr++) |= 0x8000;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 2) {  				*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.A8_UNorm:  	Utilities.ClearMemory (pDestination' 0xff' outSize);  	return;  #if DIRECTX11_1                      //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format) {  //-----------------------------------------------------------------------------  case Format.R32G32B32A32_Typeless:  case Format.R32G32B32A32_Float:  case Format.R32G32B32A32_UInt:  case Format.R32G32B32A32_SInt:  	{  		uint alpha;  		if (format == Format.R32G32B32A32_Float)  			alpha = 0x3f800000;  		else if (format == Format.R32G32B32A32_SInt)  			alpha = 0x7fffffff;  		else  			alpha = 0xffffffff;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 16) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 16) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R16G16B16A16_Typeless:  case Format.R16G16B16A16_Float:  case Format.R16G16B16A16_UNorm:  case Format.R16G16B16A16_UInt:  case Format.R16G16B16A16_SNorm:  case Format.R16G16B16A16_SInt:  	{  		ushort alpha;  		if (format == Format.R16G16B16A16_Float)  			alpha = 0x3c00;  		else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  			alpha = 0x7fff;  		else  			alpha = 0xffff;  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 8) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 8) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				*dPtr |= 0xC0000000;  				++dPtr;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				*(dPtr++) = *(sPtr++) | 0xC0000000;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.R8G8B8A8_UInt:  case Format.R8G8B8A8_SNorm:  case Format.R8G8B8A8_SInt:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  	{  		uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++) & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.B5G5R5A1_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 2) {  				*(dPtr++) |= 0x8000;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 2) {  				*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.A8_UNorm:  	Utilities.ClearMemory (pDestination' 0xff' outSize);  	return;  #if DIRECTX11_1                      //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format) {  //-----------------------------------------------------------------------------  case Format.R32G32B32A32_Typeless:  case Format.R32G32B32A32_Float:  case Format.R32G32B32A32_UInt:  case Format.R32G32B32A32_SInt:  	{  		uint alpha;  		if (format == Format.R32G32B32A32_Float)  			alpha = 0x3f800000;  		else if (format == Format.R32G32B32A32_SInt)  			alpha = 0x7fffffff;  		else  			alpha = 0xffffffff;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 16) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 16) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R16G16B16A16_Typeless:  case Format.R16G16B16A16_Float:  case Format.R16G16B16A16_UNorm:  case Format.R16G16B16A16_UInt:  case Format.R16G16B16A16_SNorm:  case Format.R16G16B16A16_SInt:  	{  		ushort alpha;  		if (format == Format.R16G16B16A16_Float)  			alpha = 0x3c00;  		else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  			alpha = 0x7fff;  		else  			alpha = 0xffff;  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 8) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 8) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				*dPtr |= 0xC0000000;  				++dPtr;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				*(dPtr++) = *(sPtr++) | 0xC0000000;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.R8G8B8A8_UInt:  case Format.R8G8B8A8_SNorm:  case Format.R8G8B8A8_SInt:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  	{  		uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++) & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.B5G5R5A1_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 2) {  				*(dPtr++) |= 0x8000;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 2) {  				*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.A8_UNorm:  	Utilities.ClearMemory (pDestination' 0xff' outSize);  	return;  #if DIRECTX11_1                      //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format) {  //-----------------------------------------------------------------------------  case Format.R32G32B32A32_Typeless:  case Format.R32G32B32A32_Float:  case Format.R32G32B32A32_UInt:  case Format.R32G32B32A32_SInt:  	{  		uint alpha;  		if (format == Format.R32G32B32A32_Float)  			alpha = 0x3f800000;  		else if (format == Format.R32G32B32A32_SInt)  			alpha = 0x7fffffff;  		else  			alpha = 0xffffffff;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 16) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 16) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R16G16B16A16_Typeless:  case Format.R16G16B16A16_Float:  case Format.R16G16B16A16_UNorm:  case Format.R16G16B16A16_UInt:  case Format.R16G16B16A16_SNorm:  case Format.R16G16B16A16_SInt:  	{  		ushort alpha;  		if (format == Format.R16G16B16A16_Float)  			alpha = 0x3c00;  		else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  			alpha = 0x7fff;  		else  			alpha = 0xffff;  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 8) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 8) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				*dPtr |= 0xC0000000;  				++dPtr;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				*(dPtr++) = *(sPtr++) | 0xC0000000;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.R8G8B8A8_UInt:  case Format.R8G8B8A8_SNorm:  case Format.R8G8B8A8_SInt:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  	{  		uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++) & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.B5G5R5A1_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 2) {  				*(dPtr++) |= 0x8000;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 2) {  				*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.A8_UNorm:  	Utilities.ClearMemory (pDestination' 0xff' outSize);  	return;  #if DIRECTX11_1                      //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  // DXGI_1_2_FORMATS  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 16) {  		dPtr += 3;  		*(dPtr++) = alpha;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 16) {  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = alpha;  		sPtr++;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 16) {  		dPtr += 3;  		*(dPtr++) = alpha;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 16) {  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = alpha;  		sPtr++;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 16) {  		dPtr += 3;  		*(dPtr++) = alpha;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 16) {  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = alpha;  		sPtr++;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: for (int count = 0; count < outSize; count += 16) {  	dPtr += 3;  	*(dPtr++) = alpha;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: for (int count = 0; count < outSize; count += 16) {  	dPtr += 3;  	*(dPtr++) = alpha;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: count += 16
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: dPtr += 3;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: for (int count = 0; count < size; count += 16) {  	*(dPtr++) = *(sPtr++);  	*(dPtr++) = *(sPtr++);  	*(dPtr++) = *(sPtr++);  	*(dPtr++) = alpha;  	sPtr++;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: count += 16
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (ushort*)(pDestination);  	for (int count = 0; count < outSize; count += 8) {  		dPtr += 3;  		*(dPtr++) = alpha;  	}  } else {  	var sPtr = (ushort*)(pSource);  	var dPtr = (ushort*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 8) {  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = alpha;  		sPtr++;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (ushort*)(pDestination);  	for (int count = 0; count < outSize; count += 8) {  		dPtr += 3;  		*(dPtr++) = alpha;  	}  } else {  	var sPtr = (ushort*)(pSource);  	var dPtr = (ushort*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 8) {  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = alpha;  		sPtr++;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (ushort*)(pDestination);  	for (int count = 0; count < outSize; count += 8) {  		dPtr += 3;  		*(dPtr++) = alpha;  	}  } else {  	var sPtr = (ushort*)(pSource);  	var dPtr = (ushort*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 8) {  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = *(sPtr++);  		*(dPtr++) = alpha;  		sPtr++;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: for (int count = 0; count < outSize; count += 8) {  	dPtr += 3;  	*(dPtr++) = alpha;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: for (int count = 0; count < outSize; count += 8) {  	dPtr += 3;  	*(dPtr++) = alpha;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: count += 8
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: dPtr += 3;  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: for (int count = 0; count < size; count += 8) {  	*(dPtr++) = *(sPtr++);  	*(dPtr++) = *(sPtr++);  	*(dPtr++) = *(sPtr++);  	*(dPtr++) = alpha;  	sPtr++;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: count += 8
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		*dPtr |= 0xC0000000;  		++dPtr;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		*(dPtr++) = *(sPtr++) | 0xC0000000;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		*dPtr |= 0xC0000000;  		++dPtr;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		*(dPtr++) = *(sPtr++) | 0xC0000000;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: for (int count = 0; count < outSize; count += 4) {  	*dPtr |= 0xC0000000;  	++dPtr;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: count += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: for (int count = 0; count < size; count += 4) {  	*(dPtr++) = *(sPtr++) | 0xC0000000;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: count += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		uint t = *dPtr & 0xFFFFFF;  		t |= alpha;  		*(dPtr++) = t;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		uint t = *(sPtr++) & 0xFFFFFF;  		t |= alpha;  		*(dPtr++) = t;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		uint t = *dPtr & 0xFFFFFF;  		t |= alpha;  		*(dPtr++) = t;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		uint t = *(sPtr++) & 0xFFFFFF;  		t |= alpha;  		*(dPtr++) = t;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: for (int count = 0; count < outSize; count += 4) {  	uint t = *dPtr & 0xFFFFFF;  	t |= alpha;  	*(dPtr++) = t;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: count += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: for (int count = 0; count < size; count += 4) {  	uint t = *(sPtr++) & 0xFFFFFF;  	t |= alpha;  	*(dPtr++) = t;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: count += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (ushort*)(pDestination);  	for (int count = 0; count < outSize; count += 2) {  		*(dPtr++) |= 0x8000;  	}  } else {  	var sPtr = (ushort*)(pSource);  	var dPtr = (ushort*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 2) {  		*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (ushort*)(pDestination);  	for (int count = 0; count < outSize; count += 2) {  		*(dPtr++) |= 0x8000;  	}  } else {  	var sPtr = (ushort*)(pSource);  	var dPtr = (ushort*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 2) {  		*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: for (int count = 0; count < outSize; count += 2) {  	*(dPtr++) |= 0x8000;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: count += 2
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: for (int count = 0; count < size; count += 2) {  	*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: count += 2
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format) {  //---------------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	if ((flags & ScanlineFlags.Legacy) != 0) {  		// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr;  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++);  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		}  		return;  	}  	break;  //---------------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8X8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  case Format.B8G8R8X8_Typeless:  case Format.B8G8R8X8_UNorm_SRgb:  	// Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format) {  //---------------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	if ((flags & ScanlineFlags.Legacy) != 0) {  		// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr;  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++);  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		}  		return;  	}  	break;  //---------------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8X8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  case Format.B8G8R8X8_Typeless:  case Format.B8G8R8X8_UNorm_SRgb:  	// Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format) {  //---------------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	if ((flags & ScanlineFlags.Legacy) != 0) {  		// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr;  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++);  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		}  		return;  	}  	break;  //---------------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8X8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  case Format.B8G8R8X8_Typeless:  case Format.B8G8R8X8_UNorm_SRgb:  	// Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format) {  //---------------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	if ((flags & ScanlineFlags.Legacy) != 0) {  		// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr;  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++);  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		}  		return;  	}  	break;  //---------------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8X8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  case Format.B8G8R8X8_Typeless:  case Format.B8G8R8X8_UNorm_SRgb:  	// Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format) {  //---------------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	if ((flags & ScanlineFlags.Legacy) != 0) {  		// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr;  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++);  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		}  		return;  	}  	break;  //---------------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8X8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  case Format.B8G8R8X8_Typeless:  case Format.B8G8R8X8_UNorm_SRgb:  	// Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format) {  //---------------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	if ((flags & ScanlineFlags.Legacy) != 0) {  		// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr;  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++);  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		}  		return;  	}  	break;  //---------------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8X8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  case Format.B8G8R8X8_Typeless:  case Format.B8G8R8X8_UNorm_SRgb:  	// Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format) {  //---------------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	if ((flags & ScanlineFlags.Legacy) != 0) {  		// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr;  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++);  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		}  		return;  	}  	break;  //---------------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8X8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  case Format.B8G8R8X8_Typeless:  case Format.B8G8R8X8_UNorm_SRgb:  	// Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format) {  //---------------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	if ((flags & ScanlineFlags.Legacy) != 0) {  		// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr;  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++);  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		}  		return;  	}  	break;  //---------------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8X8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  case Format.B8G8R8X8_Typeless:  case Format.B8G8R8X8_UNorm_SRgb:  	// Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format) {  //---------------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	if ((flags & ScanlineFlags.Legacy) != 0) {  		// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr;  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++);  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		}  		return;  	}  	break;  //---------------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8X8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  case Format.B8G8R8X8_Typeless:  case Format.B8G8R8X8_UNorm_SRgb:  	// Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format) {  //---------------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	if ((flags & ScanlineFlags.Legacy) != 0) {  		// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr;  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++);  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		}  		return;  	}  	break;  //---------------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8X8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  case Format.B8G8R8X8_Typeless:  case Format.B8G8R8X8_UNorm_SRgb:  	// Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format) {  //---------------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	if ((flags & ScanlineFlags.Legacy) != 0) {  		// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr;  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++);  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		}  		return;  	}  	break;  //---------------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8X8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  case Format.B8G8R8X8_Typeless:  case Format.B8G8R8X8_UNorm_SRgb:  	// Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format) {  //---------------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	if ((flags & ScanlineFlags.Legacy) != 0) {  		// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr;  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++);  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		}  		return;  	}  	break;  //---------------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8X8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  case Format.B8G8R8X8_Typeless:  case Format.B8G8R8X8_UNorm_SRgb:  	// Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.Legacy) != 0) {  	// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x3ff00000) >> 20;  			uint t2 = (t & 0x000003ff) << 20;  			uint t3 = (t & 0x000ffc00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x3ff00000) >> 20;  			uint t2 = (t & 0x000003ff) << 20;  			uint t3 = (t & 0x000ffc00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.Legacy) != 0) {  	// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x3ff00000) >> 20;  			uint t2 = (t & 0x000003ff) << 20;  			uint t3 = (t & 0x000ffc00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x3ff00000) >> 20;  			uint t2 = (t & 0x000003ff) << 20;  			uint t3 = (t & 0x000ffc00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.Legacy) != 0) {  	// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x3ff00000) >> 20;  			uint t2 = (t & 0x000003ff) << 20;  			uint t3 = (t & 0x000ffc00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x3ff00000) >> 20;  			uint t2 = (t & 0x000003ff) << 20;  			uint t3 = (t & 0x000ffc00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.Legacy) != 0) {  	// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x3ff00000) >> 20;  			uint t2 = (t & 0x000003ff) << 20;  			uint t3 = (t & 0x000ffc00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x3ff00000) >> 20;  			uint t2 = (t & 0x000003ff) << 20;  			uint t3 = (t & 0x000ffc00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.Legacy) != 0) {  	// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x3ff00000) >> 20;  			uint t2 = (t & 0x000003ff) << 20;  			uint t3 = (t & 0x000ffc00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x3ff00000) >> 20;  			uint t2 = (t & 0x000003ff) << 20;  			uint t3 = (t & 0x000ffc00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.Legacy) != 0) {  	// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x3ff00000) >> 20;  			uint t2 = (t & 0x000003ff) << 20;  			uint t3 = (t & 0x000ffc00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x3ff00000) >> 20;  			uint t2 = (t & 0x000003ff) << 20;  			uint t3 = (t & 0x000ffc00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		uint t = *dPtr;  		uint t1 = (t & 0x3ff00000) >> 20;  		uint t2 = (t & 0x000003ff) << 20;  		uint t3 = (t & 0x000ffc00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		uint t = *(sPtr++);  		uint t1 = (t & 0x3ff00000) >> 20;  		uint t2 = (t & 0x000003ff) << 20;  		uint t3 = (t & 0x000ffc00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		uint t = *dPtr;  		uint t1 = (t & 0x3ff00000) >> 20;  		uint t2 = (t & 0x000003ff) << 20;  		uint t3 = (t & 0x000ffc00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		uint t = *(sPtr++);  		uint t1 = (t & 0x3ff00000) >> 20;  		uint t2 = (t & 0x000003ff) << 20;  		uint t3 = (t & 0x000ffc00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		uint t = *dPtr;  		uint t1 = (t & 0x3ff00000) >> 20;  		uint t2 = (t & 0x000003ff) << 20;  		uint t3 = (t & 0x000ffc00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		uint t = *(sPtr++);  		uint t1 = (t & 0x3ff00000) >> 20;  		uint t2 = (t & 0x000003ff) << 20;  		uint t3 = (t & 0x000ffc00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		uint t = *dPtr;  		uint t1 = (t & 0x3ff00000) >> 20;  		uint t2 = (t & 0x000003ff) << 20;  		uint t3 = (t & 0x000ffc00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		uint t = *(sPtr++);  		uint t1 = (t & 0x3ff00000) >> 20;  		uint t2 = (t & 0x000003ff) << 20;  		uint t3 = (t & 0x000ffc00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		uint t = *dPtr;  		uint t1 = (t & 0x3ff00000) >> 20;  		uint t2 = (t & 0x000003ff) << 20;  		uint t3 = (t & 0x000ffc00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		uint t = *(sPtr++);  		uint t1 = (t & 0x3ff00000) >> 20;  		uint t2 = (t & 0x000003ff) << 20;  		uint t3 = (t & 0x000ffc00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		uint t = *dPtr;  		uint t1 = (t & 0x3ff00000) >> 20;  		uint t2 = (t & 0x000003ff) << 20;  		uint t3 = (t & 0x000ffc00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		uint t = *(sPtr++);  		uint t1 = (t & 0x3ff00000) >> 20;  		uint t2 = (t & 0x000003ff) << 20;  		uint t3 = (t & 0x000ffc00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: for (int count = 0; count < outSize; count += 4) {  	uint t = *dPtr;  	uint t1 = (t & 0x3ff00000) >> 20;  	uint t2 = (t & 0x000003ff) << 20;  	uint t3 = (t & 0x000ffc00);  	uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: for (int count = 0; count < outSize; count += 4) {  	uint t = *dPtr;  	uint t1 = (t & 0x3ff00000) >> 20;  	uint t2 = (t & 0x000003ff) << 20;  	uint t3 = (t & 0x000ffc00);  	uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: for (int count = 0; count < outSize; count += 4) {  	uint t = *dPtr;  	uint t1 = (t & 0x3ff00000) >> 20;  	uint t2 = (t & 0x000003ff) << 20;  	uint t3 = (t & 0x000ffc00);  	uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: count += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: for (int count = 0; count < size; count += 4) {  	uint t = *(sPtr++);  	uint t1 = (t & 0x3ff00000) >> 20;  	uint t2 = (t & 0x000003ff) << 20;  	uint t3 = (t & 0x000ffc00);  	uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: for (int count = 0; count < size; count += 4) {  	uint t = *(sPtr++);  	uint t1 = (t & 0x3ff00000) >> 20;  	uint t2 = (t & 0x000003ff) << 20;  	uint t3 = (t & 0x000ffc00);  	uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: for (int count = 0; count < size; count += 4) {  	uint t = *(sPtr++);  	uint t1 = (t & 0x3ff00000) >> 20;  	uint t2 = (t & 0x000003ff) << 20;  	uint t3 = (t & 0x000ffc00);  	uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: count += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		uint t = *dPtr;  		uint t1 = (t & 0x00ff0000) >> 16;  		uint t2 = (t & 0x000000ff) << 16;  		uint t3 = (t & 0x0000ff00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		uint t = *(sPtr++);  		uint t1 = (t & 0x00ff0000) >> 16;  		uint t2 = (t & 0x000000ff) << 16;  		uint t3 = (t & 0x0000ff00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		uint t = *dPtr;  		uint t1 = (t & 0x00ff0000) >> 16;  		uint t2 = (t & 0x000000ff) << 16;  		uint t3 = (t & 0x0000ff00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		uint t = *(sPtr++);  		uint t1 = (t & 0x00ff0000) >> 16;  		uint t2 = (t & 0x000000ff) << 16;  		uint t3 = (t & 0x0000ff00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		uint t = *dPtr;  		uint t1 = (t & 0x00ff0000) >> 16;  		uint t2 = (t & 0x000000ff) << 16;  		uint t3 = (t & 0x0000ff00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		uint t = *(sPtr++);  		uint t1 = (t & 0x00ff0000) >> 16;  		uint t2 = (t & 0x000000ff) << 16;  		uint t3 = (t & 0x0000ff00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		uint t = *dPtr;  		uint t1 = (t & 0x00ff0000) >> 16;  		uint t2 = (t & 0x000000ff) << 16;  		uint t3 = (t & 0x0000ff00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		uint t = *(sPtr++);  		uint t1 = (t & 0x00ff0000) >> 16;  		uint t2 = (t & 0x000000ff) << 16;  		uint t3 = (t & 0x0000ff00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		uint t = *dPtr;  		uint t1 = (t & 0x00ff0000) >> 16;  		uint t2 = (t & 0x000000ff) << 16;  		uint t3 = (t & 0x0000ff00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		uint t = *(sPtr++);  		uint t1 = (t & 0x00ff0000) >> 16;  		uint t2 = (t & 0x000000ff) << 16;  		uint t3 = (t & 0x0000ff00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: if (pDestination == pSource) {  	var dPtr = (uint*)(pDestination);  	for (int count = 0; count < outSize; count += 4) {  		uint t = *dPtr;  		uint t1 = (t & 0x00ff0000) >> 16;  		uint t2 = (t & 0x000000ff) << 16;  		uint t3 = (t & 0x0000ff00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  } else {  	var sPtr = (uint*)(pSource);  	var dPtr = (uint*)(pDestination);  	int size = Math.Min (outSize' inSize);  	for (int count = 0; count < size; count += 4) {  		uint t = *(sPtr++);  		uint t1 = (t & 0x00ff0000) >> 16;  		uint t2 = (t & 0x000000ff) << 16;  		uint t3 = (t & 0x0000ff00);  		uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  		*(dPtr++) = t1 | t2 | t3 | ta;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: for (int count = 0; count < outSize; count += 4) {  	uint t = *dPtr;  	uint t1 = (t & 0x00ff0000) >> 16;  	uint t2 = (t & 0x000000ff) << 16;  	uint t3 = (t & 0x0000ff00);  	uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: for (int count = 0; count < outSize; count += 4) {  	uint t = *dPtr;  	uint t1 = (t & 0x00ff0000) >> 16;  	uint t2 = (t & 0x000000ff) << 16;  	uint t3 = (t & 0x0000ff00);  	uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: for (int count = 0; count < outSize; count += 4) {  	uint t = *dPtr;  	uint t1 = (t & 0x00ff0000) >> 16;  	uint t2 = (t & 0x000000ff) << 16;  	uint t3 = (t & 0x0000ff00);  	uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: count += 4
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: for (int count = 0; count < size; count += 4) {  	uint t = *(sPtr++);  	uint t1 = (t & 0x00ff0000) >> 16;  	uint t2 = (t & 0x000000ff) << 16;  	uint t3 = (t & 0x0000ff00);  	uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: for (int count = 0; count < size; count += 4) {  	uint t = *(sPtr++);  	uint t1 = (t & 0x00ff0000) >> 16;  	uint t2 = (t & 0x000000ff) << 16;  	uint t3 = (t & 0x0000ff00);  	uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: for (int count = 0; count < size; count += 4) {  	uint t = *(sPtr++);  	uint t1 = (t & 0x00ff0000) >> 16;  	uint t2 = (t & 0x000000ff) << 16;  	uint t3 = (t & 0x0000ff00);  	uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  	*(dPtr++) = t1 | t2 | t3 | ta;  }  
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: count += 4
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,NewCube,The following statement contains a magic number: return new Image (CreateDescription (TextureDimension.TextureCube' width' width' 1' mipMapCount' format' 6)' dataPointer' 0' null' false);  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Load,The following statement contains a magic number: if (size > (85 * 1024)) {  	var handle = GCHandle.Alloc (buffer' GCHandleType.Pinned);  	return Load (handle.AddrOfPinnedObject ()' size' false' handle);  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Load,The following statement contains a magic number: if (size > (85 * 1024)) {  	var handle = GCHandle.Alloc (buffer' GCHandleType.Pinned);  	return Load (handle.AddrOfPinnedObject ()' size' false' handle);  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The following statement contains a magic number: switch (description.Dimension) {  case TextureDimension.Texture1D:  	if (description.Width <= 0 || description.Height != 1 || description.Depth != 1 || description.ArraySize == 0)  		throw new InvalidOperationException ("Invalid Width/Height/Depth/ArraySize for Image 1D");  	// Check that miplevels are fine  	description.MipLevels = Texture.CalculateMipLevels (description.Width' 1' description.MipLevels);  	break;  case TextureDimension.Texture2D:  case TextureDimension.TextureCube:  	if (description.Width <= 0 || description.Height <= 0 || description.Depth != 1 || description.ArraySize == 0)  		throw new InvalidOperationException ("Invalid Width/Height/Depth/ArraySize for Image 2D");  	if (description.Dimension == TextureDimension.TextureCube) {  		if ((description.ArraySize % 6) != 0)  			throw new InvalidOperationException ("TextureCube must have an arraysize = 6");  	}  	// Check that miplevels are fine  	description.MipLevels = Texture.CalculateMipLevels (description.Width' description.Height' description.MipLevels);  	break;  case TextureDimension.Texture3D:  	if (description.Width <= 0 || description.Height <= 0 || description.Depth <= 0 || description.ArraySize != 1)  		throw new InvalidOperationException ("Invalid Width/Height/Depth/ArraySize for Image 3D");  	// Check that miplevels are fine  	description.MipLevels = Texture.CalculateMipLevels (description.Width' description.Height' description.Depth' description.MipLevels);  	break;  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The following statement contains a magic number: if (description.Dimension == TextureDimension.TextureCube) {  	if ((description.ArraySize % 6) != 0)  		throw new InvalidOperationException ("TextureCube must have an arraysize = 6");  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The following statement contains a magic number: if ((description.ArraySize % 6) != 0)  	throw new InvalidOperationException ("TextureCube must have an arraysize = 6");  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed (fmt)) {  	int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16;  	widthCount = Math.Max (1' (width + 3) / 4);  	heightCount = Math.Max (1' (height + 3) / 4);  	rowPitch = widthCount * bpb;  	slicePitch = rowPitch * heightCount;  } else if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed (fmt)) {  	int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16;  	widthCount = Math.Max (1' (width + 3) / 4);  	heightCount = Math.Max (1' (height + 3) / 4);  	rowPitch = widthCount * bpb;  	slicePitch = rowPitch * heightCount;  } else if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed (fmt)) {  	int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16;  	widthCount = Math.Max (1' (width + 3) / 4);  	heightCount = Math.Max (1' (height + 3) / 4);  	rowPitch = widthCount * bpb;  	slicePitch = rowPitch * heightCount;  } else if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed (fmt)) {  	int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16;  	widthCount = Math.Max (1' (width + 3) / 4);  	heightCount = Math.Max (1' (height + 3) / 4);  	rowPitch = widthCount * bpb;  	slicePitch = rowPitch * heightCount;  } else if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed (fmt)) {  	int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16;  	widthCount = Math.Max (1' (width + 3) / 4);  	heightCount = Math.Max (1' (height + 3) / 4);  	rowPitch = widthCount * bpb;  	slicePitch = rowPitch * heightCount;  } else if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed (fmt)) {  	int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16;  	widthCount = Math.Max (1' (width + 3) / 4);  	heightCount = Math.Max (1' (height + 3) / 4);  	rowPitch = widthCount * bpb;  	slicePitch = rowPitch * heightCount;  } else if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed (fmt)) {  	int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16;  	widthCount = Math.Max (1' (width + 3) / 4);  	heightCount = Math.Max (1' (height + 3) / 4);  	rowPitch = widthCount * bpb;  	slicePitch = rowPitch * heightCount;  } else if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed (fmt)) {  	int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16;  	widthCount = Math.Max (1' (width + 3) / 4);  	heightCount = Math.Max (1' (height + 3) / 4);  	rowPitch = widthCount * bpb;  	slicePitch = rowPitch * heightCount;  } else if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed (fmt)) {  	int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16;  	widthCount = Math.Max (1' (width + 3) / 4);  	heightCount = Math.Max (1' (height + 3) / 4);  	rowPitch = widthCount * bpb;  	slicePitch = rowPitch * heightCount;  } else if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed (fmt)) {  	int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16;  	widthCount = Math.Max (1' (width + 3) / 4);  	heightCount = Math.Max (1' (height + 3) / 4);  	rowPitch = widthCount * bpb;  	slicePitch = rowPitch * heightCount;  } else if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed (fmt)) {  	int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16;  	widthCount = Math.Max (1' (width + 3) / 4);  	heightCount = Math.Max (1' (height + 3) / 4);  	rowPitch = widthCount * bpb;  	slicePitch = rowPitch * heightCount;  } else if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed (fmt)) {  	int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16;  	widthCount = Math.Max (1' (width + 3) / 4);  	heightCount = Math.Max (1' (height + 3) / 4);  	rowPitch = widthCount * bpb;  	slicePitch = rowPitch * heightCount;  } else if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed (fmt)) {  	int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16;  	widthCount = Math.Max (1' (width + 3) / 4);  	heightCount = Math.Max (1' (height + 3) / 4);  	rowPitch = widthCount * bpb;  	slicePitch = rowPitch * heightCount;  } else if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed (fmt)) {  	int bpb = (fmt == Format.BC1_Typeless || fmt == Format.BC1_UNorm || fmt == Format.BC1_UNorm_SRgb || fmt == Format.BC4_Typeless || fmt == Format.BC4_UNorm || fmt == Format.BC4_SNorm) ? 8 : 16;  	widthCount = Math.Max (1' (width + 3) / 4);  	heightCount = Math.Max (1' (height + 3) / 4);  	rowPitch = widthCount * bpb;  	slicePitch = rowPitch * heightCount;  } else if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: widthCount = Math.Max (1' (width + 3) / 4);  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: widthCount = Math.Max (1' (width + 3) / 4);  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: heightCount = Math.Max (1' (height + 3) / 4);  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: heightCount = Math.Max (1' (height + 3) / 4);  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsPacked (fmt)) {  	rowPitch = ((width + 1) >> 1) * 4;  	slicePitch = rowPitch * height;  } else {  	int bpp;  	if ((flags & PitchFlags.Bpp24) != 0)  		bpp = 24;  	else if ((flags & PitchFlags.Bpp16) != 0)  		bpp = 16;  	else if ((flags & PitchFlags.Bpp8) != 0)  		bpp = 8;  	else  		bpp = FormatHelper.SizeOfInBits (fmt);  	if ((flags & PitchFlags.LegacyDword) != 0) {  		// Special computation for some incorrectly created DDS files based on  		// legacy DirectDraw assumptions about pitch alignment  		rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  		slicePitch = rowPitch * height;  	} else {  		rowPitch = (width * bpp + 7) / 8;  		slicePitch = rowPitch * height;  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: rowPitch = ((width + 1) >> 1) * 4;  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if ((flags & PitchFlags.Bpp24) != 0)  	bpp = 24;  else if ((flags & PitchFlags.Bpp16) != 0)  	bpp = 16;  else if ((flags & PitchFlags.Bpp8) != 0)  	bpp = 8;  else  	bpp = FormatHelper.SizeOfInBits (fmt);  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if ((flags & PitchFlags.Bpp24) != 0)  	bpp = 24;  else if ((flags & PitchFlags.Bpp16) != 0)  	bpp = 16;  else if ((flags & PitchFlags.Bpp8) != 0)  	bpp = 8;  else  	bpp = FormatHelper.SizeOfInBits (fmt);  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if ((flags & PitchFlags.Bpp24) != 0)  	bpp = 24;  else if ((flags & PitchFlags.Bpp16) != 0)  	bpp = 16;  else if ((flags & PitchFlags.Bpp8) != 0)  	bpp = 8;  else  	bpp = FormatHelper.SizeOfInBits (fmt);  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: bpp = 24;  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if ((flags & PitchFlags.Bpp16) != 0)  	bpp = 16;  else if ((flags & PitchFlags.Bpp8) != 0)  	bpp = 8;  else  	bpp = FormatHelper.SizeOfInBits (fmt);  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if ((flags & PitchFlags.Bpp16) != 0)  	bpp = 16;  else if ((flags & PitchFlags.Bpp8) != 0)  	bpp = 8;  else  	bpp = FormatHelper.SizeOfInBits (fmt);  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: bpp = 16;  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if ((flags & PitchFlags.Bpp8) != 0)  	bpp = 8;  else  	bpp = FormatHelper.SizeOfInBits (fmt);  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: bpp = 8;  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if ((flags & PitchFlags.LegacyDword) != 0) {  	// Special computation for some incorrectly created DDS files based on  	// legacy DirectDraw assumptions about pitch alignment  	rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  	slicePitch = rowPitch * height;  } else {  	rowPitch = (width * bpp + 7) / 8;  	slicePitch = rowPitch * height;  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if ((flags & PitchFlags.LegacyDword) != 0) {  	// Special computation for some incorrectly created DDS files based on  	// legacy DirectDraw assumptions about pitch alignment  	rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  	slicePitch = rowPitch * height;  } else {  	rowPitch = (width * bpp + 7) / 8;  	slicePitch = rowPitch * height;  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if ((flags & PitchFlags.LegacyDword) != 0) {  	// Special computation for some incorrectly created DDS files based on  	// legacy DirectDraw assumptions about pitch alignment  	rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  	slicePitch = rowPitch * height;  } else {  	rowPitch = (width * bpp + 7) / 8;  	slicePitch = rowPitch * height;  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if ((flags & PitchFlags.LegacyDword) != 0) {  	// Special computation for some incorrectly created DDS files based on  	// legacy DirectDraw assumptions about pitch alignment  	rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  	slicePitch = rowPitch * height;  } else {  	rowPitch = (width * bpp + 7) / 8;  	slicePitch = rowPitch * height;  }  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: rowPitch = ((width * bpp + 31) / 32) * sizeof(int);  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: rowPitch = (width * bpp + 7) / 8;  
Magic Number,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: rowPitch = (width * bpp + 7) / 8;  
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Width;  
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Height;  
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Depth;  
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ ArraySize;  
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ MipLevels;  
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Format.GetHashCode ();  
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = this.Width;  	hashCode = (hashCode * 397) ^ this.Height;  	hashCode = (hashCode * 397) ^ this.WidthPacked;  	hashCode = (hashCode * 397) ^ this.HeightPacked;  	hashCode = (hashCode * 397) ^ this.Depth;  	hashCode = (hashCode * 397) ^ this.RowStride;  	hashCode = (hashCode * 397) ^ this.MipmapSize;  	hashCode = (hashCode * 397) ^ this.DepthStride;  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = this.Width;  	hashCode = (hashCode * 397) ^ this.Height;  	hashCode = (hashCode * 397) ^ this.WidthPacked;  	hashCode = (hashCode * 397) ^ this.HeightPacked;  	hashCode = (hashCode * 397) ^ this.Depth;  	hashCode = (hashCode * 397) ^ this.RowStride;  	hashCode = (hashCode * 397) ^ this.MipmapSize;  	hashCode = (hashCode * 397) ^ this.DepthStride;  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = this.Width;  	hashCode = (hashCode * 397) ^ this.Height;  	hashCode = (hashCode * 397) ^ this.WidthPacked;  	hashCode = (hashCode * 397) ^ this.HeightPacked;  	hashCode = (hashCode * 397) ^ this.Depth;  	hashCode = (hashCode * 397) ^ this.RowStride;  	hashCode = (hashCode * 397) ^ this.MipmapSize;  	hashCode = (hashCode * 397) ^ this.DepthStride;  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = this.Width;  	hashCode = (hashCode * 397) ^ this.Height;  	hashCode = (hashCode * 397) ^ this.WidthPacked;  	hashCode = (hashCode * 397) ^ this.HeightPacked;  	hashCode = (hashCode * 397) ^ this.Depth;  	hashCode = (hashCode * 397) ^ this.RowStride;  	hashCode = (hashCode * 397) ^ this.MipmapSize;  	hashCode = (hashCode * 397) ^ this.DepthStride;  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = this.Width;  	hashCode = (hashCode * 397) ^ this.Height;  	hashCode = (hashCode * 397) ^ this.WidthPacked;  	hashCode = (hashCode * 397) ^ this.HeightPacked;  	hashCode = (hashCode * 397) ^ this.Depth;  	hashCode = (hashCode * 397) ^ this.RowStride;  	hashCode = (hashCode * 397) ^ this.MipmapSize;  	hashCode = (hashCode * 397) ^ this.DepthStride;  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = this.Width;  	hashCode = (hashCode * 397) ^ this.Height;  	hashCode = (hashCode * 397) ^ this.WidthPacked;  	hashCode = (hashCode * 397) ^ this.HeightPacked;  	hashCode = (hashCode * 397) ^ this.Depth;  	hashCode = (hashCode * 397) ^ this.RowStride;  	hashCode = (hashCode * 397) ^ this.MipmapSize;  	hashCode = (hashCode * 397) ^ this.DepthStride;  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = this.Width;  	hashCode = (hashCode * 397) ^ this.Height;  	hashCode = (hashCode * 397) ^ this.WidthPacked;  	hashCode = (hashCode * 397) ^ this.HeightPacked;  	hashCode = (hashCode * 397) ^ this.Depth;  	hashCode = (hashCode * 397) ^ this.RowStride;  	hashCode = (hashCode * 397) ^ this.MipmapSize;  	hashCode = (hashCode * 397) ^ this.DepthStride;  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.Height;  
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.WidthPacked;  
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.HeightPacked;  
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.Depth;  
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.RowStride;  
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.MipmapSize;  
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.DepthStride;  
Magic Number,SharpDX.Toolkit.Graphics,Texture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetViewCount,The following statement contains a magic number: return GetViewIndex ((ViewType)4' arrayOrDepthSize' this.Description.MipLevels);  
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: if (textureData.Length != 6)  	throw new ArgumentException ("Invalid texture data. First dimension must be equal to 6"' "textureData");  
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin (textureData [2]' ptr => dataBox3 = GetDataBox (format' size' size' 1' textureData [0]' ptr));  
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin (textureData [3]' ptr => dataBox4 = GetDataBox (format' size' size' 1' textureData [0]' ptr));  
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin (textureData [4]' ptr => dataBox5 = GetDataBox (format' size' size' 1' textureData [0]' ptr));  
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin (textureData [5]' ptr => dataBox6 = GetDataBox (format' size' size' 1' textureData [0]' ptr));  
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: if (textureData.Length != 6)  	throw new ArgumentException ("Invalid texture data. First dimension must be equal to 6"' "textureData");  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode ();  	hashCode = (hashCode * 397) ^ Usage.GetHashCode ();  	hashCode = (hashCode * 397) ^ BindFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode ();  	hashCode = (hashCode * 397) ^ Usage.GetHashCode ();  	hashCode = (hashCode * 397) ^ BindFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode ();  	hashCode = (hashCode * 397) ^ Usage.GetHashCode ();  	hashCode = (hashCode * 397) ^ BindFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode ();  	hashCode = (hashCode * 397) ^ Usage.GetHashCode ();  	hashCode = (hashCode * 397) ^ BindFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode ();  	hashCode = (hashCode * 397) ^ Usage.GetHashCode ();  	hashCode = (hashCode * 397) ^ BindFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode ();  	hashCode = (hashCode * 397) ^ Usage.GetHashCode ();  	hashCode = (hashCode * 397) ^ BindFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode ();  	hashCode = (hashCode * 397) ^ Usage.GetHashCode ();  	hashCode = (hashCode * 397) ^ BindFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode ();  	hashCode = (hashCode * 397) ^ Usage.GetHashCode ();  	hashCode = (hashCode * 397) ^ BindFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode ();  	hashCode = (hashCode * 397) ^ Usage.GetHashCode ();  	hashCode = (hashCode * 397) ^ BindFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode ();  	hashCode = (hashCode * 397) ^ Usage.GetHashCode ();  	hashCode = (hashCode * 397) ^ BindFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int hashCode = Dimension.GetHashCode ();  	hashCode = (hashCode * 397) ^ Width;  	hashCode = (hashCode * 397) ^ Height;  	hashCode = (hashCode * 397) ^ Depth;  	hashCode = (hashCode * 397) ^ ArraySize;  	hashCode = (hashCode * 397) ^ MipLevels;  	hashCode = (hashCode * 397) ^ Format.GetHashCode ();  	hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode ();  	hashCode = (hashCode * 397) ^ Usage.GetHashCode ();  	hashCode = (hashCode * 397) ^ BindFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode ();  	hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode ();  	return hashCode;  }  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Width;  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Height;  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Depth;  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ ArraySize;  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ MipLevels;  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Format.GetHashCode ();  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode ();  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Usage.GetHashCode ();  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ BindFlags.GetHashCode ();  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode ();  
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode ();  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: frame.SetResolution (72' 72);  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: frame.SetResolution (72' 72);  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: if (targetGuid != pfGuid) {  	using (var source = new Bitmap (Factory' image.Width' image.Height' pfGuid' new DataRectangle (image.DataPointer' image.RowStride)' image.BufferStride)) {  		using (var converter = new FormatConverter (Factory)) {  			using (var palette = new Palette (Factory)) {  				palette.Initialize (source' 256' true);  				converter.Initialize (source' targetGuid' GetWICDither (flags)' palette' 0' BitmapPaletteType.Custom);  				int bpp = GetBitsPerPixel (targetGuid);  				if (bpp == 0)  					throw new NotSupportedException ("Unable to determine the Bpp for the target format");  				int rowPitch = (image.Width * bpp + 7) / 8;  				int slicePitch = rowPitch * image.Height;  				var temp = Utilities.AllocateMemory (slicePitch);  				try {  					converter.CopyPixels (rowPitch' temp' slicePitch);  					frame.Palette = palette;  					frame.WritePixels (image.Height' temp' rowPitch' slicePitch);  				} finally {  					Utilities.FreeMemory (temp);  				}  			}  		}  	}  } else {  	// No conversion required  	frame.WritePixels (image.Height' image.DataPointer' image.RowStride' image.BufferStride);  }  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: if (targetGuid != pfGuid) {  	using (var source = new Bitmap (Factory' image.Width' image.Height' pfGuid' new DataRectangle (image.DataPointer' image.RowStride)' image.BufferStride)) {  		using (var converter = new FormatConverter (Factory)) {  			using (var palette = new Palette (Factory)) {  				palette.Initialize (source' 256' true);  				converter.Initialize (source' targetGuid' GetWICDither (flags)' palette' 0' BitmapPaletteType.Custom);  				int bpp = GetBitsPerPixel (targetGuid);  				if (bpp == 0)  					throw new NotSupportedException ("Unable to determine the Bpp for the target format");  				int rowPitch = (image.Width * bpp + 7) / 8;  				int slicePitch = rowPitch * image.Height;  				var temp = Utilities.AllocateMemory (slicePitch);  				try {  					converter.CopyPixels (rowPitch' temp' slicePitch);  					frame.Palette = palette;  					frame.WritePixels (image.Height' temp' rowPitch' slicePitch);  				} finally {  					Utilities.FreeMemory (temp);  				}  			}  		}  	}  } else {  	// No conversion required  	frame.WritePixels (image.Height' image.DataPointer' image.RowStride' image.BufferStride);  }  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: if (targetGuid != pfGuid) {  	using (var source = new Bitmap (Factory' image.Width' image.Height' pfGuid' new DataRectangle (image.DataPointer' image.RowStride)' image.BufferStride)) {  		using (var converter = new FormatConverter (Factory)) {  			using (var palette = new Palette (Factory)) {  				palette.Initialize (source' 256' true);  				converter.Initialize (source' targetGuid' GetWICDither (flags)' palette' 0' BitmapPaletteType.Custom);  				int bpp = GetBitsPerPixel (targetGuid);  				if (bpp == 0)  					throw new NotSupportedException ("Unable to determine the Bpp for the target format");  				int rowPitch = (image.Width * bpp + 7) / 8;  				int slicePitch = rowPitch * image.Height;  				var temp = Utilities.AllocateMemory (slicePitch);  				try {  					converter.CopyPixels (rowPitch' temp' slicePitch);  					frame.Palette = palette;  					frame.WritePixels (image.Height' temp' rowPitch' slicePitch);  				} finally {  					Utilities.FreeMemory (temp);  				}  			}  		}  	}  } else {  	// No conversion required  	frame.WritePixels (image.Height' image.DataPointer' image.RowStride' image.BufferStride);  }  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: using (var source = new Bitmap (Factory' image.Width' image.Height' pfGuid' new DataRectangle (image.DataPointer' image.RowStride)' image.BufferStride)) {  	using (var converter = new FormatConverter (Factory)) {  		using (var palette = new Palette (Factory)) {  			palette.Initialize (source' 256' true);  			converter.Initialize (source' targetGuid' GetWICDither (flags)' palette' 0' BitmapPaletteType.Custom);  			int bpp = GetBitsPerPixel (targetGuid);  			if (bpp == 0)  				throw new NotSupportedException ("Unable to determine the Bpp for the target format");  			int rowPitch = (image.Width * bpp + 7) / 8;  			int slicePitch = rowPitch * image.Height;  			var temp = Utilities.AllocateMemory (slicePitch);  			try {  				converter.CopyPixels (rowPitch' temp' slicePitch);  				frame.Palette = palette;  				frame.WritePixels (image.Height' temp' rowPitch' slicePitch);  			} finally {  				Utilities.FreeMemory (temp);  			}  		}  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: using (var source = new Bitmap (Factory' image.Width' image.Height' pfGuid' new DataRectangle (image.DataPointer' image.RowStride)' image.BufferStride)) {  	using (var converter = new FormatConverter (Factory)) {  		using (var palette = new Palette (Factory)) {  			palette.Initialize (source' 256' true);  			converter.Initialize (source' targetGuid' GetWICDither (flags)' palette' 0' BitmapPaletteType.Custom);  			int bpp = GetBitsPerPixel (targetGuid);  			if (bpp == 0)  				throw new NotSupportedException ("Unable to determine the Bpp for the target format");  			int rowPitch = (image.Width * bpp + 7) / 8;  			int slicePitch = rowPitch * image.Height;  			var temp = Utilities.AllocateMemory (slicePitch);  			try {  				converter.CopyPixels (rowPitch' temp' slicePitch);  				frame.Palette = palette;  				frame.WritePixels (image.Height' temp' rowPitch' slicePitch);  			} finally {  				Utilities.FreeMemory (temp);  			}  		}  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: using (var source = new Bitmap (Factory' image.Width' image.Height' pfGuid' new DataRectangle (image.DataPointer' image.RowStride)' image.BufferStride)) {  	using (var converter = new FormatConverter (Factory)) {  		using (var palette = new Palette (Factory)) {  			palette.Initialize (source' 256' true);  			converter.Initialize (source' targetGuid' GetWICDither (flags)' palette' 0' BitmapPaletteType.Custom);  			int bpp = GetBitsPerPixel (targetGuid);  			if (bpp == 0)  				throw new NotSupportedException ("Unable to determine the Bpp for the target format");  			int rowPitch = (image.Width * bpp + 7) / 8;  			int slicePitch = rowPitch * image.Height;  			var temp = Utilities.AllocateMemory (slicePitch);  			try {  				converter.CopyPixels (rowPitch' temp' slicePitch);  				frame.Palette = palette;  				frame.WritePixels (image.Height' temp' rowPitch' slicePitch);  			} finally {  				Utilities.FreeMemory (temp);  			}  		}  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: using (var converter = new FormatConverter (Factory)) {  	using (var palette = new Palette (Factory)) {  		palette.Initialize (source' 256' true);  		converter.Initialize (source' targetGuid' GetWICDither (flags)' palette' 0' BitmapPaletteType.Custom);  		int bpp = GetBitsPerPixel (targetGuid);  		if (bpp == 0)  			throw new NotSupportedException ("Unable to determine the Bpp for the target format");  		int rowPitch = (image.Width * bpp + 7) / 8;  		int slicePitch = rowPitch * image.Height;  		var temp = Utilities.AllocateMemory (slicePitch);  		try {  			converter.CopyPixels (rowPitch' temp' slicePitch);  			frame.Palette = palette;  			frame.WritePixels (image.Height' temp' rowPitch' slicePitch);  		} finally {  			Utilities.FreeMemory (temp);  		}  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: using (var converter = new FormatConverter (Factory)) {  	using (var palette = new Palette (Factory)) {  		palette.Initialize (source' 256' true);  		converter.Initialize (source' targetGuid' GetWICDither (flags)' palette' 0' BitmapPaletteType.Custom);  		int bpp = GetBitsPerPixel (targetGuid);  		if (bpp == 0)  			throw new NotSupportedException ("Unable to determine the Bpp for the target format");  		int rowPitch = (image.Width * bpp + 7) / 8;  		int slicePitch = rowPitch * image.Height;  		var temp = Utilities.AllocateMemory (slicePitch);  		try {  			converter.CopyPixels (rowPitch' temp' slicePitch);  			frame.Palette = palette;  			frame.WritePixels (image.Height' temp' rowPitch' slicePitch);  		} finally {  			Utilities.FreeMemory (temp);  		}  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: using (var converter = new FormatConverter (Factory)) {  	using (var palette = new Palette (Factory)) {  		palette.Initialize (source' 256' true);  		converter.Initialize (source' targetGuid' GetWICDither (flags)' palette' 0' BitmapPaletteType.Custom);  		int bpp = GetBitsPerPixel (targetGuid);  		if (bpp == 0)  			throw new NotSupportedException ("Unable to determine the Bpp for the target format");  		int rowPitch = (image.Width * bpp + 7) / 8;  		int slicePitch = rowPitch * image.Height;  		var temp = Utilities.AllocateMemory (slicePitch);  		try {  			converter.CopyPixels (rowPitch' temp' slicePitch);  			frame.Palette = palette;  			frame.WritePixels (image.Height' temp' rowPitch' slicePitch);  		} finally {  			Utilities.FreeMemory (temp);  		}  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: using (var palette = new Palette (Factory)) {  	palette.Initialize (source' 256' true);  	converter.Initialize (source' targetGuid' GetWICDither (flags)' palette' 0' BitmapPaletteType.Custom);  	int bpp = GetBitsPerPixel (targetGuid);  	if (bpp == 0)  		throw new NotSupportedException ("Unable to determine the Bpp for the target format");  	int rowPitch = (image.Width * bpp + 7) / 8;  	int slicePitch = rowPitch * image.Height;  	var temp = Utilities.AllocateMemory (slicePitch);  	try {  		converter.CopyPixels (rowPitch' temp' slicePitch);  		frame.Palette = palette;  		frame.WritePixels (image.Height' temp' rowPitch' slicePitch);  	} finally {  		Utilities.FreeMemory (temp);  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: using (var palette = new Palette (Factory)) {  	palette.Initialize (source' 256' true);  	converter.Initialize (source' targetGuid' GetWICDither (flags)' palette' 0' BitmapPaletteType.Custom);  	int bpp = GetBitsPerPixel (targetGuid);  	if (bpp == 0)  		throw new NotSupportedException ("Unable to determine the Bpp for the target format");  	int rowPitch = (image.Width * bpp + 7) / 8;  	int slicePitch = rowPitch * image.Height;  	var temp = Utilities.AllocateMemory (slicePitch);  	try {  		converter.CopyPixels (rowPitch' temp' slicePitch);  		frame.Palette = palette;  		frame.WritePixels (image.Height' temp' rowPitch' slicePitch);  	} finally {  		Utilities.FreeMemory (temp);  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: using (var palette = new Palette (Factory)) {  	palette.Initialize (source' 256' true);  	converter.Initialize (source' targetGuid' GetWICDither (flags)' palette' 0' BitmapPaletteType.Custom);  	int bpp = GetBitsPerPixel (targetGuid);  	if (bpp == 0)  		throw new NotSupportedException ("Unable to determine the Bpp for the target format");  	int rowPitch = (image.Width * bpp + 7) / 8;  	int slicePitch = rowPitch * image.Height;  	var temp = Utilities.AllocateMemory (slicePitch);  	try {  		converter.CopyPixels (rowPitch' temp' slicePitch);  		frame.Palette = palette;  		frame.WritePixels (image.Height' temp' rowPitch' slicePitch);  	} finally {  		Utilities.FreeMemory (temp);  	}  }  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: palette.Initialize (source' 256' true);  
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeMultiframe,The following statement contains a magic number: if (images.Length < 2)  	throw new ArgumentException ("Cannot encode to multiple frame. Image doesn't have multiple frame");  
Missing Default,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  case Key.Left:  	this.AddRotateForce (-1 * f * this.LeftRightRotationSensitivity' 0);  	e.Handled = true;  	break;  case Key.Right:  	this.AddRotateForce (1 * f * this.LeftRightRotationSensitivity' 0);  	e.Handled = true;  	break;  case Key.Up:  	this.AddRotateForce (0' -1 * f * this.UpDownRotationSensitivity);  	e.Handled = true;  	break;  case Key.Down:  	this.AddRotateForce (0' 1 * f * this.UpDownRotationSensitivity);  	e.Handled = true;  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  case Key.Left:  	this.AddPanForce (-5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Right:  	this.AddPanForce (5 * f * this.LeftRightPanSensitivity' 0);  	e.Handled = true;  	break;  case Key.Up:  	this.AddPanForce (0' -5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  case Key.Down:  	this.AddPanForce (0' 5 * f * this.UpDownPanSensitivity);  	e.Handled = true;  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  case Key.PageUp:  	this.AddZoomForce (-0.1 * f * this.PageUpDownZoomSensitivity);  	e.Handled = true;  	break;  case Key.PageDown:  	this.AddZoomForce (0.1 * f * this.PageUpDownZoomSensitivity);  	e.Handled = true;  	break;  case Key.Back:  	if (this.RestoreCameraSetting ()) {  		e.Handled = true;  	}  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,CameraController,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\CameraController.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key) {  case Key.W:  	this.AddMoveForce (0' 0' 0.1 * f * this.MoveSensitivity);  	break;  case Key.A:  	this.AddMoveForce (-0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.S:  	this.AddMoveForce (0' 0' -0.1 * f * this.MoveSensitivity);  	break;  case Key.D:  	this.AddMoveForce (0.1 * f * this.LeftRightPanSensitivity' 0' 0);  	break;  case Key.Z:  	this.AddMoveForce (0' -0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  case Key.Q:  	this.AddMoveForce (0' 0.1 * f * this.LeftRightPanSensitivity' 0);  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,DPFCanvasThreading,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\DPFCanvasThreading.cs,InvalidateRender,The following switch statement is missing a default case: switch (pendingInvalidateOperation.Status) {  case DispatcherOperationStatus.Pending:  	//If there is a pending invalidation operation' try to set cycle to 2.  	//Does not matter if it is failed or not' since the pending one will eventually invalidate.  	//But this is required for mouse rotation' because it requires invalidate asap (Input priority is higher than background).  	System.Threading.Interlocked.CompareExchange (ref pendingValidationCycles' RenderCycles' 0);  	return;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,Rotate,The following switch statement is missing a default case: switch (this.Viewport.CameraRotationMode) {  case CameraRotationMode.Trackball:  	this.RotateTrackball (p0' p1' rotateAround);  	break;  case CameraRotationMode.Turntable:  	this.RotateTurntable (p1 - p0' rotateAround);  	break;  case CameraRotationMode.Turnball:  	this.RotateTurnball (p0' p1' rotateAround);  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,RotateHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\RotateHandler.cs,Started,The following switch statement is missing a default case: switch (this.CameraRotationMode) {  case CameraRotationMode.Trackball:  	break;  case CameraRotationMode.Turntable:  	break;  case CameraRotationMode.Turnball:  	this.InitTurnballRotationAxes (e.CurrentPosition);  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,Zoom,The following switch statement is missing a default case: switch (this.CameraMode) {  case CameraMode.Inspect:  	this.ChangeCameraDistance (delta' zoomAround);  	break;  case CameraMode.WalkAround:  	this.Camera.Position -= this.Camera.LookDirection * delta;  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,MoveCameraPosition,The following switch statement is missing a default case: switch (this.CameraMode) {  case CameraMode.Inspect:  case CameraMode.WalkAround:  	this.Camera.Position += (x * delta.X) + (y * delta.Y) + (z * delta.Z);  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,ZoomHandler,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Controls\MouseHandlers\ZoomHandler.cs,ZoomByChangingCameraWidth,The following switch statement is missing a default case: switch (this.CameraMode) {  case CameraMode.WalkAround:  case CameraMode.Inspect:  case CameraMode.FixedPosition:  	this.ChangeCameraDistance (delta' zoomAround);  	// Modify the camera width  	var ocamera = this.Camera as OrthographicCamera;  	if (ocamera != null) {  		ocamera.Width *= 1 + delta;  	}  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,BillboardTextModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\BillboardTextModel3D.cs,OnRender,The following switch statement is missing a default case: switch (billboardType) {  case BillboardType.MultipleText:  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.Draw (vertexCount' 0);  	break;  case BillboardType.SingleText:  	if (vertexCount == 8) {  		var half = vertexCount / 2;  		// Use background shader to draw background first  		effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  		// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  		renderContext.DeviceContext.Draw (half' half);  		// Use foreground shader to draw text  		effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  		// --- draw text' foreground vertex is beginning from 0.  		renderContext.DeviceContext.Draw (half' 0);  	}  	break;  case BillboardType.SingleImage:  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (2).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.Draw (vertexCount' 0);  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,InstancingBillboardModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\InstancingBillboardModel3D.cs,OnRender,The following switch statement is missing a default case: switch (billboardType) {  case BillboardType.SingleImage:  	// Use foreground shader to draw text  	effectTechnique.GetPassByIndex (2).Apply (renderContext.DeviceContext);  	// --- draw text' foreground vertex is beginning from 0.  	renderContext.DeviceContext.DrawInstanced (vertexCount' this.instanceInternal.Count' 0' 0);  	break;  case BillboardType.SingleText:  	if (vertexCount == 8) {  		var half = vertexCount / 2;  		// Use background shader to draw background first  		effectTechnique.GetPassByIndex (1).Apply (renderContext.DeviceContext);  		// --- draw background' background vertex is beginning from middle. <see cref="BillboardSingleText3D"/>  		renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' half' 0);  		// Use foreground shader to draw text  		effectTechnique.GetPassByIndex (0).Apply (renderContext.DeviceContext);  		// --- draw text' foreground vertex is beginning from 0.  		renderContext.DeviceContext.DrawInstanced (half' this.instanceInternal.Count' 0' 0);  	}  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,CompositeModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CompositeModel3D.cs,ChildrenChanged,The following switch statement is missing a default case: switch (e.Action) {  case NotifyCollectionChangedAction.Reset:  case NotifyCollectionChangedAction.Remove:  case NotifyCollectionChangedAction.Replace:  	foreach (Model3D item in e.OldItems) {  		// todo: detach?  		// yes' always  		item.Detach ();  		if (item.Parent == this) {  			this.RemoveLogicalChild (item);  		}  	}  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,CompositeModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\CompositeModel3D.cs,ChildrenChanged,The following switch statement is missing a default case: switch (e.Action) {  case NotifyCollectionChangedAction.Reset:  case NotifyCollectionChangedAction.Add:  case NotifyCollectionChangedAction.Replace:  	foreach (Model3D item in e.NewItems) {  		if (this.IsAttached) {  			// todo: attach?  			// yes' always    			// where to get a refrence to renderHost?  			// store it as private memeber of the class?  			if (item.Parent == null) {  				this.AddLogicalChild (item);  			}  			item.Attach (this.renderHost);  		}  	}  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,Items3DControl,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\Items3DControl.cs,OnItemsChanged,The following switch statement is missing a default case: switch (e.Action) {  case NotifyCollectionChangedAction.Add:  case NotifyCollectionChangedAction.Replace: {  	if (this.ItemTemplate != null) {  		foreach (var item in e.NewItems) {  			var element = this.ItemTemplate.LoadContent () as Element3D;  			if (element != null) {  				element.DataContext = item;  				this.children.Add (element);  				var meshModel = element as IMouse3D;  				if (meshModel != null) {  					var selectable = meshModel as ISelectable;  					meshModel.MouseDown3D += (o' e1) => {  						this.SelectedItem = item;  						if (selectable != null)  							selectable.IsSelected = true;  					};  				}  			} else {  				throw new InvalidOperationException ("Cannot create a Element3D from ItemTemplate.");  			}  		}  	} else {  		foreach (var item in e.NewItems) {  			var element = item as IRenderable;  			if (element != null) {  				this.children.Add (item);  				var meshModel = element as IMouse3D;  				if (meshModel != null) {  					var selectable = meshModel as ISelectable;  					meshModel.MouseDown3D += (o' e1) => {  						this.SelectedItem = item;  						if (selectable != null)  							selectable.IsSelected = true;  					};  				}  			}  		}  	}  	break;  }  case NotifyCollectionChangedAction.Remove: {  	if (this.ItemTemplate != null) {  		int ii = 0;  		foreach (var item in e.OldItems) {  			var element = this.children [e.OldStartingIndex + ii++] as IRenderable;  			if (element != null) {  				element.Detach ();  				this.children.Remove (element);  			} else {  				throw new InvalidOperationException ("Cannot remove a Element3D from Items.");  			}  		}  	} else {  		foreach (var item in e.OldItems) {  			var element = item as IRenderable;  			if (element != null) {  				element.Detach ();  				this.children.Remove (item);  			}  		}  	}  	break;  }  case NotifyCollectionChangedAction.Reset: {  	foreach (var item in this.children) {  		var element = item as IRenderable;  		if (element != null) {  			element.Detach ();  		} else {  			throw new InvalidOperationException ("Cannot remove a Element3D from Items.");  		}  	}  	this.children.Clear ();  	break;  }  }  
Missing Default,HelixToolkit.Wpf.SharpDX,ItemsModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ItemsModel3D.cs,ItemsModel3D_CollectionChanged,The following switch statement is missing a default case: switch (e.Action) {  case NotifyCollectionChangedAction.Reset:  	OctreeManager.Clear ();  	OctreeManager.RequestRebuild ();  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,ItemsModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ItemsModel3D.cs,ItemsModel3D_CollectionChanged,The following switch statement is missing a default case: switch (e.Action) {  case NotifyCollectionChangedAction.Replace:  case NotifyCollectionChangedAction.Remove:  	if (e.OldItems != null) {  		foreach (var item in e.OldItems) {  			if (mDictionary.ContainsKey (item)) {  				var model = mDictionary [item];  				if (model is GeometryModel3D)  					OctreeManager.RemoveItem (model as GeometryModel3D);  				model.DataContext = null;  				this.Children.Remove (model);  				mDictionary.Remove (item);  			}  		}  		InvalidateRender ();  	}  	break;  case NotifyCollectionChangedAction.Reset:  	var array = this.Children.ToArray ();  	foreach (var item in array) {  		item.DataContext = null;  		this.Children.Remove (item);  	}  	mDictionary.Clear ();  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,ItemsModel3D,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Model\Elements3D\ItemsModel3D.cs,ItemsModel3D_CollectionChanged,The following switch statement is missing a default case: switch (e.Action) {  case NotifyCollectionChangedAction.Reset:  	if (this.ItemsSource != null) {  		if (this.ItemTemplate == null) {  			foreach (var item in this.ItemsSource) {  				var model = item as Model3D;  				if (model != null) {  					this.Children.Add (model);  					mDictionary.Add (item' model);  				} else {  					throw new InvalidOperationException ("Cannot create a Model3D from ItemTemplate.");  				}  			}  		} else {  			foreach (var item in this.ItemsSource) {  				var model = this.ItemTemplate.LoadContent () as Model3D;  				if (model != null) {  					model.DataContext = item;  					this.Children.Add (model);  					mDictionary.Add (item' model);  				} else {  					throw new InvalidOperationException ("Cannot create a Model3D from ItemTemplate.");  				}  			}  		}  	}  	InvalidateRender ();  	break;  case NotifyCollectionChangedAction.Add:  case NotifyCollectionChangedAction.Replace:  	if (e.NewItems != null) {  		if (this.ItemTemplate != null) {  			foreach (var item in e.NewItems) {  				if (mDictionary.ContainsKey (item)) {  					continue;  				}  				var model = this.ItemTemplate.LoadContent () as Model3D;  				if (model != null) {  					OctreeManager.AddPendingItem (model);  					model.DataContext = item;  					this.Children.Add (model);  					mDictionary.Add (item' model);  				} else {  					throw new InvalidOperationException ("Cannot create a Model3D from ItemTemplate.");  				}  			}  		} else {  			foreach (var item in e.NewItems) {  				if (mDictionary.ContainsKey (item)) {  					continue;  				}  				var model = item as Model3D;  				if (model != null) {  					OctreeManager.AddPendingItem (model);  					this.Children.Add (model);  					mDictionary.Add (item' model);  				} else {  					throw new InvalidOperationException ("Cannot create a Model3D from ItemTemplate.");  				}  			}  		}  	}  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,Read,The following switch statement is missing a default case: switch (keyword.ToLower ()) {  // Vertex data  case "v":  	// geometric vertices  	this.AddVertex (values);  	break;  case "vt":  	// texture vertices  	this.AddTexCoord (values);  	break;  case "vn":  	// vertex normals  	this.AddNormal (values);  	break;  case "vp":  // parameter space vertices  case "cstype":  // rational or non-rational forms of curve or surface type: basis matrix' Bezier' B-spline' Cardinal' Taylor  case "degree":  // degree  case "bmat":  // basis matrix  case "step":  	// step size  	// not supported  	break;  // Elements  case "f":  	// face  	this.AddFace (values);  	break;  case "p":  // point  case "l":  // line  case "curv":  // curve  case "curv2":  // 2D curve  case "surf":  	// surface  	// not supported  	break;  // Free-form curve/surface body statements  case "parm":  // parameter name  case "trim":  // outer trimming loop (trim)  case "hole":  // inner trimming loop (hole)  case "scrv":  // special curve (scrv)  case "sp":  // special point (sp)  case "end":  	// end statement (end)  	// not supported  	break;  // Connectivity between free-form surfaces  case "con":  	// connect  	// not supported  	break;  // Grouping  case "g":  	// group name  	this.AddGroup (values);  	break;  case "s":  	// smoothing group  	this.SetSmoothingGroup (values);  	break;  case "mg":  	// merging group  	break;  case "o":  	// object name  	// not supported  	break;  // Display/render attributes  case "mtllib":  	// material library  	this.LoadMaterialLib (values);  	break;  case "usemtl":  	// material name  	this.EnsureNewMesh ();  	this.SetMaterial (values);  	break;  case "usemap":  	// texture map name  	this.EnsureNewMesh ();  	break;  case "bevel":  // bevel interpolation  case "c_interp":  // color interpolation  case "d_interp":  // dissolve interpolation  case "lod":  // level of detail  case "shadow_obj":  // shadow casting  case "trace_obj":  // ray tracing  case "ctech":  // curve approximation technique  case "stech":  	// surface approximation technique  	// not supported  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,ObjReader,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Wpf.SharpDX\Utilities\ObjReader.cs,LoadMaterialLib,The following switch statement is missing a default case: switch (keyword.ToLower ()) {  case "newmtl":  	if (value != null && !Materials.ContainsKey (value)) {  		currentMaterial = new MaterialDefinition ();  		this.Materials.Add (value' currentMaterial);  	}  	break;  case "ka":  	if (currentMaterial != null && value != null) {  		currentMaterial.Ambient = ColorParse (value);  	}  	break;  case "kd":  	if (currentMaterial != null && value != null) {  		currentMaterial.Diffuse = ColorParse (value);  	}  	break;  case "ks":  	if (currentMaterial != null && value != null) {  		currentMaterial.Specular = ColorParse (value);  	}  	break;  case "ns":  	if (currentMaterial != null && value != null) {  		currentMaterial.SpecularCoefficient = DoubleParse (value);  	}  	break;  case "d":  	if (currentMaterial != null && value != null) {  		currentMaterial.Dissolved = DoubleParse (value);  	}  	break;  case "tr":  	if (!this.SkipTransparencyValues && currentMaterial != null && value != null) {  		currentMaterial.Dissolved = DoubleParse (value);  	}  	break;  case "illum":  	if (currentMaterial != null && value != null) {  		currentMaterial.Illumination = int.Parse (value);  	}  	break;  case "map_ka":  	if (currentMaterial != null) {  		currentMaterial.AmbientMap = value;  	}  	break;  case "map_kd":  	if (currentMaterial != null) {  		currentMaterial.DiffuseMap = value;  	}  	break;  case "map_ks":  	if (currentMaterial != null) {  		currentMaterial.SpecularMap = value;  	}  	break;  case "map_d":  	if (currentMaterial != null) {  		currentMaterial.AlphaMap = value;  	}  	break;  case "map_bump":  case "bump":  	if (currentMaterial != null) {  		currentMaterial.BumpMap = value;  	}  	break;  }  
Missing Default,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,CalculateDiagonals,The following switch statement is missing a default case: switch (evClass) {  case PolygonPointClass.Start:  	// Just add the left Edge (depending on the sweeping direction)  	statusAndHelper.Add (new StatusHelperElement (sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));  	break;  case PolygonPointClass.Stop:  	// Just remove the left Edge (depending on the sweeping direction)  	statusAndHelper.Remove (sweepDown ? ev.EdgeOne : ev.EdgeTwo);  	break;  case PolygonPointClass.Regular:  	// If the Polygon is positioned on the right Side of this Event  	if (ev.Last > ev.Next) {  		// Replace the corresponding (old) StatusHelperElement with the new one  		statusAndHelper.Remove (sweepDown ? ev.EdgeOne : ev.EdgeTwo);  		statusAndHelper.Add (new StatusHelperElement (sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));  	} else {  		// Search Edge left of the Event and set Event as it's Helper  		she = statusAndHelper.SearchLeft (ev);  		she.Helper = ev;  	}  	break;  case PolygonPointClass.Merge:  	// Just remove the left Edge (depending on the sweeping direction)  	statusAndHelper.Remove (sweepDown ? ev.EdgeOne : ev.EdgeTwo);  	// Search Edge left of the Event and set Event as it's Helper  	she = statusAndHelper.SearchLeft (ev);  	she.Helper = ev;  	break;  case PolygonPointClass.Split:  	// Search Edge left of the Event  	she = statusAndHelper.SearchLeft (ev);  	// Chose diagonal from Helper of Edge to Event.  	var minP = Math.Min (she.Helper.Index' ev.Index);  	var maxP = Math.Max (she.Helper.Index' ev.Index);  	var diagonal = new Tuple<int' int> (minP' maxP);  	diagonals.Add (diagonal);  	// Replace the Helper of the StatusHelperElement by Event  	she.Helper = ev;  	// Insert the right Edge from Event  	statusAndHelper.Add (new StatusHelperElement (sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));  	break;  }  
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following switch statement is missing a default case: switch ((DXGI.Format)description.Format) {  case Format.B8G8R8A8_UNorm:  	description.Format = Format.R8G8B8A8_UNorm;  	convFlags |= ConversionFlags.Swizzle;  	break;  case Format.B8G8R8X8_UNorm:  	description.Format = Format.R8G8B8A8_UNorm;  	convFlags |= ConversionFlags.Swizzle | ConversionFlags.NoAlpha;  	break;  case Format.B8G8R8A8_Typeless:  	description.Format = Format.R8G8B8A8_Typeless;  	convFlags |= ConversionFlags.Swizzle;  	break;  case Format.B8G8R8A8_UNorm_SRgb:  	description.Format = Format.R8G8B8A8_UNorm_SRgb;  	convFlags |= ConversionFlags.Swizzle;  	break;  case Format.B8G8R8X8_Typeless:  	description.Format = Format.R8G8B8A8_Typeless;  	convFlags |= ConversionFlags.Swizzle | ConversionFlags.NoAlpha;  	break;  case Format.B8G8R8X8_UNorm_SRgb:  	description.Format = Format.R8G8B8A8_UNorm_SRgb;  	convFlags |= ConversionFlags.Swizzle | ConversionFlags.NoAlpha;  	break;  }  
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following switch statement is missing a default case: switch ((DXGI.Format)description.Format) {  case Format.B5G6R5_UNorm:  case Format.B5G5R5A1_UNorm:  	#if DIRECTX11_1  	                    case Format.B4G4R4A4_UNorm: #endif  	description.Format = Format.R8G8B8A8_UNorm;  	convFlags |= ConversionFlags.Expand;  	if (description.Format == Format.B5G6R5_UNorm)  		convFlags |= ConversionFlags.NoAlpha;  	break;  }  
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following switch statement is missing a default case: switch (description.Format) {  case Format.R8G8B8A8_UNorm:  	ddpf = DDS.PixelFormat.A8B8G8R8;  	break;  case Format.R16G16_UNorm:  	ddpf = DDS.PixelFormat.G16R16;  	break;  case Format.R8G8_UNorm:  	ddpf = DDS.PixelFormat.A8L8;  	break;  case Format.R16_UNorm:  	ddpf = DDS.PixelFormat.L16;  	break;  case Format.R8_UNorm:  	ddpf = DDS.PixelFormat.L8;  	break;  case Format.A8_UNorm:  	ddpf = DDS.PixelFormat.A8;  	break;  case Format.R8G8_B8G8_UNorm:  	ddpf = DDS.PixelFormat.R8G8_B8G8;  	break;  case Format.G8R8_G8B8_UNorm:  	ddpf = DDS.PixelFormat.G8R8_G8B8;  	break;  case Format.BC1_UNorm:  	ddpf = DDS.PixelFormat.DXT1;  	break;  case Format.BC2_UNorm:  	ddpf = DDS.PixelFormat.DXT3;  	break;  case Format.BC3_UNorm:  	ddpf = DDS.PixelFormat.DXT5;  	break;  case Format.BC4_UNorm:  	ddpf = DDS.PixelFormat.BC4_UNorm;  	break;  case Format.BC4_SNorm:  	ddpf = DDS.PixelFormat.BC4_SNorm;  	break;  case Format.BC5_UNorm:  	ddpf = DDS.PixelFormat.BC5_UNorm;  	break;  case Format.BC5_SNorm:  	ddpf = DDS.PixelFormat.BC5_SNorm;  	break;  case Format.B5G6R5_UNorm:  	ddpf = DDS.PixelFormat.R5G6B5;  	break;  case Format.B5G5R5A1_UNorm:  	ddpf = DDS.PixelFormat.A1R5G5B5;  	break;  case Format.B8G8R8A8_UNorm:  	ddpf = DDS.PixelFormat.A8R8G8B8;  	break;  // DXGI 1.1  case Format.B8G8R8X8_UNorm:  	ddpf = DDS.PixelFormat.X8R8G8B8;  	break;  // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                         ddpf = DDS.PixelFormat.A4R4G4B4;                         break; #endif  // Legacy D3DX formats using D3DFMT enum value as FourCC  case Format.R32G32B32A32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 116;  	// D3DFMT_A32B32G32R32F  	break;  case Format.R16G16B16A16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 113;  	// D3DFMT_A16B16G16R16F  	break;  case Format.R16G16B16A16_UNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 36;  	// D3DFMT_A16B16G16R16  	break;  case Format.R16G16B16A16_SNorm:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 110;  	// D3DFMT_Q16W16V16U16  	break;  case Format.R32G32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 115;  	// D3DFMT_G32R32F  	break;  case Format.R16G16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 112;  	// D3DFMT_G16R16F  	break;  case Format.R32_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 114;  	// D3DFMT_R32F  	break;  case Format.R16_Float:  	ddpf.Size = Utilities.SizeOf<DDS.PixelFormat> ();  	ddpf.Flags = DDS.PixelFormatFlags.FourCC;  	ddpf.FourCC = 111;  	// D3DFMT_R16F  	break;  }  
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following switch statement is missing a default case: switch (description.Dimension) {  case TextureDimension.Texture1D:  	header->Height = description.Height;  	header->Width = header->Depth = 1;  	break;  case TextureDimension.Texture2D:  case TextureDimension.TextureCube:  	header->Height = description.Height;  	header->Width = description.Width;  	header->Depth = 1;  	if (description.Dimension == TextureDimension.TextureCube) {  		header->SurfaceFlags |= DDS.SurfaceFlags.Cubemap;  		header->CubemapFlags |= DDS.CubemapFlags.AllFaces;  	}  	break;  case TextureDimension.Texture3D:  	header->Flags |= DDS.HeaderFlags.Volume;  	header->CubemapFlags |= DDS.CubemapFlags.Volume;  	header->Height = description.Height;  	header->Width = description.Width;  	header->Depth = description.Depth;  	break;  }  
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following switch statement is missing a default case: switch (description.Dimension) {  case TextureDimension.Texture1D:  	ext->ResourceDimension = ResourceDimension.Texture1D;  	break;  case TextureDimension.Texture2D:  case TextureDimension.TextureCube:  	ext->ResourceDimension = ResourceDimension.Texture2D;  	break;  case TextureDimension.Texture3D:  	ext->ResourceDimension = ResourceDimension.Texture3D;  	break;  }  
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following switch statement is missing a default case: switch (inFormat) {  case TEXP_LEGACY_FORMAT.R8G8B8:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4) {  			// 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well  			int t1 = (*(sPtr) << 16);  			int t2 = (*(sPtr + 1) << 8);  			int t3 = *(sPtr + 2);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			sPtr += 3;  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.R3G3B2:  	switch (outFormat) {  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  				int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  				int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  				*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  			}  		}  		return true;  	case Format.B5G6R5_UNorm:  		// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  		{  			var sPtr = (byte*)(pSource);  			var dPtr = (short*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  				byte t = *(sPtr++);  				var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  				var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  				var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  				*(dPtr++) = (short)(t1 | t2 | t3);  			}  		}  		return true;  	}  	break;  case TEXP_LEGACY_FORMAT.A8R3G3B2:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (short*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));  			uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));  			uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_P8 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			*(dPtr++) = pal8 [t];  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A8P8:  	if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)  		return false;  	// D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)pal8 [t & 0xff];  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)((t & 0xff00) << 16));  			*(dPtr++) = (int)(t1 | ta);  		}  	}  	return true;  case TEXP_LEGACY_FORMAT.A4L4:  	switch (outFormat) {  	#if DIRECTX11_1  	                case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  	// DXGI_1_2_FORMATS  	case Format.R8G8B8A8_UNorm:  		// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  		{  			byte* sPtr = (byte*)(pSource);  			int* dPtr = (int*)(pDestination);  			for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  				byte t = *(sPtr++);  				uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  				uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  				*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  			}  		}  		return true;  	}  	break;  #if !DIRECTX11_1  case TEXP_LEGACY_FORMAT.B4G4R4A4:  	if (outFormat != Format.R8G8B8A8_UNorm)  		return false;  	// D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm  	{  		short* sPtr = (short*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			short t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));  			uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));  			uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf000) << 16) | ((t & 0xf000) << 12)));  			*(dPtr++) = (int)(t1 | t2 | t3 | ta);  		}  	}  	return true;  #endif  }  
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following switch statement is missing a default case: switch (outFormat) {  case Format.R8G8B8A8_UNorm:  	// D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);  			int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);  			int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);  			*(dPtr++) = (int)(t1 | t2 | t3 | 0xff000000);  		}  	}  	return true;  case Format.B5G6R5_UNorm:  	// D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm  	{  		var sPtr = (byte*)(pSource);  		var dPtr = (short*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2) {  			byte t = *(sPtr++);  			var t1 = (ushort)(((t & 0xe0) << 8) | ((t & 0xc0) << 5));  			var t2 = (ushort)(((t & 0x1c) << 6) | ((t & 0x1c) << 3));  			var t3 = (ushort)(((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));  			*(dPtr++) = (short)(t1 | t2 | t3);  		}  	}  	return true;  }  
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following switch statement is missing a default case: switch (outFormat) {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                     // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                      {                         byte * sPtr = (byte*)(pSource);                         short * dPtr = (short*)(pDestination);                          for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                         {                             byte t = *(sPtr++);                              short t1 = (short)(t & 0x0f);                             ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                              *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                         }                     }                     return true; #endif  // DXGI_1_2_FORMATS  case Format.R8G8B8A8_UNorm:  	// D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm  	{  		byte* sPtr = (byte*)(pSource);  		int* dPtr = (int*)(pDestination);  		for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4) {  			byte t = *(sPtr++);  			uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));  			uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint)(((t & 0xf0) << 24) | ((t & 0xf0) << 20)));  			*(dPtr++) = (int)(t1 | (t1 << 8) | (t1 << 16) | ta);  		}  	}  	return true;  }  
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following switch statement is missing a default case: switch (inFormat) {  case DXGI.Format.B5G6R5_UNorm:  	// DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));  			uint t2 = (uint)(((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			*(dPtr++) = t1 | t2 | t3 | 0xff000000;  		}  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  	// DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm  	{  		var sPtr = (ushort*)(pSource);  		var dPtr = (uint*)(pDestination);  		for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4) {  			ushort t = *(sPtr++);  			uint t1 = (uint)(((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));  			uint t2 = (uint)(((t & 0x03e0) << 6) | ((t & 0x0380) << 1));  			uint t3 = (uint)(((t & 0x001f) << 19) | ((t & 0x001c) << 14));  			uint ta = (uint)((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	break;  #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                     // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                     {                         var sPtr = (ushort*) (pSource);                         var dPtr = (uint*) (pDestination);                          for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                         {                             ushort t = *(sPtr++);                              uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                             uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                             uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                             uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                              *(dPtr++) = t1 | t2 | t3 | ta;                         }                     }                     break; #endif  // DXGI_1_2_FORMATS  }  
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following switch statement is missing a default case: switch (format) {  //-----------------------------------------------------------------------------  case Format.R32G32B32A32_Typeless:  case Format.R32G32B32A32_Float:  case Format.R32G32B32A32_UInt:  case Format.R32G32B32A32_SInt:  	{  		uint alpha;  		if (format == Format.R32G32B32A32_Float)  			alpha = 0x3f800000;  		else if (format == Format.R32G32B32A32_SInt)  			alpha = 0x7fffffff;  		else  			alpha = 0xffffffff;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 16) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 16) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R16G16B16A16_Typeless:  case Format.R16G16B16A16_Float:  case Format.R16G16B16A16_UNorm:  case Format.R16G16B16A16_UInt:  case Format.R16G16B16A16_SNorm:  case Format.R16G16B16A16_SInt:  	{  		ushort alpha;  		if (format == Format.R16G16B16A16_Float)  			alpha = 0x3c00;  		else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)  			alpha = 0x7fff;  		else  			alpha = 0xffff;  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 8) {  				dPtr += 3;  				*(dPtr++) = alpha;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 8) {  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = *(sPtr++);  				*(dPtr++) = alpha;  				sPtr++;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				*dPtr |= 0xC0000000;  				++dPtr;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				*(dPtr++) = *(sPtr++) | 0xC0000000;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.R8G8B8A8_UInt:  case Format.R8G8B8A8_SNorm:  case Format.R8G8B8A8_SInt:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  	{  		uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++) & 0xFFFFFF;  				t |= alpha;  				*(dPtr++) = t;  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.B5G5R5A1_UNorm:  	{  		if (pDestination == pSource) {  			var dPtr = (ushort*)(pDestination);  			for (int count = 0; count < outSize; count += 2) {  				*(dPtr++) |= 0x8000;  			}  		} else {  			var sPtr = (ushort*)(pSource);  			var dPtr = (ushort*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 2) {  				*(dPtr++) = (ushort)(*(sPtr++) | 0x8000);  			}  		}  	}  	return;  //-----------------------------------------------------------------------------  case Format.A8_UNorm:  	Utilities.ClearMemory (pDestination' 0xff' outSize);  	return;  #if DIRECTX11_1                      //-----------------------------------------------------------------------------                     case Format.B4G4R4A4_UNorm:                         {                             if (pDestination == pSource)                             {                                 var dPtr = (ushort*) (pDestination);                                 for (int count = 0; count < outSize; count += 2)                                 {                                     *(dPtr++) |= 0xF000;                                 }                             }                             else                             {                                 var sPtr = (ushort*) (pSource);                                 var dPtr = (ushort*) (pDestination);                                 int size = Math.Min(outSize' inSize);                                 for (int count = 0; count < size; count += 2)                                 {                                     *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                 }                             }                         }                         return; #endif  // DXGI_1_2_FORMATS  }  
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following switch statement is missing a default case: switch (format) {  //---------------------------------------------------------------------------------  case Format.R10G10B10A2_Typeless:  case Format.R10G10B10A2_UNorm:  case Format.R10G10B10A2_UInt:  case Format.R10G10B10_Xr_Bias_A2_UNorm:  	if ((flags & ScanlineFlags.Legacy) != 0) {  		// Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)  		if (pDestination == pSource) {  			var dPtr = (uint*)(pDestination);  			for (int count = 0; count < outSize; count += 4) {  				uint t = *dPtr;  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		} else {  			var sPtr = (uint*)(pSource);  			var dPtr = (uint*)(pDestination);  			int size = Math.Min (outSize' inSize);  			for (int count = 0; count < size; count += 4) {  				uint t = *(sPtr++);  				uint t1 = (t & 0x3ff00000) >> 20;  				uint t2 = (t & 0x000003ff) << 20;  				uint t3 = (t & 0x000ffc00);  				uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);  				*(dPtr++) = t1 | t2 | t3 | ta;  			}  		}  		return;  	}  	break;  //---------------------------------------------------------------------------------  case Format.R8G8B8A8_Typeless:  case Format.R8G8B8A8_UNorm:  case Format.R8G8B8A8_UNorm_SRgb:  case Format.B8G8R8A8_UNorm:  case Format.B8G8R8X8_UNorm:  case Format.B8G8R8A8_Typeless:  case Format.B8G8R8A8_UNorm_SRgb:  case Format.B8G8R8X8_Typeless:  case Format.B8G8R8X8_UNorm_SRgb:  	// Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)  	if (pDestination == pSource) {  		var dPtr = (uint*)(pDestination);  		for (int count = 0; count < outSize; count += 4) {  			uint t = *dPtr;  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	} else {  		var sPtr = (uint*)(pSource);  		var dPtr = (uint*)(pDestination);  		int size = Math.Min (outSize' inSize);  		for (int count = 0; count < size; count += 4) {  			uint t = *(sPtr++);  			uint t1 = (t & 0x00ff0000) >> 16;  			uint t2 = (t & 0x000000ff) << 16;  			uint t3 = (t & 0x0000ff00);  			uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);  			*(dPtr++) = t1 | t2 | t3 | ta;  		}  	}  	return;  }  
Missing Default,SharpDX.Toolkit.Graphics,DepthStencilBuffer,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,ComputeViewFormat,The following switch statement is missing a default case: switch (format) {  case SharpDX.DXGI.Format.D16_UNorm:  case DXGI.Format.R16_Float:  case DXGI.Format.R16_Typeless:  	return DepthFormat.Depth16;  case SharpDX.DXGI.Format.D32_Float:  case DXGI.Format.R32_Float:  case DXGI.Format.R32_Typeless:  	return DepthFormat.Depth32;  case SharpDX.DXGI.Format.D24_UNorm_S8_UInt:  case SharpDX.DXGI.Format.R24_UNorm_X8_Typeless:  	return DepthFormat.Depth24Stencil8;  case SharpDX.DXGI.Format.D32_Float_S8X24_UInt:  case SharpDX.DXGI.Format.R32_Float_X8X24_Typeless:  	return DepthFormat.Depth32Stencil8X24;  }  
Missing Default,SharpDX.Toolkit.Graphics,GraphicsResource,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\GraphicsResource.cs,GetCpuAccessFlagsFromUsage,The following switch statement is missing a default case: switch (usage) {  case ResourceUsage.Dynamic:  	return CpuAccessFlags.Write;  case ResourceUsage.Staging:  	return CpuAccessFlags.Read | CpuAccessFlags.Write;  }  
Missing Default,SharpDX.Toolkit.Graphics,Image,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The following switch statement is missing a default case: switch (description.Dimension) {  case TextureDimension.Texture1D:  	if (description.Width <= 0 || description.Height != 1 || description.Depth != 1 || description.ArraySize == 0)  		throw new InvalidOperationException ("Invalid Width/Height/Depth/ArraySize for Image 1D");  	// Check that miplevels are fine  	description.MipLevels = Texture.CalculateMipLevels (description.Width' 1' description.MipLevels);  	break;  case TextureDimension.Texture2D:  case TextureDimension.TextureCube:  	if (description.Width <= 0 || description.Height <= 0 || description.Depth != 1 || description.ArraySize == 0)  		throw new InvalidOperationException ("Invalid Width/Height/Depth/ArraySize for Image 2D");  	if (description.Dimension == TextureDimension.TextureCube) {  		if ((description.ArraySize % 6) != 0)  			throw new InvalidOperationException ("TextureCube must have an arraysize = 6");  	}  	// Check that miplevels are fine  	description.MipLevels = Texture.CalculateMipLevels (description.Width' description.Height' description.MipLevels);  	break;  case TextureDimension.Texture3D:  	if (description.Width <= 0 || description.Height <= 0 || description.Depth <= 0 || description.ArraySize != 1)  		throw new InvalidOperationException ("Invalid Width/Height/Depth/ArraySize for Image 3D");  	// Check that miplevels are fine  	description.MipLevels = Texture.CalculateMipLevels (description.Width' description.Height' description.Depth' description.MipLevels);  	break;  }  
Missing Default,SharpDX.Toolkit.Graphics,Texture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,New,The following switch statement is missing a default case: switch (description.Dimension) {  case TextureDimension.Texture1D:  	return RenderTarget1D.New (graphicsDevice' description);  case TextureDimension.Texture2D:  	return RenderTarget2D.New (graphicsDevice' description);  case TextureDimension.Texture3D:  	return RenderTarget3D.New (graphicsDevice' description);  case TextureDimension.TextureCube:  	return RenderTargetCube.New (graphicsDevice' description);  }  
Missing Default,SharpDX.Toolkit.Graphics,Texture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,New,The following switch statement is missing a default case: switch (description.Dimension) {  case TextureDimension.Texture1D:  	return Texture1D.New (graphicsDevice' description);  case TextureDimension.Texture2D:  	return Texture2D.New (graphicsDevice' description);  case TextureDimension.Texture3D:  	return Texture3D.New (graphicsDevice' description);  case TextureDimension.TextureCube:  	return TextureCube.New (graphicsDevice' description);  }  
Missing Default,SharpDX.Toolkit.Graphics,Texture,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,Load,The following switch statement is missing a default case: switch (image.Description.Dimension) {  case TextureDimension.Texture1D:  	return Texture1D.New (device' image' flags' usage);  case TextureDimension.Texture2D:  	return Texture2D.New (device' image' flags' usage);  case TextureDimension.Texture3D:  	return Texture3D.New (device' image' flags' usage);  case TextureDimension.TextureCube:  	return TextureCube.New (device' image' flags' usage);  }  
Missing Default,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,ToWIC,The following switch statement is missing a default case: switch (format) {  case SharpDX.DXGI.Format.R8G8B8A8_UNorm_SRgb:  	guid = SharpDX.WIC.PixelFormat.Format32bppRGBA;  	return true;  case SharpDX.DXGI.Format.D32_Float:  	guid = SharpDX.WIC.PixelFormat.Format32bppGrayFloat;  	return true;  case SharpDX.DXGI.Format.D16_UNorm:  	guid = SharpDX.WIC.PixelFormat.Format16bppGray;  	return true;  case SharpDX.DXGI.Format.B8G8R8A8_UNorm_SRgb:  	guid = SharpDX.WIC.PixelFormat.Format32bppBGRA;  	return true;  case SharpDX.DXGI.Format.B8G8R8X8_UNorm_SRgb:  	guid = SharpDX.WIC.PixelFormat.Format32bppBGR;  	return true;  }  
Missing Default,SharpDX.Toolkit.Graphics,WICHelper,F:\newReposMay17\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,DetermineFormat,The following switch statement is missing a default case: switch (format) {  case DXGI.Format.B8G8R8A8_UNorm:  // BGRA  case DXGI.Format.B8G8R8X8_UNorm:  	// BGRX  	if ((flags & WICFlags.ForceRgb) != 0) {  		format = DXGI.Format.R8G8B8A8_UNorm;  		pixelFormatOut = WIC.PixelFormat.Format32bppRGBA;  	}  	break;  case DXGI.Format.R10G10B10_Xr_Bias_A2_UNorm:  	if ((flags & WICFlags.NoX2Bias) != 0) {  		format = DXGI.Format.R10G10B10A2_UNorm;  		pixelFormatOut = WIC.PixelFormat.Format32bppRGBA1010102;  	}  	break;  case DXGI.Format.B5G5R5A1_UNorm:  case DXGI.Format.B5G6R5_UNorm:  	if ((flags & WICFlags.No16Bpp) != 0) {  		format = DXGI.Format.R8G8B8A8_UNorm;  		pixelFormatOut = WIC.PixelFormat.Format32bppRGBA;  	}  	break;  case DXGI.Format.R1_UNorm:  	if ((flags & WICFlags.FlagsAllowMono) == 0) {  		// By default we want to promote a black & white to greyscale since R1 is not a generally supported D3D format  		format = DXGI.Format.R8_UNorm;  		pixelFormatOut = WIC.PixelFormat.Format8bppGray;  	}  	break;  }  
