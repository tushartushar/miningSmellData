Implementation smell,Namespace,Class,File,Method,Description
Long Method,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The method has 2051 lines of code.
Long Method,HelixToolkit.SharpDX.Core,CMOReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\CMOReader.cs,Load,The method has 174 lines of code.
Long Method,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,Read,The method has 109 lines of code.
Long Method,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddFace,The method has 170 lines of code.
Long Method,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,LoadMaterialLib,The method has 119 lines of code.
Long Method,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,Load,The method has 113 lines of code.
Long Method,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,Load_ascii,The method has 163 lines of code.
Long Method,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,Load_binaryBE,The method has 126 lines of code.
Long Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The method has 110 lines of code.
Long Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The method has 202 lines of code.
Long Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 109 lines of code.
Long Method,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The method has 108 lines of code.
Long Method,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The method has 131 lines of code.
Long Method,HelixToolkit.SharpDX.Core,SweepLinePolygonTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,The method has 125 lines of code.
Long Method,Core2D,BorderRenderCore2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\BorderRenderCore2D.cs,OnRender,The method has 104 lines of code.
Long Method,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessMonoMask,The method has 125 lines of code.
Long Method,Shaders,DefaultBlendStateDescriptions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\DefaultShaders\DefaultStates.cs,DefaultBlendStateDescriptions,The method has 102 lines of code.
Long Method,Utilities,TextureLoader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TextureLoader.cs,GenerateMipMaps,The method has 126 lines of code.
Long Method,Render,DefaultRenderHost,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\DefaultRenderHostPartial_Properties.cs,SeparateRenderables,The method has 122 lines of code.
Long Method,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,Arrange,The method has 131 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The method has 157 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The method has 211 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The method has 163 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The method has 206 lines of code.
Complex Method,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,OnTimeStep,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,Zoom,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.SharpDX.Core,BoundingBoxExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BoundingBoxExtensions.cs,Transform,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,ToColor4,Cyclomatic complexity of the method is 15
Complex Method,HelixToolkit.SharpDX.Core,MeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\MeshGeometry3D.cs,HitTest,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.SharpDX.Core,CMOReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\CMOReader.cs,Load,Cyclomatic complexity of the method is 15
Complex Method,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,Read,Cyclomatic complexity of the method is 21
Complex Method,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddFace,Cyclomatic complexity of the method is 28
Complex Method,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,LoadMaterialLib,Cyclomatic complexity of the method is 31
Complex Method,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,Load,Cyclomatic complexity of the method is 20
Complex Method,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,CreateMesh,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,CreateMeshGeometry3D,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,Load,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,Load_ascii,Cyclomatic complexity of the method is 22
Complex Method,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,Load_binaryBE,Cyclomatic complexity of the method is 17
Complex Method,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMaterial,Cyclomatic complexity of the method is 13
Complex Method,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateGrid,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GetLineToLineDistance,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,TreeTraversal,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,BuildSubTree,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTest,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,FindNearestPointFromPoint,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,Expand,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.SharpDX.Core,MeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTestCurrentNodeExcludeChild,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.SharpDX.Core,MeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,FindNearestPointBySphereExcludeChild,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.SharpDX.Core,LineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTestCurrentNodeExcludeChild,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.SharpDX.Core,LineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,FindNearestPointBySphereExcludeChild,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.SharpDX.Core,PointGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTestCurrentNodeExcludeChild,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.SharpDX.Core,PointGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,FindNearestPointBySphereExcludeChild,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddLoftedGeometry,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,Cyclomatic complexity of the method is 27
Complex Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangles,Cyclomatic complexity of the method is 13
Complex Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,Cyclomatic complexity of the method is 14
Complex Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,Cyclomatic complexity of the method is 15
Complex Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Append,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Simplify,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,Cyclomatic complexity of the method is 13
Complex Method,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,Cyclomatic complexity of the method is 21
Complex Method,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,Cyclomatic complexity of the method is 26
Complex Method,HelixToolkit.SharpDX.Core,SweepLinePolygonTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.SharpDX.Core,SweepLinePolygonTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,Cyclomatic complexity of the method is 17
Complex Method,HelixToolkit.SharpDX.Core,SweepLinePolygonTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,CalculateDiagonals,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.SharpDX.Core,PolygonPoint,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,PointClass,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourFacet,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.SharpDX.Core,DoubleKeyDictionary<K;T;V>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\DoubleKeyDictionary.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,Core2D,BorderRenderCore2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\BorderRenderCore2D.cs,OnRender,Cyclomatic complexity of the method is 14
Complex Method,Core,StaticGeometryBatchingBufferBase<BatchedGeometry;VertStruct>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Batching\StaticGeometryBatchingBufferBase.cs,OnSubmitGeometries,Cyclomatic complexity of the method is 8
Complex Method,Core,GeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\GeometryBufferModel.cs,UpdateBuffers,Cyclomatic complexity of the method is 9
Complex Method,Core,PostEffectMeshOutlineBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshOutlineBlurCore.cs,Render,Cyclomatic complexity of the method is 13
Complex Method,Core,PostEffectMeshXRayCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshXRay.cs,Render,Cyclomatic complexity of the method is 16
Complex Method,Core,PostEffectMeshXRayGridCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshXRayGrid.cs,Render,Cyclomatic complexity of the method is 13
Complex Method,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,Render,Cyclomatic complexity of the method is 12
Complex Method,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessMonoMask,Cyclomatic complexity of the method is 9
Complex Method,Core,DuplicationResource,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,GetFrame,Cyclomatic complexity of the method is 10
Complex Method,Shaders,ShaderDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Shaders\ShaderDescription.cs,CreateShader,Cyclomatic complexity of the method is 18
Complex Method,Shaders,ShaderPass,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Shaders\ShaderPass.cs,ShaderPass,Cyclomatic complexity of the method is 9
Complex Method,Shaders,ShaderReflector,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Shaders\ShaderReflector.cs,Parse,Cyclomatic complexity of the method is 11
Complex Method,Animations,KeyFrameUpdater,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Animations\KeyFrameUpdater.cs,Update,Cyclomatic complexity of the method is 16
Complex Method,Utilities,GroupNodeGeometryBoundOctreeManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeManager.cs,ProcessPendingItems,Cyclomatic complexity of the method is 8
Complex Method,Utilities,StaticLineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticLineGeometryOctree.cs,HitTestCurrentNodeExcludeChild,Cyclomatic complexity of the method is 9
Complex Method,Utilities,StaticLineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticLineGeometryOctree.cs,FindNearestPointBySphereExcludeChild,Cyclomatic complexity of the method is 8
Complex Method,Utilities,StaticMeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticMeshGeometryOctree.cs,HitTestCurrentNodeExcludeChild,Cyclomatic complexity of the method is 10
Complex Method,Utilities,StaticMeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticMeshGeometryOctree.cs,FindNearestPointBySphereExcludeChild,Cyclomatic complexity of the method is 8
Complex Method,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,BuildSubTree,Cyclomatic complexity of the method is 10
Complex Method,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,HitTest,Cyclomatic complexity of the method is 13
Complex Method,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,FindNearestPointBySphere,Cyclomatic complexity of the method is 8
Complex Method,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,FindNearestPointFromPoint,Cyclomatic complexity of the method is 10
Complex Method,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,GetChildIndex,Cyclomatic complexity of the method is 9
Complex Method,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,SetChildIndex,Cyclomatic complexity of the method is 9
Complex Method,Utilities,StaticPointGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticPointGeometryOctree.cs,HitTestCurrentNodeExcludeChild,Cyclomatic complexity of the method is 10
Complex Method,Utilities,StaticPointGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticPointGeometryOctree.cs,FindNearestPointBySphereExcludeChild,Cyclomatic complexity of the method is 8
Complex Method,Utilities,ScreenCapture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ScreenCapture.cs,GetPfGuid,Cyclomatic complexity of the method is 11
Complex Method,Utilities,TokenizerHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TokenizerHelper.cs,NextToken,Cyclomatic complexity of the method is 11
Complex Method,Utilities,TokenizerHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TokenizerHelper.cs,ScanToNextToken,Cyclomatic complexity of the method is 8
Complex Method,Model,GenericMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\GenericMaterialVariable.cs,OnInitialPropertyBindings,Cyclomatic complexity of the method is 8
Complex Method,Model,Entry,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Metadata.cs,DataAs,Cyclomatic complexity of the method is 8
Complex Method,Model.Scene,ParticleStormNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ParticleStormNode.cs,UpdateBounds,Cyclomatic complexity of the method is 8
Complex Method,Model.Scene,SortingGroupNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\SortingGroupNode.cs,Sort,Cyclomatic complexity of the method is 11
Complex Method,Model.Scene,SortingGroupNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\SortingGroupNode.cs,GetDistance,Cyclomatic complexity of the method is 10
Complex Method,Render,DefaultRenderHost,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\DefaultRenderHostPartial_Properties.cs,SeparateRenderables,Cyclomatic complexity of the method is 24
Complex Method,Render,TexturePool,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\ColorBufferPool.cs,Get,Cyclomatic complexity of the method is 8
Complex Method,Model.Scene2D,ContentNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\ContentNode2D.cs,MeasureOverride,Cyclomatic complexity of the method is 9
Complex Method,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,Measure,Cyclomatic complexity of the method is 9
Complex Method,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,Arrange,Cyclomatic complexity of the method is 22
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,GetDXGIFormat,Cyclomatic complexity of the method is 12
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,Cyclomatic complexity of the method is 30
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,Cyclomatic complexity of the method is 43
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,Cyclomatic complexity of the method is 21
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,Cyclomatic complexity of the method is 19
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,Cyclomatic complexity of the method is 27
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,Cyclomatic complexity of the method is 10
Complex Method,SharpDX.Toolkit.Graphics,DepthStencilBuffer,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,GetDepthStencilView,Cyclomatic complexity of the method is 10
Complex Method,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,Cyclomatic complexity of the method is 10
Complex Method,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,CalculateImageArray,Cyclomatic complexity of the method is 8
Complex Method,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Save,Cyclomatic complexity of the method is 10
Complex Method,SharpDX.Toolkit.Graphics,Texture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,New,Cyclomatic complexity of the method is 10
Complex Method,SharpDX.Toolkit.Graphics,Texture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,OnPropertyChanged,Cyclomatic complexity of the method is 12
Complex Method,SharpDX.Toolkit.Graphics,WICHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,DetermineFormat,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf,CuttingEarsTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,Cyclomatic complexity of the method is 12
Long Parameter List,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,LookAt,The method has 5 parameters. Parameters: camera' target' newLookDirection' newUpDirection' animationTime
Long Parameter List,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,ZoomExtents,The method has 5 parameters. Parameters: camera' viewport' center' radius' animationTime
Long Parameter List,HelixToolkit.SharpDX.Core,BitmapExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BitmapExtensions.cs,ToBitmapStream,The method has 12 parameters. Parameters: text' fontSize' foreground' background' fontFamily' fontWeight' fontStyle' padding' width' height' predefinedSize' deviceResources
Long Parameter List,HelixToolkit.SharpDX.Core,BitmapExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BitmapExtensions.cs,GetTextLayoutMetrices,The method has 8 parameters. Parameters: text' deviceResources' fontSize' fontFamily' fontWeight' fontStyle' maxWidth' maxHeight
Long Parameter List,HelixToolkit.SharpDX.Core,BitmapExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BitmapExtensions.cs,CreateBitmapStream,The method has 5 parameters. Parameters: deviceResources' width' height' imageType' drawingAction
Long Parameter List,HelixToolkit.SharpDX.Core,BitmapExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BitmapExtensions.cs,CreateSolidColorBitmapStream,The method has 5 parameters. Parameters: deviceResources' width' height' imageType' color
Long Parameter List,HelixToolkit.SharpDX.Core,BitmapExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BitmapExtensions.cs,CreateLinearGradientBitmapStream,The method has 9 parameters. Parameters: deviceResources' width' height' imageType' startPoint' endPoint' gradients' extendMode' gamma
Long Parameter List,HelixToolkit.SharpDX.Core,BitmapExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BitmapExtensions.cs,CreateRadiusGradientBitmapStream,The method has 11 parameters. Parameters: deviceResources' width' height' imageType' center' gradientOriginOffset' radiusX' radiusY' gradients' extendMode' gamma
Long Parameter List,HelixToolkit.SharpDX.Core,BitmapExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BitmapExtensions.cs,CreateViewBoxTexture,The method has 24 parameters. Parameters: deviceResources' front' back' left' right' top' down' frontFaceColor' backFaceColor' leftFaceColor' rightFaceColor' topFaceColor' bottomFaceColor' frontTextColor' backTextColor' leftTextColor' rightTextColor' topTextColor' bottomTextColor' fontFamily' fontWeight' fontStyle' fontSize' faceSize
Long Parameter List,HelixToolkit.SharpDX.Core,BitmapExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BitmapExtensions.cs,ToBillboardImage3D,The method has 5 parameters. Parameters: items' effectsManager' maxWidth' maxHeight' squareImage
Long Parameter List,HelixToolkit.SharpDX.Core,IViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\IViewportExtensions.cs,FindNearest,The method has 5 parameters. Parameters: viewport' position' point' normal' model
Long Parameter List,HelixToolkit.SharpDX.Core,IViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\IViewportExtensions.cs,UnProjectOnPlane,The method has 5 parameters. Parameters: viewport' p' position' normal' intersection
Long Parameter List,HelixToolkit.SharpDX.Core,RayExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\RayExtensions.cs,UnProject,The method has 7 parameters. Parameters: point2d' view' projection' nearPlane' w' h' isPerpective
Long Parameter List,HelixToolkit.SharpDX.Core,IOctreeManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Interface\IOctreeManager.cs,HitTest,The method has 5 parameters. Parameters: context' model' modelMatrix' rayWS' hits
Long Parameter List,HelixToolkit.SharpDX.Core,BillboardImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardImage3D.cs,HitTest,The method has 6 parameters. Parameters: context' modelMatrix' rayWS' hits' originalSource' fixedSize
Long Parameter List,HelixToolkit.SharpDX.Core,BoneSkinnedMeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BoneSkinnedMeshGeometry3D.cs,HitTestWithSkinnedVertices,The method has 6 parameters. Parameters: context' skinnedVertices' modelMatrix' rayWS' hits' originalSource
Long Parameter List,HelixToolkit.SharpDX.Core,BillboardBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardBase.cs,HitTest,The method has 6 parameters. Parameters: context' modelMatrix' rayWS' hits' originalSource' fixedSize
Long Parameter List,HelixToolkit.SharpDX.Core,BillboardBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardBase.cs,HitTestFixedSize,The method has 6 parameters. Parameters: context' modelMatrix' rayWS' hits' originalSource' count
Long Parameter List,HelixToolkit.SharpDX.Core,BillboardBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardBase.cs,HitTestNonFixedSize,The method has 6 parameters. Parameters: context' modelMatrix' rayWS' hits' originalSource' count
Long Parameter List,HelixToolkit.SharpDX.Core,BillboardBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardBase.cs,GetHitTestQuad,The method has 8 parameters. Parameters: center' TL' TR' BL' BR' viewMatrix' viewMatrixInv' scale
Long Parameter List,HelixToolkit.SharpDX.Core,BillboardBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardBase.cs,GetScreenQuad,The method has 7 parameters. Parameters: center' TL' TR' BL' BR' screenViewProjection' scale
Long Parameter List,HelixToolkit.SharpDX.Core,BillboardSingleImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleImage3D.cs,HitTest,The method has 6 parameters. Parameters: context' modelMatrix' rayWS' hits' originalSource' fixedSize
Long Parameter List,HelixToolkit.SharpDX.Core,BillboardSingleText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The method has 5 parameters. Parameters: text' origin' w' h' info
Long Parameter List,HelixToolkit.SharpDX.Core,BillboardSingleText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleText3D.cs,HitTest,The method has 6 parameters. Parameters: context' modelMatrix' rayWS' hits' originalSource' fixedSize
Long Parameter List,HelixToolkit.SharpDX.Core,BillboardText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardText3D.cs,DrawCharacter,The method has 6 parameters. Parameters: character' origin' w' h' kerning' info
Long Parameter List,HelixToolkit.SharpDX.Core,BillboardText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardText3D.cs,HitTest,The method has 6 parameters. Parameters: context' modelMatrix' rayWS' hits' originalSource' fixedSize
Long Parameter List,HelixToolkit.SharpDX.Core,LineGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\LineGeometry3D.cs,HitTest,The method has 6 parameters. Parameters: context' modelMatrix' rayWS' hits' originalSource' hitTestThickness
Long Parameter List,HelixToolkit.SharpDX.Core,MeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\MeshGeometry3D.cs,HitTest,The method has 5 parameters. Parameters: context' modelMatrix' rayWS' hits' originalSource
Long Parameter List,HelixToolkit.SharpDX.Core,PointGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\PointGeometry3D.cs,HitTest,The method has 6 parameters. Parameters: context' modelMatrix' rayWS' hits' originalSource' hitThickness
Long Parameter List,HelixToolkit.SharpDX.Core,UVTransform,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Layouts.cs,UVTransform,The method has 5 parameters. Parameters: rotation' scalingX' scalingY' translationX' translationY
Long Parameter List,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,CreateMesh,The method has 8 parameters. Parameters: positions' textureCoordinates' triangleIndices' transforms' normals' tangents' bitangents' material
Long Parameter List,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddGrid,The method has 5 parameters. Parameters: plane' columns' rows' width' height
Long Parameter List,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateGrid,The method has 5 parameters. Parameters: plane' min0' max0' min1' max1
Long Parameter List,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GetPointToLineDistance2D,The method has 5 parameters. Parameters: pt' p0' p1' closest' t
Long Parameter List,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GetRayToLineDistance,The method has 7 parameters. Parameters: ray' t0' t1' sp' tp' sc' tc
Long Parameter List,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GetLineToLineDistance,The method has 9 parameters. Parameters: s0' s1' t0' t1' sp' tp' sc' tc' sIsRay
Long Parameter List,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,DynamicOctreeBase,The method has 5 parameters. Parameters: bound' objList' parent' parameter' stackCache
Long Parameter List,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,TreeTraversal,The method has 6 parameters. Parameters: root' stack' criteria' process' breakCriteria' useParallel
Long Parameter List,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTest,The method has 6 parameters. Parameters: context' model' geometry' modelMatrix' rayWS' hits
Long Parameter List,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTest,The method has 7 parameters. Parameters: context' model' geometry' modelMatrix' rayWS' hits' hitThickness
Long Parameter List,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 9 parameters. Parameters: context' model' geometry' modelMatrix' rayWS' rayModel' hits' isIntersect' hitThickness
Long Parameter List,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,PushExistingToChild,The method has 5 parameters. Parameters: node' index' isContains' createNodeFunc' octant
Long Parameter List,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,FindSmallestNodeContainsBoundingBox,The method has 5 parameters. Parameters: bound' item' isContains' root' stackCache
Long Parameter List,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,FindChildByItemBound,The method has 6 parameters. Parameters: item' bound' isContains' root' stackCache' index
Long Parameter List,HelixToolkit.SharpDX.Core,MeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,MeshGeometryOctree,The method has 7 parameters. Parameters: positions' indices' bound' triIndex' parent' paramter' stackCache
Long Parameter List,HelixToolkit.SharpDX.Core,MeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,MeshGeometryOctree,The method has 5 parameters. Parameters: bound' list' parent' paramter' stackCache
Long Parameter List,HelixToolkit.SharpDX.Core,MeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 9 parameters. Parameters: context' model' geometry' modelMatrix' rayWS' rayModel' hits' isIntersect' hitThickness
Long Parameter List,HelixToolkit.SharpDX.Core,LineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,LineGeometryOctree,The method has 7 parameters. Parameters: positions' indices' bound' triIndex' parent' paramter' stackCache
Long Parameter List,HelixToolkit.SharpDX.Core,LineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,LineGeometryOctree,The method has 5 parameters. Parameters: bound' list' parent' paramter' stackCache
Long Parameter List,HelixToolkit.SharpDX.Core,LineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 9 parameters. Parameters: context' model' geometry' modelMatrix' rayWS' rayModel' hits' isIntersect' hitThickness
Long Parameter List,HelixToolkit.SharpDX.Core,PointGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,PointGeometryOctree,The method has 6 parameters. Parameters: bound' positions' list' parent' paramter' stackCache
Long Parameter List,HelixToolkit.SharpDX.Core,PointGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 9 parameters. Parameters: context' model' geometry' modelMatrix' rayWS' rayModel' hits' isIntersect' hitThickness
Long Parameter List,HelixToolkit.SharpDX.Core,InstancingModel3DOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,InstancingModel3DOctree,The method has 6 parameters. Parameters: bound' instanceMatrix' objects' parent' parameter' stackCache
Long Parameter List,HelixToolkit.SharpDX.Core,InstancingModel3DOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTestCurrentNodeExcludeChild,The method has 9 parameters. Parameters: context' model' geometry' modelMatrix' rayWS' rayModel' hits' isIntersect' hitThickness
Long Parameter List,HelixToolkit.SharpDX.Core,IOctreeBasic,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeInterfaces.cs,HitTest,The method has 6 parameters. Parameters: context' model' geometry' modelMatrix' rayWS' hits
Long Parameter List,HelixToolkit.SharpDX.Core,IOctreeBasic,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeInterfaces.cs,HitTest,The method has 7 parameters. Parameters: context' model' geometry' modelMatrix' rayWS' hits' hitThickness
Long Parameter List,HelixToolkit.SharpDX.Core,IDynamicOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeInterfaces.cs,HitTestCurrentNodeExcludeChild,The method has 9 parameters. Parameters: context' model' geometry' modelMatrix' rayWS' rayModel' hits' isIntersect' hitThickness
Long Parameter List,HelixToolkit.SharpDX.Core,TreeTraverser,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TreeTraverser.cs,PreorderDFT,The method has 5 parameters. Parameters: nodes' context' condition' results' stackCache
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The method has 6 parameters. Parameters: positions' normals' textureCoordinates' triangleIndices' tangents' bitangents
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The method has 6 parameters. Parameters: positions' normals' textureCoordinates' indices' tangents' bitangents
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddArrow,The method has 5 parameters. Parameters: point1' point2' diameter' headLength' thetaDiv
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBox,The method has 5 parameters. Parameters: center' xlength' ylength' zlength' faces
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBox,The method has 7 parameters. Parameters: center' x' y' xlength' ylength' zlength' faces
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCone,The method has 8 parameters. Parameters: origin' direction' baseRadius' topRadius' height' baseCap' topCap' thetaDiv
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCone,The method has 5 parameters. Parameters: origin' apex' baseRadius' baseCap' thetaDiv
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The method has 6 parameters. Parameters: center' normal' up' dist' width' height
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The method has 6 parameters. Parameters: p1' p2' radius' thetaDiv' cap1' cap2
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The method has 6 parameters. Parameters: center' radiusx' radiusy' radiusz' thetaDiv' phiDiv
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The method has 5 parameters. Parameters: center' forward' up' sideLength' height
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The method has 5 parameters. Parameters: point1' point2' innerDiameter' diameter' thetaDiv
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The method has 6 parameters. Parameters: center' forward' up' sideLength' height' closeBase
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The method has 8 parameters. Parameters: p0' p1' p2' p3' uv0' uv1' uv2' uv3
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The method has 8 parameters. Parameters: plane' columns' rows' width' height' flipTriangles' flipTexCoordsUAxis' flipTexCoordsVAxis
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndices,The method has 5 parameters. Parameters: index0' rows' columns' rowsClosed' columnsClosed
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The method has 5 parameters. Parameters: points' textureValues' origin' direction' thetaDiv
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The method has 6 parameters. Parameters: origin' axis' section' sectionIndices' thetaDiv' textureValues
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The method has 6 parameters. Parameters: p0' p1' p2' uv0' uv1' uv2
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 7 parameters. Parameters: path' values' diameters' thetaDiv' isTubeClosed' frontCap' backCap
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 6 parameters. Parameters: path' diameter' thetaDiv' isTubeClosed' frontCap' backCap
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 8 parameters. Parameters: path' values' diameters' section' isTubeClosed' isSectionClosed' frontCap' backCap
Long Parameter List,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 10 parameters. Parameters: path' angles' values' diameters' section' sectionXAxis' isTubeClosed' isSectionClosed' frontCap' backCap
Long Parameter List,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,The method has 8 parameters. Parameters: vertices' triangles' texture' normals' verticesOut' trianglesOut' textureOut' normalOut
Long Parameter List,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The method has 6 parameters. Parameters: p' i0' i1' v0' v1' deleted
Long Parameter List,HelixToolkit.SharpDX.Core,SymmetricMatrix,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,SymmetricMatrix,The method has 10 parameters. Parameters: m11' m12' m13' m14' m22' m23' m24' m33' m34' m44
Long Parameter List,HelixToolkit.SharpDX.Core,SymmetricMatrix,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,det,The method has 9 parameters. Parameters: a11' a12' a13' a21' a22' a23' a31' a32' a33
Long Parameter List,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourFacet,The method has 7 parameters. Parameters: index0' index1' index2' newPositions' newNormals' newTextureCoordinates' triangleIndices
Long Parameter List,Core2D,ArcSegment,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\Models\ArcSegment.cs,ArcSegment,The method has 5 parameters. Parameters: point' size' rotation' sweepDirection' arcSize
Long Parameter List,Core,BillboardBufferModel<VertexStruct>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\BillboardBufferModel.cs,OnCreateVertexBuffer,The method has 5 parameters. Parameters: context' buffer' bufferIndex' geometry' deviceResources
Long Parameter List,Core,GeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\GeometryBufferModel.cs,OnCreateVertexBuffer,The method has 5 parameters. Parameters: context' buffer' bufferIndex' geometry' deviceResources
Long Parameter List,Core,DefaultLineGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\LineBufferModel.cs,OnCreateVertexBuffer,The method has 5 parameters. Parameters: context' buffer' bufferIndex' geometry' deviceResources
Long Parameter List,Core,DefaultMeshGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\MeshBufferModel.cs,OnCreateVertexBuffer,The method has 5 parameters. Parameters: context' buffer' bufferIndex' geometry' deviceResources
Long Parameter List,Core,DefaultPointGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\PointBufferModel.cs,OnCreateVertexBuffer,The method has 5 parameters. Parameters: context' buffer' bufferIndex' geometry' deviceResources
Long Parameter List,Core,PostEffectBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBlurCore.cs,PostEffectBlurCore,The method has 6 parameters. Parameters: blurVerticalPass' blurHorizontalPass' textureSlot' samplerSlot' sampler' manager
Long Parameter List,Core,PostEffectBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBlurCore.cs,Run,The method has 7 parameters. Parameters: context' deviceContext' source' sourceWidth' sourceHeight' depth' modelStruct
Long Parameter List,Core,PostEffectBloomCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBoomCore.cs,BindTarget,The method has 6 parameters. Parameters: dsv' targetView' context' width' height' clear
Long Parameter List,Core,PostEffectMeshOutlineBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshOutlineBlurCore.cs,DrawOutline,The method has 6 parameters. Parameters: context' deviceContext' depthStencilBuffer' source' width' height
Long Parameter List,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,GetCursorVertexBound,The method has 5 parameters. Parameters: viewportWidth' viewportHeight' deskWidth' deskHeight' rect
Long Parameter List,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessMonoMask,The method has 7 parameters. Parameters: context' isMono' info' width' height' left' top
Long Parameter List,Core,DuplicationResource,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,GetFrame,The method has 5 parameters. Parameters: outputIndex' data' pointer' timeOut' accessLost
Long Parameter List,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,CreateProjectionMatrix,The method has 8 parameters. Parameters: isPerspective' isRightHand' scale' fov' near' far' w' h
Long Parameter List,Core,SkyBoxBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SkyBoxRenderCore.cs,OnCreateVertexBuffer,The method has 5 parameters. Parameters: context' buffer' bufferIndex' geometry' deviceResources
Long Parameter List,Core,SkyDomeBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SkyDomeRenderCore.cs,OnCreateVertexBuffer,The method has 5 parameters. Parameters: context' buffer' bufferIndex' geometry' deviceResources
Long Parameter List,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,BindTarget,The method has 5 parameters. Parameters: dsv' targetView' context' width' height
Long Parameter List,Core,VolumeCubeBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,OnCreateVertexBuffer,The method has 5 parameters. Parameters: context' buffer' bufferIndex' geometry' deviceResources
Long Parameter List,Shaders,GeometryShader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Shaders\GeometryShader.cs,GeometryShader,The method has 6 parameters. Parameters: device' name' byteCode' streamOutputElements' bufferStrides' rasterizedStream
Long Parameter List,Shaders,ShaderDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Shaders\ShaderDescription.cs,ShaderDescription,The method has 7 parameters. Parameters: name' type' featureLevel' byteCode' constantBuffers' textures' samplers
Long Parameter List,Shaders,ShaderDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Shaders\ShaderDescription.cs,ShaderDescription,The method has 5 parameters. Parameters: name' type' reflector' byteCodeName' byteCodeReader
Long Parameter List,Utilities,BitmapProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\BitmapProxy.cs,CreateDescription,The method has 6 parameters. Parameters: dpiX' dpiY' format' alphaMode' options' colorContext
Long Parameter List,Utilities,BitmapProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\BitmapProxy.cs,NewDescription,The method has 5 parameters. Parameters: dpiX' dpiY' format' bitmapOptions' colorContext
Long Parameter List,Utilities,ConstantBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ConstantBufferProxy.cs,ConstantBufferProxy,The method has 7 parameters. Parameters: name' structSize' bindFlags' cpuAccessFlags' optionFlags' usage' strideSize
Long Parameter List,Utilities,IElementsBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ElementsBufferProxy.cs,UploadDataToBuffer,The method has 5 parameters. Parameters: context' data' count' offset' minBufferCount
Long Parameter List,Utilities,IElementsBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ElementsBufferProxy.cs,UploadDataToBuffer,The method has 5 parameters. Parameters: context' data' countByBytes' offsetByBytes' minBufferCountByBytes
Long Parameter List,Utilities,ImmutableBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ElementsBufferProxy.cs,ImmutableBufferProxy,The method has 5 parameters. Parameters: structureSize' bindFlags' cpuAccess' optionFlags' usage
Long Parameter List,Utilities,ImmutableBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ElementsBufferProxy.cs,UploadDataToBuffer,The method has 5 parameters. Parameters: context' data' count' offset' minBufferCount
Long Parameter List,Utilities,ImmutableBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ElementsBufferProxy.cs,UploadDataToBuffer,The method has 5 parameters. Parameters: context' data' countByBytes' offsetByBytes' minBufferCountByBytes
Long Parameter List,Utilities,DynamicBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ElementsBufferProxy.cs,DynamicBufferProxy,The method has 5 parameters. Parameters: structureSize' bindFlags' canOverWrite' optionFlags' lazyResize
Long Parameter List,Utilities,DynamicBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ElementsBufferProxy.cs,DynamicBufferProxy,The method has 6 parameters. Parameters: structureSize' bindFlags' canOverWrite' cpuAccess' optionFlags' lazyResize
Long Parameter List,Utilities,DynamicBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ElementsBufferProxy.cs,UploadDataToBuffer,The method has 5 parameters. Parameters: context' data' count' offset' minBufferCount
Long Parameter List,Utilities,DynamicBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ElementsBufferProxy.cs,UploadDataToBuffer,The method has 5 parameters. Parameters: context' data' byteCount' byteOffset' minBufferSizeByBytes
Long Parameter List,Utilities,BoundableNodeOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\RenderableBoundingOctree.cs,BoundableNodeOctree,The method has 5 parameters. Parameters: bound' objList' parent' paramter' queueCache
Long Parameter List,Utilities,BoundableNodeOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\RenderableBoundingOctree.cs,HitTestCurrentNodeExcludeChild,The method has 9 parameters. Parameters: context' model' geometry' modelMatrix' rayWS' rayModel' hits' isIntersect' hitThickness
Long Parameter List,Utilities,OctreeManagerBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeManager.cs,HitTest,The method has 5 parameters. Parameters: context' model' modelMatrix' rayWS' hits
Long Parameter List,Utilities,GroupNodeGeometryBoundOctreeManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeManager.cs,HitTest,The method has 5 parameters. Parameters: context' model' modelMatrix' rayWS' hits
Long Parameter List,Utilities,StaticInstancingModelOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticInstancingOctree.cs,HitTestCurrentNodeExcludeChild,The method has 10 parameters. Parameters: octant' context' model' geometry' modelMatrix' rayWS' rayModel' hits' isIntersect' hitThickness
Long Parameter List,Utilities,StaticInstancingModelOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticInstancingOctree.cs,FindNearestPointBySphereExcludeChild,The method has 5 parameters. Parameters: octant' context' sphere' points' isIntersect
Long Parameter List,Utilities,StaticBatchedGeometryBoundsOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticInstancingOctree.cs,HitTestCurrentNodeExcludeChild,The method has 10 parameters. Parameters: octant' context' model' geometry' modelMatrix' rayWS' rayModel' hits' isIntersect' hitThickness
Long Parameter List,Utilities,StaticBatchedGeometryBoundsOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticInstancingOctree.cs,FindNearestPointBySphereExcludeChild,The method has 5 parameters. Parameters: octant' context' sphere' points' isIntersect
Long Parameter List,Utilities,StaticLineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticLineGeometryOctree.cs,HitTestCurrentNodeExcludeChild,The method has 10 parameters. Parameters: octant' context' model' geometry' modelMatrix' rayWS' rayModel' hits' isIntersect' hitThickness
Long Parameter List,Utilities,StaticLineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticLineGeometryOctree.cs,FindNearestPointBySphereExcludeChild,The method has 5 parameters. Parameters: octant' context' sphere' result' isIntersect
Long Parameter List,Utilities,StaticMeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticMeshGeometryOctree.cs,HitTestCurrentNodeExcludeChild,The method has 10 parameters. Parameters: octant' context' model' geometry' modelMatrix' rayWS' rayModel' hits' isIntersect' hitThickness
Long Parameter List,Utilities,StaticMeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticMeshGeometryOctree.cs,FindNearestPointBySphereExcludeChild,The method has 5 parameters. Parameters: octant' context' sphere' result' isIntersect
Long Parameter List,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,HitTest,The method has 6 parameters. Parameters: context' model' geometry' modelMatrix' rayWS' hits
Long Parameter List,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,HitTest,The method has 7 parameters. Parameters: context' model' geometry' modelMatrix' rayWS' hits' hitThickness
Long Parameter List,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,FindNearestPointBySphereExcludeChild,The method has 5 parameters. Parameters: octant' context' sphere' points' isIntersect
Long Parameter List,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,HitTestCurrentNodeExcludeChild,The method has 10 parameters. Parameters: octant' context' model' geometry' modelMatrix' rayWS' rayModel' hits' isIntersect' hitThickness
Long Parameter List,Utilities,StaticPointGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticPointGeometryOctree.cs,HitTest,The method has 7 parameters. Parameters: context' model' geometry' modelMatrix' rayWS' hits' hitThickness
Long Parameter List,Utilities,StaticPointGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticPointGeometryOctree.cs,HitTestCurrentNodeExcludeChild,The method has 10 parameters. Parameters: octant' context' model' geometry' modelMatrix' rayWS' rayModel' hits' isIntersect' hitThickness
Long Parameter List,Utilities,StaticPointGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticPointGeometryOctree.cs,FindNearestPointBySphereExcludeChild,The method has 5 parameters. Parameters: octant' context' sphere' result' isIntersect
Long Parameter List,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateView,The method has 5 parameters. Parameters: array' length' format' createSRV' generateMipMaps
Long Parameter List,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateView,The method has 6 parameters. Parameters: array' width' height' format' createSRV' generateMipMaps
Long Parameter List,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateView,The method has 6 parameters. Parameters: dataPtr' width' height' format' createSRV' generateMipMaps
Long Parameter List,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateView,The method has 7 parameters. Parameters: pixels' width' height' depth' format' createSRV' generateMipMaps
Long Parameter List,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateView,The method has 7 parameters. Parameters: dataPtr' width' height' depth' format' createSRV' generateMipMaps
Long Parameter List,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateViewFromColorArray,The method has 5 parameters. Parameters: array' width' height' createSRV' generateMipMaps
Long Parameter List,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateView,The method has 5 parameters. Parameters: device' array' format' createSRV' generateMipMaps
Long Parameter List,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateView,The method has 7 parameters. Parameters: device' array' width' height' format' createSRV' generateMipMaps
Long Parameter List,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateView,The method has 7 parameters. Parameters: device' dataPtr' width' height' format' createSRV' generateMipMaps
Long Parameter List,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateViewFromColorArray,The method has 6 parameters. Parameters: device' array' width' height' createSRV' generateMipMaps
Long Parameter List,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateViewFromPixelData,The method has 8 parameters. Parameters: device' pixels' width' height' depth' format' createSRV' generateMipMaps
Long Parameter List,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateViewFromPixelData,The method has 8 parameters. Parameters: device' pixels' width' height' depth' format' createSRV' generateMipMaps
Long Parameter List,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateViewFromPixelData,The method has 8 parameters. Parameters: device' pixels' width' height' depth' format' createSRV' generateMipMaps
Long Parameter List,Utilities,ScreenCapture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ScreenCapture.cs,CopyTextureToWICStream,The method has 5 parameters. Parameters: deviceResource' staging' stream' pfGuid' containerFormat
Long Parameter List,Utilities,VolumeDataHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\VolumeDataHelper.cs,GenerateGradients,The method has 5 parameters. Parameters: data' width' height' depth' sampleSize
Long Parameter List,Utilities,VolumeDataHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\VolumeDataHelper.cs,FilterNxNxN,The method has 5 parameters. Parameters: data' width' height' depth' n
Long Parameter List,Utilities,VolumeDataHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\VolumeDataHelper.cs,SampleNxNxN,The method has 8 parameters. Parameters: data' width' height' depth' x' y' z' n
Long Parameter List,Utilities,VolumeDataHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\VolumeDataHelper.cs,IsInBounds,The method has 6 parameters. Parameters: width' height' depth' x' y' z
Long Parameter List,Utilities,VolumeDataHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\VolumeDataHelper.cs,SampleGradients,The method has 7 parameters. Parameters: data' width' height' depth' x' y' z
Long Parameter List,Utilities,VolumeDataHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\VolumeDataHelper.cs,SampleVolume,The method has 7 parameters. Parameters: data' width' height' depth' x' y' z
Long Parameter List,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,RotateTrackball,The method has 12 parameters. Parameters: cameraMode' p1' p2' rotateAround' sensitivity' viewportWidth' viewportHeight' camera' invertFactor' newPosition' newLookDirection' newUpDirection
Long Parameter List,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,RotateTurnball,The method has 12 parameters. Parameters: cameraMode' p1' p2' rotateAround' sensitivity' viewportWidth' viewportHeight' camera' invertFactor' newPosition' newLookDirection' newUpDirection
Long Parameter List,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,InitTurnballRotationAxes,The method has 6 parameters. Parameters: p1' viewportWidth' viewportHeight' camera' rotationAxisX' rotationAxisY
Long Parameter List,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,RotateTurntable,The method has 12 parameters. Parameters: cameraMode' delta' rotateAround' sensitivity' viewportWidth' viewportHeight' camera' invertFactor' modelUpDirection' newPosition' newLookDirection' newUpDirection
Long Parameter List,Model,BillboardMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\BillboardMaterialVariable.cs,BillboardMaterialVariable,The method has 5 parameters. Parameters: manager' technique' materialCore' billboardPassName' billboardOITPassName
Long Parameter List,Model,DiffuseMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\DiffuseMaterialVariable.cs,DiffuseMaterialVariables,The method has 9 parameters. Parameters: manager' technique' materialCore' materialPassName' wireframePassName' materialOITPassName' wireframeOITPassName' shadowPassName' depthPassName
Long Parameter List,Model,GenericMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\GenericMaterialVariable.cs,GenericMaterialVariable,The method has 8 parameters. Parameters: manager' technique' materialCore' constantBufferDescription' materialShaderPassName' shadowShaderPassName' wireframePassName' depthPassName
Long Parameter List,Model,GenericMeshMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\GenericMaterialVariable.cs,GenericMeshMaterialVariable,The method has 7 parameters. Parameters: manager' technique' materialCore' constantBufferDescription' materialShaderPassName' shadowShaderPassName' wireframePassName
Long Parameter List,Model,GenericPointMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\GenericMaterialVariable.cs,GenericPointMaterialVariable,The method has 6 parameters. Parameters: manager' technique' materialCore' constantBufferDescription' materialShaderPassName' shadowShaderPassName
Long Parameter List,Model,LineArrowMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\LineArrowMaterialVariable.cs,LineArrowMaterialVariable,The method has 6 parameters. Parameters: manager' technique' materialCore' linePassName' shadowPassName' depthPassName
Long Parameter List,Model,LineMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\LineMaterialVariable.cs,LineMaterialVariable,The method has 6 parameters. Parameters: manager' technique' materialCore' linePassName' shadowPassName' depthPassName
Long Parameter List,Model,PassOnlyMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PassOnlyMaterialVariable.cs,PassOnlyMaterialVariable,The method has 5 parameters. Parameters: passName' technique' shadowPassName' wireframePassName' depthPassName
Long Parameter List,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,PBRMaterialVariable,The method has 11 parameters. Parameters: manager' technique' core' materialPassName' wireframePassName' materialOITPassName' wireframeOITPassName' shadowPassName' tessellationPassName' tessellationOITPassName' depthPassName
Long Parameter List,Model,PointMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PointMaterialVariable.cs,PointMaterialVariable,The method has 6 parameters. Parameters: manager' technique' materialCore' pointPassName' shadowPassName' depthPassName
Long Parameter List,Model,VolumeTextureParams,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\VolumeTextureMaterial.cs,VolumeTextureParams,The method has 5 parameters. Parameters: data' width' height' depth' format
Long Parameter List,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,PhongMaterialVariables,The method has 11 parameters. Parameters: manager' technique' materialCore' materialPassName' wireframePassName' materialOITPassName' wireframeOITPassName' shadowPassName' tessellationPassName' tessellationOITPassName' depthPassName
Long Parameter List,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The method has 5 parameters. Parameters: mesh' which' color' label' labelColor
Long Parameter List,Model.Scene,SceneNodeMouseDownArgs,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\Abstract\SceneNode.cs,SceneNodeMouseDownArgs,The method has 5 parameters. Parameters: viewport' pos' node' hit' originalInputEventArgs
Long Parameter List,Model.Scene,SceneNodeMouseMoveArgs,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\Abstract\SceneNode.cs,SceneNodeMouseMoveArgs,The method has 5 parameters. Parameters: viewport' pos' node' hit' originalInputEventArgs
Long Parameter List,Model.Scene,SceneNodeMouseUpArgs,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\Abstract\SceneNode.cs,SceneNodeMouseUpArgs,The method has 5 parameters. Parameters: viewport' pos' node' hit' originalInputEventArgs
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,DrawIndexedInstanced,The method has 5 parameters. Parameters: indexCountPerInstance' instanceCount' startIndexLocation' baseVertexLocation' startInstanceLocation
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,MapSubresource,The method has 6 parameters. Parameters: resource' mipSlice' arraySlice' mode' flags' stream
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,MapSubresource,The method has 6 parameters. Parameters: resource' mipSlice' arraySlice' mode' flags' stream
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,MapSubresource,The method has 6 parameters. Parameters: resource' mipSlice' arraySlice' mode' flags' stream
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,MapSubresource,The method has 6 parameters. Parameters: resource' mipSlice' arraySlice' mode' flags' mipSizeOut
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,MapSubresource,The method has 5 parameters. Parameters: resource' subresource' mode' flags' stream
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,ResolveSubresource,The method has 5 parameters. Parameters: source' sourceSubresource' destination' destinationSubresource' format
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,UpdateSubresource,The method has 6 parameters. Parameters: dstResourceRef' dstSubresource' dstBoxRef' srcDataRef' srcRowPitch' srcDepthPitch
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,UpdateSubresource,The method has 6 parameters. Parameters: data' resource' subresource' rowPitch' depthPitch' region
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,UpdateSubresource,The method has 6 parameters. Parameters: data' resource' subresource' rowPitch' depthPitch' region
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,UpdateSubresourceSafe,The method has 5 parameters. Parameters: source' resource' srcBytesPerElement' subresource' isCompressedResource
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,UpdateSubresourceSafe,The method has 6 parameters. Parameters: source' resource' srcBytesPerElement' subresource' region' isCompressedResource
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,UpdateSubresourceSafe,The method has 7 parameters. Parameters: data' resource' srcBytesPerElement' subresource' rowPitch' depthPitch' isCompressedResource
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,UpdateSubresourceSafe,The method has 7 parameters. Parameters: data' resource' srcBytesPerElement' subresource' rowPitch' depthPitch' isCompressedResource
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,CopySubresourceRegion,The method has 8 parameters. Parameters: source' sourceSubresource' sourceRegion' destination' destinationSubResource' dstX' dstY' dstZ
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,SetRenderTarget,The method has 10 parameters. Parameters: dsv' rtv' width' height' clearRTV' color' clearDSV' flags' depth' stencil
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,SetRenderTarget,The method has 5 parameters. Parameters: rtv' width' height' clearRTV' color
Long Parameter List,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,SetViewport,The method has 6 parameters. Parameters: x' y' width' height' minZ' maxZ
Long Parameter List,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,OnCreateRenderTargetAndDepthBuffers,The method has 5 parameters. Parameters: width' height' createDepthStencilBuffer' colorBuffer' depthStencilBuffer
Long Parameter List,Render,IRenderTaskScheduler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\Renderer\RenderTaskScheduler.cs,ScheduleAndRun,The method has 7 parameters. Parameters: items' pool' context' parameter' testFrustum' outputCommands' numRendered
Long Parameter List,Render,AutoRenderTaskScheduler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\Renderer\RenderTaskScheduler.cs,ScheduleAndRun,The method has 7 parameters. Parameters: items' pool' context' parameter' testFrustum' outputCommands' numRendered
Long Parameter List,SharpDX.Toolkit.Graphics,PixelFormat,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDS.cs,PixelFormat,The method has 7 parameters. Parameters: flags' fourCC' rgbBitCount' rBitMask' gBitMask' bBitMask' aBitMask
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The method has 5 parameters. Parameters: headerPtr' size' flags' description' convFlags
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The method has 5 parameters. Parameters: description' flags' pDestination' maxsize' required
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The method has 8 parameters. Parameters: pDestination' outSize' outFormat' pSource' inSize' inFormat' pal8' flags
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The method has 8 parameters. Parameters: pDDS' offset' size' metadata' cpFlags' convFlags' pal8' handle
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SaveToDDSStream,The method has 5 parameters. Parameters: pixelBuffers' count' metadata' flags' stream
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The method has 6 parameters. Parameters: pDestination' outSize' pSource' inSize' inFormat' flags
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The method has 6 parameters. Parameters: pDestination' outSize' pSource' inSize' format' flags
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The method has 6 parameters. Parameters: pDestination' outSize' pSource' inSize' format' flags
Long Parameter List,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Image,The method has 6 parameters. Parameters: description' dataPointer' offset' handle' bufferIsDisposable' pitchFlags
Long Parameter List,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New2D,The method has 5 parameters. Parameters: width' height' mipMapCount' format' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New3D,The method has 5 parameters. Parameters: width' height' depth' mipMapCount' format
Long Parameter List,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New1D,The method has 5 parameters. Parameters: width' mipMapCount' format' arraySize' dataPointer
Long Parameter List,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New2D,The method has 6 parameters. Parameters: width' height' mipMapCount' format' arraySize' dataPointer
Long Parameter List,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New3D,The method has 6 parameters. Parameters: width' height' depth' mipMapCount' format' dataPointer
Long Parameter List,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The method has 6 parameters. Parameters: description' dataPointer' offset' handle' bufferIsDisposable' pitchFlags
Long Parameter List,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,CreateDescription,The method has 7 parameters. Parameters: dimension' width' height' depth' mipMapCount' format' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The method has 8 parameters. Parameters: fmt' width' height' rowPitch' slicePitch' widthCount' heightCount' flags
Long Parameter List,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,SetupImageArray,The method has 5 parameters. Parameters: buffer' pixelSize' imageDesc' pitchFlags' output
Long Parameter List,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Save,The method has 5 parameters. Parameters: pixelBuffers' count' description' imageStream' fileType
Long Parameter List,SharpDX.Toolkit.Graphics,MipMapDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,MipMapDescription,The method has 7 parameters. Parameters: width' height' depth' rowStride' depthStride' widthPacked' heightPacked
Long Parameter List,SharpDX.Toolkit.Graphics,PixelBuffer,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs,PixelBuffer,The method has 6 parameters. Parameters: width' height' format' rowStride' bufferStride' dataPointer
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget1D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,New,The method has 5 parameters. Parameters: device' width' format' flags' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget1D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,New,The method has 6 parameters. Parameters: device' width' mipCount' format' flags' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget1D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,NewRenderTargetDescription,The method has 5 parameters. Parameters: width' format' textureFlags' mipCount' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,New,The method has 7 parameters. Parameters: device' width' height' depth' format' flags' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,New,The method has 8 parameters. Parameters: device' width' height' depth' mipCount' format' flags' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,NewRenderTargetDescription,The method has 6 parameters. Parameters: width' height' depth' format' textureFlags' mipCount
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTargetCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTargetCube.cs,New,The method has 5 parameters. Parameters: device' size' mipCount' format' flags
Long Parameter List,SharpDX.Toolkit.Graphics,Texture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetDataBox,The method has 6 parameters. Parameters: format' width' height' depth' textureData' fixedPointer
Long Parameter List,SharpDX.Toolkit.Graphics,Texture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetViewSliceBounds,The method has 5 parameters. Parameters: viewType' arrayOrDepthIndex' mipIndex' arrayOrDepthCount' mipCount
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The method has 6 parameters. Parameters: device' width' format' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The method has 7 parameters. Parameters: device' width' mipCount' format' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The method has 6 parameters. Parameters: device' width' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1DBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1DBase.cs,NewDescription,The method has 6 parameters. Parameters: width' format' textureFlags' mipCount' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 7 parameters. Parameters: device' width' height' format' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 8 parameters. Parameters: device' width' height' mipCount' format' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 7 parameters. Parameters: device' width' height' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 9 parameters. Parameters: device' width' height' mipCount' format' textureData' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2DBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,NewDescription,The method has 7 parameters. Parameters: width' height' format' textureFlags' mipCount' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 7 parameters. Parameters: device' width' height' depth' format' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 8 parameters. Parameters: device' width' height' depth' mipCount' format' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 8 parameters. Parameters: device' width' height' depth' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 9 parameters. Parameters: device' width' height' depth' mipCount' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3DBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3DBase.cs,NewDescription,The method has 7 parameters. Parameters: width' height' depth' format' textureFlags' mipCount' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 5 parameters. Parameters: device' size' format' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 6 parameters. Parameters: device' size' mipCount' format' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 6 parameters. Parameters: device' size' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 6 parameters. Parameters: device' size' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,NewTextureCubeDescription,The method has 5 parameters. Parameters: size' format' flags' mipCount' usage
Long Parameter List,SharpDX.Toolkit.Graphics,WICHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeMultiframe,The method has 5 parameters. Parameters: images' count' flags' guidContainerFormat' stream
Long Parameter List,SharpDX.Toolkit.Graphics,WICHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,SaveToWICMemory,The method has 5 parameters. Parameters: pixelBuffer' count' flags' fileType' stream
Long Parameter List,Utilities.ImagePacker,SpritePackerBase<T;E>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImagePacker\SpritePackerBase.cs,Pack,The method has 10 parameters. Parameters: items' requirePowerOfTwo' requireSquareImage' maximumWidth' maximumHeight' imagePadding' outputImage' imageWidth' imageHeight' outputMap
Long Parameter List,Utilities.ImagePacker,SpritePackerBase<T;E>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImagePacker\SpritePackerBase.cs,TestPackingImages,The method has 5 parameters. Parameters: testWidth' testHeight' testImagePlacement' packedWidth' packedHeight
Long Parameter List,HelixToolkit.Wpf,CuttingEarsTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,InsideTriangle,The method has 8 parameters. Parameters: Ax' Ay' Bx' By' Cx' Cy' Px' Py
Long Parameter List,HelixToolkit.Wpf,CuttingEarsTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Snip,The method has 6 parameters. Parameters: contour' u' v' w' n' V
Long Identifier,HelixToolkit.SharpDX.Core,Constants,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Interface\Constants.cs,,The length of the parameter EmptyReadOnlyRenderable2DArray is 30.
Long Identifier,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,Load,The length of the parameter containsHomogeneousCoordinates is 30.
Long Identifier,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,Load,The length of the parameter nextLineContainsVertexDimension is 31.
Long Identifier,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,Load,The length of the parameter nextLineContainsNumberOfVertices is 32.
Long Identifier,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,,The length of the parameter AllCurvesShouldHaveTheSameNumberOfPoints is 40.
Long Identifier,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,,The length of the parameter SourceMeshNormalsShouldNotBeNull is 32.
Long Identifier,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,,The length of the parameter SourceMeshTextureCoordinatesShouldNotBeNull is 43.
Long Identifier,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,,The length of the parameter WrongNumberOfTextureCoordinates is 31.
Long Identifier,Shaders,DefaultPSShaderDescriptions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\DefaultShaders\DefaultPixelShaders.cs,,The length of the parameter PSEffectFullScreenBlurVertical is 30.
Long Identifier,Shaders,DefaultPSShaderDescriptions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\DefaultShaders\DefaultPixelShaders.cs,,The length of the parameter PSEffectFullScreenBlurHorizontal is 32.
Long Identifier,Model,GenericMaterialCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\GenericMaterialCore.cs,GenericMaterialCore,The length of the parameter modelMaterialConstantBufferName is 31.
Long Identifier,Model,GenericMeshMaterialCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\GenericMaterialCore.cs,GenericMeshMaterialCore,The length of the parameter modelMaterialConstantBufferName is 31.
Long Identifier,Model,GenericLineMaterialCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\GenericMaterialCore.cs,GenericLineMaterialCore,The length of the parameter modelMaterialConstantBufferName is 31.
Long Identifier,Model,GenericPointMaterialCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\GenericMaterialCore.cs,GenericPointMaterialCore,The length of the parameter modelMaterialConstantBufferName is 31.
Long Identifier,Model,MaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\MaterialVariableBase.cs,MaterialVariable,The length of the parameter meshMaterialConstantBufferDesc is 30.
Long Identifier,Model,MaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\MaterialVariableBase.cs,,The length of the parameter DefaultPointLineConstantBufferDesc is 34.
Long Identifier,Model,MaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\MaterialVariableBase.cs,,The length of the parameter DefaultVolumeConstantBufferDesc is 31.
Long Identifier,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,,The length of the parameter SamplerCheckVertexShaderStartIdx is 32.
Long Identifier,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,,The length of the parameter SamplerCheckHullShaderStartIdx is 30.
Long Identifier,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,,The length of the parameter SamplerCheckDomainShaderStartIdx is 32.
Long Identifier,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,,The length of the parameter SamplerCheckGeometryShaderStartIdx is 34.
Long Identifier,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,,The length of the parameter SamplerCheckPixelShaderStartIdx is 31.
Long Identifier,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,,The length of the parameter SamplerCheckComputeShaderStartIdx is 33.
Long Identifier,Render,DX11RenderHostBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\RenderHostBase.cs,,The length of the parameter UpdatePerFrameRenderableRequested is 33.
Long Statement,HelixToolkit.SharpDX.Core.Controls,MouseGestureHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\MouseGestureHandler.cs,Completed,The length of the statement  "            var elapsed = (double)(Stopwatch.GetTimestamp() - startTick) / Stopwatch.Frequency * 1000; //this.ManipulationWatch.ElapsedMilliseconds; " is 136.
Long Statement,HelixToolkit.SharpDX.Core.Controls,MouseGestureHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\MouseGestureHandler.cs,SetMouseDownPoint,The length of the statement  "            if (!this.Controller.FixedRotationPointEnabled && this.Controller.Viewport.FindHitsInFrustum(this.MouseDownPoint' ref hits)) " is 124.
Long Statement,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,ChangeCameraDistance,The length of the statement  "            if (newDistance > Controller.ZoomDistanceLimitFar && (oldDistance < Controller.ZoomDistanceLimitFar || newDistance > oldDistance)) " is 130.
Long Statement,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,ChangeCameraDistance,The length of the statement  "            if (newDistance < Controller.ZoomDistanceLimitNear && (oldDistance > Controller.ZoomDistanceLimitNear || newDistance < oldDistance)) " is 132.
Long Statement,HelixToolkit.SharpDX.Core,BitmapExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BitmapExtensions.cs,CreateBitmapStream,The length of the statement  "            var bitmap = new global::SharpDX.WIC.Bitmap(deviceResources.WICImgFactory' width' height' global::SharpDX.WIC.PixelFormat.Format32bppBGR' " is 137.
Long Statement,HelixToolkit.SharpDX.Core,BitmapExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BitmapExtensions.cs,CreateViewBoxTexture,The length of the statement  "                 Color4[] faceColors = new Color4[] { frontFaceColor' backFaceColor' leftFaceColor' rightFaceColor' topFaceColor' bottomFaceColor }; " is 131.
Long Statement,HelixToolkit.SharpDX.Core,BitmapExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BitmapExtensions.cs,CreateViewBoxTexture,The length of the statement  "                 Color4[] textColors = new Color4[] { frontTextColor' backTextColor' leftTextColor' rightTextColor' topTextColor' bottomTextColor }; " is 131.
Long Statement,HelixToolkit.SharpDX.Core,BitmapExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BitmapExtensions.cs,CreateViewBoxTexture,The length of the statement  "                     using (var layout = GetTextLayoutMetrices(texts[i]' deviceResources' fontSize' fontFamily' fontWeight' fontStyle' faceSize' faceSize)) " is 134.
Long Statement,HelixToolkit.SharpDX.Core,IViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\IViewportExtensions.cs,GetViewProjectionMatrix,The length of the statement  "                : viewport.CameraCore.CreateProjectionMatrix((float)viewport.ViewportRectangle.Width / (float)viewport.ViewportRectangle.Height); " is 129.
Long Statement,HelixToolkit.SharpDX.Core,IViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\IViewportExtensions.cs,GetProjectionMatrix,The length of the statement  "                : viewport.CameraCore.CreateProjectionMatrix((float)viewport.ViewportRectangle.Width / (float)viewport.ViewportRectangle.Height); " is 129.
Long Statement,HelixToolkit.SharpDX.Core,BillboardImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardImage3D.cs,HitTest,The length of the statement  "            if (!IsInitialized || context == null || (!fixedSize && !BoundingSphere.TransformBoundingSphere(modelMatrix).Intersects(ref rayWS))) " is 132.
Long Statement,HelixToolkit.SharpDX.Core,BoneSkinnedMeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BoneSkinnedMeshGeometry3D.cs,skinnedTriangles,The length of the statement  "                yield return new Triangle() { P0 = skinnedVertices[Indices[i]]' P1 = skinnedVertices[Indices[i + 1]]' P2 = skinnedVertices[Indices[i + 2]]' }; " is 142.
Long Statement,HelixToolkit.SharpDX.Core,BoneSkinnedMeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BoneSkinnedMeshGeometry3D.cs,HitTestWithSkinnedVertices,The length of the statement  "            var rayModel = new Ray(Vector3.TransformCoordinate(rayWS.Position' modelInvert)' Vector3.Normalize(Vector3.TransformNormal(rayWS.Direction' modelInvert))); " is 155.
Long Statement,HelixToolkit.SharpDX.Core,BillboardBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardBase.cs,HitTestFixedSize,The length of the statement  "                var quad = GetScreenQuad(ref c' ref vert.OffTL' ref vert.OffTR' ref vert.OffBL' ref vert.OffBR' ref visualToScreen' ref scale); " is 127.
Long Statement,HelixToolkit.SharpDX.Core,BillboardBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardBase.cs,HitTestFixedSize,The length of the statement  "                    Debug.WriteLine(string.Format("Hit; HitPoint:{0}; Text={1}"' result.PointHit' result.TextInfo == null ? Type.ToString() : result.TextInfo.Text)); " is 145.
Long Statement,HelixToolkit.SharpDX.Core,BillboardBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardBase.cs,HitTestNonFixedSize,The length of the statement  "                var quad = GetHitTestQuad(ref c' ref vert.OffTL' ref vert.OffTR' ref vert.OffBL' ref vert.OffBR' ref viewMatrix' ref viewMatrixInv' ref scale); " is 143.
Long Statement,HelixToolkit.SharpDX.Core,BillboardBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardBase.cs,HitTestNonFixedSize,The length of the statement  "                    Debug.WriteLine(string.Format("Hit; HitPoint:{0}; Text={1}"' result.PointHit' result.TextInfo == null ? Type.ToString() : result.TextInfo.Text)); " is 145.
Long Statement,HelixToolkit.SharpDX.Core,BillboardSingleImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleImage3D.cs,HitTest,The length of the statement  "            if (!IsInitialized || context == null || Width == 0 || Height == 0 || (!fixedSize && !BoundingSphere.TransformBoundingSphere(modelMatrix).Intersects(ref rayWS))) " is 161.
Long Statement,HelixToolkit.SharpDX.Core,BillboardSingleImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleImage3D.cs,HitTest,The length of the statement  "            return fixedSize ? HitTestFixedSize(context' ref modelMatrix' ref rayWS' ref hits' originalSource' BillboardVertices.Count) " is 123.
Long Statement,HelixToolkit.SharpDX.Core,BillboardSingleText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleText3D.cs,OnUpdateTextureAndBillboardVertices,The length of the statement  "                    new Vector4((float)Padding.Left' (float)Padding.Top' (float)Padding.Right' (float)Padding.Bottom)' ref w' ref h' predefinedSize' deviceResources); " is 146.
Long Statement,HelixToolkit.SharpDX.Core,BillboardSingleText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleText3D.cs,OnUpdateTextureAndBillboardVertices,The length of the statement  "                Texture = TextInfo.Text.ToBitmapStream(FontSize' Color.White' Color.Black' FontFamily' FontWeight.ToDXFontWeight()' FontStyle.ToDXFontStyle()' " is 142.
Long Statement,HelixToolkit.SharpDX.Core,BillboardSingleText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleText3D.cs,OnUpdateTextureAndBillboardVertices,The length of the statement  "                    new Vector4((float)Padding.Left' (float)Padding.Top' (float)Padding.Right' (float)Padding.Bottom)' ref w' ref h' predefinedSize' deviceResources); " is 146.
Long Statement,HelixToolkit.SharpDX.Core,BillboardSingleText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleText3D.cs,HitTest,The length of the statement  "            if (!IsInitialized || context == null || Width == 0 || Height == 0 || (!fixedSize && !BoundingSphere.TransformBoundingSphere(modelMatrix).Intersects(ref rayWS))) " is 161.
Long Statement,HelixToolkit.SharpDX.Core,BillboardSingleText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleText3D.cs,HitTest,The length of the statement  "            return fixedSize ? HitTestFixedSize(context' ref modelMatrix' ref rayWS' ref hits' originalSource' BillboardVertices.Count) " is 123.
Long Statement,HelixToolkit.SharpDX.Core,BillboardText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardText3D.cs,HitTest,The length of the statement  "            if (!IsInitialized || context == null || Width == 0 || Height == 0 || (!fixedSize && !BoundingSphere.TransformBoundingSphere(modelMatrix).Intersects(ref rayWS))) " is 161.
Long Statement,HelixToolkit.SharpDX.Core,LineGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\LineGeometry3D.cs,HitTest,The length of the statement  "                    var rayToLineDistance = LineBuilder.GetRayToLineDistance(rayWS' t0' t1' out Vector3 sp' out Vector3 tp' out float sc' out float tc); " is 132.
Long Statement,HelixToolkit.SharpDX.Core,MeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\MeshGeometry3D.cs,HitTest,The length of the statement  "                var rayModel = new Ray(Vector3.TransformCoordinate(rayWS.Position' modelInvert)' Vector3.Normalize(Vector3.TransformNormal(rayWS.Direction' modelInvert))); " is 155.
Long Statement,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The length of the statement  "                InputLayoutDescription = new InputLayoutDescription(DefaultVSShaderByteCodes.VSMeshDefault' DefaultInputLayout.VSInput)' " is 120.
Long Statement,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The length of the statement  "                        InputLayoutDescription = new InputLayoutDescription(DefaultVSShaderByteCodes.VSMeshBoneSkinningBasic' DefaultInputLayout.VSInputBoneSkinnedBasic)' " is 146.
Long Statement,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The length of the statement  "                InputLayoutDescription = new InputLayoutDescription(DefaultVSShaderByteCodes.VSMeshBatched' DefaultInputLayout.VSMeshBatchedInput)' " is 131.
Long Statement,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The length of the statement  "                        InputLayoutDescription = new InputLayoutDescription(DefaultVSShaderByteCodes.VSMeshBoneSkinningBasic' DefaultInputLayout.VSInputBoneSkinnedBasic)' " is 146.
Long Statement,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The length of the statement  "                InputLayoutDescription = new InputLayoutDescription(DefaultVSShaderByteCodes.VSMeshInstancing' DefaultInputLayout.VSInputInstancing)' " is 133.
Long Statement,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The length of the statement  "                        InputLayoutDescription = new InputLayoutDescription(DefaultVSShaderByteCodes.VSMeshBoneSkinningBasic' DefaultInputLayout.VSInputBoneSkinnedBasic)' " is 146.
Long Statement,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The length of the statement  "                InputLayoutDescription = new InputLayoutDescription(DefaultVSShaderByteCodes.VSBillboard' DefaultInputLayout.VSInputBillboard)' " is 127.
Long Statement,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The length of the statement  "                InputLayoutDescription = new InputLayoutDescription(DefaultVSShaderByteCodes.VSBillboardInstancing' DefaultInputLayout.VSInputBillboardInstancing)' " is 147.
Long Statement,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The length of the statement  "                InputLayoutDescription = new InputLayoutDescription(DefaultVSShaderByteCodes.VSMeshDefault' DefaultInputLayout.VSInput)' " is 120.
Long Statement,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The length of the statement  "                InputLayoutDescription = new InputLayoutDescription(DefaultVSShaderByteCodes.VSParticle' DefaultInputLayout.VSInputParticle)' " is 125.
Long Statement,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The length of the statement  "                InputLayoutDescription = new InputLayoutDescription(DefaultVSShaderByteCodes.VSSkybox' DefaultInputLayout.VSInputSkybox)' " is 121.
Long Statement,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The length of the statement  "                InputLayoutDescription = new InputLayoutDescription(DefaultVSShaderByteCodes.VSSprite2D' DefaultInputLayout.VSInputSprite2D)' " is 125.
Long Statement,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The length of the statement  "                InputLayoutDescription = new InputLayoutDescription(DefaultVSShaderByteCodes.VSVolume3D' DefaultInputLayout.VSInputVolume3D)' " is 125.
Long Statement,HelixToolkit.SharpDX.Core,EffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\EffectsManager.cs,Initialize,The length of the statement  "                throw new PlatformNotSupportedException("Graphic adapter does not meet minimum requirement' must support DirectX 10 or above."); " is 128.
Long Statement,HelixToolkit.SharpDX.Core,EffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\EffectsManager.cs,Initialize,The length of the statement  "            device = new global::SharpDX.Direct3D11.Device(DriverType.Hardware' DeviceCreationFlags.BgraSupport' FeatureLevel.Level_10_1); " is 126.
Long Statement,HelixToolkit.SharpDX.Core,EffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\EffectsManager.cs,Initialize,The length of the statement  "            Log(LogLevel.Information' $"Direct3D device initilized. DriverType: {DriverType}; FeatureLevel: {device.FeatureLevel}"); " is 120.
Long Statement,HelixToolkit.SharpDX.Core,EffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\EffectsManager.cs,Initialize,The length of the statement  "                deviceContext2D = Collect(new global::SharpDX.Direct2D1.DeviceContext(device2D' global::SharpDX.Direct2D1.DeviceContextOptions.EnableMultithreadedOptimizations)); " is 162.
Long Statement,HelixToolkit.SharpDX.Core,EffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\EffectsManager.cs,AddTechnique,The length of the statement  "            techniqueDict.Add(description.Name' new Lazy<IRenderTechnique>(() => { return Initialized ? Collect(new Technique(description' Device' this)) : null; }' true)); " is 160.
Long Statement,HelixToolkit.SharpDX.Core,EffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\EffectsManager.cs,Reinitialize,The length of the statement  "                    techniqueDict.Add(tech.Name' new Lazy<IRenderTechnique>(() => { return Initialized ? Collect(new Technique(tech' Device' this)) : null; }' true)); " is 146.
Long Statement,HelixToolkit.SharpDX.Core,EffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\EffectsManager.cs,GetBestAdapter,The length of the statement  "                    if ((bestAdapter == null) || (videoMemory > bestVideoMemory) || ((videoMemory == bestVideoMemory) && (systemMemory > bestSystemMemory))) " is 136.
Long Statement,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,Read,The length of the statement  "                            case "cstype": // rational or non-rational forms of curve or surface type: basis matrix' Bezier' B-spline' Cardinal' Taylor " is 123.
Long Statement,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,ColorParse,The length of the statement  "            return System.Windows.Media.Color.FromRgb((byte)(fields[0] * 255)' (byte)(fields[1] * 255)' (byte)(fields[2] * 255)).ToColor4(); " is 128.
Long Statement,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddFace,The length of the statement  "                    throw new FileFormatException(string.Format("Invalid texture coordinate index ({0}) on line {1}."' vti' this.currentLineNo)); " is 125.
Long Statement,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,IsDigitChar,The length of the statement  "            if (input == '-' || input == '+' || input == '0' || input == '1' || input == '2' || input == '3' || input == '4' || input == '5' || input == '6' || input == '7' || input == '8' || input == '9' || input == '.') " is 209.
Long Statement,HelixToolkit.SharpDX.Core,ShaderExporter,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\RenderTechniqueImportExport.cs,ImportTechniques,The length of the statement  "                    using (var binaryXMLReader = XmlDictionaryReader.CreateBinaryReader(memory' new XmlDictionaryReaderQuotas() { MaxArrayLength = (int)memory.Length })) " is 149.
Long Statement,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The length of the statement  "                CreateMesh(positions' textureCoordinates' triangleIndices' transforms' out normals' out tangents' out bitangents' new PhongMaterial() " is 133.
Long Statement,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTest,The length of the statement  "            var rayModel = new Ray(Vector3.TransformCoordinate(rayWS.Position' modelInv)' Vector3.Normalize(Vector3.TransformNormal(rayWS.Direction' modelInv))); " is 149.
Long Statement,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTest,The length of the statement  "                    bool nodeHit = node.HitTestCurrentNodeExcludeChild(context' model' geometry' modelMatrix' ref rayWS' ref rayModel' ref modelHits' ref isIntersect' hitThickness); " is 161.
Long Statement,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,Expand,The length of the statement  "            var newCenter = center + new Vector3(xDirection * Math.Abs(half.X)' yDirection * Math.Abs(half.Y)' zDirection * Math.Abs(half.Z)); " is 130.
Long Statement,HelixToolkit.SharpDX.Core,InstancingModel3DOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTestCurrentNodeExcludeChild,The length of the statement  "            var bound = Bound.Transform(modelMatrix);// BoundingBox.FromPoints(Bound.GetCorners().Select(x => Vector3.TransformCoordinate(x' modelMatrix)).ToArray()); " is 154.
Long Statement,HelixToolkit.SharpDX.Core,InstancingModel3DOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTestCurrentNodeExcludeChild,The length of the statement  "                    var b = Objects[i].Value.Transform(modelMatrix);// BoundingBox.FromPoints(t.Item2.GetCorners().Select(x => Vector3.TransformCoordinate(x' modelMatrix)).ToArray()); " is 163.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormals,The length of the statement  "            //Cannot use normals[i].normalize() if using Media3D.Vector3DCollection. Does not change the internal value in Vector3DCollection. " is 130.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "            var radiusSphere = 0.25f * (DoubleOrSingle)Math.Sqrt(3) * (1 + (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength; " is 122.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "                var newPoint = new Point3D(radiusSphere * (DoubleOrSingle)Math.Cos(gamma)' 0' radiusSphere * (DoubleOrSingle)Math.Sin(gamma)); " is 126.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "                var newPoint = new Point3D(radiusSphere * (DoubleOrSingle)Math.Cos(gamma)' 0' radiusSphere * (DoubleOrSingle)Math.Sin(gamma)); " is 126.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "                    var u = (DoubleOrSingle)Math.Atan2(SharedFunctions.DotProduct(ref planeCTP' ref forward)' SharedFunctions.DotProduct(ref planeCTP' ref right)); " is 143.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The length of the statement  "                    var p = new Point3D(center.X + (DoubleOrSingle)(radiusx * x)' center.Y + (DoubleOrSingle)(radiusy * y)' center.Z + (DoubleOrSingle)(radiusz * z)); " is 146.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The length of the statement  "                        this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues[j])); " is 163.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The length of the statement  "                        this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues[j + 1])); " is 173.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The length of the statement  "                        this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues[j])); " is 163.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                    var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25)))); " is 132.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList(); " is 188.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                    var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList(); " is 246.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                        var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList(); " is 246.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                        var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0); " is 177.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Scale,The length of the statement  "                    this.Positions[i].X * (DoubleOrSingle)scaleX' this.Positions[i].Y * (DoubleOrSingle)scaleY' this.Positions[i].Z * (DoubleOrSingle)scaleZ); " is 138.
Long Statement,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Scale,The length of the statement  "                        this.Normals[i].X * (DoubleOrSingle)scaleX' this.Normals[i].Y * (DoubleOrSingle)scaleY' this.Normals[i].Z * (DoubleOrSingle)scaleZ); " is 132.
Long Statement,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The length of the statement  "            return new MeshGeometry3D { Positions = p' TriangleIndices = new IntCollection(ti)' Normals = n' TextureCoordinates = tc }; " is 123.
Long Statement,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The length of the statement  "                contourHelper.ContourFacet(index0' index1' index2' out positions' out normals' out textureCoordinates' out triangleIndices); " is 124.
Long Statement,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,The length of the statement  "            RemoveIsolatedVertices(mesh.Positions' mesh.TriangleIndices' mesh.TextureCoordinates' mesh.Normals' out vertNew' out triNew' out textureNew' out normalNew); " is 156.
Long Statement,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,The length of the statement  "            var newMesh = new MeshGeometry3D() { Positions = vertNew' TriangleIndices = triNew' TextureCoordinates = textureNew' Normals = normalNew }; " is 139.
Long Statement,HelixToolkit.SharpDX.Core,Polygon3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,Flatten,The length of the statement  "            var m = new Matrix3D(backward.X' right.X' up.X' 0' backward.Y' right.Y' up.Y' 0' backward.Z' right.Z' up.Z' 0' 0' 0' 0' 1); " is 123.
Long Statement,HelixToolkit.SharpDX.Core,SweepLinePolygonTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,The length of the statement  "                //if (!(leftChain.Contains(top) && leftChain.Contains(newPoint) || rightChain.Contains(top) && rightChain.Contains(newPoint))) " is 126.
Long Statement,Core2D,RenderCore2DBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\Abstract\RenderCore2DBase.cs,Render,The length of the statement  "                            using (var borderDotStyle = new D2D.StrokeStyle(context.DeviceContext.Factory' new D2D.StrokeStyleProperties() { DashStyle = D2D.DashStyle.DashDot })) " is 150.
Long Statement,Core2D,RenderCore2DBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\Abstract\RenderCore2DBase.cs,Render,The length of the statement  "                                using (var borderLineStyle = new D2D.StrokeStyle(context.DeviceContext.Factory' new D2D.StrokeStyleProperties() { DashStyle = D2D.DashStyle.Solid })) " is 149.
Long Statement,Core2D,BorderRenderCore2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\BorderRenderCore2D.cs,OnRender,The length of the statement  "                    if(borderThickness.X == borderThickness.Y && borderThickness.X == borderThickness.Z && borderThickness.X == borderThickness.W) " is 126.
Long Statement,Core2D,BorderRenderCore2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\BorderRenderCore2D.cs,OnRender,The length of the statement  "                                    figure.AddSegment(new ArcSegment(LayoutBound.TopLeft + new Vector2(CornerRadius' 0)' new Size2F(CornerRadius' CornerRadius)' 0'  " is 127.
Long Statement,Core2D,BorderRenderCore2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\BorderRenderCore2D.cs,OnRender,The length of the statement  "                                    figure.AddSegment(new ArcSegment(LayoutBound.TopRight + new Vector2(0' CornerRadius) ' new Size2F(CornerRadius' CornerRadius)' 0' " is 129.
Long Statement,Core2D,BorderRenderCore2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\BorderRenderCore2D.cs,OnRender,The length of the statement  "                                    figure.AddSegment(new ArcSegment(LayoutBound.BottomRight - new Vector2(CornerRadius' 0)' new Size2F(CornerRadius' CornerRadius)' 0' " is 131.
Long Statement,Core2D,BorderRenderCore2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\BorderRenderCore2D.cs,OnRender,The length of the statement  "                                    figure.AddSegment(new ArcSegment(LayoutBound.BottomLeft - new Vector2(0' CornerRadius)' new Size2F(CornerRadius' CornerRadius)' 0' " is 130.
Long Statement,Core2D,ArcSegment,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\Models\ArcSegment.cs,Create,The length of the statement  "                sink.AddArc(new D2D.ArcSegment() { ArcSize = ArcSize' Point = Point' RotationAngle = Rotation' Size = Size' SweepDirection = SweepDirection }); " is 143.
Long Statement,Core2D,TextRenderCore2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\TextRenderCore2D.cs,OnRender,The length of the statement  "                context.DeviceContext.DrawTextLayout(new Vector2(LayoutBound.Left' LayoutBound.Top)' textLayout' Foreground' DrawingOptions); " is 125.
Long Statement,Core,DefaultStaticMeshBatchingBuffer,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Batching\DefaultMeshBatchingBuffer.cs,OnFillVertArray,The length of the statement  "                    var normals = mesh.Normals != null ? mesh.Normals.GetEnumerator() : Enumerable.Repeat(Vector3.Zero' vertexCount).GetEnumerator(); " is 129.
Long Statement,Core,DefaultStaticMeshBatchingBuffer,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Batching\DefaultMeshBatchingBuffer.cs,OnFillVertArray,The length of the statement  "                    var tangents = mesh.Tangents != null ? mesh.Tangents.GetEnumerator() : Enumerable.Repeat(Vector3.Zero' vertexCount).GetEnumerator(); " is 132.
Long Statement,Core,DefaultStaticMeshBatchingBuffer,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Batching\DefaultMeshBatchingBuffer.cs,OnFillVertArray,The length of the statement  "                    var bitangents = mesh.BiTangents != null ? mesh.BiTangents.GetEnumerator() : Enumerable.Repeat(Vector3.Zero' vertexCount).GetEnumerator(); " is 138.
Long Statement,Core,DefaultStaticMeshBatchingBuffer,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Batching\DefaultMeshBatchingBuffer.cs,OnFillVertArray,The length of the statement  "                    var textures = mesh.TextureCoordinates != null ? mesh.TextureCoordinates.GetEnumerator() : Enumerable.Repeat(Vector2.Zero' vertexCount).GetEnumerator(); " is 152.
Long Statement,Core,StaticGeometryBatchingBufferBase<BatchedGeometry;VertStruct>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Batching\StaticGeometryBatchingBufferBase.cs,OnSubmitGeometries,The length of the statement  "                vertexBufferBindings = new[] { new VertexBufferBinding(VertexBuffer[0].Buffer' VertexBuffer[0].StructureSize' VertexBuffer[0].Offset) }; " is 136.
Long Statement,Core,BoneSkinRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\BoneSkinRenderCore.cs,OnAttach,The length of the statement  "                    boneSkinSBSlot = preComputeBoneSkinPass.VertexShader.ShaderResourceViewMapping.GetMapping(DefaultBufferNames.BoneSkinSB).Slot; " is 126.
Long Statement,Core,BoneSkinRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\BoneSkinRenderCore.cs,OnUpdate,The length of the statement  "                if (preComputeBoneSkinPass.IsNULL || preComputeBoneBuffer == null || !preComputeBoneBuffer.CanPreCompute || !matricsChanged) " is 124.
Long Statement,Core,BillboardBufferModel<VertexStruct>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\BillboardBufferModel.cs,OnCreateVertexBuffer,The length of the statement  "                        buffer.UploadDataToBuffer(context' billboardGeometry.BillboardVertices' billboardGeometry.BillboardVertices.Count' 0' geometry.PreDefinedVertexCount); " is 150.
Long Statement,Core,BoneSkinPreComputeBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\BoneSkinBufferModel.cs,MeshBuffer_OnBoneIdBufferUpdated,The length of the statement  "                        new VertexBufferBinding(meshBuffer.BoneIdBuffer.Buffer' meshBuffer.BoneIdBuffer.StructureSize' meshBuffer.BoneIdBuffer.Offset) " is 126.
Long Statement,Core,BoneSkinPreComputeBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\BoneSkinBufferModel.cs,UpdateBuffers,The length of the statement  "                                vertexBufferBindings = VertexBuffer.Select(x => x != null ? new VertexBufferBinding(x.Buffer' x.StructureSize' x.Offset) : new VertexBufferBinding()).ToArray(); " is 160.
Long Statement,Core,BoneSkinPreComputeBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\BoneSkinBufferModel.cs,UpdateBuffers,The length of the statement  "                                    new VertexBufferBinding(meshBuffer.BoneIdBuffer.Buffer' meshBuffer.BoneIdBuffer.StructureSize' meshBuffer.BoneIdBuffer.Offset) " is 126.
Long Statement,Core,BoneSkinPreComputeBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\BoneSkinBufferModel.cs,CopySkinnedToArray,The length of the statement  "                if (skinnedVertexStagingBuffer.Buffer == null || skinnedVertexStagingBuffer.ElementCount != skinnedVertexBuffer.ElementCount) " is 125.
Long Statement,Core,GeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\GeometryBufferModel.cs,OnCreateVertexBufferBinding,The length of the statement  "                return VertexBuffer.Select(x => x != null ? new VertexBufferBinding(x.Buffer' x.StructureSize' x.Offset) : new VertexBufferBinding()).ToArray(); " is 144.
Long Statement,Core,DefaultLineGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\LineBufferModel.cs,OnBuildVertexArray,The length of the statement  "                var array =  vertexArrayBuffer != null && vertexArrayBuffer.Length >= vertexCount ? vertexArrayBuffer : new LinesVertex[vertexCount]; " is 133.
Long Statement,Core,DefaultLineGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\LineBufferModel.cs,OnBuildVertexArray,The length of the statement  "                var colors = geometry.Colors != null ? geometry.Colors.GetEnumerator() : Enumerable.Repeat(Color4.White' vertexCount).GetEnumerator(); " is 134.
Long Statement,Core,DefaultMeshGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\MeshBufferModel.cs,OnCreateVertexBuffer,The length of the statement  "                                buffer.UploadDataToBuffer(context' mesh.TextureCoordinates' mesh.TextureCoordinates.Count' 0' geometry.PreDefinedVertexCount); " is 126.
Long Statement,Core,DefaultMeshGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\MeshBufferModel.cs,BuildVertexArray,The length of the statement  "                var normals = geometry.Normals != null ? geometry.Normals.GetEnumerator() : Enumerable.Repeat(Vector3.Zero' vertexCount).GetEnumerator(); " is 137.
Long Statement,Core,DefaultMeshGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\MeshBufferModel.cs,BuildVertexArray,The length of the statement  "                var tangents = geometry.Tangents != null ? geometry.Tangents.GetEnumerator() : Enumerable.Repeat(Vector3.Zero' vertexCount).GetEnumerator(); " is 140.
Long Statement,Core,DefaultMeshGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\MeshBufferModel.cs,BuildVertexArray,The length of the statement  "                var bitangents = geometry.BiTangents != null ? geometry.BiTangents.GetEnumerator() : Enumerable.Repeat(Vector3.Zero' vertexCount).GetEnumerator(); " is 146.
Long Statement,Core,DefaultMeshGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\MeshBufferModel.cs,BuildVertexArray,The length of the statement  "                var array = vertexArrayBuffer != null && vertexArrayBuffer.Length >= vertexCount ? vertexArrayBuffer : new DefaultVertex[vertexCount]; " is 134.
Long Statement,Core,DefaultPointGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\PointBufferModel.cs,OnBuildVertexArray,The length of the statement  "                var array = vertexArrayBuffer != null && vertexArrayBuffer.Length >= vertexCount ? vertexArrayBuffer : new PointsVertex[vertexCount]; " is 133.
Long Statement,Core,DefaultPointGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\PointBufferModel.cs,OnBuildVertexArray,The length of the statement  "                var colors = geometry.Colors != null ? geometry.Colors.GetEnumerator() : Enumerable.Repeat(Color4.White' vertexCount).GetEnumerator(); " is 134.
Long Statement,Core,Sprite2DBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\SpriteBufferModel.cs,AttachBuffers,The length of the statement  "                    context.SetVertexBuffers(0' new VertexBufferBinding(vertextBuffer.Buffer' vertextBuffer.StructureSize' vertextBuffer.Offset)); " is 126.
Long Statement,Core,Sprite2DBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\SpriteBufferModel.cs,UpdateBuffers,The length of the statement  "                if(SpriteCount == 0 || IndexCount == 0 || Sprites == null || Indices == null || Sprites.Length < SpriteCount || Indices.Length < IndexCount) " is 140.
Long Statement,Core,CrossSectionMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\CrossSectionMeshRenderCore.cs,CreateRasterState,The length of the statement  "                this.backfaceRasterState = Collect(EffectTechnique.EffectsManager.StateManager.Register(new RasterizerStateDescription() " is 120.
Long Statement,Core,DynamicCubeMapCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\DynamicCubeMapCore.cs,CreateCubeMapResources,The length of the statement  "                    Texture2DArray = new RenderTargetViewDescription.Texture2DArrayResource() { MipSlice = 0' FirstArraySlice = 0' ArraySize = 1 } " is 126.
Long Statement,Core,DynamicCubeMapCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\DynamicCubeMapCore.cs,CreateCubeMapResources,The length of the statement  "                    Texture2DArray = new DepthStencilViewDescription.Texture2DArrayResource() { MipSlice = 0' FirstArraySlice = 0' ArraySize = 1 } " is 126.
Long Statement,Core,DynamicCubeMapCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\DynamicCubeMapCore.cs,UpdateTargets,The length of the statement  "                    cubeFaceCameras.Cameras[i].View = (IsLeftHanded ? Matrix.LookAtLH(center' targets[i]' upVectors[i]) : Matrix.LookAtRH(center' targets[i]' upVectors[i])) * Matrix.Scaling(-1' 1' 1); " is 180.
Long Statement,Core,DynamicCubeMapCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\DynamicCubeMapCore.cs,UpdateTargets,The length of the statement  "                    cubeFaceCameras.Cameras[i].Projection = IsLeftHanded ? Matrix.PerspectiveFovLH((float)Math.PI * 0.5f' 1' NearField' FarField) " is 125.
Long Statement,Core,AxisPlaneGridCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\AxisPlaneGridCore.cs,Render,The length of the statement  "                DefaultShaderPass.BindStates(deviceContext' StateType.BlendState | StateType.DepthStencilState | StateType.RasterState); " is 120.
Long Statement,Core,DirectionalLightCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Lights\DirectionalLightCore.cs,OnRender,The length of the statement  "                lightScene.LightModels.Lights[index].LightDir = -Vector3.TransformNormal(direction' ModelMatrix).Normalized().ToVector4(0); " is 123.
Long Statement,Core,SpotLightCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Lights\SpotLightCore.cs,OnRender,The length of the statement  "                lightScene.LightModels.Lights[index].LightDir = Vector3.TransformNormal(direction' ModelMatrix).Normalized().ToVector4(0); " is 122.
Long Statement,Core,SpotLightCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Lights\SpotLightCore.cs,OnRender,The length of the statement  "                lightScene.LightModels.Lights[index].LightSpot = new Vector4((float)Math.Cos(outerAngle / 360.0f * Math.PI)' (float)Math.Cos(innerAngle / 360.0f * Math.PI)' fallOff' 0); " is 169.
Long Statement,Core,ParticleRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ParticleRenderCore.cs,OnAttach,The length of the statement  "                currentStateSlot = updatePass.GetShader(ShaderStage.Compute).UnorderedAccessViewMapping.TryGetBindSlot(CurrentSimStateUAVBufferName); " is 133.
Long Statement,Core,ParticleRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ParticleRenderCore.cs,OnAttach,The length of the statement  "                newStateSlot = updatePass.GetShader(ShaderStage.Compute).UnorderedAccessViewMapping.TryGetBindSlot(NewSimStateUAVBufferName); " is 125.
Long Statement,Core,ParticleRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ParticleRenderCore.cs,OnAttach,The length of the statement  "                renderStateSlot = renderPass.GetShader(ShaderStage.Vertex).ShaderResourceViewMapping.TryGetBindSlot(SimStateBufferName); " is 120.
Long Statement,Core,ParticleRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ParticleRenderCore.cs,UpdateInsertThrottle,The length of the statement  "                InsertElapseThrottle = (8.0f * InsertVariables.InitialEnergy / InsertVariables.EnergyDissipationRate / System.Math.Max(0' (particleCount + 8))); " is 144.
Long Statement,Core,PostEffectMeshOutlineBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshOutlineBlurCore.cs,Render,The length of the statement  "                using (var depthStencilBuffer = context.GetOffScreenDS(TextureSize' global::SharpDX.DXGI.Format.D32_Float_S8X24_UInt' out width' out height)) " is 141.
Long Statement,Core,PostEffectMeshOutlineBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshOutlineBlurCore.cs,Render,The length of the statement  "                                    if (effect.TryGetAttribute(EffectAttributeNames.ColorAttributeName' out object attribute) && attribute is string colorStr) " is 122.
Long Statement,Core,PostEffectMeshOutlineBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshOutlineBlurCore.cs,Render,The length of the statement  "                                    if (effect.TryGetAttribute(EffectAttributeNames.ColorAttributeName' out object attribute) && attribute is string colorStr) " is 122.
Long Statement,Core,PostEffectMeshOutlineBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshOutlineBlurCore.cs,DrawOutline,The length of the statement  "                        blurPassVertical.PixelShader.BindTexture(deviceContext' textureSlot' context.RenderHost.RenderBuffer.FullResPPBuffer.NextRTV); " is 126.
Long Statement,Core,PostEffectMeshOutlineBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshOutlineBlurCore.cs,DrawOutline,The length of the statement  "                deviceContext.SetRenderTarget(depthStencilBuffer' context.RenderHost.RenderBuffer.FullResPPBuffer.NextRTV' width' height' " is 121.
Long Statement,Core,PostEffectMeshOutlineBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshOutlineBlurCore.cs,DrawOutline,The length of the statement  "                screenOutlinePass.PixelShader.BindTexture(deviceContext' textureSlot' context.RenderHost.RenderBuffer.FullResPPBuffer.NextRTV); " is 127.
Long Statement,Core,PostEffectMeshXRayCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshXRay.cs,Render,The length of the statement  "                var depthStencilBuffer = hasMSAA ? context.GetOffScreenDS(OffScreenTextureSize.Full' Format.D32_Float_S8X24_UInt) : buffer.DepthStencilBuffer; " is 142.
Long Statement,Core,PostEffectMeshXRayCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshXRay.cs,Render,The length of the statement  "                deviceContext.SetRenderTarget(depthStencilBuffer' buffer.FullResPPBuffer.CurrentRTV' buffer.TargetWidth' buffer.TargetHeight); " is 126.
Long Statement,Core,PostEffectMeshXRayCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshXRay.cs,Render,The length of the statement  "                        if (effect.TryGetAttribute(EffectAttributeNames.ColorAttributeName' out object attribute) && attribute is string colorStr) " is 122.
Long Statement,Core,PostEffectMeshXRayCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshXRay.cs,Render,The length of the statement  "                            if (effect.TryGetAttribute(EffectAttributeNames.ColorAttributeName' out object attribute) && attribute is string colorStr) " is 122.
Long Statement,Core,PostEffectMeshXRayGridCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshXRayGrid.cs,Render,The length of the statement  "                var depthStencilBuffer = hasMSAA ? context.GetOffScreenDS(OffScreenTextureSize.Full' Format.D32_Float_S8X24_UInt) : buffer.DepthStencilBuffer; " is 142.
Long Statement,Core,PostEffectMeshXRayGridCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshXRayGrid.cs,Render,The length of the statement  "                deviceContext.SetRenderTarget(depthStencilBuffer' buffer.FullResPPBuffer.CurrentRTV' buffer.TargetWidth' buffer.TargetHeight); " is 126.
Long Statement,Core,PostEffectMeshXRayGridCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshXRayGrid.cs,Render,The length of the statement  "                    if (currentCores[i].Value.TryGetAttribute(EffectAttributeNames.ColorAttributeName' out object attribute) && attribute is string colorStr) " is 137.
Long Statement,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,OnAttach,The length of the statement  "                CursorShaderPass = technique.EffectsManager[DefaultRenderTechniqueNames.ScreenDuplication][DefaultPassNames.ScreenQuad]; " is 120.
Long Statement,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,OnAttach,The length of the statement  "                textureBindSlot = DefaultShaderPass.PixelShader.ShaderResourceViewMapping.TryGetBindSlot(DefaultBufferNames.DiffuseMapTB); " is 122.
Long Statement,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,Render,The length of the statement  "                            GetCursorVertexBound((int)context.ActualWidth' (int)context.ActualHeight' frameProcessor.TextureWidth' frameProcessor.TextureHeight' ref rect); " is 143.
Long Statement,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,Render,The length of the statement  "                        using (var textureView = new global::SharpDX.Direct3D11.ShaderResourceView(deviceContext' frameProcessor.SharedTexture)) " is 120.
Long Statement,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,DrawCursor,The length of the statement  "                //deviceContext.DeviceContext.OutputMerger.SetBlendState(CursorShaderPass.BlendState' new RawColor4(0' 0' 0' 0)); //Set special blend factor " is 140.
Long Statement,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessFrame,The length of the statement  "                    if (sharedTexture == null || sharedDescription.Width != data.Frame.Description.Width || sharedDescription.Height != data.Frame.Description.Height) " is 146.
Long Statement,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessFrame,The length of the statement  "                            CpuAccessFlags = CpuAccessFlags.None' Format = data.Frame.Description.Format' Width = data.Frame.Description.Width' Height = data.Frame.Description.Height' " is 155.
Long Statement,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessFrame,The length of the statement  "                            MipLevels = 1' Usage = ResourceUsage.Default' SampleDescription = new SampleDescription(1' 0)' OptionFlags = ResourceOptionFlags.None' ArraySize=1 " is 146.
Long Statement,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessCursor,The length of the statement  "                    int rowPitch = pointer.ShapeInfo.Type == (int)OutputDuplicatePointerShapeType.Color ? pointer.ShapeInfo.Pitch : width * BPP; " is 124.
Long Statement,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessCursor,The length of the statement  "                        global::SharpDX.Utilities.Pin(pointer.ShapeInfo.Type == (int)OutputDuplicatePointerShapeType.Color ? pointer.PtrShapeBuffer : initBuffer' ptr => " is 144.
Long Statement,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessMonoMask,The length of the statement  "                    var dataBox = context.MapSubresource(copyBuffer' 0' global::SharpDX.Direct3D11.MapMode.Read' global::SharpDX.Direct3D11.MapFlags.None); " is 135.
Long Statement,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessMonoMask,The length of the statement  "                                        initBuffer32[(row * stageTextureDesc.Width) + col] = (desktop32[(row * desktopPitchInPixels) + col] & AndMask32) ^ XorMask32; " is 125.
Long Statement,Core,DuplicationResource,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,GetFrame,The length of the statement  "                    var code = info.Duplication.TryAcquireNextFrame(getFrameTimeOut' out OutputDuplicateFrameInformation frameInfo' out Resource desktopResource); " is 142.
Long Statement,Core,DuplicationResource,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,RetrieveCursorMetadata,The length of the statement  "                    if (frameInfo.PointerPosition.Visible && pointerInfo.Visible && (pointerInfo.WhoUpdatedPositionLast != outputDevice) && (pointerInfo.LastTimeStamp > frameInfo.LastMouseUpdateTime)) " is 180.
Long Statement,Core,DuplicationResource,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,RetrieveCursorMetadata,The length of the statement  "                                duplication.GetFramePointerShape(frameInfo.PointerShapeBufferSize' (IntPtr)ptrShapeBufferPtr' out pointerInfo.BufferSize' out OutputDuplicatePointerShapeInformation info); " is 171.
Long Statement,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,OnCreateProjectionMatrix,The length of the statement  "                projectionMatrix = CreateProjectionMatrix(IsPerspective' IsRightHand' scale' Fov' 0.001f' 100f' CameraDistance' CameraDistance); " is 128.
Long Statement,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,RenderAbsolutePositionOrtho,The length of the statement  "                deviceContext.SetScissorRectangle((int)Math.Round(offX)' (int)Math.Round(offY)' (int)(viewportSize + offX)' (int)(viewportSize + offY)); " is 136.
Long Statement,Core,SkyBoxRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SkyBoxRenderCore.cs,UpdateTexture,The length of the statement  "                    if(cubeTextureRes.TextureView != null && cubeTextureRes.TextureView.Description.Dimension == ShaderResourceViewDimension.TextureCube) " is 133.
Long Statement,Core,SkyDomeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SkyDomeRenderCore.cs,UpdateTexture,The length of the statement  "                    if (cubeTextureRes.TextureView != null && cubeTextureRes.TextureView.Description.Dimension == ShaderResourceViewDimension.TextureCube) " is 134.
Long Statement,Core.Components,ConstantBufferComponent,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Components\ConstantBufferComponent.cs,Upload,The length of the statement  "                        throw new ArgumentOutOfRangeException($"Try to write value out of range. StructureSize {structSize} > Internal Buffer Size {internalByteArray.Length}"); " is 152.
Long Statement,Core.Components,ConstantBufferComponent,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Components\ConstantBufferComponent.cs,WriteValueByName,The length of the statement  "                            throw new ArgumentException($"Input struct size {structSize} is larger than shader variable {variable.Name} size {variable.Size}"); " is 131.
Long Statement,Core.Components,ConstantBufferComponent,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Components\ConstantBufferComponent.cs,WriteValueByName,The length of the statement  "                        Technique.EffectsManager.Logger.Log(Logger.LogLevel.Warning' $"Variable not found in constant buffer {bufferDesc.Name}. Variable = {name}"); " is 140.
Long Statement,Core.Components,ConstantBufferComponent,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Components\ConstantBufferComponent.cs,WriteValue,The length of the statement  "                        throw new ArgumentOutOfRangeException($"Try to write value out of range. StructureSize {structSize} + Offset {offset} > Internal Buffer Size {internalByteArray.Length}"); " is 170.
Long Statement,Core.Components,ConstantBufferComponent,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Components\ConstantBufferComponent.cs,ReadValueByName,The length of the statement  "                            throw new ArgumentException($"Input struct size {structSize} is larger than shader variable {variable.Name} size {variable.Size}"); " is 131.
Long Statement,Core.Components,ConstantBufferComponent,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Components\ConstantBufferComponent.cs,ReadValueByName,The length of the statement  "                        Technique.EffectsManager.Logger.Log(Logger.LogLevel.Warning' $"Variable not found in constant buffer {bufferDesc.Name}. Variable = {name}"); " is 140.
Long Statement,Core.Components,ConstantBufferComponent,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Components\ConstantBufferComponent.cs,ReadValue,The length of the statement  "                        throw new ArgumentOutOfRangeException($"Try to read value out of range. StructureSize {structSize} + Offset {offset} > Internal Buffer Size {internalByteArray.Length}"); " is 169.
Long Statement,Shaders,ShaderDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Shaders\ShaderDescription.cs,CreateShader,The length of the statement  "                    logger?.Log(LogLevel.Warning' $"Shader {this.Name} requires FeatureLevel {Level}. Current device only supports FeatureLevel {device.FeatureLevel} and below."); " is 159.
Long Statement,Shaders,ShaderDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Shaders\ShaderDescription.cs,CreateShader,The length of the statement  "                    //throw new Exception($"Shader {this.Name} requires FeatureLevel {Level}. Current device only supports FeatureLevel {device.FeatureLevel} and below."); " is 151.
Long Statement,Helper,HelixToolkitByteCodeReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\DefaultShaders\UWPShaderReader.cs,Read,The length of the statement  "                var filePath = Path.Combine(Windows.ApplicationModel.Package.Current.InstalledLocation.Path' @"HelixToolkit.UWP" + @"\Resources\" + name + @".cso"); " is 148.
Long Statement,Animations,NodeAnimationUpdater,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Animations\KeyFrameUpdater.cs,UpdateNodes,The length of the statement  "                    while(idxTime.Index < count - 1 && accumulatedTime > frames[idxTime.Index+1].Time)//check if should move to next time frame " is 123.
Long Statement,ShaderManager,ConstantBufferPool,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\ConstantBufferPool.cs,ErrorCheck,The length of the statement  "                        $"Please refer and update to latest HelixToolkit.SharpDX.ShaderBuilder.CommonBuffers.hlsl. Link: https://github.com/helix-toolkit/helix-toolkit"); " is 146.
Long Statement,ShaderManager,ShaderPool,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\ShaderPool.cs,Create,The length of the statement  "                return description.ByteCode == null ? Constants.GetNullShader(description.ShaderType) : description.CreateShader(device' ConstantBufferPool' logger); " is 149.
Long Statement,ShaderManager,LayoutPool,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\ShaderPool.cs,Create,The length of the statement  "                return description.Key == null || description.Value == null ? null : new InputLayout(Device' description.Key' description.Value); " is 129.
Long Statement,Utilities,BitmapProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\BitmapProxy.cs,Create,The length of the statement  "                return new BitmapProxy(name' context' surface' CreateDescription(context.DotsPerInch.Width' context.DotsPerInch.Height' surface.Description.Format)); " is 149.
Long Statement,Utilities,BitmapProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\BitmapProxy.cs,Create,The length of the statement  "                return new BitmapProxy(name' context' size' CreateDescription(context.DotsPerInch.Width' context.DotsPerInch.Height' format' global::SharpDX.Direct2D1.AlphaMode.Premultiplied' BitmapOptions.Target)); " is 199.
Long Statement,Utilities,BoundableNodeOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\RenderableBoundingOctree.cs,HitTestCurrentNodeExcludeChild,The length of the statement  "                //var bound = Bound.Transform(modelMatrix);// BoundingBox.FromPoints(Bound.GetCorners().Select(x => Vector3.TransformCoordinate(x' modelMatrix)).ToArray()); " is 156.
Long Statement,Utilities,BoundableNodeOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\RenderableBoundingOctree.cs,Expand,The length of the statement  "                (newRoot as BoundableNodeOctree).TransferOctantDictionary(root' ref root.OctantDictionary);//Transfer the dictionary to new root " is 128.
Long Statement,Utilities,BoundableNodeOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\RenderableBoundingOctree.cs,Shrink,The length of the statement  "                (newRoot as BoundableNodeOctree).TransferOctantDictionary(root' ref root.OctantDictionary);//Transfer the dictionary to new root " is 128.
Long Statement,Utilities,InstancingRenderableOctreeManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeManager.cs,RebuildTree,The length of the statement  "                        //new InstancingModel3DOctree(instMatrix' (inst as SceneNode).OriginalBounds' this.Parameter' new Stack<KeyValuePair<int' IOctree[]>>(10)); " is 139.
Long Statement,Utilities,StaticLineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticLineGeometryOctree.cs,HitTestCurrentNodeExcludeChild,The length of the statement  "                        var rayToLineDistance = LineBuilder.GetRayToLineDistance(rayWS' t0' t1' out Vector3 sp' out Vector3 tp' out float sc' out float tc); " is 132.
Long Statement,Utilities,StaticLineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticLineGeometryOctree.cs,FindNearestPointBySphereExcludeChild,The length of the statement  "                            float distance = LineBuilder.GetPointToLineDistance2D(ref sphere.Center' ref v0' ref v1' out Vector3 cloestPoint' out float t); " is 127.
Long Statement,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,HitTest,The length of the statement  "                var rayModel = new Ray(Vector3.TransformCoordinate(rayWS.Position' modelInv)' Vector3.Normalize(Vector3.TransformNormal(rayWS.Direction' modelInv))); " is 149.
Long Statement,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateView,The length of the statement  "                            throw new ArgumentOutOfRangeException($"Texture width * height = {texture.Width * texture.Height} is larger than texture data length {texture.NonCompressedData.Length}."); " is 171.
Long Statement,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateView,The length of the statement  "                            CreateView(texture.NonCompressedData' texture.Width' texture.Height' texture.UncompressedFormat' true' disableAutoGenMipMap); " is 125.
Long Statement,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateView,The length of the statement  "                var texture = Collect(global::SharpDX.Toolkit.Graphics.Texture1D.New(device' Math.Min(array.Length' length)' format' array)); " is 125.
Long Statement,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateView,The length of the statement  "                    throw new ArgumentOutOfRangeException($"Width*Height*Depth = {width * height * depth} is larger than array size {pixels.Length}."); " is 131.
Long Statement,Utilities,ShaderResourceViewProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ShaderResourceViewProxy.cs,CreateView,The length of the statement  "                var img = global::SharpDX.Toolkit.Graphics.Image.New3D(width' height' depth' global::SharpDX.Toolkit.Graphics.MipMapCount.Auto' format' dataPtr); " is 145.
Long Statement,Utilities,ScreenCapture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ScreenCapture.cs,SaveWICTextureToFile,The length of the statement  "                using (WICStream stream = new WICStream(deviceResource.WICImgFactory' fileName' global::SharpDX.IO.NativeFileAccess.Write)) " is 123.
Long Statement,Utilities,ScreenCapture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ScreenCapture.cs,SaveWICTextureToBitmapStream,The length of the statement  "                        succ = CopyTextureToWICStream(deviceResource' staging' stream' pfGuid' BitmapExtensions.ToWICImageFormat(Direct2DImageFormat.Bmp)); " is 131.
Long Statement,Utilities,ScreenCapture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ScreenCapture.cs,CopyTextureToWICStream,The length of the statement  "                                frame.WritePixels(desc.Height' new global::SharpDX.DataRectangle(databox.DataPointer' databox.RowPitch)' databox.RowPitch * desc.Height); " is 137.
Long Statement,Utilities,TextureLoader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TextureLoader.cs,FromFileAsShaderResourceView,The length of the statement  "                    if (!disableAutoGenMipMap && texture.Description.MipLevels == 1)// Check if it already has mipmaps or not' if loaded DDS file' it may already has precompiled mipmaps' don't need to generate again " is 195.
Long Statement,Utilities,TextureLoader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TextureLoader.cs,FromMemoryAsShaderResourceView,The length of the statement  "                    if (!disableAutoGenMipMap && texture.Description.MipLevels == 1)// Check if it already has mipmaps or not' if loaded DDS file' it may already has precompiled mipmaps' don't need to generate again " is 195.
Long Statement,Utilities,TextureLoader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TextureLoader.cs,FromMemoryAsShaderResource,The length of the statement  "                    if (!disableAutoGenMipMap && texture.Description.MipLevels == 1)// Check if it already has mipmaps or not' if loaded DDS file' it may already has precompiled mipmaps' don't need to generate again " is 195.
Long Statement,Model,LineArrowHeadTailMaterialCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\LineArrowMaterialCore.cs,CreateMaterialVariables,The length of the statement  "                return new LineArrowMaterialVariable(manager' manager.GetTechnique(DefaultRenderTechniqueNames.LinesArrowHeadTail)' this); " is 122.
Long Statement,Model,BillboardMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\BillboardMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(BillboardMaterialCore.FixedSize)' () => { WriteValue(PointLineMaterialStruct.FixedSize' materialCore.FixedSize); }); " is 142.
Long Statement,Model,BillboardMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\BillboardMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(BillboardMaterialCore.Type)' () => { WriteValue(PointLineMaterialStruct.ParamsStr' new Vector4((int)materialCore.Type' 0' 0' 0)); }); " is 159.
Long Statement,Model,ColorStripeMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\ColorStripeMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                    WriteValue(PhongPBRMaterialStruct.HasDiffuseAlphaMapStr' material.ColorStripeYEnabled && (textureIndex & 1u << 1) != 0 ? 1 : 0); " is 128.
Long Statement,Model,ColorStripeMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\ColorStripeMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                    WriteValue(PhongPBRMaterialStruct.HasDiffuseAlphaMapStr' material.ColorStripeYEnabled && (textureIndex & 1u << 1) != 0 ? 1 : 0); " is 128.
Long Statement,Model,ColorStripeMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\ColorStripeMaterialVariable.cs,CreateTextureView,The length of the statement  "                textures[which] = (colors == null || colors.Count == 0) ? null : Collect(new ShaderResourceViewProxy(deviceResources.Device)); " is 126.
Long Statement,Model,DiffuseMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\DiffuseMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(DiffuseMaterialCore.EnableFlatShading)' () => { WriteValue(PhongPBRMaterialStruct.RenderFlat' material.EnableFlatShading); }); " is 152.
Long Statement,Model,LineArrowMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\LineArrowMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                    () => { WriteValue(PointLineMaterialStruct.ParamsStr' new Vector3(material.Thickness' material.Smoothness' material.ArrowSize)); }); " is 132.
Long Statement,Model,LineMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\LineMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(LineMaterialCore.LineColor)' () => { WriteValue(PointLineMaterialStruct.ColorStr' material.LineColor); }); " is 132.
Long Statement,Model,LineMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\LineMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(LineMaterialCore.Thickness)' () => { WriteValue(PointLineMaterialStruct.ParamsStr' new Vector2(material.Thickness' material.Smoothness)); }); " is 167.
Long Statement,Model,LineMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\LineMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(LineMaterialCore.Smoothness)' () => { WriteValue(PointLineMaterialStruct.ParamsStr' new Vector2(material.Thickness' material.Smoothness)); }); " is 168.
Long Statement,Model,LineMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\LineMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(LineMaterialCore.TextureScale)' () => { WriteValue(PointLineMaterialStruct.TextureScaleStr' material.TextureScale); }); " is 145.
Long Statement,Model,LineMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\LineMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(LineMaterialCore.AlphaThreshold)' () => { WriteValue(PointLineMaterialStruct.AlphaThresholdStr' material.AlphaThreshold); }); " is 151.
Long Statement,Model,LineMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\LineMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(LineMaterialCore.EnableDistanceFading)' () => { WriteValue(PointLineMaterialStruct.EnableDistanceFading' material.EnableDistanceFading ? 1 : 0); }); " is 174.
Long Statement,Model,LineMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\LineMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(LineMaterialCore.FadingNearDistance)' () => { WriteValue(PointLineMaterialStruct.FadeNearDistance' material.FadingNearDistance); }); " is 158.
Long Statement,Model,LineMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\LineMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(LineMaterialCore.FadingFarDistance)' () => { WriteValue(PointLineMaterialStruct.FadeFarDistance' material.FadingFarDistance); }); " is 155.
Long Statement,Model,LineMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\LineMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(LineMaterialCore.FixedSize)' () => { WriteValue(PointLineMaterialStruct.FixedSize' material.FixedSize); }); " is 133.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.AlbedoColor)' () => { WriteValue(PhongPBRMaterialStruct.DiffuseStr' material.AlbedoColor); }); " is 136.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.EmissiveColor)' () => { WriteValue(PhongPBRMaterialStruct.EmissiveStr' material.EmissiveColor); }); " is 141.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.MetallicFactor)' () => { WriteValue(PhongPBRMaterialStruct.ConstantMetallic' material.MetallicFactor); }); " is 148.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.RoughnessFactor)' () => { WriteValue(PhongPBRMaterialStruct.RoughnessStr' material.RoughnessFactor); }); " is 146.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.AmbientOcclusionFactor)' () => { WriteValue(PhongPBRMaterialStruct.AmbientOcclusionStr' material.AmbientOcclusionFactor); }); " is 167.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.ReflectanceFactor)' () => { WriteValue(PhongPBRMaterialStruct.ReflectanceStr' material.ReflectanceFactor); }); " is 152.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.ClearCoatStrength)' () => { WriteValue(PhongPBRMaterialStruct.ClearCoatStr' material.ClearCoatStrength); }); " is 150.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.ClearCoatRoughness)' () => { WriteValue(PhongPBRMaterialStruct.ClearCoatRoughnessStr' material.ClearCoatRoughness); }); " is 161.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.RenderAlbedoMap)' () => { WriteValue(PhongPBRMaterialStruct.HasDiffuseMapStr' material.RenderAlbedoMap && TextureResources[AlbedoMapIdx] != null ? 1 : 0); }); " is 200.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.RenderEmissiveMap)' () => { WriteValue(PhongPBRMaterialStruct.HasEmissiveMapStr' material.RenderEmissiveMap && TextureResources[EmissiveMapIdx] != null ? 1 : 0); }); " is 207.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.RenderNormalMap)' () => { WriteValue(PhongPBRMaterialStruct.HasNormalMapStr' material.RenderNormalMap && TextureResources[NormalMapIdx] != null ? 1 : 0); }); " is 199.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.RenderDisplacementMap)' () => { WriteValue(PhongPBRMaterialStruct.HasDisplacementMapStr' material.RenderDisplacementMap && TextureResources[DisplaceMapIdx] != null ? 1 : 0); }); " is 219.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.RenderIrradianceMap)' () => { WriteValue(PhongPBRMaterialStruct.HasIrradianceMapStr' material.RenderIrradianceMap && TextureResources[IrradianceMapIdx] != null ? 1 : 0); }); " is 215.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.RenderRoughnessMetallicMap)' () => { WriteValue(PhongPBRMaterialStruct.HasRMMapStr' material.RenderRoughnessMetallicMap && TextureResources[RMMapIdx] != null ? 1 : 0); }); " is 213.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.RenderAmbientOcclusionMap)' () => { WriteValue(PhongPBRMaterialStruct.HasAOMapStr' material.RenderAmbientOcclusionMap && TextureResources[AOMapIdx] != null ? 1 : 0); }); " is 211.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.EnableAutoTangent)' () => { WriteValue(PhongPBRMaterialStruct.EnableAutoTangent' material.EnableAutoTangent); }); " is 155.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.DisplacementMapScaleMask)' () => { WriteValue(PhongPBRMaterialStruct.DisplacementMapScaleMaskStr' material.DisplacementMapScaleMask); }); " is 179.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.RenderShadowMap)' () => { WriteValue(PhongPBRMaterialStruct.RenderShadowMapStr' material.RenderShadowMap ? 1 : 0); }); " is 160.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.RenderEnvironmentMap)' () => { WriteValue(PhongPBRMaterialStruct.HasCubeMapStr' material.RenderEnvironmentMap ? 1 : 0); }); " is 165.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.MaxTessellationDistance)' () => { WriteValue(PhongPBRMaterialStruct.MaxTessDistanceStr' material.MaxTessellationDistance); }); " is 168.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.MinTessellationDistance)' () => { WriteValue(PhongPBRMaterialStruct.MinTessDistanceStr' material.MinTessellationDistance); }); " is 168.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.MaxDistanceTessellationFactor)' () => { WriteValue(PhongPBRMaterialStruct.MaxDistTessFactorStr' material.MaxDistanceTessellationFactor); }); " is 182.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.MinDistanceTessellationFactor)' () => { WriteValue(PhongPBRMaterialStruct.MinDistTessFactorStr' material.MinDistanceTessellationFactor); }); " is 182.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.AlbedoMap)' () => { CreateTextureView(material.AlbedoMap' AlbedoMapIdx); TriggerPropertyAction(nameof(PBRMaterialCore.RenderAlbedoMap)); }); " is 182.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.EmissiveMap)' () => { CreateTextureView(material.EmissiveMap' EmissiveMapIdx); TriggerPropertyAction(nameof(PBRMaterialCore.RenderEmissiveMap)); }); " is 190.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.NormalMap)' () => { CreateTextureView(material.NormalMap' NormalMapIdx); TriggerPropertyAction(nameof(PBRMaterialCore.RenderNormalMap)); }); " is 182.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.IrradianceMap)' () => { CreateTextureView(material.IrradianceMap' IrradianceMapIdx); TriggerPropertyAction(nameof(PBRMaterialCore.RenderIrradianceMap)); }); " is 198.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.DisplacementMap)' () => { CreateTextureView(material.DisplacementMap' DisplaceMapIdx); TriggerPropertyAction(nameof(PBRMaterialCore.RenderDisplacementMap)); }); " is 202.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.RoughnessMetallicMap)' () => { CreateTextureView(material.RoughnessMetallicMap' RMMapIdx); TriggerPropertyAction(nameof(PBRMaterialCore.RenderRoughnessMetallicMap)); }); " is 211.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.AmbientOcculsionMap)' () => { CreateTextureView(material.AmbientOcculsionMap' AOMapIdx); TriggerPropertyAction(nameof(PBRMaterialCore.RenderAmbientOcclusionMap)); }); " is 208.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.SurfaceMapSampler)' () => { CreateSampler(material.SurfaceMapSampler' SurfaceSamplerIdx); }); " is 135.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.DisplacementMapSampler)' () => { CreateSampler(material.DisplacementMapSampler' DisplaceSamplerIdx); }); " is 146.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PBRMaterialCore.EnableFlatShading)' () => { WriteValue(PhongPBRMaterialStruct.RenderFlat' material.EnableFlatShading); }); " is 148.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,UpdateMappings,The length of the statement  "                    texDisplaceSlot = shaderPass.DomainShader.ShaderResourceViewMapping.TryGetBindSlot(DefaultBufferNames.DisplacementMapTB); " is 121.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,UpdateMappings,The length of the statement  "                    samplerDisplaceSlot = shaderPass.DomainShader.SamplerMapping.TryGetBindSlot(DefaultSamplerStateNames.DisplacementMapSampler); " is 125.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,UpdateMappings,The length of the statement  "                    texDisplaceSlot = shaderPass.VertexShader.ShaderResourceViewMapping.TryGetBindSlot(DefaultBufferNames.DisplacementMapTB); " is 121.
Long Statement,Model,PBRMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PBRMaterialVariable.cs,UpdateMappings,The length of the statement  "                    samplerDisplaceSlot = shaderPass.VertexShader.SamplerMapping.TryGetBindSlot(DefaultSamplerStateNames.DisplacementMapSampler); " is 125.
Long Statement,Model,PointMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PointMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PointMaterialCore.PointColor)' () => { WriteValue(PointLineMaterialStruct.ColorStr' material.PointColor); }); " is 135.
Long Statement,Model,PointMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PointMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PointMaterialCore.Width)' () => { WriteValue(PointLineMaterialStruct.ParamsStr' new Vector4(material.Width' material.Height' (int)material.Figure' material.FigureRatio)); }); " is 200.
Long Statement,Model,PointMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PointMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PointMaterialCore.Height)' () => { WriteValue(PointLineMaterialStruct.ParamsStr' new Vector4(material.Width' material.Height' (int)material.Figure' material.FigureRatio)); }); " is 201.
Long Statement,Model,PointMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PointMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PointMaterialCore.Figure)' () => { WriteValue(PointLineMaterialStruct.ParamsStr' new Vector4(material.Width' material.Height' (int)material.Figure' material.FigureRatio)); }); " is 201.
Long Statement,Model,PointMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PointMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PointMaterialCore.FigureRatio)' () => { WriteValue(PointLineMaterialStruct.ParamsStr' new Vector4(material.Width' material.Height' (int)material.Figure' material.FigureRatio)); }); " is 206.
Long Statement,Model,PointMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PointMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PointMaterialCore.EnableDistanceFading)' () => { WriteValue(PointLineMaterialStruct.EnableDistanceFading' material.EnableDistanceFading ? 1 : 0); }); " is 175.
Long Statement,Model,PointMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PointMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PointMaterialCore.FadingNearDistance)' () => { WriteValue(PointLineMaterialStruct.FadeNearDistance' material.FadingNearDistance); }); " is 159.
Long Statement,Model,PointMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PointMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PointMaterialCore.FadingFarDistance)' () => { WriteValue(PointLineMaterialStruct.FadeFarDistance' material.FadingFarDistance); }); " is 156.
Long Statement,Model,PointMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PointMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PointMaterialCore.FixedSize)' () => { WriteValue(PointLineMaterialStruct.FixedSize' material.FixedSize); }); " is 134.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.DiffuseColor)' () => { WriteValue(PhongPBRMaterialStruct.DiffuseStr' material.DiffuseColor); }); " is 140.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.AmbientColor)' () => { WriteValue(PhongPBRMaterialStruct.AmbientStr' material.AmbientColor); }); " is 140.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.EmissiveColor)' () => { WriteValue(PhongPBRMaterialStruct.EmissiveStr' material.EmissiveColor); }); " is 143.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.ReflectiveColor)' () => { WriteValue(PhongPBRMaterialStruct.ReflectStr' material.ReflectiveColor); }); " is 146.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.SpecularColor)' () => { WriteValue(PhongPBRMaterialStruct.SpecularStr' material.SpecularColor); }); " is 143.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.SpecularShininess)' () => { WriteValue(PhongPBRMaterialStruct.ShininessStr' material.SpecularShininess); }); " is 152.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.DisplacementMapScaleMask)' () => { WriteValue(PhongPBRMaterialStruct.DisplacementMapScaleMaskStr' material.DisplacementMapScaleMask); }); " is 181.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.RenderShadowMap)' ()=> { WriteValue(PhongPBRMaterialStruct.RenderShadowMapStr' material.RenderShadowMap ? 1 : 0); }); " is 161.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.RenderEnvironmentMap)' () => { WriteValue(PhongPBRMaterialStruct.HasCubeMapStr' material.RenderEnvironmentMap ? 1 : 0); }); " is 167.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.EnableAutoTangent)' () => { WriteValue(PhongPBRMaterialStruct.EnableAutoTangent' material.EnableAutoTangent); }); " is 157.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.MaxTessellationDistance)' () => { WriteValue(PhongPBRMaterialStruct.MaxTessDistanceStr' material.MaxTessellationDistance); }); " is 170.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.MaxDistanceTessellationFactor)' () => { WriteValue(PhongPBRMaterialStruct.MaxDistTessFactorStr' material.MaxDistanceTessellationFactor); }); " is 184.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.MinTessellationDistance)' () => { WriteValue(PhongPBRMaterialStruct.MinTessDistanceStr' material.MinTessellationDistance); }); " is 170.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.MinDistanceTessellationFactor)' () => { WriteValue(PhongPBRMaterialStruct.MinDistTessFactorStr' material.MinDistanceTessellationFactor); }); " is 184.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.RenderDiffuseMap)' () => { WriteValue(PhongPBRMaterialStruct.HasDiffuseMapStr' material.RenderDiffuseMap && textureResources[DiffuseIdx] != null ? 1 : 0); }); " is 202.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.RenderDiffuseAlphaMap)' () => { WriteValue(PhongPBRMaterialStruct.HasDiffuseAlphaMapStr' material.RenderDiffuseAlphaMap && textureResources[AlphaIdx] != null ? 1 : 0); }); " is 215.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.RenderNormalMap)' () => { WriteValue(PhongPBRMaterialStruct.HasNormalMapStr' material.RenderNormalMap && textureResources[NormalIdx] != null ? 1 : 0); }); " is 198.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.RenderSpecularColorMap)' () => { WriteValue(PhongPBRMaterialStruct.HasSpecularColorMap' material.RenderSpecularColorMap && textureResources[SpecularColorIdx] != null ? 1 : 0); }); " is 223.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.RenderDisplacementMap)' () => { WriteValue(PhongPBRMaterialStruct.HasDisplacementMapStr' material.RenderDisplacementMap && textureResources[DisplaceIdx] != null ? 1 : 0); }); " is 218.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.RenderEmissiveMap)' () => { WriteValue(PhongPBRMaterialStruct.HasEmissiveMapStr' material.RenderEmissiveMap && textureResources[EmissiveIdx] != null ? 1 : 0); }); " is 206.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.EnableFlatShading)' () => { WriteValue(PhongPBRMaterialStruct.RenderFlat' material.EnableFlatShading); }); " is 150.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,OnInitialPropertyBindings,The length of the statement  "                AddPropertyBinding(nameof(PhongMaterialCore.EnableTessellation)' () => { EnableTessellation = material.EnableTessellation; }); " is 126.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,UpdateMappings,The length of the statement  "                    texDisplaceSlot = shaderPass.DomainShader.ShaderResourceViewMapping.TryGetBindSlot(DefaultBufferNames.DisplacementMapTB); " is 121.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,UpdateMappings,The length of the statement  "                    samplerDisplaceSlot = shaderPass.DomainShader.SamplerMapping.TryGetBindSlot(DefaultSamplerStateNames.DisplacementMapSampler); " is 125.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,UpdateMappings,The length of the statement  "                    texDisplaceSlot = shaderPass.VertexShader.ShaderResourceViewMapping.TryGetBindSlot(DefaultBufferNames.DisplacementMapTB); " is 121.
Long Statement,Model,PhongMaterialVariables,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\PhongMaterialVariable.cs,UpdateMappings,The length of the statement  "                    samplerDisplaceSlot = shaderPass.VertexShader.SamplerMapping.TryGetBindSlot(DefaultSamplerStateNames.DisplacementMapSampler); " is 125.
Long Statement,Model.Components,GeometryBoundManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Components\GeometryBoundManager.cs,RaiseOnTransformBoundSphereChanged,The length of the statement  "                OnTransformBoundSphereChanged?.Invoke(elementCore' new BoundChangeArgs<BoundingSphere>(ref newBoundSphere' ref oldBoundSphere)); " is 128.
Long Statement,Model.Scene,BatchedMeshNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\BatchedMeshNode.cs,AttachMaterial,The length of the statement  "                    core.MaterialVariables = materialVariable = Collect(EffectsManager.MaterialVariableManager.Register(material' EffectTechnique)); " is 128.
Long Statement,Model.Scene,BatchedMeshNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\BatchedMeshNode.cs,CanHitTest,The length of the statement  "                return base.CanHitTest(context) && Geometries != null && Geometries.Length > 0 && Materials != null && Materials.Length > 0; " is 124.
Long Statement,Model.Scene,VolumeTextureNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\VolumeTextureNode.cs,AttachMaterial,The length of the statement  "                    materialVariable = core.MaterialVariables = Collect(EffectsManager.MaterialVariableManager.Register(material' EffectTechnique)); " is 128.
Long Statement,Model.Scene,GeometryNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\Abstract\GeometryNode.cs,TestViewFrustum,The length of the statement  "                return BoundingFrustumExtensions.Intersects(ref viewFrustum' ref BoundManager.BoundsWithTransform' ref BoundManager.BoundsSphereWithTransform); " is 143.
Long Statement,Model.Scene,MaterialGeometryNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\Abstract\MaterialGeometryNode.cs,AttachMaterial,The length of the statement  "                    materialVariable = core.MaterialVariables = Collect(EffectsManager.MaterialVariableManager.Register(material' EffectTechnique)); " is 128.
Long Statement,Model.Scene,BillboardNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\BillboardNode.cs,OnCreateBufferModel,The length of the statement  "                var buffer = geometry != null && geometry.IsDynamic ? EffectsManager.GeometryBufferManager.Register<DynamicBillboardBufferModel>(modelGuid' geometry)  " is 149.
Long Statement,Model.Scene,BillboardNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\BillboardNode.cs,TestViewFrustum,The length of the statement  "                return BoundingFrustumExtensions.Intersects(ref viewFrustum' ref BoundManager.BoundsSphereWithTransform);// viewFrustum.Intersects(ref sphere); " is 143.
Long Statement,Model.Scene,BillboardNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\BillboardNode.cs,OnHitTest,The length of the statement  "                    return (Geometry as BillboardBase).HitTest(context' totalModelMatrix' ref ray' ref hits' this.WrapperSource' c.FixedSize); " is 122.
Long Statement,Model.Scene,BoneSkinMeshNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\BoneSkinMeshNode.cs,OnCreateBufferModel,The length of the statement  "                return !(EffectsManager.GeometryBufferManager.Register<BoneSkinnedMeshBufferModel>(modelGuid' geometry) is IBoneSkinMeshBufferModel buffer) ?  " is 141.
Long Statement,Model.Scene,BoneSkinMeshNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\BoneSkinMeshNode.cs,OnCreateBufferModel,The length of the statement  "                    EmptyGeometryBufferModel.Empty : new BoneSkinPreComputeBufferModel(buffer' buffer.VertexStructSize.FirstOrDefault()) as IAttachableBufferModel; " is 143.
Long Statement,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The length of the statement  "                        labelText.TextInfo[which] = new TextInfo(label' new Vector3(arrowSize + 1.5f' 0' 0)) { Foreground = labelColor' Scale = 0.5f };                " is 127.
Long Statement,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The length of the statement  "                        labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' arrowSize + 1.5f' 0)) { Foreground = labelColor' Scale = 0.5f }; " is 127.
Long Statement,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The length of the statement  "                        labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' 0' arrowSize + 1.5f)) { Foreground = labelColor' Scale = 0.5f }; " is 127.
Long Statement,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The length of the statement  "                var colors = new Color4Collection(mesh.Colors == null ? Enumerable.Repeat<Color4>(Color.Black' mesh.Positions.Count) : mesh.Colors); " is 132.
Long Statement,Model.Scene,InstancingMeshNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\InstancingMeshNode.cs,HitTest,The length of the statement  "                        isHit = octreeManager.Octree.HitTest(context' this.WrapperSource' Geometry' TotalModelMatrixInternal' rayWS' ref boundHits); " is 124.
Long Statement,Model.Scene,ShadowMapNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\Lights\ShadowMapNode.cs,Core_OnUpdateLightSource,The length of the statement  "                    shadowCore.LightViewProjectMatrix = camera.CreateViewMatrix() * camera.CreateProjectionMatrix(shadowCore.Width / shadowCore.Height); " is 132.
Long Statement,Model.Scene,LineNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\LineNode.cs,OnCreateBufferModel,The length of the statement  "                return geometry != null && geometry.IsDynamic ? EffectsManager.GeometryBufferManager.Register<DynamicLineGeometryBufferModel>(modelGuid' geometry)  " is 146.
Long Statement,Model.Scene,LineNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\LineNode.cs,OnHitTest,The length of the statement  "                return (Geometry as LineGeometry3D).HitTest(context' totalModelMatrix' ref ray' ref hits' this.WrapperSource' (float)HitTestThickness); " is 135.
Long Statement,Model.Scene,MeshNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\MeshNode.cs,OnCreateBufferModel,The length of the statement  "                return geometry != null && geometry.IsDynamic ? EffectsManager.GeometryBufferManager.Register<DynamicMeshGeometryBufferModel>(modelGuid' geometry) " is 146.
Long Statement,Model.Scene,PointNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\PointNode.cs,OnCreateBufferModel,The length of the statement  "                return geometry != null && geometry.IsDynamic ? EffectsManager.GeometryBufferManager.Register<DynamicPointGeometryBufferModel>(modelGuid' geometry)  " is 147.
Long Statement,Model.Scene,PointNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\PointNode.cs,OnHitTest,The length of the statement  "                return (Geometry as PointGeometry3D).HitTest(context' totalModelMatrix' ref ray' ref hits' this.WrapperSource' (float)HitTestThickness); " is 136.
Long Statement,Model.Scene,ScreenSpacedNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ScreenSpacedNode.cs,CreateAbsoluteModeRay,The length of the statement  "                    newRay = RayExtensions.UnProject(new Vector2(point2d.X' point2d.Y)' ref viewMatrix' ref projMatrix' screenSpaceCore.GlobalTransform.Frustum.Z' " is 142.
Long Statement,Model.Scene,SortingGroupNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\SortingGroupNode.cs,Sort,The length of the statement  "                    sortingTransparentCache.Sort(delegate (SortStruct a' SortStruct b) { return a.Key > b.Key ? -1 : a.Key < b.Key ? 1 : 0; }); " is 123.
Long Statement,Model.Scene,SortingGroupNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\SortingGroupNode.cs,Sort,The length of the statement  "                            sortingTransparentCache.Sort(delegate (SortStruct a' SortStruct b) { return a.Key > b.Key ? -1 : a.Key < b.Key ? 1 : 0; }); " is 123.
Long Statement,Model.Scene,SortingGroupNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\SortingGroupNode.cs,Sort,The length of the statement  "                        sortingTransparentCache.Sort(delegate (SortStruct a' SortStruct b) { return a.Key > b.Key ? -1 : a.Key < b.Key ? 1 : 0; }); " is 123.
Long Statement,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,CreateTextureCoordinates,The length of the statement  "                    mesh.TextureCoordinates[i] = new Vector2(mesh.TextureCoordinates[i].X * inc + inc * (int)(i / segment)' mesh.TextureCoordinates[i].Y); " is 134.
Long Statement,Render,DefaultRenderHost,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\DefaultRenderHostPartial_Properties.cs,SeparateRenderables,The length of the statement  "                    transparentPartitioner = transparentNodes.Count > 0 ? Partitioner.Create(0' transparentNodes.Count' FrustumPartitionSize) : null; " is 129.
Long Statement,Render,DefaultRenderHost,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\DefaultRenderHostPartial_Properties.cs,OnRender,The length of the statement  "                    renderParameter.RenderTargetView = new global::SharpDX.Direct3D11.RenderTargetView[] { RenderBuffer.FullResPPBuffer.CurrentRTV }; " is 129.
Long Statement,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,DrawIndexedInstanced,The length of the statement  "                deviceContext.DrawIndexedInstanced(indexCountPerInstance' instanceCount' startIndexLocation' baseVertexLocation' startIndexLocation); " is 133.
Long Statement,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,UpdateSubresourceSafe,The length of the statement  "                deviceContext.UpdateSubresourceSafe(ref data' resource' srcBytesPerElement' subresource' rowPitch' depthPitch' isCompressedResource); " is 133.
Long Statement,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,CopySubresourceRegion,The length of the statement  "                deviceContext.CopySubresourceRegion(source' sourceSubresource' sourceRegion' destination' destinationSubResource' dstX' dstY' dstZ); " is 132.
Long Statement,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,SetBlendState,The length of the statement  "                if (AutoSkipRedundantStateSetting && currBlendState == blendState && blendFactor == currBlendFactor && currSampleMask == sampleMask) " is 132.
Long Statement,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,SetBlendState,The length of the statement  "                if (AutoSkipRedundantStateSetting && currBlendState == blendState && blendFactor == currBlendFactor && currSampleMask == sampleMask) " is 132.
Long Statement,Render,TexturePool,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\ColorBufferPool.cs,Get,The length of the statement  "                            texture.CreateView(new DepthStencilViewDescription() { Format = Format.D32_Float' Dimension = DepthStencilViewDimension.Texture2D }); " is 133.
Long Statement,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,SetDefaultRenderTargets,The length of the statement  "                context.SetRenderTargets(isColorBuffer ? depthStencilBuffer : null' new RenderTargetView[] { isColorBuffer ? colorBuffer : backBuffer }); " is 137.
Long Statement,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,SetDefaultRenderTargets,The length of the statement  "                //context.OutputMerger.SetTargets(depthStencilBuffer' new RenderTargetView[] { isColorBuffer ? colorBuffer : backBuffer }); " is 123.
Long Statement,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,ClearRenderTarget,The length of the statement  "                    context.ClearDepthStencilView(depthStencilBuffer' DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil' 1.0f' 0); " is 122.
Long Statement,Render,DX11SwapChainCompositionRenderBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11SwapChainCompositionRenderBufferProxy.cs,OnCreateBackBuffer,The length of the statement  "                    swapChain.ResizeBuffers(swapChain.Description1.BufferCount' TargetWidth' TargetHeight' swapChain.Description.ModeDescription.Format' swapChain.Description.Flags); " is 162.
Long Statement,Render,DX11SwapChainCompositionRenderBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11SwapChainCompositionRenderBufferProxy.cs,CreateSwapChain,The length of the statement  "                    using (global::SharpDX.DXGI.SwapChain1 swapChain1 = new global::SharpDX.DXGI.SwapChain1(dxgiFactory2' Device' ref desc)) " is 120.
Long Statement,Render,DX11SwapChainCompositionRenderBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11SwapChainCompositionRenderBufferProxy.cs,Present,The length of the statement  "                    if (desc == global::SharpDX.DXGI.ResultCode.DeviceRemoved || desc == global::SharpDX.DXGI.ResultCode.DeviceReset || desc == global::SharpDX.DXGI.ResultCode.DeviceHung) " is 167.
Long Statement,Render,DX11SwapChainRenderBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11SwapChainRenderBufferProxy.cs,OnCreateBackBuffer,The length of the statement  "                    swapChain.ResizeBuffers(swapChain.Description1.BufferCount' TargetWidth' TargetHeight' swapChain.Description.ModeDescription.Format' swapChain.Description.Flags); " is 162.
Long Statement,Render,DX11SwapChainRenderBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11SwapChainRenderBufferProxy.cs,Present,The length of the statement  "                    if (desc == global::SharpDX.DXGI.ResultCode.DeviceRemoved || desc == global::SharpDX.DXGI.ResultCode.DeviceReset || desc == global::SharpDX.DXGI.ResultCode.DeviceHung) " is 167.
Long Statement,Render,ImmediateContextRenderer,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\Renderer\ImmediateContextRenderer.cs,RenderToPingPongBuffer,The length of the statement  "                    ImmediateContext.ResolveSubresource(parameter.CurrentTargetTexture' 0' buffer.FullResPPBuffer.CurrentTexture' 0' buffer.Format); " is 128.
Long Statement,Render,ImmediateContextRenderer,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\Renderer\ImmediateContextRenderer.cs,RenderScreenSpaced,The length of the statement  "                    var depthStencilBuffer = useDefault ? buffer.DepthStencilBuffer : context.GetOffScreenDS(OffScreenTextureSize.Full' Format.D32_Float_S8X24_UInt); " is 145.
Long Statement,Render,DX11RenderHostBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\RenderHostBase.cs,UpdateAndRender,The length of the statement  "                            renderStatistics.NumDrawCalls = renderer.ImmediateContext.ResetDrawCalls() + EffectsManager.DeviceContextPool.ResetDrawCalls(); " is 127.
Long Statement,Render,DX11RenderHostBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\RenderHostBase.cs,StartD3D,The length of the statement  "                immediateDeviceContext = Collect(new DeviceContextProxy(effectsManager.Device.ImmediateContext1' effectsManager.Device)); " is 121.
Long Statement,Render,DX11RenderHostBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\RenderHostBase.cs,StartD3D,The length of the statement  "                immediateDeviceContext = Collect(new DeviceContextProxy(effectsManager.Device.ImmediateContext' effectsManager.Device)); " is 120.
Long Statement,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,Render,The length of the statement  "                EnsureBitmapCache(context' new Size2((int)Math.Ceiling(LayoutClipBound.Width)' (int)Math.Ceiling(LayoutClipBound.Height))' context.DeviceContext.MaximumBitmapSize); " is 164.
Long Statement,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,Arrange,The length of the statement  "                var arrangeResultSize = ArrangeOverride(new RectangleF(Margin.Left' Margin.Top' arrangeSize.X - MarginWidthHeight.X' arrangeSize.Y - MarginWidthHeight.Y)).ToVector2(); " is 167.
Long Statement,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,Arrange,The length of the statement  "                var clippedArrangeResultSize = new Vector2(Math.Min(arrangeResultSize.X' maxSize.X)' Math.Min(arrangeResultSize.Y' maxSize.Y)); " is 127.
Long Statement,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,Arrange,The length of the statement  "                var clientSize = new Vector2(Math.Max(0' rectWidthHeight.X - MarginWidthHeight.X)' Math.Max(0' rectWidthHeight.Y - MarginWidthHeight.Y)); " is 137.
Long Statement,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,Arrange,The length of the statement  "                if ((tempHorizontalAlign == HorizontalAlignment.Center || tempHorizontalAlign == HorizontalAlignment.Stretch) && clientSize.X >= clippedArrangeResultSize.X) " is 156.
Long Statement,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,Arrange,The length of the statement  "                if ((tempVerticalAlign == VerticalAlignment.Center || tempVerticalAlign == VerticalAlignment.Stretch) && clientSize.Y >= clippedArrangeResultSize.Y) " is 148.
Long Statement,Model.Scene2D,BorderNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\BorderNode2D.cs,MeasureOverride,The length of the statement  "                    var childAvail = new Size2F(Math.Max(0' availableSize.Width - margin.Width)' Math.Max(0' availableSize.Height - margin.Height)); " is 128.
Long Statement,Model.Scene2D,BorderNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\BorderNode2D.cs,MeasureOverride,The length of the statement  "                    return new Size2F((float)(BorderThickness.Left / 2 + Padding.Left + BorderThickness.Right / 2 + Padding.Right + MarginWidthHeight.X + Width == float.PositiveInfinity ? 0 : Width)' " is 179.
Long Statement,Model.Scene2D,BorderNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\BorderNode2D.cs,MeasureOverride,The length of the statement  "                        (float)(BorderThickness.Top / 2 + Padding.Top + BorderThickness.Bottom / 2 + Padding.Bottom + MarginWidthHeight.Y + Height == float.PositiveInfinity ? 0 : Height)); " is 164.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The length of the statement  "            if ((header.PixelFormat.Flags & DDS.PixelFormatFlags.FourCC) != 0 && (new FourCC('D'' 'X'' '1'' '0') == header.PixelFormat.FourCC)) " is 131.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The length of the statement  "                        throw new InvalidOperationException(string.Format("Unexpected dimension [{0}] from DDS HeaderDX10"' headerDX10.ResourceDimension)); " is 131.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The length of the statement  "                if ((description.ArraySize != 6) || (description.Dimension != TextureDimension.Texture2D) || (description.Dimension != TextureDimension.TextureCube)) " is 149.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The length of the statement  "            Image.ComputePitch(description.Format' description.Width' description.Height' out rowPitch' out slicePitch' out newWidth' out newHeight); " is 137.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LoadFromDDSMemory,The length of the statement  "            var image = CreateImageFromDDS(pSource' offset' size - offset' mdata' (flags & DDSFlags.LegacyDword) != 0 ? Image.PitchFlags.LegacyDword : Image.PitchFlags.None' convFlags' pal8' handle); " is 187.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The length of the statement  "                else if ((convFlags & (ConversionFlags.Format565 | ConversionFlags.Format5551 | ConversionFlags.Format4444 | ConversionFlags.Format8332 | ConversionFlags.FormatA8P8)) != 0) " is 172.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The length of the statement  "            var isCopyNeeded = (convFlags & (ConversionFlags.Expand | ConversionFlags.CopyMemory)) != 0 || ((cpFlags & Image.PitchFlags.LegacyDword) != 0); " is 143.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The length of the statement  "                                        ExpandScanline(pDest' dpitch' pSrc' spitch' (convFlags & ConversionFlags.Format565) != 0 ? DXGI.Format.B5G6R5_UNorm : DXGI.Format.B5G5R5A1_UNorm' tflags); " is 154.
Long Statement,SharpDX.Toolkit.Graphics,DepthStencilBuffer,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,GetDepthStencilView,The length of the statement  "                        dsvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? DepthStencilViewDimension.Texture2DMultisampledArray : DepthStencilViewDimension.Texture2DArray; " is 170.
Long Statement,SharpDX.Toolkit.Graphics,DepthStencilBuffer,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,GetDepthStencilView,The length of the statement  "                        dsvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? DepthStencilViewDimension.Texture2DMultisampled : DepthStencilViewDimension.Texture2D; " is 160.
Long Statement,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New1D,The length of the statement  "            return new Image(CreateDescription(TextureDimension.Texture1D' width' 1' 1' mipMapCount' format' arraySize)' dataPointer' 0' null' false); " is 138.
Long Statement,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New2D,The length of the statement  "            return new Image(CreateDescription(TextureDimension.Texture2D' width' height' 1' mipMapCount' format' arraySize)' dataPointer' 0' null' false); " is 143.
Long Statement,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,NewCube,The length of the statement  "            return new Image(CreateDescription(TextureDimension.TextureCube' width' width' 1' mipMapCount' format' 6)' dataPointer' 0' null' false); " is 136.
Long Statement,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New3D,The length of the statement  "            return new Image(CreateDescription(TextureDimension.Texture3D' width' width' depth' mipMapCount' format' 1)' dataPointer' 0' null' false); " is 138.
Long Statement,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The length of the statement  "                    description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.Depth' description.MipLevels); " is 132.
Long Statement,SharpDX.Toolkit.Graphics,ImageDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,Equals,The length of the statement  "            return Dimension.Equals(other.Dimension) && Width == other.Width && Height == other.Height && Depth == other.Depth && ArraySize == other.ArraySize && MipLevels == other.MipLevels && Format.Equals(other.Format); " is 210.
Long Statement,SharpDX.Toolkit.Graphics,ImageDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,ToString,The length of the statement  "            return string.Format("Dimension: {0}' Width: {1}' Height: {2}' Depth: {3}' Format: {4}' ArraySize: {5}' MipLevels: {6}"' Dimension' Width' Height' Depth' Format' ArraySize' MipLevels); " is 184.
Long Statement,SharpDX.Toolkit.Graphics,MipMapDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,Equals,The length of the statement  "            return this.Width == other.Width && this.Height == other.Height && this.WidthPacked == other.WidthPacked && this.HeightPacked == other.HeightPacked && this.Depth == other.Depth && this.RowStride == other.RowStride && this.MipmapSize == other.MipmapSize && this.DepthStride == other.DepthStride; " is 294.
Long Statement,SharpDX.Toolkit.Graphics,PixelBuffer,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs,CopyTo,The length of the statement  "                throw new ArgumentException("Invalid destination pixelBufferArray. Mush have same Width' Height and Format"' "pixelBuffer"); " is 124.
Long Statement,SharpDX.Toolkit.Graphics,PixelBuffer,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs,GetPixels,The length of the statement  "                throw new ArgumentException(string.Format("Invalid sizeof(T)' not a multiple of current size [{0}]in bytes "' totalSize)); " is 122.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget1D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,New,The length of the statement  "            return new RenderTarget1D(device' NewRenderTargetDescription(width' format' flags | TextureFlags.RenderTarget' mipCount' arraySize)); " is 133.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget2D.cs,GetRenderTargetView,The length of the statement  "                        rtvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? RenderTargetViewDimension.Texture2DMultisampledArray : RenderTargetViewDimension.Texture2DArray; " is 170.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget2D.cs,GetRenderTargetView,The length of the statement  "                        rtvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? RenderTargetViewDimension.Texture2DMultisampled : RenderTargetViewDimension.Texture2D; " is 160.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,New,The length of the statement  "            return new RenderTarget3D(device' NewRenderTargetDescription(width' height' depth' format' flags | TextureFlags.RenderTarget' mipCount)); " is 137.
Long Statement,SharpDX.Toolkit.Graphics,RenderTargetCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTargetCube.cs,New,The length of the statement  "            return new RenderTargetCube(device' NewRenderTargetDescription(size' format' flags | TextureFlags.RenderTarget' mipCount)); " is 123.
Long Statement,SharpDX.Toolkit.Graphics,Texture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,CalculatePixelDataCount,The length of the statement  "            return CalculateWidth<TData>(mipLevel) * CalculateMipSize(Description.Height' mipLevel) * CalculateMipSize(Description.Depth' mipLevel); " is 136.
Long Statement,SharpDX.Toolkit.Graphics,Texture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,OnPropertyChanged,The length of the statement  "                            if (shaderResourceView != null) shaderResourceView.View.DebugName = Name == null ? null : String.Format("{0} SRV[{1}]"' i' Name); " is 129.
Long Statement,SharpDX.Toolkit.Graphics,Texture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,OnPropertyChanged,The length of the statement  "                            if (renderTargetView != null) renderTargetView.View.DebugName = Name == null ? null : String.Format("{0} RTV[{1}]"' i' Name); " is 125.
Long Statement,SharpDX.Toolkit.Graphics,Texture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,OnPropertyChanged,The length of the statement  "                            if (unorderedAccessView != null) unorderedAccessView.DebugName = Name == null ? null : String.Format("{0} UAV[{1}]"' i' Name); " is 126.
Long Statement,SharpDX.Toolkit.Graphics,TextureViewKey,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,Equals,The length of the statement  "                return ViewFormat == other.ViewFormat && ViewType == other.ViewType && ArrayOrDepthSlice == other.ArrayOrDepthSlice && MipIndex == other.MipIndex; " is 146.
Long Statement,SharpDX.Toolkit.Graphics,Texture1D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The length of the statement  "                texture = new Texture1D(device' NewDescription(width' format' flags' 1' 1' usage)' GetDataBox(format' width' 1' 1' textureData' ptr)); " is 134.
Long Statement,SharpDX.Toolkit.Graphics,Texture1DBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1DBase.cs,GetUnorderedAccessView,The length of the statement  "                        Dimension = this.Description.ArraySize > 1 ? UnorderedAccessViewDimension.Texture1DArray : UnorderedAccessViewDimension.Texture1D " is 129.
Long Statement,SharpDX.Toolkit.Graphics,Texture1DBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1DBase.cs,NewDescription,The length of the statement  "            if ((desc.BindFlags & BindFlags.RenderTarget) != 0 && (desc.BindFlags & BindFlags.ShaderResource) != 0 && desc.MipLevels > 1) " is 125.
Long Statement,SharpDX.Toolkit.Graphics,Texture2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The length of the statement  "                texture = New(device' width' height' 1' format' new[] { GetDataBox(format' width' height' 1' textureData' ptr) }' flags' 1' usage); " is 131.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,GetShaderResourceView,The length of the statement  "                            srvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? ShaderResourceViewDimension.Texture2DMultisampledArray : ShaderResourceViewDimension.Texture2DArray; " is 174.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,GetShaderResourceView,The length of the statement  "                        srvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? ShaderResourceViewDimension.Texture2DMultisampled : ShaderResourceViewDimension.Texture2D; " is 164.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,GetUnorderedAccessView,The length of the statement  "                        Dimension = this.Description.ArraySize > 1 ? UnorderedAccessViewDimension.Texture2DArray : UnorderedAccessViewDimension.Texture2D " is 129.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,NewDescription,The length of the statement  "            if ((desc.BindFlags & BindFlags.RenderTarget) != 0 && (desc.BindFlags & BindFlags.ShaderResource) != 0 && desc.MipLevels > 1) " is 125.
Long Statement,SharpDX.Toolkit.Graphics,Texture3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The length of the statement  "                texture = New(device' width' height' depth' 1' format' new[] { GetDataBox(format' width' height' depth' textureData' ptr) }' flags' usage); " is 139.
Long Statement,SharpDX.Toolkit.Graphics,Texture3DBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3DBase.cs,NewDescription,The length of the statement  "            if ((desc.BindFlags & BindFlags.RenderTarget) != 0 && (desc.BindFlags & BindFlags.ShaderResource) != 0 && desc.MipLevels > 1) " is 125.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "            return new TextureCube(device' NewTextureCubeDescription(size' format' flags | TextureFlags.ShaderResource' mipCount' usage)); " is 126.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "            return new TextureCube(device' NewTextureCubeDescription(size' format' flags | TextureFlags.ShaderResource' 1' usage)' dataBox1' dataBox2' dataBox3' dataBox4' dataBox5' dataBox6); " is 179.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "            return new TextureCube(device' NewTextureCubeDescription(size' format' flags | TextureFlags.ShaderResource' 1' usage)' textureData); " is 132.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "            return new TextureCube(device' CreateTextureDescriptionFromImage(image' flags | TextureFlags.ShaderResource' usage)' image.ToDataBox()); " is 136.
Long Statement,SharpDX.Toolkit.Graphics,TextureDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,ToStagingDescription,The length of the statement  "            copy.OptionFlags = copy.Dimension == TextureDimension.TextureCube ? ResourceOptionFlags.TextureCube : ResourceOptionFlags.None; " is 127.
Long Statement,SharpDX.Toolkit.Graphics,TextureDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,Equals,The length of the statement  "            return Dimension.Equals(other.Dimension) && Width == other.Width && Height == other.Height && Depth == other.Depth && ArraySize == other.ArraySize && MipLevels == other.MipLevels && Format.Equals(other.Format) && SampleDescription.Equals(other.SampleDescription) && Usage.Equals(other.Usage) && BindFlags.Equals(other.BindFlags) && CpuAccessFlags.Equals(other.CpuAccessFlags) && OptionFlags.Equals(other.OptionFlags); " is 417.
Long Statement,SharpDX.Toolkit.Graphics,TextureView,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureView.cs,Initialize,The length of the statement  "                        throw new ArgumentException("Expecting argument to be a ShaderResourceView' RenderTargetView or DepthStencilView"' "view"); " is 123.
Long Statement,SharpDX.Toolkit.Graphics,WICHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The length of the statement  "                using (var source = new Bitmap(Factory' image.Width' image.Height' pfGuid' new DataRectangle(image.DataPointer' image.RowStride)' image.BufferStride)) " is 150.
Long Statement,Utilities.ImagePacker,ArevaloRectanglePacker,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImagePacker\ArevaloRectanglePacker.cs,TryPack,The length of the statement  "			    int anchorIndex = SelectAnchorRecursive(rectangleWidth' rectangleHeight' actualPackingAreaWidth' actualPackingAreaHeight); " is 122.
Long Statement,Utilities.ImagePacker,ArevaloRectanglePacker,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImagePacker\ArevaloRectanglePacker.cs,SelectAnchorRecursive,The length of the statement  "			    int freeAnchorIndex = FindFirstFreeAnchor(rectangleWidth' rectangleHeight' testedPackingAreaWidth' testedPackingAreaHeight); " is 124.
Long Statement,Utilities.ImagePacker,ArevaloRectanglePacker,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImagePacker\ArevaloRectanglePacker.cs,SelectAnchorRecursive,The length of the statement  "				    return SelectAnchorRecursive(rectangleWidth' rectangleHeight' testedPackingAreaWidth' Math.Min(testedPackingAreaHeight*2' PackingAreaHeight)); " is 142.
Long Statement,Utilities.ImagePacker,ArevaloRectanglePacker,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImagePacker\ArevaloRectanglePacker.cs,SelectAnchorRecursive,The length of the statement  "				    return SelectAnchorRecursive(rectangleWidth' rectangleHeight' Math.Min(testedPackingAreaWidth*2' PackingAreaWidth)' testedPackingAreaHeight); " is 141.
Long Statement,Utilities.ImagePacker,ArevaloRectanglePacker,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImagePacker\ArevaloRectanglePacker.cs,IsFree,The length of the statement  "			    bool leavesPackingArea = (rectangle.X < 0) || (rectangle.Y < 0) || (rectangle.Right > testedPackingAreaWidth) || (rectangle.Bottom > testedPackingAreaHeight); " is 158.
Long Statement,Utilities.ImagePacker,SpritePackerBase<T;E>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImagePacker\SpritePackerBase.cs,TestPackingImages,The length of the statement  "                    if (!rectanglePacker.TryPack((int)Math.Ceiling(size.Width + padding)' (int)Math.Ceiling(size.Height + padding)' out Point origin)) " is 130.
Complex Conditional,HelixToolkit.SharpDX.Core,BoundingSphereExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BoundingSphereExtensions.cs,FromPoints,The conditional expression  "points == null || start < 0 || start >= points.Count || count < 0 || (start + count) > points.Count"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,ToColor4,The conditional expression  "text.Length >= 2 && (text[0] == '\'' || text[0] == '"') && text[0] == text[text.Length - 1]"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,ToColor4,The conditional expression  "(text.Length == 7 && text[0] == '#') ||                                   (text.Length == 8 && (text.StartsWith("0x") || text.StartsWith("0X"))) ||                                   (text.Length == 8 && (text.StartsWith("&h") || text.StartsWith("&H")))"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,BillboardImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardImage3D.cs,HitTest,The conditional expression  "!IsInitialized || context == null || (!fixedSize && !BoundingSphere.TransformBoundingSphere(modelMatrix).Intersects(ref rayWS))"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,BoneSkinnedMeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BoneSkinnedMeshGeometry3D.cs,HitTestWithSkinnedVertices,The conditional expression  "skinnedVertices == null || skinnedVertices.Length == 0                  || Indices == null || Indices.Count == 0"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,BillboardSingleImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleImage3D.cs,HitTest,The conditional expression  "!IsInitialized || context == null || Width == 0 || Height == 0 || (!fixedSize && !BoundingSphere.TransformBoundingSphere(modelMatrix).Intersects(ref rayWS))"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,BillboardSingleText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleText3D.cs,HitTest,The conditional expression  "!IsInitialized || context == null || Width == 0 || Height == 0 || (!fixedSize && !BoundingSphere.TransformBoundingSphere(modelMatrix).Intersects(ref rayWS))"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,BillboardText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardText3D.cs,HitTest,The conditional expression  "!IsInitialized || context == null || Width == 0 || Height == 0 || (!fixedSize && !BoundingSphere.TransformBoundingSphere(modelMatrix).Intersects(ref rayWS))"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,Geometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\Geometry3D.cs,UpdateBounds,The conditional expression  "Bound.Maximum.IsUndefined() || Bound.Minimum.IsUndefined() || BoundingSphere.Center.IsUndefined()                  || float.IsInfinity(Bound.Center.X) || float.IsInfinity(Bound.Center.Y) || float.IsInfinity(Bound.Center.Z)"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,LineGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\LineGeometry3D.cs,HitTest,The conditional expression  "Positions == null || Positions.Count == 0                  || Indices == null || Indices.Count == 0"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,MeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\MeshGeometry3D.cs,HitTest,The conditional expression  "Positions == null || Positions.Count == 0                  || Indices == null || Indices.Count == 0"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,EffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\EffectsManager.cs,GetBestAdapter,The conditional expression  "(bestAdapter == null) || (videoMemory > bestVideoMemory) || ((videoMemory == bestVideoMemory) && (systemMemory > bestSystemMemory))"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,PathHelpers,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,GetFullPath,The conditional expression  "path.Length > 1                      && (path[0] == Path.DirectorySeparatorChar || path[0] == Path.AltDirectorySeparatorChar)                      && (path[1] != Path.DirectorySeparatorChar && path[1] != Path.AltDirectorySeparatorChar)"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,IsDigitChar,The conditional expression  "input == '-' || input == '+' || input == '0' || input == '1' || input == '2' || input == '3' || input == '4' || input == '5' || input == '6' || input == '7' || input == '8' || input == '9' || input == '.'"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,TryReadAscii,The conditional expression  "line.Length == 0 || line.StartsWith("\0") || line.StartsWith("#") || line.StartsWith("!")                      || line.StartsWith("$")"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,CreateOctants,The conditional expression  "dimensions == Vector3.Zero || (dimensions.X < minSize && dimensions.Y < minSize && dimensions.Z < minSize)"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,GetCircle,The conditional expression  "(!closed && !CircleCache.Value.TryGetValue(thetaDiv' out circle)) ||                  (closed && !ClosedCircleCache.Value.TryGetValue(thetaDiv' out circle))"  is complex.
Complex Conditional,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The conditional expression  "selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1))"  is complex.
Complex Conditional,Core,BoneSkinRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\BoneSkinRenderCore.cs,OnUpdate,The conditional expression  "preComputeBoneSkinPass.IsNULL || preComputeBoneBuffer == null || !preComputeBoneBuffer.CanPreCompute || !matricsChanged"  is complex.
Complex Conditional,Core,Sprite2DBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\SpriteBufferModel.cs,UpdateBuffers,The conditional expression  "SpriteCount == 0 || IndexCount == 0 || Sprites == null || Indices == null || Sprites.Length < SpriteCount || Indices.Length < IndexCount"  is complex.
Complex Conditional,Core,OrderIndependentTransparentRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\OrderIndependantTransparentRenderCore.cs,CreateTextureResources,The conditional expression  "width != (int)context.ActualWidth || height != (int)context.ActualHeight                      || sampleDesc.Count != currSampleDesc.Count || sampleDesc.Quality != currSampleDesc.Quality"  is complex.
Complex Conditional,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessCursor,The conditional expression  "pointerResource == null || currentType != pointer.ShapeInfo.Type                          || pointerTexDesc.Width != width || pointerTexDesc.Height != height"  is complex.
Complex Conditional,Core,DuplicationResource,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,RetrieveCursorMetadata,The conditional expression  "frameInfo.PointerPosition.Visible && pointerInfo.Visible && (pointerInfo.WhoUpdatedPositionLast != outputDevice) && (pointerInfo.LastTimeStamp > frameInfo.LastMouseUpdateTime)"  is complex.
Complex Conditional,Core,SkyDomeBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SkyDomeRenderCore.cs,OnCreateVertexBuffer,The conditional expression  "bufferIndex == 0 && geometry != null && geometry.Positions != null && geometry.Positions.Count > 0"  is complex.
Complex Conditional,Utilities,DynamicBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ElementsBufferProxy.cs,EnsureBufferCapacity,The conditional expression  "buffer == null || Capacity < bytes || (!LazyResize && Capacity != bytes)"  is complex.
Complex Conditional,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctants,The conditional expression  "dimensions == Vector3.Zero || (dimensions.X < minSize || dimensions.Y < minSize || dimensions.Z < minSize)"  is complex.
Complex Conditional,Model.Scene,GeometryNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\Abstract\GeometryNode.cs,UpdateNotRender,The conditional expression  "IsHitTestVisible && context.AutoUpdateOctree && geometry != null && geometry.OctreeDirty"  is complex.
Complex Conditional,Model.Scene,ScreenSpacedNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ScreenSpacedNode.cs,CreateRelativeScreenModeRay,The conditional expression  "px < 0 || py < 0 || px > viewportSize || py > viewportSize"  is complex.
Complex Conditional,Model.Scene,ScreenSpacedNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ScreenSpacedNode.cs,CreateAbsoluteModeRay,The conditional expression  "px < 0 || py < 0 || px > viewportSize || py > viewportSize"  is complex.
Complex Conditional,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,SetBlendState,The conditional expression  "AutoSkipRedundantStateSetting && currBlendState == blendState && blendFactor == currBlendFactor && currSampleMask == sampleMask"  is complex.
Complex Conditional,Render,DeviceContextProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\DeviceContextProxy\DeviceContextProxy_DrawCalls.cs,SetBlendState,The conditional expression  "AutoSkipRedundantStateSetting && currBlendState == blendState && blendFactor == currBlendFactor && currSampleMask == sampleMask"  is complex.
Complex Conditional,Render,DX11RenderHostBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\RenderHostBase.cs,UpdateAndRender,The conditional expression  "desc == global::SharpDX.DXGI.ResultCode.DeviceRemoved || desc == global::SharpDX.DXGI.ResultCode.DeviceReset                               || desc == global::SharpDX.DXGI.ResultCode.DeviceHung || desc == global::SharpDX.Direct2D1.ResultCode.RecreateTarget                              || desc == global::SharpDX.DXGI.ResultCode.AccessLost"  is complex.
Complex Conditional,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,RenderBitmapCache,The conditional expression  "IsRenderable && EnableBitmapCache && IsBitmapCacheValid && !IsVisualDirty && context.HasTarget"  is complex.
Complex Conditional,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,EnsureBitmapCache,The conditional expression  "size.Width <= 0 || size.Height <= 0 || !EnableBitmapCache || size.Width * size.Height < MinimumBitmapSize"  is complex.
Complex Conditional,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,InvalidateAll,The conditional expression  "p.IsTransformDirty && p.IsMeasureDirty && p.IsArrangeDirty && p.IsVisualDirty"  is complex.
Complex Conditional,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,Measure,The conditional expression  "!IsAttached || Visibility == Visibility.Collapsed || (!IsMeasureDirty && previousMeasureSize == size)"  is complex.
Complex Conditional,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,Arrange,The conditional expression  "(!IsArrangeDirty && !ancestorDirty && previousArrange == rect) || rectWidthHeight.IsZero"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,GetDXGIFormat,The conditional expression  "pixelFormat.RBitMask == entry.PixelFormat.RBitMask                              && pixelFormat.GBitMask == entry.PixelFormat.GBitMask                              && pixelFormat.BBitMask == entry.PixelFormat.BBitMask                              && pixelFormat.ABitMask == entry.PixelFormat.ABitMask"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The conditional expression  "description.Width <= 0 || description.Height != 1 || description.Depth != 1 || description.ArraySize == 0"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The conditional expression  "description.Width <= 0 || description.Height <= 0 || description.Depth != 1 || description.ArraySize == 0"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The conditional expression  "description.Width <= 0 || description.Height <= 0 || description.Depth <= 0 || description.ArraySize != 1"  is complex.
Empty Catch Block,HelixToolkit.SharpDX.Core,Disposer,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Disposer.cs,RemoveAndDispose,The method has an empty catch block.
Empty Catch Block,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Load,The method has an empty catch block.
Empty Catch Block,SharpDX.Toolkit.Graphics,WICHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeSingleFrame,The method has an empty catch block.
Empty Catch Block,SharpDX.Toolkit.Graphics,WICHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,Dispose,The method has an empty catch block.
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,AddMoveForce,The following statement contains a magic number: this.moveSpeed += delta * 40;
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationPosition = new Vector2(Width / 2f' Height / 2f);
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationPosition = new Vector2(Width / 2f' Height / 2f);
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationSpeed.X += dx * 40;
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,AddRotateForce,The following statement contains a magic number: this.rotationSpeed.Y += dy * 40;
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,AddZoomForce,The following statement contains a magic number: this.zoomSpeed += delta * 8;
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,MouseWheel,The following statement contains a magic number: this.AddZoomForce(-delta * 0.001f' nearestPoint);
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,MouseWheel,The following statement contains a magic number: this.AddZoomForce(-delta * 0.001f);
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,FindPanVector,The following statement contains a magic number: var f = l * 0.001f;
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: time = time == 0 ? 0.016f : time;
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: time = Math.Min(time' 0.05f);
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: var factor = this.IsInertiaEnabled ? Clamp((float)Math.Pow(this.InertiaFactor' time / 0.02f)' 0.1f' 1) : 0;
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: var factor = this.IsInertiaEnabled ? Clamp((float)Math.Pow(this.InertiaFactor' time / 0.02f)' 0.1f' 1) : 0;
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: this.rotationSpeed.LengthSquared() > 0.1f
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: this.panSpeed.LengthSquared() > 0.0001f
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: this.moveSpeed.LengthSquared() > 0.0001f
Magic Number,HelixToolkit.SharpDX.Core.Controls,CameraController,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\CameraController.cs,OnTimeStep,The following statement contains a magic number: Math.Abs(this.zoomSpeed) > 0.001f
Magic Number,HelixToolkit.SharpDX.Core.Controls,MouseGestureHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\MouseGestureHandler.cs,Completed,The following statement contains a magic number: var elapsed = (double)(Stopwatch.GetTimestamp() - startTick) / Stopwatch.Frequency * 1000;
Magic Number,HelixToolkit.SharpDX.Core.Controls,PanHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\PanHandler.cs,Delta,The following statement contains a magic number: Camera.LookDirection.LengthSquared() < 1e-5f
Magic Number,HelixToolkit.SharpDX.Core.Controls,PanHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\PanHandler.cs,OnInertiaStarting,The following statement contains a magic number: var speed = (this.LastPoint - this.MouseDownPoint) * (40.0f / (float)elapsedTime);
Magic Number,HelixToolkit.SharpDX.Core.Controls,RotateHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\RotateHandler.cs,Started,The following statement contains a magic number: this.rotationPoint = new Vector2(                  this.Controller.Width / 2' this.Controller.Height / 2);
Magic Number,HelixToolkit.SharpDX.Core.Controls,RotateHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\RotateHandler.cs,Started,The following statement contains a magic number: this.rotationPoint = new Vector2(                  this.Controller.Width / 2' this.Controller.Height / 2);
Magic Number,HelixToolkit.SharpDX.Core.Controls,RotateHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\RotateHandler.cs,OnInertiaStarting,The following statement contains a magic number: this.Controller.StartSpin(                  4 * deltaV * (float)(this.Controller.SpinReleaseTime / elapsedTime)'                  this.MouseDownPoint'                  this.rotationPoint3D);
Magic Number,HelixToolkit.SharpDX.Core.Controls,ViewportCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ViewportCore.cs,ViewCubeHitTest,The following statement contains a magic number: Vector3.Cross(normal' ModelUpDirection).LengthSquared() < 1e-5
Magic Number,HelixToolkit.SharpDX.Core.Controls,ViewportCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ViewportCore.cs,ViewCubeClicked,The following statement contains a magic number: CameraCore.AnimateTo(newPosition' lookDirection' upDirection' 500);
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,Delta,The following statement contains a magic number: Zoom(delta.Y * 0.01f' zoomPoint3D);
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,Started,The following statement contains a magic number: zoomPoint = new Vector2(Controller.Width / 2f' Controller.Height / 2f);
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,Started,The following statement contains a magic number: zoomPoint = new Vector2(Controller.Width / 2f' Controller.Height / 2f);
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,Zoom,The following statement contains a magic number: delta = -0.5f;
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,Zoom,The following statement contains a magic number: delta < -0.5f
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,ZoomByChangingCameraWidth,The following statement contains a magic number: delta = -0.5f;
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,ZoomByChangingCameraWidth,The following statement contains a magic number: delta < -0.5f
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,ZoomByChangingCameraWidth,The following statement contains a magic number: switch (CameraMode)              {                  case CameraMode.WalkAround:                  case CameraMode.Inspect:                  case CameraMode.FixedPosition:                      if (ChangeCameraDistance(ref delta' zoomAround))                      {                          // Modify the camera width                          if (Camera is OrthographicCameraCore ocamera)                          {                              ocamera.Width *= (float)Math.Pow(2.5f' delta);                          }                      }                      break;              }
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,ChangeCameraDistance,The following statement contains a magic number: relativePosition /= 10;
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,ChangeCameraDistance,The following statement contains a magic number: relativePosition.LengthSquared() < 1e-5
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,ChangeCameraDistance,The following statement contains a magic number: var f = Math.Pow(2.5' delta);
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,ChangeCameraDistance,The following statement contains a magic number: Controller.ZoomAroundMouseDownPoint && relativeTarget.LengthSquared() > 1e-3
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,ChangeCameraDistance,The following statement contains a magic number: delta = (float)(Math.Log(f) / Math.Log(2.5));
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,ChangeCameraDistance,The following statement contains a magic number: delta = (float)(Math.Log(f) / Math.Log(2.5));
Magic Number,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,ChangeCameraDistance,The following statement contains a magic number: newLookDirection.LengthSquared() < 1e-5
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,ZoomToRectangle,The following statement contains a magic number: LookAt(pcam' newTarget' newLookDirection' 200);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,ZoomToRectangle,The following statement contains a magic number: viewport.UnProject(new Vector2(zoomRectangle.Top' zoomRectangle.Left)' out var topLeftRay)                  && viewport.UnProject(new Vector2(zoomRectangle.Top' zoomRectangle.Right)' out var topRightRay)                  && viewport.UnProject(                          new Vector2(                              (zoomRectangle.Left + zoomRectangle.Right) * 0.5f'                              (zoomRectangle.Top + zoomRectangle.Bottom) * 0.5f)' out var centerRay)
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,ZoomToRectangle,The following statement contains a magic number: viewport.UnProject(new Vector2(zoomRectangle.Top' zoomRectangle.Left)' out var topLeftRay)                  && viewport.UnProject(new Vector2(zoomRectangle.Top' zoomRectangle.Right)' out var topRightRay)                  && viewport.UnProject(                          new Vector2(                              (zoomRectangle.Left + zoomRectangle.Right) * 0.5f'                              (zoomRectangle.Top + zoomRectangle.Bottom) * 0.5f)' out var centerRay)
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.Position = new Vector3(20' 10' 40);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.Position = new Vector3(20' 10' 40);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.Position = new Vector3(20' 10' 40);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3(-20' -10' -40);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3(-20' -10' -40);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3(-20' -10' -40);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.FieldOfView = 45;
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.NearPlaneDistance = 0.1f;
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.FarPlaneDistance = 1000;
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.Position = new Vector3(20' 10' 40);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.Position = new Vector3(20' 10' 40);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.Position = new Vector3(20' 10' 40);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3(-20' -10' -40);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3(-20' -10' -40);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.LookDirection = new Vector3(-20' -10' -40);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.Width = 40;
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.NearPlaneDistance = 0.1f;
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,Reset,The following statement contains a magic number: camera.FarPlaneDistance = 1000;
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,ZoomExtents,The following statement contains a magic number: var center = bounds.Center + (diagonal * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,ZoomExtents,The following statement contains a magic number: float radius = diagonal.Length() * 0.5f;
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,ZoomExtents,The following statement contains a magic number: float disth = radius / (float)Math.Tan(0.5 * pcam.FieldOfView * Math.PI / 180);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,ZoomExtents,The following statement contains a magic number: float disth = radius / (float)Math.Tan(0.5 * pcam.FieldOfView * Math.PI / 180);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,ZoomExtents,The following statement contains a magic number: float distv = radius / (float)Math.Tan(0.5 * vfov * Math.PI / 180);
Magic Number,HelixToolkit.SharpDX.Core,CameraExtension,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\CameraExtension.cs,ZoomExtents,The following statement contains a magic number: float distv = radius / (float)Math.Tan(0.5 * vfov * Math.PI / 180);
Magic Number,HelixToolkit.SharpDX.Core,ViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\ViewportExtensions.cs,ZoomByChangingFieldOfView,The following statement contains a magic number: float r = d * (float)Math.Tan(0.5f * fov / 180 * Math.PI);
Magic Number,HelixToolkit.SharpDX.Core,ViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\ViewportExtensions.cs,ZoomByChangingFieldOfView,The following statement contains a magic number: float r = d * (float)Math.Tan(0.5f * fov / 180 * Math.PI);
Magic Number,HelixToolkit.SharpDX.Core,ViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\ViewportExtensions.cs,ZoomByChangingFieldOfView,The following statement contains a magic number: fov *= 1f + (delta * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,ViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\ViewportExtensions.cs,ZoomByChangingFieldOfView,The following statement contains a magic number: float d2 = r / (float)Math.Tan(0.5f * fov / 180 * Math.PI);
Magic Number,HelixToolkit.SharpDX.Core,ViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Extensions\ViewportExtensions.cs,ZoomByChangingFieldOfView,The following statement contains a magic number: float d2 = r / (float)Math.Tan(0.5f * fov / 180 * Math.PI);
Magic Number,HelixToolkit.SharpDX.Core,BitmapExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BitmapExtensions.cs,ToBillboardImage3D,The following statement contains a magic number: var code = imagePacker.Pack(items' true' squareImage' maxWidth' maxHeight' 2'                      out global::SharpDX.WIC.Bitmap bitmap' out int imageWidth' out int imageHeight'                      out var map);
Magic Number,HelixToolkit.SharpDX.Core,BoundingBoxExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BoundingBoxExtensions.cs,FromPoints,The following statement contains a magic number: return new BoundingBox(min - new Vector3(0.1f)' max + new Vector3(0.1f));
Magic Number,HelixToolkit.SharpDX.Core,BoundingBoxExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BoundingBoxExtensions.cs,FromPoints,The following statement contains a magic number: return new BoundingBox(min - new Vector3(0.1f)' max + new Vector3(0.1f));
Magic Number,HelixToolkit.SharpDX.Core,BoundingBoxExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BoundingBoxExtensions.cs,FromPoints,The following statement contains a magic number: diff.AnySmallerOrEqual(0.0001f)
Magic Number,HelixToolkit.SharpDX.Core,BoundingBoxExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BoundingBoxExtensions.cs,Center,The following statement contains a magic number: return (box.Minimum + box.Maximum) * 0.5f;
Magic Number,HelixToolkit.SharpDX.Core,BoundingFrustumExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BoundingFrustumExtensions.cs,Intersects,The following statement contains a magic number: i < 6
Magic Number,HelixToolkit.SharpDX.Core,BoundingFrustumExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BoundingFrustumExtensions.cs,Intersects,The following statement contains a magic number: i < 6
Magic Number,HelixToolkit.SharpDX.Core,BoundingFrustumExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BoundingFrustumExtensions.cs,Intersects,The following statement contains a magic number: i < 6
Magic Number,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,FromArgb,The following statement contains a magic number: return new Color((byte)(argb >> 16)' (byte)(argb >> 8)' (byte)argb' (byte)(argb >> 24));
Magic Number,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,FromArgb,The following statement contains a magic number: return new Color((byte)(argb >> 16)' (byte)(argb >> 8)' (byte)argb' (byte)(argb >> 24));
Magic Number,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,FromArgb,The following statement contains a magic number: return new Color((byte)(argb >> 16)' (byte)(argb >> 8)' (byte)argb' (byte)(argb >> 24));
Magic Number,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,FromArgb,The following statement contains a magic number: return new Color((byte)r' (byte)g' (byte)b' (byte)(255));
Magic Number,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,ToArgb,The following statement contains a magic number: value |= color.G << 8;
Magic Number,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,ToArgb,The following statement contains a magic number: value |= color.R << 16;
Magic Number,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,ToArgb,The following statement contains a magic number: value |= color.A << 24;
Magic Number,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,EncodeToFloat,The following statement contains a magic number: var ex = (uint)(color.Red * 255);
Magic Number,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,EncodeToFloat,The following statement contains a magic number: var ey = (uint)(color.Green * 255);
Magic Number,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,EncodeToFloat,The following statement contains a magic number: var ez = (uint)(color.Blue * 255);
Magic Number,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,EncodeToFloat,The following statement contains a magic number: var v = (ex << 16) | (ey << 8) | ez;
Magic Number,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,EncodeToFloat,The following statement contains a magic number: var v = (ex << 16) | (ey << 8) | ez;
Magic Number,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,Encode2FloatToFloat,The following statement contains a magic number: uint abPacked = (aScaled << 16) | (bScaled & 0xFFFF);
Magic Number,HelixToolkit.SharpDX.Core,IViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\IViewportExtensions.cs,UnProject,The following statement contains a magic number: Vector3 v = new Vector3                  {                      X = (2 * px / w - 1) / projMatrix.M11'                      Y = -(2 * py / h - 1) / projMatrix.M22'                      Z = 1 / projMatrix.M33                  };
Magic Number,HelixToolkit.SharpDX.Core,IViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\IViewportExtensions.cs,UnProject,The following statement contains a magic number: Vector3 v = new Vector3                  {                      X = (2 * px / w - 1) / projMatrix.M11'                      Y = -(2 * py / h - 1) / projMatrix.M22'                      Z = 1 / projMatrix.M33                  };
Magic Number,HelixToolkit.SharpDX.Core,IViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\IViewportExtensions.cs,GetViewportMatrix,The following statement contains a magic number: return new Matrix(                  viewport.ViewportRectangle.Width / 2f'                  0'                  0'                  0'                  0'                  -viewport.ViewportRectangle.Height / 2f'                  0'                  0'                  0'                  0'                  1'                  0'                  (viewport.ViewportRectangle.Width - 1) / 2f'                  (viewport.ViewportRectangle.Height - 1) / 2f'                  0'                  1);
Magic Number,HelixToolkit.SharpDX.Core,IViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\IViewportExtensions.cs,GetViewportMatrix,The following statement contains a magic number: return new Matrix(                  viewport.ViewportRectangle.Width / 2f'                  0'                  0'                  0'                  0'                  -viewport.ViewportRectangle.Height / 2f'                  0'                  0'                  0'                  0'                  1'                  0'                  (viewport.ViewportRectangle.Width - 1) / 2f'                  (viewport.ViewportRectangle.Height - 1) / 2f'                  0'                  1);
Magic Number,HelixToolkit.SharpDX.Core,IViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\IViewportExtensions.cs,GetViewportMatrix,The following statement contains a magic number: return new Matrix(                  viewport.ViewportRectangle.Width / 2f'                  0'                  0'                  0'                  0'                  -viewport.ViewportRectangle.Height / 2f'                  0'                  0'                  0'                  0'                  1'                  0'                  (viewport.ViewportRectangle.Width - 1) / 2f'                  (viewport.ViewportRectangle.Height - 1) / 2f'                  0'                  1);
Magic Number,HelixToolkit.SharpDX.Core,IViewportExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\IViewportExtensions.cs,GetViewportMatrix,The following statement contains a magic number: return new Matrix(                  viewport.ViewportRectangle.Width / 2f'                  0'                  0'                  0'                  0'                  -viewport.ViewportRectangle.Height / 2f'                  0'                  0'                  0'                  0'                  1'                  0'                  (viewport.ViewportRectangle.Width - 1) / 2f'                  (viewport.ViewportRectangle.Height - 1) / 2f'                  0'                  1);
Magic Number,HelixToolkit.SharpDX.Core,PointerSizeHelpers,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\PointerSizeHelpers.cs,ToUInt64,The following statement contains a magic number: UIntPtr.Size == 8
Magic Number,HelixToolkit.SharpDX.Core,RayExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\RayExtensions.cs,UnProject,The following statement contains a magic number: Vector3 v = new Vector3              {                  X = (2 * px / w - 1) / projection.M11'                  Y = -(2 * py / h - 1) / projection.M22'                  Z = 1 / projection.M33              };
Magic Number,HelixToolkit.SharpDX.Core,RayExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\RayExtensions.cs,UnProject,The following statement contains a magic number: Vector3 v = new Vector3              {                  X = (2 * px / w - 1) / projection.M11'                  Y = -(2 * py / h - 1) / projection.M22'                  Z = 1 / projection.M33              };
Magic Number,HelixToolkit.SharpDX.Core,VectorExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Vector3DExtensions.cs,AngleBetween,The following statement contains a magic number: theta = (float)(Math.PI - 2.0 * Math.Asin((-vector1 - vector2).Length() / 2.0));
Magic Number,HelixToolkit.SharpDX.Core,VectorExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Vector3DExtensions.cs,AngleBetween,The following statement contains a magic number: theta = (float)(Math.PI - 2.0 * Math.Asin((-vector1 - vector2).Length() / 2.0));
Magic Number,HelixToolkit.SharpDX.Core,VectorExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Vector3DExtensions.cs,FindAnyPerpendicular,The following statement contains a magic number: u.LengthSquared() < 1e-3
Magic Number,HelixToolkit.SharpDX.Core,BillboardImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardImage3D.cs,DrawImageVertex,The following statement contains a magic number: var tl = new Vector2(-info.Width / 2' info.Height / 2);
Magic Number,HelixToolkit.SharpDX.Core,BillboardImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardImage3D.cs,DrawImageVertex,The following statement contains a magic number: var tl = new Vector2(-info.Width / 2' info.Height / 2);
Magic Number,HelixToolkit.SharpDX.Core,BillboardImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardImage3D.cs,DrawImageVertex,The following statement contains a magic number: var br = new Vector2(info.Width / 2' -info.Height / 2);
Magic Number,HelixToolkit.SharpDX.Core,BillboardImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardImage3D.cs,DrawImageVertex,The following statement contains a magic number: var br = new Vector2(info.Width / 2' -info.Height / 2);
Magic Number,HelixToolkit.SharpDX.Core,ImageInfo,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardImage3D.cs,UpdateImage,The following statement contains a magic number: BoundSphere = new BoundingSphere(Position' Math.Max(Width * Scale' Height * Scale) / 2);
Magic Number,HelixToolkit.SharpDX.Core,BoneSkinnedMeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BoneSkinnedMeshGeometry3D.cs,CreateSkeletonMesh,The following statement contains a magic number: builder.AddPyramid(new Vector3(0' scale / 2' 0)' Vector3.UnitZ' Vector3.UnitY' scale' 0' true);
Magic Number,HelixToolkit.SharpDX.Core,BoneSkinnedMeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BoneSkinnedMeshGeometry3D.cs,CreateSkeletonMesh,The following statement contains a magic number: j < singleBone.Positions.Count - 6
Magic Number,HelixToolkit.SharpDX.Core,BoneSkinnedMeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BoneSkinnedMeshGeometry3D.cs,CreateSkeletonMesh,The following statement contains a magic number: builder.AddSphere(Vector3.Zero' scale / 2' 12' 12);
Magic Number,HelixToolkit.SharpDX.Core,BoneSkinnedMeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BoneSkinnedMeshGeometry3D.cs,CreateSkeletonMesh,The following statement contains a magic number: builder.AddSphere(Vector3.Zero' scale / 2' 12' 12);
Magic Number,HelixToolkit.SharpDX.Core,BoneSkinnedMeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BoneSkinnedMeshGeometry3D.cs,CreateSkeletonMesh,The following statement contains a magic number: builder.AddSphere(Vector3.Zero' scale / 2' 12' 12);
Magic Number,HelixToolkit.SharpDX.Core,BoneSkinnedMeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BoneSkinnedMeshGeometry3D.cs,skinnedTriangles,The following statement contains a magic number: yield return new Triangle() { P0 = skinnedVertices[Indices[i]]' P1 = skinnedVertices[Indices[i + 1]]' P2 = skinnedVertices[Indices[i + 2]]' };
Magic Number,HelixToolkit.SharpDX.Core,BoneSkinnedMeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BoneSkinnedMeshGeometry3D.cs,HitTestWithSkinnedVertices,The following statement contains a magic number: result.TriangleIndices = new System.Tuple<int' int' int>(Indices[index]' Indices[index + 1]' Indices[index + 2]);
Magic Number,HelixToolkit.SharpDX.Core,BoneSkinnedMeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BoneSkinnedMeshGeometry3D.cs,HitTestWithSkinnedVertices,The following statement contains a magic number: result.Tag = index / 3;
Magic Number,HelixToolkit.SharpDX.Core,BoneSkinnedMeshGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BoneSkinnedMeshGeometry3D.cs,HitTestWithSkinnedVertices,The following statement contains a magic number: index += 3;
Magic Number,HelixToolkit.SharpDX.Core,BillboardSingleImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleImage3D.cs,UpdateBounds,The following statement contains a magic number: BoundingSphere = new BoundingSphere(Center' (float)Math.Sqrt(Width * Width + Height * Height) / 2);
Magic Number,HelixToolkit.SharpDX.Core,BillboardSingleImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleImage3D.cs,OnUpdateTextureAndBillboardVertices,The following statement contains a magic number: var tl = new Vector2(-w / 2' h / 2);
Magic Number,HelixToolkit.SharpDX.Core,BillboardSingleImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleImage3D.cs,OnUpdateTextureAndBillboardVertices,The following statement contains a magic number: var tl = new Vector2(-w / 2' h / 2);
Magic Number,HelixToolkit.SharpDX.Core,BillboardSingleImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleImage3D.cs,OnUpdateTextureAndBillboardVertices,The following statement contains a magic number: var br = new Vector2(w / 2' -h / 2);
Magic Number,HelixToolkit.SharpDX.Core,BillboardSingleImage3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleImage3D.cs,OnUpdateTextureAndBillboardVertices,The following statement contains a magic number: var br = new Vector2(w / 2' -h / 2);
Magic Number,HelixToolkit.SharpDX.Core,BillboardSingleText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The following statement contains a magic number: var tl = new Vector2(-w / 2' h / 2);
Magic Number,HelixToolkit.SharpDX.Core,BillboardSingleText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The following statement contains a magic number: var tl = new Vector2(-w / 2' h / 2);
Magic Number,HelixToolkit.SharpDX.Core,BillboardSingleText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The following statement contains a magic number: var br = new Vector2(w / 2' -h / 2);
Magic Number,HelixToolkit.SharpDX.Core,BillboardSingleText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardSingleText3D.cs,DrawCharacter,The following statement contains a magic number: var br = new Vector2(w / 2' -h / 2);
Magic Number,HelixToolkit.SharpDX.Core,TextInfo,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardText3D.cs,UpdateTextInfo,The following statement contains a magic number: BoundSphere = new BoundingSphere(Origin' Math.Max(actualWidth' actualHeight) / 2);
Magic Number,HelixToolkit.SharpDX.Core,BillboardText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardText3D.cs,OnUpdateTextureAndBillboardVertices,The following statement contains a magic number: var tempList = new List<BillboardVertex>(100);
Magic Number,HelixToolkit.SharpDX.Core,BillboardText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardText3D.cs,OnUpdateTextureAndBillboardVertices,The following statement contains a magic number: var halfW = rect.Width / 2;
Magic Number,HelixToolkit.SharpDX.Core,BillboardText3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardText3D.cs,OnUpdateTextureAndBillboardVertices,The following statement contains a magic number: var halfH = rect.Height / 2;
Magic Number,HelixToolkit.SharpDX.Core,Triangle,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\Geometry3D.cs,Clone,The following statement contains a magic number: t.v[2] = this.v[2];
Magic Number,HelixToolkit.SharpDX.Core,Triangle,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\Geometry3D.cs,Clone,The following statement contains a magic number: t.v[2] = this.v[2];
Magic Number,HelixToolkit.SharpDX.Core,Triangle,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\Geometry3D.cs,Clone,The following statement contains a magic number: t.err[2] = this.err[2];
Magic Number,HelixToolkit.SharpDX.Core,Triangle,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\Geometry3D.cs,Clone,The following statement contains a magic number: t.err[2] = this.err[2];
Magic Number,HelixToolkit.SharpDX.Core,Triangle,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\Geometry3D.cs,Clone,The following statement contains a magic number: t.err[3] = this.err[3];
Magic Number,HelixToolkit.SharpDX.Core,Triangle,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\Geometry3D.cs,Clone,The following statement contains a magic number: t.err[3] = this.err[3];
Magic Number,HelixToolkit.SharpDX.Core,PointGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\PointGeometry3D.cs,UpdateBounds,The following statement contains a magic number: var off = new Vector3(0.5f);
Magic Number,HelixToolkit.SharpDX.Core,PointGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\PointGeometry3D.cs,UpdateBounds,The following statement contains a magic number: Bound.Size.LengthSquared() < 1e-1f
Magic Number,HelixToolkit.SharpDX.Core,PointGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\PointGeometry3D.cs,UpdateBounds,The following statement contains a magic number: BoundingSphere = new BoundingSphere(BoundingSphere.Center' 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,PointGeometry3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\PointGeometry3D.cs,UpdateBounds,The following statement contains a magic number: BoundingSphere.Radius < 1e-1f
Magic Number,HelixToolkit.SharpDX.Core,RenderContext,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderContext.cs,RenderContext,The following statement contains a magic number: OITWeightPower = 3;
Magic Number,HelixToolkit.SharpDX.Core,EffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\EffectsManager.cs,GetBestAdapter,The following statement contains a magic number: ulong MByte = 1024 * 1024;
Magic Number,HelixToolkit.SharpDX.Core,EffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\EffectsManager.cs,GetBestAdapter,The following statement contains a magic number: ulong MByte = 1024 * 1024;
Magic Number,HelixToolkit.SharpDX.Core,FastList<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Collection\FastList.cs,EnsureCapacity,The following statement contains a magic number: var num = (Items.Length == 0) ? _defaultCapacity : (Items.Length*2);
Magic Number,HelixToolkit.SharpDX.Core,FastList<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Collection\FastList.cs,InsertRange,The following statement contains a magic number: Array.Copy(Items' (index + count)' Items' (index * 2)' (_size - index));
Magic Number,HelixToolkit.SharpDX.Core,FastList<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Collection\FastList.cs,TrimExcess,The following statement contains a magic number: var num = (int) (Items.Length*0.9);
Magic Number,HelixToolkit.SharpDX.Core,BinaryReaderExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\CMOReader.cs,ReadCMO_wchar,The following statement contains a magic number: var result = System.Text.Encoding.Unicode.GetString(br.ReadBytes(length * 2)' 0' length * 2);
Magic Number,HelixToolkit.SharpDX.Core,BinaryReaderExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\CMOReader.cs,ReadCMO_wchar,The following statement contains a magic number: var result = System.Text.Encoding.Unicode.GetString(br.ReadBytes(length * 2)' 0' length * 2);
Magic Number,HelixToolkit.SharpDX.Core,ModelReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ModelReader.cs,ModelReader,The following statement contains a magic number: this.DefaultMaterial = new PhongMaterialCore                  {                      Name = "Gold"'                      AmbientColor = new Color4(0.24725f' 0.1995f' 0.0745f' 1.0f)'                      DiffuseColor = new Color4(0.75164f' 0.60648f' 0.22648f' 1.0f)'                      SpecularColor = new Color4(0.628281f' 0.555802f' 0.366065f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 0.0f)'                      SpecularShininess = 51.2f'                  };
Magic Number,HelixToolkit.SharpDX.Core,ModelReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ModelReader.cs,ModelReader,The following statement contains a magic number: this.DefaultMaterial = new PhongMaterialCore                  {                      Name = "Gold"'                      AmbientColor = new Color4(0.24725f' 0.1995f' 0.0745f' 1.0f)'                      DiffuseColor = new Color4(0.75164f' 0.60648f' 0.22648f' 1.0f)'                      SpecularColor = new Color4(0.628281f' 0.555802f' 0.366065f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 0.0f)'                      SpecularShininess = 51.2f'                  };
Magic Number,HelixToolkit.SharpDX.Core,ModelReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ModelReader.cs,ModelReader,The following statement contains a magic number: this.DefaultMaterial = new PhongMaterialCore                  {                      Name = "Gold"'                      AmbientColor = new Color4(0.24725f' 0.1995f' 0.0745f' 1.0f)'                      DiffuseColor = new Color4(0.75164f' 0.60648f' 0.22648f' 1.0f)'                      SpecularColor = new Color4(0.628281f' 0.555802f' 0.366065f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 0.0f)'                      SpecularShininess = 51.2f'                  };
Magic Number,HelixToolkit.SharpDX.Core,ModelReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ModelReader.cs,ModelReader,The following statement contains a magic number: this.DefaultMaterial = new PhongMaterialCore                  {                      Name = "Gold"'                      AmbientColor = new Color4(0.24725f' 0.1995f' 0.0745f' 1.0f)'                      DiffuseColor = new Color4(0.75164f' 0.60648f' 0.22648f' 1.0f)'                      SpecularColor = new Color4(0.628281f' 0.555802f' 0.366065f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 0.0f)'                      SpecularShininess = 51.2f'                  };
Magic Number,HelixToolkit.SharpDX.Core,ModelReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ModelReader.cs,ModelReader,The following statement contains a magic number: this.DefaultMaterial = new PhongMaterialCore                  {                      Name = "Gold"'                      AmbientColor = new Color4(0.24725f' 0.1995f' 0.0745f' 1.0f)'                      DiffuseColor = new Color4(0.75164f' 0.60648f' 0.22648f' 1.0f)'                      SpecularColor = new Color4(0.628281f' 0.555802f' 0.366065f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 0.0f)'                      SpecularShininess = 51.2f'                  };
Magic Number,HelixToolkit.SharpDX.Core,ModelReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ModelReader.cs,ModelReader,The following statement contains a magic number: this.DefaultMaterial = new PhongMaterialCore                  {                      Name = "Gold"'                      AmbientColor = new Color4(0.24725f' 0.1995f' 0.0745f' 1.0f)'                      DiffuseColor = new Color4(0.75164f' 0.60648f' 0.22648f' 1.0f)'                      SpecularColor = new Color4(0.628281f' 0.555802f' 0.366065f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 0.0f)'                      SpecularShininess = 51.2f'                  };
Magic Number,HelixToolkit.SharpDX.Core,ModelReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ModelReader.cs,ModelReader,The following statement contains a magic number: this.DefaultMaterial = new PhongMaterialCore                  {                      Name = "Gold"'                      AmbientColor = new Color4(0.24725f' 0.1995f' 0.0745f' 1.0f)'                      DiffuseColor = new Color4(0.75164f' 0.60648f' 0.22648f' 1.0f)'                      SpecularColor = new Color4(0.628281f' 0.555802f' 0.366065f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 0.0f)'                      SpecularShininess = 51.2f'                  };
Magic Number,HelixToolkit.SharpDX.Core,ModelReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ModelReader.cs,ModelReader,The following statement contains a magic number: this.DefaultMaterial = new PhongMaterialCore                  {                      Name = "Gold"'                      AmbientColor = new Color4(0.24725f' 0.1995f' 0.0745f' 1.0f)'                      DiffuseColor = new Color4(0.75164f' 0.60648f' 0.22648f' 1.0f)'                      SpecularColor = new Color4(0.628281f' 0.555802f' 0.366065f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 0.0f)'                      SpecularShininess = 51.2f'                  };
Magic Number,HelixToolkit.SharpDX.Core,ModelReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ModelReader.cs,ModelReader,The following statement contains a magic number: this.DefaultMaterial = new PhongMaterialCore                  {                      Name = "Gold"'                      AmbientColor = new Color4(0.24725f' 0.1995f' 0.0745f' 1.0f)'                      DiffuseColor = new Color4(0.75164f' 0.60648f' 0.22648f' 1.0f)'                      SpecularColor = new Color4(0.628281f' 0.555802f' 0.366065f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 0.0f)'                      SpecularShininess = 51.2f'                  };
Magic Number,HelixToolkit.SharpDX.Core,ModelReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ModelReader.cs,ModelReader,The following statement contains a magic number: this.DefaultMaterial = new PhongMaterialCore                  {                      Name = "Gold"'                      AmbientColor = new Color4(0.24725f' 0.1995f' 0.0745f' 1.0f)'                      DiffuseColor = new Color4(0.75164f' 0.60648f' 0.22648f' 1.0f)'                      SpecularColor = new Color4(0.628281f' 0.555802f' 0.366065f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 0.0f)'                      SpecularShininess = 51.2f'                  };
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,ColorParse,The following statement contains a magic number: return new Color((float)fields[0]' (float)fields[1]' (float)fields[2]' 1);
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddFace,The following statement contains a magic number: int vni = ff.Length > 2 && ff[2].Length > 0 ? int.Parse(ff[2]) : int.MaxValue;
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddFace,The following statement contains a magic number: int vni = ff.Length > 2 && ff[2].Length > 0 ? int.Parse(ff[2]) : int.MaxValue;
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddFace,The following statement contains a magic number: int vni = ff.Length > 2 && ff[2].Length > 0 ? int.Parse(ff[2]) : int.MaxValue;
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddFace,The following statement contains a magic number: faceIndices.Count < 3
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddFace,The following statement contains a magic number: faceIndices.Count == 3
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddFace,The following statement contains a magic number: faceIndices.Count == 4
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddNormal,The following statement contains a magic number: this.Normals.Add(new Vector3D((float)fields[0]' (float)-fields[2]' (float)fields[1]));
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddVertex,The following statement contains a magic number: this.Points.Add(new Point3D((float)fields[0]' (float)-fields[2]' (float)fields[1]));
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddVertex,The following statement contains a magic number: this.Colors.Add(new Color4((float)fields[3]' (float)fields[4]' (float)fields[5]' 1f));
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddVertex,The following statement contains a magic number: this.Colors.Add(new Color4((float)fields[3]' (float)fields[4]' (float)fields[5]' 1f));
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddVertex,The following statement contains a magic number: this.Colors.Add(new Color4((float)fields[3]' (float)fields[4]' (float)fields[5]' 1f));
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddVertex,The following statement contains a magic number: fields.Count == 6
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,AddVertex,The following statement contains a magic number: fields.Count >= 6
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,GetMaterial,The following statement contains a magic number: return new PhongMaterialCore()              {                  Name = "DefaultVRML"'                  AmbientColor = new Color(0.2f' 0.2f' 0.2f' 1.0f)'                  DiffuseColor = new Color(0.8f' 0.8f' 0.8f' 1.0f)'                  SpecularColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  EmissiveColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  SpecularShininess = 25.6f'              };
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,GetMaterial,The following statement contains a magic number: return new PhongMaterialCore()              {                  Name = "DefaultVRML"'                  AmbientColor = new Color(0.2f' 0.2f' 0.2f' 1.0f)'                  DiffuseColor = new Color(0.8f' 0.8f' 0.8f' 1.0f)'                  SpecularColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  EmissiveColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  SpecularShininess = 25.6f'              };
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,GetMaterial,The following statement contains a magic number: return new PhongMaterialCore()              {                  Name = "DefaultVRML"'                  AmbientColor = new Color(0.2f' 0.2f' 0.2f' 1.0f)'                  DiffuseColor = new Color(0.8f' 0.8f' 0.8f' 1.0f)'                  SpecularColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  EmissiveColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  SpecularShininess = 25.6f'              };
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,GetMaterial,The following statement contains a magic number: return new PhongMaterialCore()              {                  Name = "DefaultVRML"'                  AmbientColor = new Color(0.2f' 0.2f' 0.2f' 1.0f)'                  DiffuseColor = new Color(0.8f' 0.8f' 0.8f' 1.0f)'                  SpecularColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  EmissiveColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  SpecularShininess = 25.6f'              };
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,GetMaterial,The following statement contains a magic number: return new PhongMaterialCore()              {                  Name = "DefaultVRML"'                  AmbientColor = new Color(0.2f' 0.2f' 0.2f' 1.0f)'                  DiffuseColor = new Color(0.8f' 0.8f' 0.8f' 1.0f)'                  SpecularColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  EmissiveColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  SpecularShininess = 25.6f'              };
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,GetMaterial,The following statement contains a magic number: return new PhongMaterialCore()              {                  Name = "DefaultVRML"'                  AmbientColor = new Color(0.2f' 0.2f' 0.2f' 1.0f)'                  DiffuseColor = new Color(0.8f' 0.8f' 0.8f' 1.0f)'                  SpecularColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  EmissiveColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  SpecularShininess = 25.6f'              };
Magic Number,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,GetMaterial,The following statement contains a magic number: return new PhongMaterialCore()              {                  Name = "DefaultVRML"'                  AmbientColor = new Color(0.2f' 0.2f' 0.2f' 1.0f)'                  DiffuseColor = new Color(0.8f' 0.8f' 0.8f' 1.0f)'                  SpecularColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  EmissiveColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  SpecularShininess = 25.6f'              };
Magic Number,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,BuildModel,The following statement contains a magic number: gm.Material = new PhongMaterialCore()              {                  Name = "DefaultVRML"'                  AmbientColor = new Color(0.2f' 0.2f' 0.2f' 1.0f)'                  DiffuseColor = new Color(0.8f' 0.8f' 0.8f' 1.0f)'                  SpecularColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  EmissiveColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  SpecularShininess = 25.6f'              };
Magic Number,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,BuildModel,The following statement contains a magic number: gm.Material = new PhongMaterialCore()              {                  Name = "DefaultVRML"'                  AmbientColor = new Color(0.2f' 0.2f' 0.2f' 1.0f)'                  DiffuseColor = new Color(0.8f' 0.8f' 0.8f' 1.0f)'                  SpecularColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  EmissiveColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  SpecularShininess = 25.6f'              };
Magic Number,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,BuildModel,The following statement contains a magic number: gm.Material = new PhongMaterialCore()              {                  Name = "DefaultVRML"'                  AmbientColor = new Color(0.2f' 0.2f' 0.2f' 1.0f)'                  DiffuseColor = new Color(0.8f' 0.8f' 0.8f' 1.0f)'                  SpecularColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  EmissiveColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  SpecularShininess = 25.6f'              };
Magic Number,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,BuildModel,The following statement contains a magic number: gm.Material = new PhongMaterialCore()              {                  Name = "DefaultVRML"'                  AmbientColor = new Color(0.2f' 0.2f' 0.2f' 1.0f)'                  DiffuseColor = new Color(0.8f' 0.8f' 0.8f' 1.0f)'                  SpecularColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  EmissiveColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  SpecularShininess = 25.6f'              };
Magic Number,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,BuildModel,The following statement contains a magic number: gm.Material = new PhongMaterialCore()              {                  Name = "DefaultVRML"'                  AmbientColor = new Color(0.2f' 0.2f' 0.2f' 1.0f)'                  DiffuseColor = new Color(0.8f' 0.8f' 0.8f' 1.0f)'                  SpecularColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  EmissiveColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  SpecularShininess = 25.6f'              };
Magic Number,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,BuildModel,The following statement contains a magic number: gm.Material = new PhongMaterialCore()              {                  Name = "DefaultVRML"'                  AmbientColor = new Color(0.2f' 0.2f' 0.2f' 1.0f)'                  DiffuseColor = new Color(0.8f' 0.8f' 0.8f' 1.0f)'                  SpecularColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  EmissiveColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  SpecularShininess = 25.6f'              };
Magic Number,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,BuildModel,The following statement contains a magic number: gm.Material = new PhongMaterialCore()              {                  Name = "DefaultVRML"'                  AmbientColor = new Color(0.2f' 0.2f' 0.2f' 1.0f)'                  DiffuseColor = new Color(0.8f' 0.8f' 0.8f' 1.0f)'                  SpecularColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  EmissiveColor = new Color(0.0f' 0.0f' 0.0f' 1.0f)'                  SpecularShininess = 25.6f'              };
Magic Number,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,Load,The following statement contains a magic number: int vertexDimension = 3;
Magic Number,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,Load,The following statement contains a magic number: var uv = new double[2];
Magic Number,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,Load,The following statement contains a magic number: j < 2
Magic Number,HelixToolkit.SharpDX.Core,OffReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\OffReader.cs,Load,The following statement contains a magic number: this.Vertices.Add(new Point3D((float)x[0]' (float)x[1]' (float)x[2]));
Magic Number,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,Load,The following statement contains a magic number: switch (modelFormat)              {                  case PlyFormatTypes.ascii:                      {                          if (plymodelURI.Length > 6)                          {                              using (FileStream fs = new FileStream(plymodelURI' FileMode.Open' FileAccess.Read))                              {                                  Load_ascii(fs);                              }                          }                              break;                      }                    case PlyFormatTypes.binary_big_endian:                      {                          if (plymodelURI.Length > 6)                          {                              using (FileStream fs = new FileStream(plymodelURI' FileMode.Open' FileAccess.Read))                              {                                  Load_binaryBE(fs);                              }                          }                          break;                      }                    case PlyFormatTypes.binary_little_endian:                      {                            break;                      }                  default:                      break;              }
Magic Number,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,Load,The following statement contains a magic number: switch (modelFormat)              {                  case PlyFormatTypes.ascii:                      {                          if (plymodelURI.Length > 6)                          {                              using (FileStream fs = new FileStream(plymodelURI' FileMode.Open' FileAccess.Read))                              {                                  Load_ascii(fs);                              }                          }                              break;                      }                    case PlyFormatTypes.binary_big_endian:                      {                          if (plymodelURI.Length > 6)                          {                              using (FileStream fs = new FileStream(plymodelURI' FileMode.Open' FileAccess.Read))                              {                                  Load_binaryBE(fs);                              }                          }                          break;                      }                    case PlyFormatTypes.binary_little_endian:                      {                            break;                      }                  default:                      break;              }
Magic Number,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,Load_binaryBE,The following statement contains a magic number: ObjectInformation.Add(strarr[1]' double.Parse(strarr[2]));
Magic Number,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,Load_binaryBE,The following statement contains a magic number: VerticesNumber = int.Parse(strarr[2]);
Magic Number,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,Load_binaryBE,The following statement contains a magic number: elementLines_Count += int.Parse(strarr[2]);
Magic Number,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,Load_binaryBE,The following statement contains a magic number: switch (currentElement)                          {                              case PlyElements.vertex:                                  {                                      if (strarr[2] == "nx" || strarr[2] == "ny" || strarr[2] == "nz")                                      {                                          elements_range["vertex"].ContainsNormals = true;                                      }                                        int propInd = elements_range["vertex"].PropertyIndex;                                      elements_range["vertex"].Property_with_Index.Add(strarr[2]' propInd);                                      //Increase the property index if there's an element which has/hasn't been supported.                                      elements_range["vertex"].PropertyIndex += 1;                                      break;                                  }                                case PlyElements.face:                                  {                                      //nothing to do yet                                        break;                                  }                                default:                                  break;                          }
Magic Number,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,Load_binaryBE,The following statement contains a magic number: switch (currentElement)                          {                              case PlyElements.vertex:                                  {                                      if (strarr[2] == "nx" || strarr[2] == "ny" || strarr[2] == "nz")                                      {                                          elements_range["vertex"].ContainsNormals = true;                                      }                                        int propInd = elements_range["vertex"].PropertyIndex;                                      elements_range["vertex"].Property_with_Index.Add(strarr[2]' propInd);                                      //Increase the property index if there's an element which has/hasn't been supported.                                      elements_range["vertex"].PropertyIndex += 1;                                      break;                                  }                                case PlyElements.face:                                  {                                      //nothing to do yet                                        break;                                  }                                default:                                  break;                          }
Magic Number,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,Load_binaryBE,The following statement contains a magic number: switch (currentElement)                          {                              case PlyElements.vertex:                                  {                                      if (strarr[2] == "nx" || strarr[2] == "ny" || strarr[2] == "nz")                                      {                                          elements_range["vertex"].ContainsNormals = true;                                      }                                        int propInd = elements_range["vertex"].PropertyIndex;                                      elements_range["vertex"].Property_with_Index.Add(strarr[2]' propInd);                                      //Increase the property index if there's an element which has/hasn't been supported.                                      elements_range["vertex"].PropertyIndex += 1;                                      break;                                  }                                case PlyElements.face:                                  {                                      //nothing to do yet                                        break;                                  }                                default:                                  break;                          }
Magic Number,HelixToolkit.SharpDX.Core,PlyReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\PlyReader.cs,Load_binaryBE,The following statement contains a magic number: switch (currentElement)                          {                              case PlyElements.vertex:                                  {                                      if (strarr[2] == "nx" || strarr[2] == "ny" || strarr[2] == "nz")                                      {                                          elements_range["vertex"].ContainsNormals = true;                                      }                                        int propInd = elements_range["vertex"].PropertyIndex;                                      elements_range["vertex"].Property_with_Index.Add(strarr[2]' propInd);                                      //Increase the property index if there's an element which has/hasn't been supported.                                      elements_range["vertex"].PropertyIndex += 1;                                      break;                                  }                                case PlyElements.face:                                  {                                      //nothing to do yet                                        break;                                  }                                default:                                  break;                          }
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ParseNormal,The following statement contains a magic number: double y = double.Parse(match.Groups[2].Value' CultureInfo.InvariantCulture);
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ParseNormal,The following statement contains a magic number: double z = double.Parse(match.Groups[3].Value' CultureInfo.InvariantCulture);
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadFloat,The following statement contains a magic number: var bytes = reader.ReadBytes(4);
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadUInt16,The following statement contains a magic number: var bytes = reader.ReadBytes(2);
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadUInt32,The following statement contains a magic number: var bytes = reader.ReadBytes(4);
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,TryParseVertex,The following statement contains a magic number: float y = float.Parse(match.Groups[2].Value' CultureInfo.InvariantCulture);
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,TryParseVertex,The following statement contains a magic number: float z = float.Parse(match.Groups[3].Value' CultureInfo.InvariantCulture);
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: var attrib = Convert.ToString(ReadUInt16(reader)' 2).PadLeft(16' '0').ToCharArray();
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: var attrib = Convert.ToString(ReadUInt16(reader)' 2).PadLeft(16' '0').ToCharArray();
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: int blue = attrib[15].Equals('1') ? 1 : 0;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib[14].Equals('1') ? blue + 2 : blue;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib[14].Equals('1') ? blue + 2 : blue;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib[13].Equals('1') ? blue + 4 : blue;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib[13].Equals('1') ? blue + 4 : blue;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib[12].Equals('1') ? blue + 8 : blue;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib[12].Equals('1') ? blue + 8 : blue;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib[11].Equals('1') ? blue + 16 : blue;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: blue = attrib[11].Equals('1') ? blue + 16 : blue;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: int b = blue * 8;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: int green = attrib[10].Equals('1') ? 1 : 0;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib[9].Equals('1') ? green + 2 : green;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib[9].Equals('1') ? green + 2 : green;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib[8].Equals('1') ? green + 4 : green;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib[8].Equals('1') ? green + 4 : green;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib[7].Equals('1') ? green + 8 : green;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib[7].Equals('1') ? green + 8 : green;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib[6].Equals('1') ? green + 16 : green;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: green = attrib[6].Equals('1') ? green + 16 : green;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: int g = green * 8;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: int red = attrib[5].Equals('1') ? 1 : 0;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: red = attrib[4].Equals('1') ? red + 2 : red;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: red = attrib[4].Equals('1') ? red + 2 : red;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: red = attrib[3].Equals('1') ? red + 4 : red;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: red = attrib[3].Equals('1') ? red + 4 : red;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: red = attrib[2].Equals('1') ? red + 8 : red;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: red = attrib[2].Equals('1') ? red + 8 : red;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: red = attrib[1].Equals('1') ? red + 16 : red;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: int r = red * 8;
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: var currentColor = new Color(r/255f' g/255f' b/255f);
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: var currentColor = new Color(r/255f' g/255f' b/255f);
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,ReadTriangle,The following statement contains a magic number: var currentColor = new Color(r/255f' g/255f' b/255f);
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,TryReadBinary,The following statement contains a magic number: length < 84
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,TryReadBinary,The following statement contains a magic number: this.Header = System.Text.Encoding.ASCII.GetString(reader.ReadBytes(80)).Trim();
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,TryReadBinary,The following statement contains a magic number: length - 84 != numberTriangles * 50
Magic Number,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,TryReadBinary,The following statement contains a magic number: length - 84 != numberTriangles * 50
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,Read,The following statement contains a magic number: switch (id)                      {                          case ChunkID.EDIT_MATERIAL:                              this.ReadMaterial(reader' size);                              break;                          case ChunkID.EDIT_OBJECT:                              this.ReadObject(reader' size);                              break;                          case ChunkID.EDIT3DS:                          case ChunkID.OBJ_CAMERA:                          case ChunkID.OBJ_LIGHT:                          case ChunkID.OBJ_TRIMESH:                                // don't read the whole chunk' read the sub-defines...                              break;                            default:                                // download the whole chunk                              this.ReadData(reader' size - 6);                              break;                      }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMaterial,The following statement contains a magic number: int total = 6;
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMaterial,The following statement contains a magic number: float specularPower = 100;
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id)                  {                      case ChunkID.MAT_NAME01:                          name = this.ReadString(reader);                          break;                      case ChunkID.MAT_TRANSPARENCY:                          // skip the first 6 bytes                          this.ReadData(reader' 6);                          // read the percent value as 16Bit Uint                          byte[] data = this.ReadData(reader' 2);                          opacity = (100 - BitConverter.ToUInt16(data' 0)) / 100.0;                          break;                      case ChunkID.MAT_LUMINANCE:                          luminance = this.ReadColor(reader);                          break;                      case ChunkID.MAT_DIFFUSE:                          diffuse = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SPECULAR:                          specular = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SHININESS:                          //byte[] bytes = this.ReadData(reader' size - 6);                          specularPower = this.ReadPercent(reader' size - 6);                          break;                      case ChunkID.MAT_MAP:                          texture = this.ReadMatMap(reader' size - 6);                          break;                      case ChunkID.MAT_MAPFILE:                          this.ReadData(reader' size - 6);                          break;                        default:                          this.ReadData(reader' size - 6);                          break;                  }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id)                  {                      case ChunkID.MAT_NAME01:                          name = this.ReadString(reader);                          break;                      case ChunkID.MAT_TRANSPARENCY:                          // skip the first 6 bytes                          this.ReadData(reader' 6);                          // read the percent value as 16Bit Uint                          byte[] data = this.ReadData(reader' 2);                          opacity = (100 - BitConverter.ToUInt16(data' 0)) / 100.0;                          break;                      case ChunkID.MAT_LUMINANCE:                          luminance = this.ReadColor(reader);                          break;                      case ChunkID.MAT_DIFFUSE:                          diffuse = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SPECULAR:                          specular = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SHININESS:                          //byte[] bytes = this.ReadData(reader' size - 6);                          specularPower = this.ReadPercent(reader' size - 6);                          break;                      case ChunkID.MAT_MAP:                          texture = this.ReadMatMap(reader' size - 6);                          break;                      case ChunkID.MAT_MAPFILE:                          this.ReadData(reader' size - 6);                          break;                        default:                          this.ReadData(reader' size - 6);                          break;                  }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id)                  {                      case ChunkID.MAT_NAME01:                          name = this.ReadString(reader);                          break;                      case ChunkID.MAT_TRANSPARENCY:                          // skip the first 6 bytes                          this.ReadData(reader' 6);                          // read the percent value as 16Bit Uint                          byte[] data = this.ReadData(reader' 2);                          opacity = (100 - BitConverter.ToUInt16(data' 0)) / 100.0;                          break;                      case ChunkID.MAT_LUMINANCE:                          luminance = this.ReadColor(reader);                          break;                      case ChunkID.MAT_DIFFUSE:                          diffuse = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SPECULAR:                          specular = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SHININESS:                          //byte[] bytes = this.ReadData(reader' size - 6);                          specularPower = this.ReadPercent(reader' size - 6);                          break;                      case ChunkID.MAT_MAP:                          texture = this.ReadMatMap(reader' size - 6);                          break;                      case ChunkID.MAT_MAPFILE:                          this.ReadData(reader' size - 6);                          break;                        default:                          this.ReadData(reader' size - 6);                          break;                  }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id)                  {                      case ChunkID.MAT_NAME01:                          name = this.ReadString(reader);                          break;                      case ChunkID.MAT_TRANSPARENCY:                          // skip the first 6 bytes                          this.ReadData(reader' 6);                          // read the percent value as 16Bit Uint                          byte[] data = this.ReadData(reader' 2);                          opacity = (100 - BitConverter.ToUInt16(data' 0)) / 100.0;                          break;                      case ChunkID.MAT_LUMINANCE:                          luminance = this.ReadColor(reader);                          break;                      case ChunkID.MAT_DIFFUSE:                          diffuse = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SPECULAR:                          specular = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SHININESS:                          //byte[] bytes = this.ReadData(reader' size - 6);                          specularPower = this.ReadPercent(reader' size - 6);                          break;                      case ChunkID.MAT_MAP:                          texture = this.ReadMatMap(reader' size - 6);                          break;                      case ChunkID.MAT_MAPFILE:                          this.ReadData(reader' size - 6);                          break;                        default:                          this.ReadData(reader' size - 6);                          break;                  }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id)                  {                      case ChunkID.MAT_NAME01:                          name = this.ReadString(reader);                          break;                      case ChunkID.MAT_TRANSPARENCY:                          // skip the first 6 bytes                          this.ReadData(reader' 6);                          // read the percent value as 16Bit Uint                          byte[] data = this.ReadData(reader' 2);                          opacity = (100 - BitConverter.ToUInt16(data' 0)) / 100.0;                          break;                      case ChunkID.MAT_LUMINANCE:                          luminance = this.ReadColor(reader);                          break;                      case ChunkID.MAT_DIFFUSE:                          diffuse = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SPECULAR:                          specular = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SHININESS:                          //byte[] bytes = this.ReadData(reader' size - 6);                          specularPower = this.ReadPercent(reader' size - 6);                          break;                      case ChunkID.MAT_MAP:                          texture = this.ReadMatMap(reader' size - 6);                          break;                      case ChunkID.MAT_MAPFILE:                          this.ReadData(reader' size - 6);                          break;                        default:                          this.ReadData(reader' size - 6);                          break;                  }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id)                  {                      case ChunkID.MAT_NAME01:                          name = this.ReadString(reader);                          break;                      case ChunkID.MAT_TRANSPARENCY:                          // skip the first 6 bytes                          this.ReadData(reader' 6);                          // read the percent value as 16Bit Uint                          byte[] data = this.ReadData(reader' 2);                          opacity = (100 - BitConverter.ToUInt16(data' 0)) / 100.0;                          break;                      case ChunkID.MAT_LUMINANCE:                          luminance = this.ReadColor(reader);                          break;                      case ChunkID.MAT_DIFFUSE:                          diffuse = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SPECULAR:                          specular = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SHININESS:                          //byte[] bytes = this.ReadData(reader' size - 6);                          specularPower = this.ReadPercent(reader' size - 6);                          break;                      case ChunkID.MAT_MAP:                          texture = this.ReadMatMap(reader' size - 6);                          break;                      case ChunkID.MAT_MAPFILE:                          this.ReadData(reader' size - 6);                          break;                        default:                          this.ReadData(reader' size - 6);                          break;                  }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id)                  {                      case ChunkID.MAT_NAME01:                          name = this.ReadString(reader);                          break;                      case ChunkID.MAT_TRANSPARENCY:                          // skip the first 6 bytes                          this.ReadData(reader' 6);                          // read the percent value as 16Bit Uint                          byte[] data = this.ReadData(reader' 2);                          opacity = (100 - BitConverter.ToUInt16(data' 0)) / 100.0;                          break;                      case ChunkID.MAT_LUMINANCE:                          luminance = this.ReadColor(reader);                          break;                      case ChunkID.MAT_DIFFUSE:                          diffuse = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SPECULAR:                          specular = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SHININESS:                          //byte[] bytes = this.ReadData(reader' size - 6);                          specularPower = this.ReadPercent(reader' size - 6);                          break;                      case ChunkID.MAT_MAP:                          texture = this.ReadMatMap(reader' size - 6);                          break;                      case ChunkID.MAT_MAPFILE:                          this.ReadData(reader' size - 6);                          break;                        default:                          this.ReadData(reader' size - 6);                          break;                  }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMaterial,The following statement contains a magic number: switch (id)                  {                      case ChunkID.MAT_NAME01:                          name = this.ReadString(reader);                          break;                      case ChunkID.MAT_TRANSPARENCY:                          // skip the first 6 bytes                          this.ReadData(reader' 6);                          // read the percent value as 16Bit Uint                          byte[] data = this.ReadData(reader' 2);                          opacity = (100 - BitConverter.ToUInt16(data' 0)) / 100.0;                          break;                      case ChunkID.MAT_LUMINANCE:                          luminance = this.ReadColor(reader);                          break;                      case ChunkID.MAT_DIFFUSE:                          diffuse = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SPECULAR:                          specular = this.ReadColor(reader);                          break;                      case ChunkID.MAT_SHININESS:                          //byte[] bytes = this.ReadData(reader' size - 6);                          specularPower = this.ReadPercent(reader' size - 6);                          break;                      case ChunkID.MAT_MAP:                          texture = this.ReadMatMap(reader' size - 6);                          break;                      case ChunkID.MAT_MAPFILE:                          this.ReadData(reader' size - 6);                          break;                        default:                          this.ReadData(reader' size - 6);                          break;                  }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMaterial,The following statement contains a magic number: diffuse.A = (byte)(opacity * 255);
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMaterial,The following statement contains a magic number: luminance.A = (byte)(opacity * 255);
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMaterial,The following statement contains a magic number: Math.Abs(opacity) > 0.001
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadObject,The following statement contains a magic number: int total = 6;
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadObject,The following statement contains a magic number: switch (id)                  {                      case ChunkID.OBJ_TRIMESH:                          this.ReadTriangularMesh(reader' size);                          break;                      default:                          {                              this.ReadData(reader' size - 6);                              break;                          }                  }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: int bytesRead = 6;
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id)                  {                      case ChunkID.TRI_VERTEXL:                          positions = this.ReadVertexList(reader);                          break;                      case ChunkID.TRI_FACEL1:                          faces = ReadFaceList(reader);                          size -= (faces.Count / 3 * 8) + 2;                          facesets = this.ReadFaceSets(reader' size - 6);                          break;                      case ChunkID.TRI_TEXCOORD:                          textureCoordinates = ReadTexCoords(reader);                          break;                      case ChunkID.TRI_LOCAL:                          transforms.Add(this.ReadTransformation(reader));                          break;                      default:                          this.ReadData(reader' size - 6);                          break;                    }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id)                  {                      case ChunkID.TRI_VERTEXL:                          positions = this.ReadVertexList(reader);                          break;                      case ChunkID.TRI_FACEL1:                          faces = ReadFaceList(reader);                          size -= (faces.Count / 3 * 8) + 2;                          facesets = this.ReadFaceSets(reader' size - 6);                          break;                      case ChunkID.TRI_TEXCOORD:                          textureCoordinates = ReadTexCoords(reader);                          break;                      case ChunkID.TRI_LOCAL:                          transforms.Add(this.ReadTransformation(reader));                          break;                      default:                          this.ReadData(reader' size - 6);                          break;                    }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id)                  {                      case ChunkID.TRI_VERTEXL:                          positions = this.ReadVertexList(reader);                          break;                      case ChunkID.TRI_FACEL1:                          faces = ReadFaceList(reader);                          size -= (faces.Count / 3 * 8) + 2;                          facesets = this.ReadFaceSets(reader' size - 6);                          break;                      case ChunkID.TRI_TEXCOORD:                          textureCoordinates = ReadTexCoords(reader);                          break;                      case ChunkID.TRI_LOCAL:                          transforms.Add(this.ReadTransformation(reader));                          break;                      default:                          this.ReadData(reader' size - 6);                          break;                    }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id)                  {                      case ChunkID.TRI_VERTEXL:                          positions = this.ReadVertexList(reader);                          break;                      case ChunkID.TRI_FACEL1:                          faces = ReadFaceList(reader);                          size -= (faces.Count / 3 * 8) + 2;                          facesets = this.ReadFaceSets(reader' size - 6);                          break;                      case ChunkID.TRI_TEXCOORD:                          textureCoordinates = ReadTexCoords(reader);                          break;                      case ChunkID.TRI_LOCAL:                          transforms.Add(this.ReadTransformation(reader));                          break;                      default:                          this.ReadData(reader' size - 6);                          break;                    }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: switch (id)                  {                      case ChunkID.TRI_VERTEXL:                          positions = this.ReadVertexList(reader);                          break;                      case ChunkID.TRI_FACEL1:                          faces = ReadFaceList(reader);                          size -= (faces.Count / 3 * 8) + 2;                          facesets = this.ReadFaceSets(reader' size - 6);                          break;                      case ChunkID.TRI_TEXCOORD:                          textureCoordinates = ReadTexCoords(reader);                          break;                      case ChunkID.TRI_LOCAL:                          transforms.Add(this.ReadTransformation(reader));                          break;                      default:                          this.ReadData(reader' size - 6);                          break;                    }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: CreateMesh(positions' textureCoordinates' triangleIndices' transforms' out normals' out tangents' out bitangents' new PhongMaterial()                  {                      Name = "Gray"'                      AmbientColor = new Color4(0.1f' 0.1f' 0.1f' 1.0f)'                      DiffuseColor = new Color4(0.254902f' 0.254902f' 0.254902f' 1.0f)'                      SpecularColor = new Color4(0.0225f' 0.0225f' 0.0225f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 1.0f)'                      SpecularShininess = 12.8f'                  });
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: CreateMesh(positions' textureCoordinates' triangleIndices' transforms' out normals' out tangents' out bitangents' new PhongMaterial()                  {                      Name = "Gray"'                      AmbientColor = new Color4(0.1f' 0.1f' 0.1f' 1.0f)'                      DiffuseColor = new Color4(0.254902f' 0.254902f' 0.254902f' 1.0f)'                      SpecularColor = new Color4(0.0225f' 0.0225f' 0.0225f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 1.0f)'                      SpecularShininess = 12.8f'                  });
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: CreateMesh(positions' textureCoordinates' triangleIndices' transforms' out normals' out tangents' out bitangents' new PhongMaterial()                  {                      Name = "Gray"'                      AmbientColor = new Color4(0.1f' 0.1f' 0.1f' 1.0f)'                      DiffuseColor = new Color4(0.254902f' 0.254902f' 0.254902f' 1.0f)'                      SpecularColor = new Color4(0.0225f' 0.0225f' 0.0225f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 1.0f)'                      SpecularShininess = 12.8f'                  });
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: CreateMesh(positions' textureCoordinates' triangleIndices' transforms' out normals' out tangents' out bitangents' new PhongMaterial()                  {                      Name = "Gray"'                      AmbientColor = new Color4(0.1f' 0.1f' 0.1f' 1.0f)'                      DiffuseColor = new Color4(0.254902f' 0.254902f' 0.254902f' 1.0f)'                      SpecularColor = new Color4(0.0225f' 0.0225f' 0.0225f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 1.0f)'                      SpecularShininess = 12.8f'                  });
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: CreateMesh(positions' textureCoordinates' triangleIndices' transforms' out normals' out tangents' out bitangents' new PhongMaterial()                  {                      Name = "Gray"'                      AmbientColor = new Color4(0.1f' 0.1f' 0.1f' 1.0f)'                      DiffuseColor = new Color4(0.254902f' 0.254902f' 0.254902f' 1.0f)'                      SpecularColor = new Color4(0.0225f' 0.0225f' 0.0225f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 1.0f)'                      SpecularShininess = 12.8f'                  });
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: CreateMesh(positions' textureCoordinates' triangleIndices' transforms' out normals' out tangents' out bitangents' new PhongMaterial()                  {                      Name = "Gray"'                      AmbientColor = new Color4(0.1f' 0.1f' 0.1f' 1.0f)'                      DiffuseColor = new Color4(0.254902f' 0.254902f' 0.254902f' 1.0f)'                      SpecularColor = new Color4(0.0225f' 0.0225f' 0.0225f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 1.0f)'                      SpecularShininess = 12.8f'                  });
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: CreateMesh(positions' textureCoordinates' triangleIndices' transforms' out normals' out tangents' out bitangents' new PhongMaterial()                  {                      Name = "Gray"'                      AmbientColor = new Color4(0.1f' 0.1f' 0.1f' 1.0f)'                      DiffuseColor = new Color4(0.254902f' 0.254902f' 0.254902f' 1.0f)'                      SpecularColor = new Color4(0.0225f' 0.0225f' 0.0225f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 1.0f)'                      SpecularShininess = 12.8f'                  });
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: CreateMesh(positions' textureCoordinates' triangleIndices' transforms' out normals' out tangents' out bitangents' new PhongMaterial()                  {                      Name = "Gray"'                      AmbientColor = new Color4(0.1f' 0.1f' 0.1f' 1.0f)'                      DiffuseColor = new Color4(0.254902f' 0.254902f' 0.254902f' 1.0f)'                      SpecularColor = new Color4(0.0225f' 0.0225f' 0.0225f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 1.0f)'                      SpecularShininess = 12.8f'                  });
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: CreateMesh(positions' textureCoordinates' triangleIndices' transforms' out normals' out tangents' out bitangents' new PhongMaterial()                  {                      Name = "Gray"'                      AmbientColor = new Color4(0.1f' 0.1f' 0.1f' 1.0f)'                      DiffuseColor = new Color4(0.254902f' 0.254902f' 0.254902f' 1.0f)'                      SpecularColor = new Color4(0.0225f' 0.0225f' 0.0225f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 1.0f)'                      SpecularShininess = 12.8f'                  });
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadTriangularMesh,The following statement contains a magic number: CreateMesh(positions' textureCoordinates' triangleIndices' transforms' out normals' out tangents' out bitangents' new PhongMaterial()                  {                      Name = "Gray"'                      AmbientColor = new Color4(0.1f' 0.1f' 0.1f' 1.0f)'                      DiffuseColor = new Color4(0.254902f' 0.254902f' 0.254902f' 1.0f)'                      SpecularColor = new Color4(0.0225f' 0.0225f' 0.0225f' 1.0f)'                      EmissiveColor = new Color4(0.0f' 0.0f' 0.0f' 1.0f)'                      SpecularShininess = 12.8f'                  });
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ComputeNormals,The following statement contains a magic number: var i3 = triangleIndices[t + 2];
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: var triangleIndices = new IntCollection(subFaces.Count * 3);
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: triangleIndices.Add(faces[f * 3]);
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: triangleIndices.Add(faces[(f * 3) + 1]);
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: triangleIndices.Add(faces[(f * 3) + 2]);
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ConvertFaceIndices,The following statement contains a magic number: triangleIndices.Add(faces[(f * 3) + 2]);
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: int total = 6;
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: switch (id)                  {                      case ChunkID.TRI_FACEMAT:                          {                              string name = this.ReadString(reader);                              int n = reader.ReadUInt16();                              var c = new List<int>();                              for (int i = 0; i < n; i++)                              {                                  c.Add(reader.ReadUInt16());                              }                                var fm = new FaceSet { Name = name' Faces = c };                              list.Add(fm);                              break;                          }                        case ChunkID.TRI_SMOOTH:                          {                              this.ReadData(reader' size - 6);                              break;                          }                        default:                          {                              this.ReadData(reader' size - 6);                              break;                          }                  }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadFaceSets,The following statement contains a magic number: switch (id)                  {                      case ChunkID.TRI_FACEMAT:                          {                              string name = this.ReadString(reader);                              int n = reader.ReadUInt16();                              var c = new List<int>();                              for (int i = 0; i < n; i++)                              {                                  c.Add(reader.ReadUInt16());                              }                                var fm = new FaceSet { Name = name' Faces = c };                              list.Add(fm);                              break;                          }                        case ChunkID.TRI_SMOOTH:                          {                              this.ReadData(reader' size - 6);                              break;                          }                        default:                          {                              this.ReadData(reader' size - 6);                              break;                          }                  }
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadMatMap,The following statement contains a magic number: size -= 14;
Magic Number,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadPercent,The following statement contains a magic number: size -= 6;
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: var dx = new Vector3D((float)xlength/2f' 0' 0);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: var dy = new Vector3D(0' (float)ylength/2f' 0);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: var dz = new Vector3D(0' 0' (float)zlength/2f);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange(new[] { i0 + 0' i0 + 4' i0 + 1' i0 + 5' i0 + 2' i0 + 6' i0 + 3' i0 + 7 });
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange(new[] { i0 + 0' i0 + 4' i0 + 1' i0 + 5' i0 + 2' i0 + 6' i0 + 3' i0 + 7 });
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange(new[] { i0 + 0' i0 + 4' i0 + 1' i0 + 5' i0 + 2' i0 + 6' i0 + 3' i0 + 7 });
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange(new[] { i0 + 0' i0 + 4' i0 + 1' i0 + 5' i0 + 2' i0 + 6' i0 + 3' i0 + 7 });
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange(new[] { i0 + 0' i0 + 4' i0 + 1' i0 + 5' i0 + 2' i0 + 6' i0 + 3' i0 + 7 });
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddBox,The following statement contains a magic number: lineListIndices.AddRange(new[] { i0 + 0' i0 + 4' i0 + 1' i0 + 5' i0 + 2' i0 + 6' i0 + 3' i0 + 7 });
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddGrid,The following statement contains a magic number: columns < 2 || rows < 2
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddGrid,The following statement contains a magic number: columns < 2 || rows < 2
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddCircle,The following statement contains a magic number: segments < 3
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddCircle,The following statement contains a magic number: float sectionAngle = (float)(2.0 * Math.PI / segments);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,AddCircle,The following statement contains a magic number: axis.LengthSquared() > 1e-6
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[1]' cc[2]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[2]' cc[3]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[2]' cc[3]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[3]' cc[0]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[4]' cc[5]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[4]' cc[5]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[5]' cc[6]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[5]' cc[6]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[6]' cc[7]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[6]' cc[7]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[7]' cc[4]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[7]' cc[4]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[0]' cc[4]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[1]' cc[5]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[2]' cc[6]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[2]' cc[6]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[3]' cc[7]);
Magic Number,HelixToolkit.SharpDX.Core,LineBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\LineBuilder.cs,GenerateBoundingBox,The following statement contains a magic number: ll.AddLine(cc[3]' cc[7]);
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,DynamicOctreeBase,The following statement contains a magic number: stack = stackCache ?? new Stack<KeyValuePair<int' IDynamicOctree[]>>(64);
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,CreateOctants,The following statement contains a magic number: Vector3 half = dimensions / 2.0f;
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,CreateOctants,The following statement contains a magic number: return new BoundingBox[8] {                  new BoundingBox(minimum' center)'                  new BoundingBox(new Vector3(center.X' minimum.Y' minimum.Z)' new Vector3(maximum.X' center.Y' center.Z))'                  new BoundingBox(new Vector3(center.X' minimum.Y' center.Z)' new Vector3(maximum.X' center.Y' maximum.Z))'                  new BoundingBox(new Vector3(minimum.X' minimum.Y' center.Z)' new Vector3(center.X' center.Y' maximum.Z))'                  new BoundingBox(new Vector3(minimum.X' center.Y' minimum.Z)' new Vector3(center.X' maximum.Y' center.Z))'                  new BoundingBox(new Vector3(center.X' center.Y' minimum.Z)' new Vector3(maximum.X' maximum.Y' center.Z))'                  new BoundingBox(center' maximum)'                  new BoundingBox(new Vector3(minimum.X' center.Y' center.Z)' new Vector3(center.X' maximum.Y' maximum.Z))                  };
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,BuildSubTree,The following statement contains a magic number: var octList = new List<T>[8];
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,BuildSubTree,The following statement contains a magic number: octList[i] = new List<T>(Objects.Count / 8);
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,BuildSubTree,The following statement contains a magic number: i < 8
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,BuildSubTree,The following statement contains a magic number: x < 8
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,BuildSubTree,The following statement contains a magic number: i < 8
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,FindEnclosingCube,The following statement contains a magic number: var v = (bound.Maximum - bound.Minimum) / 2 + bound.Minimum;
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,SigBit,The following statement contains a magic number: return (int)Math.Pow(2' Math.Ceiling(Math.Log(x) / Math.Log(2)));
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,SigBit,The following statement contains a magic number: return (int)Math.Pow(2' Math.Ceiling(Math.Log(x) / Math.Log(2)));
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,FindNearestPointFromPoint,The following statement contains a magic number: heuristicSearchFactor = Math.Min(1.0f' Math.Max(0.1f' heuristicSearchFactor));
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,Expand,The following statement contains a magic number: var half = dimension / 2 + epsilon;
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,Expand,The following statement contains a magic number: var newSize = dimension * 2;
Magic Number,HelixToolkit.SharpDX.Core,DynamicOctreeBase<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,Expand,The following statement contains a magic number: diff < 10e-8
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,MeshGeometryOctree,The following statement contains a magic number: Objects = new List<KeyValuePair<int' BoundingBox>>(indices.Count / 3);
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,MeshGeometryOctree,The following statement contains a magic number: i < indices.Count / 3
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,GetBoundingBox,The following statement contains a magic number: var actual = triangleIndex * 3;
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTestCurrentNodeExcludeChild,The following statement contains a magic number: var idx = Objects[i].Key * 3;
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTestCurrentNodeExcludeChild,The following statement contains a magic number: var t3 = Indices[idx + 2];
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,FindNearestPointBySphereExcludeChild,The following statement contains a magic number: var idx = Objects[i].Key * 3;
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,FindNearestPointBySphereExcludeChild,The following statement contains a magic number: var t3 = Indices[idx + 2];
Magic Number,HelixToolkit.SharpDX.Core,LineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,LineGeometryOctree,The following statement contains a magic number: Objects = new List<KeyValuePair<int' BoundingBox>>(indices.Count / 2);
Magic Number,HelixToolkit.SharpDX.Core,LineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,LineGeometryOctree,The following statement contains a magic number: i < indices.Count / 2
Magic Number,HelixToolkit.SharpDX.Core,LineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,GetBoundingBox,The following statement contains a magic number: var actual = triangleIndex * 2;
Magic Number,HelixToolkit.SharpDX.Core,LineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,HitTestCurrentNodeExcludeChild,The following statement contains a magic number: var idx = Objects[i].Key * 2;
Magic Number,HelixToolkit.SharpDX.Core,LineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\Octree.cs,FindNearestPointBySphereExcludeChild,The following statement contains a magic number: var idx = Objects[i].Key * 3;
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: Vector3[] verts = new Vector3[8];
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[7] = box.Maximum;
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[0]' verts[2]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[0]' verts[3]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[4]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[4]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[5]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[5]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[6]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[6]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[1]' verts[6]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[1]' verts[5]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[4]' verts[2]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[4]' verts[2]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[4]' verts[3]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[4]' verts[3]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[2]' verts[6]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[2]' verts[6]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[3]' verts[5]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[3]' verts[5]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: Vector3[] verts = new Vector3[8];
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: verts[7] = box.Maximum;
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[0]' verts[2]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[0]' verts[3]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[7]' verts[4]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[7]' verts[4]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[7]' verts[5]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[7]' verts[5]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[7]' verts[6]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[7]' verts[6]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[1]' verts[6]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[1]' verts[5]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[4]' verts[2]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[4]' verts[2]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[4]' verts[3]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[4]' verts[3]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[2]' verts[6]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[2]' verts[6]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[3]' verts[5]);
Magic Number,HelixToolkit.SharpDX.Core,OctreeHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\OctreeHelper.cs,CreatePathLines,The following statement contains a magic number: builder.AddLine(verts[3]' verts[5]);
Magic Number,HelixToolkit.SharpDX.Core,TreeTraverser,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TreeTraverser.cs,PreorderDFT,The following statement contains a magic number: var stack = stackCache ?? new Stack<IEnumerator<SceneNode>>(20);
Magic Number,HelixToolkit.SharpDX.Core,TreeTraverser,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TreeTraverser.cs,PreorderDFT,The following statement contains a magic number: var stack = stackCache ?? new Stack<KeyValuePair<int' IList<SceneNode>>>(20);
Magic Number,HelixToolkit.SharpDX.Core,TreeTraverser,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TreeTraverser.cs,PreorderDFTGetCores,The following statement contains a magic number: var stack = stackCache ?? new Stack<IEnumerator<SceneNode>>(20);
Magic Number,HelixToolkit.SharpDX.Core,TreeTraverser,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TreeTraverser.cs,PreorderDFTRun,The following statement contains a magic number: var stack = stackCache ?? new Stack<KeyValuePair<int' IList<SceneNode2D>>>(20);
Magic Number,HelixToolkit.SharpDX.Core,TreeTraverser,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TreeTraverser.cs,PreorderDFTGetCores,The following statement contains a magic number: var stack = stackCache ?? new Stack<IEnumerator<SceneNode2D>>(20);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,GetCircle,The following statement contains a magic number: var theta = (DoubleOrSingle)Math.PI * 2 * ((DoubleOrSingle)i / num);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormals,The following statement contains a magic number: var i3 = triangleIndices[t + 2];
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The following statement contains a magic number: var i3 = triangleIndices[t + 2];
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: var i3 = indices[t + 2];
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: var i4 = indices[t + 3];
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddArrow,The following statement contains a magic number: var r = (DoubleOrSingle)diameter / 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddArrow,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' 0)'                      new Point(0' r)'                      new Point(length - (DoubleOrSingle)(diameter * headLength)' r)'                      new Point(length - (DoubleOrSingle)(diameter * headLength)' r * 2)'                      new Point(length' 0)                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: var n = normal * (DoubleOrSingle)dist / 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: up *= (DoubleOrSingle)height / 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: right *= (DoubleOrSingle)width / 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add(i0 + 3);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The following statement contains a magic number: this.AddCone(p1' n' diameter / 2' diameter / 2' l' false' false' thetaDiv);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The following statement contains a magic number: this.AddCone(p1' n' diameter / 2' diameter / 2' l' false' false' thetaDiv);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusSphere = 0.25f * (DoubleOrSingle)Math.Sqrt(3) * (1 + (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusSphere = 0.25f * (DoubleOrSingle)Math.Sqrt(3) * (1 + (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusSphere = 0.25f * (DoubleOrSingle)Math.Sqrt(3) * (1 + (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusFace = 0.1f * (DoubleOrSingle)Math.Sqrt(50 + 10 * (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusFace = 0.1f * (DoubleOrSingle)Math.Sqrt(50 + 10 * (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusFace = 0.1f * (DoubleOrSingle)Math.Sqrt(50 + 10 * (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusFace = 0.1f * (DoubleOrSingle)Math.Sqrt(50 + 10 * (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var pentagonPoints = GetCircle(5' true);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var gamma = (DoubleOrSingle)Math.Acos(1 - (sideLength * sideLength / (2 * radiusSphere * radiusSphere)));
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var v = cTPUpValue * 0.5f + 0.5f;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var v = cTPUpValue * 0.5f + 0.5f;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation(this.positions.Skip(positionsCount).Take(5).Select((p' i) => i).ToList());
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation(this.positions.Skip(positionsCount + 15).Select((p' i) => 15 + i).ToList());
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation(this.positions.Skip(positionsCount + 15).Select((p' i) => 15 + i).ToList());
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: i < 5
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The following statement contains a magic number: var dt = 2 * (DoubleOrSingle)Math.PI / thetaDiv;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The following statement contains a magic number: var uv = new Point(theta / (2 * (DoubleOrSingle)Math.PI)' phi / (DoubleOrSingle)Math.PI);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedGeometry,The following statement contains a magic number: int np = 2 * points.Count;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedGeometry,The following statement contains a magic number: int i2 = (index0 + 2) % np;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedGeometry,The following statement contains a magic number: int i3 = ((index0 + 2) % np) + 1;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: points.Count % 2 != 0
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: int i0 = index0 + (i * 2);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: int i2 = i0 + 3;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: int i3 = i0 + 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The following statement contains a magic number: var n = forward * (DoubleOrSingle)sideLength / 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The following statement contains a magic number: up *= (DoubleOrSingle)height / 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The following statement contains a magic number: right *= (DoubleOrSingle)sideLength / 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' (DoubleOrSingle)innerDiameter / 2)'                      new Point(0' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)innerDiameter / 2)                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' (DoubleOrSingle)innerDiameter / 2)'                      new Point(0' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)innerDiameter / 2)                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' (DoubleOrSingle)innerDiameter / 2)'                      new Point(0' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)innerDiameter / 2)                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' (DoubleOrSingle)innerDiameter / 2)'                      new Point(0' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)innerDiameter / 2)                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: pc.Add(new Point(0' (DoubleOrSingle)innerDiameter / 2));
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: this.triangleIndices.Add(vertexIndices[i + 2]);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: i + 2 < n
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: var n = forward * (DoubleOrSingle)sideLength / 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: right *= (DoubleOrSingle)sideLength / 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: var down = -up * 1f / 3;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: var realup = up * 2f / 3;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: var realup = up * 2f / 3;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: i < 4
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add(i0 + 3);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: Debug.Assert(quadPositions.Count > 0 && quadPositions.Count % 4 == 0' "Wrong number of positions.");
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: this.triangleIndices.Add(i + 2);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: this.triangleIndices.Add(i + 2);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: this.triangleIndices.Add(i + 3);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: i + 3 < indexEnd
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The following statement contains a magic number: columns < 2 || rows < 2
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The following statement contains a magic number: columns < 2 || rows < 2
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndices,The following statement contains a magic number: !isSpherical || i < rows - 2
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndicesFlipped,The following statement contains a magic number: !isSpherical || i < rows - 2
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var a = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 + Math.Sqrt(5.0)));
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var a = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 + Math.Sqrt(5.0)));
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var a = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 + Math.Sqrt(5.0)));
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var b = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 - Math.Sqrt(5.0)));
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var b = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 - Math.Sqrt(5.0)));
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var b = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 - Math.Sqrt(5.0)));
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: int totalNodes = (points.Count - 1) * 2 * thetaDiv;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: int rowNodes = (points.Count - 1) * 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: int i0 = index0 + (i * rowNodes) + (j * 2);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: int i2 = index0 + ((((i + 1) * rowNodes) + (j * 2)) % totalNodes);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var heightSphere = (DoubleOrSingle)Math.Sqrt(6) / 3 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var heightSphere = (DoubleOrSingle)Math.Sqrt(6) / 3 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var radiusSphere = (DoubleOrSingle)Math.Sqrt(6) / 4 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var radiusSphere = (DoubleOrSingle)Math.Sqrt(6) / 4 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var heightFace = (DoubleOrSingle)Math.Sqrt(3) / 2 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var heightFace = (DoubleOrSingle)Math.Sqrt(3) / 2 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var radiusFace = (DoubleOrSingle)Math.Sqrt(3) / 3 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var radiusFace = (DoubleOrSingle)Math.Sqrt(3) / 3 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var halfLength = (DoubleOrSingle)sideLength * 0.5f;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The following statement contains a magic number: i < 3
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: this.triangleIndices.Add(vertices[i + 2]);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: i + 2 < vertices.Count
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: fanPositions.Count < 3
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: this.triangleIndices.Add(i + 2);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: i + 2 < indexEnd
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangles,The following statement contains a magic number: trianglePositions.Count % 3 != 0
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: this.triangleIndices.Add(i + 2);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: this.triangleIndices.Add(i + 3);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: this.triangleIndices.Add(i + 2);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: i + 3 < indexEnd
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: i + 2 < indexEnd
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: pathLength < 2 || sectionLength < 2
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: pathLength < 2 || sectionLength < 2
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: var r = diameters != null ? (DoubleOrSingle)diameters[i % diametersCount] / 2 : 1;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: var normal = path[count - 1] - path[count - 2];
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: pathLength < 2 || sectionLength < 2
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: pathLength < 2 || sectionLength < 2
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: var radius = diameters != null ? (DoubleOrSingle)diameters[i % diametersCount] / 2 : 1;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: SharedFunctions.LengthSquared(ref right) > 1e-6f
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: var normal = path[count - 1] - path[count - 2];
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: int i2 = i + 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: i1 = i + 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: i0 = i + 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,FindCornerNormal,The following statement contains a magic number: int i2 = i + 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,NoSharedVertices,The following statement contains a magic number: int i2 = i + 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: int i2 = this.TriangleIndices[i + 2];
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: var p01 = p0 + (v01 * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: var p12 = p1 + (v12 * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: var p20 = p2 + (v20 * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: var uv2 = this.TextureCoordinates[i0 + 2];
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: var u01 = uv0 + (t01 * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: var u12 = uv1 + (t12 * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: var u20 = uv2 + (t20 * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: this.TriangleIndices[i + 2] = i20;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: int i2 = this.TriangleIndices[i + 2];
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: var p01 = p0 + (v01 * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: var p12 = p1 + (v12 * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: var p20 = p2 + (v20 * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: int i12 = im + 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: int i20 = im + 3;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: var uv2 = this.TextureCoordinates[i0 + 2];
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: var u01 = uv0 + (t01 * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: var u12 = uv1 + (t12 * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: var u20 = uv2 + (t20 * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: this.TriangleIndices[i + 2] = im;
Magic Number,HelixToolkit.SharpDX.Core,MeshBuilder,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: im += 4;
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CalculateNormals,The following statement contains a magic number: int index2 = triangleIndices[i + 2];
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: int i0 = i * 3;
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: j < 3
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: i < mesh.TriangleIndices.Count / 3
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: int i0 = i * 3;
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: j < 3
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: i < mesh.TriangleIndices.Count / 3
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: int i0 = i * 3;
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: var p2 = mesh.Positions[mesh.TriangleIndices[i0 + 2]];
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos(SharedFunctions.DotProduct(ref n' ref n2));
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: j < 3
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: i < mesh.TriangleIndices.Count / 3
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The following statement contains a magic number: int i2 = i + 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: mesh.TriangleIndices.Count % 3 != 0
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: sb.AppendFormat("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: sb.AppendFormat("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The following statement contains a magic number: var index2 = mesh.TriangleIndices[i + 2];
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The following statement contains a magic number: contourHelper.ContourFacet(                      mesh.TriangleIndices[i]'                      mesh.TriangleIndices[i + 1]'                      mesh.TriangleIndices[i + 2]'                      out positions'                      out normals'                      out textureCoordinates'                      out triangleIndices);
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: segment1 % 2 == 1
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: segmentCount -= 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: segment2 % 2 == 1
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: segmentCount -= 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: curveCount += 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: segmentCount -= 2;
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CreateKey,The following statement contains a magic number: return ((ulong)i0 << 32) + i1;
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i0 = (uint)(key >> 32);
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i1 = (uint)((key << 32) >> 32);
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i1 = (uint)((key << 32) >> 32);
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveOutOfRangeTriangles,The following statement contains a magic number: triangles[i] >= numVerts || triangles[i + 1] >= numVerts || triangles[i + 2] >= numVerts
Magic Number,HelixToolkit.SharpDX.Core,MeshGeometryHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveOutOfRangeTriangles,The following statement contains a magic number: removeOutOfRangeTriangles.RemoveRange(idx' 3);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,MeshSimplification,The following statement contains a magic number: triangles = new List<Triangle>(Enumerable.Range(0' model.TriangleIndices.Count / 3).Select(x=>new Triangle()));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,MeshSimplification,The following statement contains a magic number: tri.v[2] = model.TriangleIndices[i++];
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: return Simplify(int.MaxValue' 7' verbose' true);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: int maxIteration = 9999;
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: maxIteration = 100;
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: lossless || iteration % 5 == 0
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: double threshold = 0.001;
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: tri.err[3] > threshold || tri.deleted || tri.dirty
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: int i1 = tri.v[(j + 1) % 3];
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: j < 3
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,GetMesh,The following statement contains a magic number: var tris = new Int32Collection(triangles.Count*3);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,GetMesh,The following statement contains a magic number: tris.Add(tri.v[2]);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: int id1 = t.v[(s + 1) % 3];
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: int id2 = t.v[(s + 2) % 3];
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: int id2 = t.v[(s + 2) % 3];
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: SharedFunctions.DotProduct(ref d1' ref d2) > 0.999
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: SharedFunctions.DotProduct(ref n' ref t.normal) < 0.2
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: t.err[1] = CalculateError(t.v[1]' t.v[2]' out p);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: t.err[2] = CalculateError(t.v[2]' t.v[0]' out p);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: t.err[2] = CalculateError(t.v[2]' t.v[0]' out p);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: t.err[3] = Math.Min(t.err[0]' Math.Min(t.err[1]' t.err[2]));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: t.err[3] = Math.Min(t.err[0]' Math.Min(t.err[1]' t.err[2]));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8)));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: var p2 = vertices[tri.v[2]].p;
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: j < 3
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: tri.err[i] = CalculateError(tri.v[i]' tri.v[(i + 1) % 3]' out p);
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: i < 3
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: tri.err[3] = Math.Min(tri.err[0]' Math.Min(tri.err[1]' tri.err[2]));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: tri.err[3] = Math.Min(tri.err[0]' Math.Min(tri.err[1]' tri.err[2]));
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: vertices[tri.v[2]].tCount++;
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: int totalTris = triangles.Count * 3;
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: j < 3
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: k < 3
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CompactMesh,The following statement contains a magic number: vertices[triangles[i].v[2]].tCount = 1;
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CompactMesh,The following statement contains a magic number: tri.v[2] = vertices[tri.v[2]].tStart;
Magic Number,HelixToolkit.SharpDX.Core,MeshSimplification,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CompactMesh,The following statement contains a magic number: tri.v[2] = vertices[tri.v[2]].tStart;
Magic Number,HelixToolkit.SharpDX.Core,Polygon3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: this.Points.Count < 3
Magic Number,HelixToolkit.SharpDX.Core,Polygon3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: n.LengthSquared() > 1e-10
Magic Number,HelixToolkit.SharpDX.Core,Polygon3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: Vector3D result = Vector3D.Cross(v1' this.Points[2] - this.Points[0]);
Magic Number,HelixToolkit.SharpDX.Core,Polygon3D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,IsPlanar,The following statement contains a magic number: i == 2
Magic Number,HelixToolkit.SharpDX.Core,SweepLinePolygonTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: count < 3
Magic Number,HelixToolkit.SharpDX.Core,SweepLinePolygonTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,BestEdge,The following statement contains a magic number: var bestAngle = (float)Math.PI * 2;
Magic Number,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourHelper,The following statement contains a magic number: this.normals = hasNormals ? new Vector3D[3] : null;
Magic Number,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourHelper,The following statement contains a magic number: this.textures = hasTextureCoordinates ? new Point[3] : null;
Magic Number,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,GetContourFacet,The following statement contains a magic number: return this.sides[2] > 0 ? ContourFacetResult.TwoOnly : ContourFacetResult.ZeroAndOne;
Magic Number,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,GetContourFacet,The following statement contains a magic number: this.IsSideAlone(2)
Magic Number,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.indices[2] = index2;
Magic Number,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.points[2] = this.meshPositions[index2];
Magic Number,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.normals[2] = this.meshNormals[index2];
Magic Number,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.textures[2] = this.meshTextureCoordinates[index2];
Magic Number,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides[2] = (this.a * this.points[2].X) + (this.b * this.points[2].Y) + (this.c * this.points[2].Z) + this.d;
Magic Number,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides[2] = (this.a * this.points[2].X) + (this.b * this.points[2].Y) + (this.c * this.points[2].Z) + this.d;
Magic Number,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides[2] = (this.a * this.points[2].X) + (this.b * this.points[2].Y) + (this.c * this.points[2].Z) + this.d;
Magic Number,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides[2] = (this.a * this.points[2].X) + (this.b * this.points[2].Y) + (this.c * this.points[2].Z) + this.d;
Magic Number,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,IsSideAlone,The following statement contains a magic number: Func<int' int> getNext = i => i + 1 > 2 ? 0 : i + 1;
Magic Number,HelixToolkit.SharpDX.Core,ContourHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,AllSidesBelowContour,The following statement contains a magic number: return this.sides[0] >= 0                  && this.sides[1] >= 0                  && this.sides[2] >= 0;
Magic Number,HelixToolkit.SharpDX.Core,MathHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\MathHelper.cs,GenerateNoiseMap,The following statement contains a magic number: var frequency = 0.5f;
Magic Number,HelixToolkit.SharpDX.Core,MathHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\MathHelper.cs,GenerateNoiseMap,The following statement contains a magic number: frequency *= 2;
Magic Number,HelixToolkit.SharpDX.Core,MathHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\MathHelper.cs,GenerateNoiseMap,The following statement contains a magic number: amplitude /= 2;
Magic Number,HelixToolkit.SharpDX.Core,Noise2d,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\MathHelper.cs,CalculatePermutation,The following statement contains a magic number: p = Enumerable.Range(0' 256).ToArray();
Magic Number,HelixToolkit.SharpDX.Core,Noise2d,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\MathHelper.cs,CalculateGradients,The following statement contains a magic number: grad = new Vector2[256];
Magic Number,HelixToolkit.SharpDX.Core,Noise2d,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\MathHelper.cs,CalculateGradients,The following statement contains a magic number: gradient = new Vector2((float)(_random.NextDouble() * 2 - 1)' (float)(_random.NextDouble() * 2 - 1));
Magic Number,HelixToolkit.SharpDX.Core,Noise2d,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\MathHelper.cs,CalculateGradients,The following statement contains a magic number: gradient = new Vector2((float)(_random.NextDouble() * 2 - 1)' (float)(_random.NextDouble() * 2 - 1));
Magic Number,HelixToolkit.SharpDX.Core,Noise2d,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\MathHelper.cs,Drop,The following statement contains a magic number: return 1f - t * t * t * (t * (t * 6 - 15) + 10);
Magic Number,HelixToolkit.SharpDX.Core,Noise2d,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\MathHelper.cs,Drop,The following statement contains a magic number: return 1f - t * t * t * (t * (t * 6 - 15) + 10);
Magic Number,HelixToolkit.SharpDX.Core,Noise2d,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\MathHelper.cs,Drop,The following statement contains a magic number: return 1f - t * t * t * (t * (t * 6 - 15) + 10);
Magic Number,Core2D,RenderCore2DBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\Abstract\RenderCore2DBase.cs,Render,The following statement contains a magic number: context.DeviceContext.DrawRectangle(LayoutClippingBound' borderBrush' 0.5f' borderDotStyle);
Magic Number,Core2D,EllipseRenderCore2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\EllipseRenderCore2D.cs,OnRender,The following statement contains a magic number: ellipse.RadiusX = LayoutBound.Width / 2;
Magic Number,Core2D,EllipseRenderCore2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\EllipseRenderCore2D.cs,OnRender,The following statement contains a magic number: ellipse.RadiusY = LayoutBound.Height / 2;
Magic Number,Core2D,FrameStatisticsRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\FrameStatisticsRenderCore.cs,OnAttach,The following statement contains a magic number: format = Collect(new TextFormat(factory' "Arial"' 12));
Magic Number,Core2D,FrameStatisticsRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\FrameStatisticsRenderCore.cs,OnRender,The following statement contains a magic number: Background = new D2D.SolidColorBrush(context.DeviceContext' new Color4(0.8f' 0.8f' 0.8f' 0.6f));
Magic Number,Core2D,FrameStatisticsRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\FrameStatisticsRenderCore.cs,OnRender,The following statement contains a magic number: Background = new D2D.SolidColorBrush(context.DeviceContext' new Color4(0.8f' 0.8f' 0.8f' 0.6f));
Magic Number,Core2D,FrameStatisticsRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\FrameStatisticsRenderCore.cs,OnRender,The following statement contains a magic number: Background = new D2D.SolidColorBrush(context.DeviceContext' new Color4(0.8f' 0.8f' 0.8f' 0.6f));
Magic Number,Core2D,FrameStatisticsRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core2D\FrameStatisticsRenderCore.cs,OnRender,The following statement contains a magic number: Background = new D2D.SolidColorBrush(context.DeviceContext' new Color4(0.8f' 0.8f' 0.8f' 0.6f));
Magic Number,Core,StaticGeometryBatchingBufferBase<BatchedGeometry;VertStruct>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Batching\StaticGeometryBatchingBufferBase.cs,OnSubmitGeometries,The following statement contains a magic number: Geometries.Length > 50 && totalVertex > 5000
Magic Number,Core,StaticGeometryBatchingBufferBase<BatchedGeometry;VertStruct>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Batching\StaticGeometryBatchingBufferBase.cs,OnSubmitGeometries,The following statement contains a magic number: Geometries.Length > 50 && totalVertex > 5000
Magic Number,Core,DefaultMeshGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\MeshBufferModel.cs,IsVertexBufferChanged,The following statement contains a magic number: switch (bufferIndex)                  {                      case 0:                          return base.IsVertexBufferChanged(propertyName' bufferIndex);                      case 1:                          return propertyName.Equals(nameof(MeshGeometry3D.TextureCoordinates));                                        case 2:                          return propertyName.Equals(nameof(MeshGeometry3D.Colors));                      default:                          return false;                  }
Magic Number,Core,DefaultMeshGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\MeshBufferModel.cs,OnCreateVertexBuffer,The following statement contains a magic number: switch (bufferIndex)                      {                          case 0:                              // -- set geometry if given                              if (geometry.Positions != null && geometry.Positions.Count > 0)                              {                                  // --- get geometry                                  var data = BuildVertexArray(mesh);                                  buffer.UploadDataToBuffer(context' data' geometry.Positions.Count' 0' geometry.PreDefinedVertexCount);                              }                              else                              {                                  //buffer.DisposeAndClear();                                  buffer.UploadDataToBuffer(context' emptyVerts' 0);                              }                              break;                          case 1:                              if(mesh.TextureCoordinates != null && mesh.TextureCoordinates.Count > 0)                              {                                  buffer.UploadDataToBuffer(context' mesh.TextureCoordinates' mesh.TextureCoordinates.Count' 0' geometry.PreDefinedVertexCount);                              }                              else                              {                                  buffer.UploadDataToBuffer(context' emptyTextureArray' 0);                              }                              break;                          case 2:                              if (geometry.Colors != null && geometry.Colors.Count > 0)                              {                                  buffer.UploadDataToBuffer(context' geometry.Colors' geometry.Colors.Count' 0' geometry.PreDefinedVertexCount);                              }                              else                              {                                  buffer.UploadDataToBuffer(context' emptyColorArray' 0);                              }                              break;                      }
Magic Number,Core,CrossSectionMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\CrossSectionMeshRenderCore.cs,OnRender,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,DrawScreenQuadCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\DrawScreenQuadCore.cs,Render,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,DynamicCubeMapCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\DynamicCubeMapCore.cs,CreateCubeMapResources,The following statement contains a magic number: i < 6
Magic Number,Core,DynamicCubeMapCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\DynamicCubeMapCore.cs,CreateCubeMapResources,The following statement contains a magic number: i < 6
Magic Number,Core,DynamicCubeMapCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\DynamicCubeMapCore.cs,OnDetach,The following statement contains a magic number: i < 6
Magic Number,Core,DynamicCubeMapCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\DynamicCubeMapCore.cs,Render,The following statement contains a magic number: Parallel.For(0' 6' (index) =>      #endif                  {                                     try                      {                          var ctx = contextPool.Get();                          ctx.ClearRenderTargetView(cubeRTVs[index]' context.RenderHost.ClearColor);                          ctx.ClearDepthStencilView(cubeDSVs[index]' DepthStencilClearFlags.Depth' 1' 0);                          ctx.SetRenderTarget(cubeDSVs[index]' cubeRTVs[index]);                          ctx.SetViewport(ref viewport);                          ctx.SetScissorRectangle(0' 0' FaceSize' FaceSize);                          var transforms = new GlobalTransformStruct();                          transforms.Projection = cubeFaceCameras.Cameras[index].Projection;                          transforms.View = cubeFaceCameras.Cameras[index].View;                          transforms.Viewport = new Vector4(FaceSize' FaceSize' 1/FaceSize' 1/FaceSize);                          transforms.ViewProjection = transforms.View * transforms.Projection;                            modelCB.Upload(ctx' ref transforms);                            var frustum = new BoundingFrustum(transforms.ViewProjection);                          //Render opaque                          for (int i = 0; i < context.RenderHost.PerFrameOpaqueNodes.Count; ++i)                          {                              var node = context.RenderHost.PerFrameOpaqueNodes[i];                              if (node.GUID != this.GUID && !IgnoredGuid.Contains(node.GUID) && node.TestViewFrustum(ref frustum))                              {                                  node.Render(context' ctx);                              }                          }                          //Render particle                          for (int i = 0; i < context.RenderHost.PerFrameParticleNodes.Count; ++i)                          {                              var node = context.RenderHost.PerFrameParticleNodes[i];                              if (node.GUID != this.GUID && !IgnoredGuid.Contains(node.GUID) && node.TestViewFrustum(ref frustum))                              {                                  node.Render(context' ctx);                              }                          }                          commands[index] = ctx.FinishCommandList(true);                          contextPool.Put(ctx);                      }                      catch(Exception ex)                      {                          exception = ex;                      }                                  }      #if !TEST                  );
Magic Number,Core,DynamicCubeMapCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\DynamicCubeMapCore.cs,UpdateTargets,The following statement contains a magic number: cubeFaceCameras.Cameras[i].Projection = IsLeftHanded ? Matrix.PerspectiveFovLH((float)Math.PI * 0.5f' 1' NearField' FarField)                      : Matrix.PerspectiveFovRH((float)Math.PI * 0.5f' 1' NearField' FarField);
Magic Number,Core,DynamicCubeMapCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\DynamicCubeMapCore.cs,UpdateTargets,The following statement contains a magic number: cubeFaceCameras.Cameras[i].Projection = IsLeftHanded ? Matrix.PerspectiveFovLH((float)Math.PI * 0.5f' 1' NearField' FarField)                      : Matrix.PerspectiveFovRH((float)Math.PI * 0.5f' 1' NearField' FarField);
Magic Number,Core,DynamicCubeMapCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\DynamicCubeMapCore.cs,UpdateTargets,The following statement contains a magic number: i < 6
Magic Number,Core,AxisPlaneGridCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\AxisPlaneGridCore.cs,AxisPlaneGridCore,The following statement contains a magic number: GridSpacing = 10;
Magic Number,Core,AxisPlaneGridCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\AxisPlaneGridCore.cs,AxisPlaneGridCore,The following statement contains a magic number: GridThickness = 0.05f;
Magic Number,Core,AxisPlaneGridCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\AxisPlaneGridCore.cs,AxisPlaneGridCore,The following statement contains a magic number: FadingFactor = 0.2f;
Magic Number,Core,AxisPlaneGridCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\AxisPlaneGridCore.cs,Render,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,AxisPlaneGridCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\AxisPlaneGridCore.cs,OnUpdatePerModelStruct,The following statement contains a magic number: angle > Math.PI / 3
Magic Number,Core,AxisPlaneGridCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\AxisPlaneGridCore.cs,OnUpdatePerModelStruct,The following statement contains a magic number: n /= 10;
Magic Number,Core,AxisPlaneGridCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\AxisPlaneGridCore.cs,OnUpdatePerModelStruct,The following statement contains a magic number: n *= 10;
Magic Number,Core,AxisPlaneGridCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\AxisPlaneGridCore.cs,OnUpdatePerModelStruct,The following statement contains a magic number: n < 1e6
Magic Number,Core,SpotLightCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Lights\SpotLightCore.cs,OnRender,The following statement contains a magic number: lightScene.LightModels.Lights[index].LightSpot = new Vector4((float)Math.Cos(outerAngle / 360.0f * Math.PI)' (float)Math.Cos(innerAngle / 360.0f * Math.PI)' fallOff' 0);
Magic Number,Core,SpotLightCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Lights\SpotLightCore.cs,OnRender,The following statement contains a magic number: lightScene.LightModels.Lights[index].LightSpot = new Vector4((float)Math.Cos(outerAngle / 360.0f * Math.PI)' (float)Math.Cos(innerAngle / 360.0f * Math.PI)' fallOff' 0);
Magic Number,Core,MeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\MeshRenderCore.cs,CreateRasterState,The following statement contains a magic number: wireframeDesc.DepthBias = -100;
Magic Number,Core,MeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\MeshRenderCore.cs,CreateRasterState,The following statement contains a magic number: wireframeDesc.SlopeScaledDepthBias = -2f;
Magic Number,Core,MeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\MeshRenderCore.cs,CreateRasterState,The following statement contains a magic number: wireframeDesc.DepthBiasClamp = -0.00008f;
Magic Number,Core,MeshOutlineRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\MeshOutlineRenderCore.cs,MeshOutlineRenderCore,The following statement contains a magic number: OutlineFadingFactor = 1.5f;
Magic Number,Core,OrderIndependentTransparentRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\OrderIndependantTransparentRenderCore.cs,Bind,The following statement contains a magic number: targets = deviceContext.GetRenderTargets(2);
Magic Number,Core,OrderIndependentTransparentRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\OrderIndependantTransparentRenderCore.cs,Render,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,ParticleRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ParticleRenderCore.cs,UpdateInsertThrottle,The following statement contains a magic number: InsertElapseThrottle = (8.0f * InsertVariables.InitialEnergy / InsertVariables.EnergyDissipationRate / System.Math.Max(0' (particleCount + 8)));
Magic Number,Core,ParticleRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ParticleRenderCore.cs,UpdateInsertThrottle,The following statement contains a magic number: InsertElapseThrottle = (8.0f * InsertVariables.InitialEnergy / InsertVariables.EnergyDissipationRate / System.Math.Max(0' (particleCount + 8)));
Magic Number,Core,ParticleRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ParticleRenderCore.cs,UpdateTime,The following statement contains a magic number: double timeElapsed = Math.Max(0' (context.TimeStamp.TotalMilliseconds - prevTimeMillis) / 1000);
Magic Number,Core,PostEffectBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBlurCore.cs,Run,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,PostEffectBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBlurCore.cs,Run,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,PostEffectBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBlurCore.cs,Run,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,PostEffectBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBlurCore.cs,Run,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,PostEffectBloomCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBoomCore.cs,PostEffectBloomCore,The following statement contains a magic number: ThresholdColor = new Color4(0.8f' 0.8f' 0.8f' 0f);
Magic Number,Core,PostEffectBloomCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBoomCore.cs,PostEffectBloomCore,The following statement contains a magic number: ThresholdColor = new Color4(0.8f' 0.8f' 0.8f' 0f);
Magic Number,Core,PostEffectBloomCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBoomCore.cs,PostEffectBloomCore,The following statement contains a magic number: ThresholdColor = new Color4(0.8f' 0.8f' 0.8f' 0f);
Magic Number,Core,PostEffectBloomCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBoomCore.cs,PostEffectBloomCore,The following statement contains a magic number: BloomPassIntensity = 0.95f;
Magic Number,Core,PostEffectBloomCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBoomCore.cs,PostEffectBloomCore,The following statement contains a magic number: BloomCombineIntensity = 0.7f;
Magic Number,Core,PostEffectBloomCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBoomCore.cs,PostEffectBloomCore,The following statement contains a magic number: BloomCombineSaturation = 0.7f;
Magic Number,Core,PostEffectBloomCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBoomCore.cs,Render,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,PostEffectBloomCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectBoomCore.cs,Render,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,PostEffectFXAA,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectFXAA.cs,Render,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,PostEffectFXAA,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectFXAA.cs,Render,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,PostEffectFXAA,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectFXAA.cs,OnUpdatePerModelStruct,The following statement contains a magic number: switch (FXAALevel)                  {                      case FXAALevel.Low:                          modelStruct.Param.M11 = 0.25f; //fxaaQualitySubpix                          modelStruct.Param.M12 = 0.250f; // FxaaFloat fxaaQualityEdgeThreshold'                          modelStruct.Param.M13 = 0.0833f; // FxaaFloat fxaaQualityEdgeThresholdMin'                          break;                      case FXAALevel.Medium:                          modelStruct.Param.M11 = 0.50f;                          modelStruct.Param.M12 = 0.166f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.High:                          modelStruct.Param.M11 = 0.75f;                          modelStruct.Param.M12 = 0.125f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.Ultra:                          modelStruct.Param.M11 = 1.00f;                          modelStruct.Param.M12 = 0.063f;                          modelStruct.Param.M13 = 0.0312f;                          break;                  }
Magic Number,Core,PostEffectFXAA,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectFXAA.cs,OnUpdatePerModelStruct,The following statement contains a magic number: switch (FXAALevel)                  {                      case FXAALevel.Low:                          modelStruct.Param.M11 = 0.25f; //fxaaQualitySubpix                          modelStruct.Param.M12 = 0.250f; // FxaaFloat fxaaQualityEdgeThreshold'                          modelStruct.Param.M13 = 0.0833f; // FxaaFloat fxaaQualityEdgeThresholdMin'                          break;                      case FXAALevel.Medium:                          modelStruct.Param.M11 = 0.50f;                          modelStruct.Param.M12 = 0.166f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.High:                          modelStruct.Param.M11 = 0.75f;                          modelStruct.Param.M12 = 0.125f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.Ultra:                          modelStruct.Param.M11 = 1.00f;                          modelStruct.Param.M12 = 0.063f;                          modelStruct.Param.M13 = 0.0312f;                          break;                  }
Magic Number,Core,PostEffectFXAA,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectFXAA.cs,OnUpdatePerModelStruct,The following statement contains a magic number: switch (FXAALevel)                  {                      case FXAALevel.Low:                          modelStruct.Param.M11 = 0.25f; //fxaaQualitySubpix                          modelStruct.Param.M12 = 0.250f; // FxaaFloat fxaaQualityEdgeThreshold'                          modelStruct.Param.M13 = 0.0833f; // FxaaFloat fxaaQualityEdgeThresholdMin'                          break;                      case FXAALevel.Medium:                          modelStruct.Param.M11 = 0.50f;                          modelStruct.Param.M12 = 0.166f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.High:                          modelStruct.Param.M11 = 0.75f;                          modelStruct.Param.M12 = 0.125f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.Ultra:                          modelStruct.Param.M11 = 1.00f;                          modelStruct.Param.M12 = 0.063f;                          modelStruct.Param.M13 = 0.0312f;                          break;                  }
Magic Number,Core,PostEffectFXAA,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectFXAA.cs,OnUpdatePerModelStruct,The following statement contains a magic number: switch (FXAALevel)                  {                      case FXAALevel.Low:                          modelStruct.Param.M11 = 0.25f; //fxaaQualitySubpix                          modelStruct.Param.M12 = 0.250f; // FxaaFloat fxaaQualityEdgeThreshold'                          modelStruct.Param.M13 = 0.0833f; // FxaaFloat fxaaQualityEdgeThresholdMin'                          break;                      case FXAALevel.Medium:                          modelStruct.Param.M11 = 0.50f;                          modelStruct.Param.M12 = 0.166f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.High:                          modelStruct.Param.M11 = 0.75f;                          modelStruct.Param.M12 = 0.125f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.Ultra:                          modelStruct.Param.M11 = 1.00f;                          modelStruct.Param.M12 = 0.063f;                          modelStruct.Param.M13 = 0.0312f;                          break;                  }
Magic Number,Core,PostEffectFXAA,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectFXAA.cs,OnUpdatePerModelStruct,The following statement contains a magic number: switch (FXAALevel)                  {                      case FXAALevel.Low:                          modelStruct.Param.M11 = 0.25f; //fxaaQualitySubpix                          modelStruct.Param.M12 = 0.250f; // FxaaFloat fxaaQualityEdgeThreshold'                          modelStruct.Param.M13 = 0.0833f; // FxaaFloat fxaaQualityEdgeThresholdMin'                          break;                      case FXAALevel.Medium:                          modelStruct.Param.M11 = 0.50f;                          modelStruct.Param.M12 = 0.166f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.High:                          modelStruct.Param.M11 = 0.75f;                          modelStruct.Param.M12 = 0.125f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.Ultra:                          modelStruct.Param.M11 = 1.00f;                          modelStruct.Param.M12 = 0.063f;                          modelStruct.Param.M13 = 0.0312f;                          break;                  }
Magic Number,Core,PostEffectFXAA,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectFXAA.cs,OnUpdatePerModelStruct,The following statement contains a magic number: switch (FXAALevel)                  {                      case FXAALevel.Low:                          modelStruct.Param.M11 = 0.25f; //fxaaQualitySubpix                          modelStruct.Param.M12 = 0.250f; // FxaaFloat fxaaQualityEdgeThreshold'                          modelStruct.Param.M13 = 0.0833f; // FxaaFloat fxaaQualityEdgeThresholdMin'                          break;                      case FXAALevel.Medium:                          modelStruct.Param.M11 = 0.50f;                          modelStruct.Param.M12 = 0.166f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.High:                          modelStruct.Param.M11 = 0.75f;                          modelStruct.Param.M12 = 0.125f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.Ultra:                          modelStruct.Param.M11 = 1.00f;                          modelStruct.Param.M12 = 0.063f;                          modelStruct.Param.M13 = 0.0312f;                          break;                  }
Magic Number,Core,PostEffectFXAA,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectFXAA.cs,OnUpdatePerModelStruct,The following statement contains a magic number: switch (FXAALevel)                  {                      case FXAALevel.Low:                          modelStruct.Param.M11 = 0.25f; //fxaaQualitySubpix                          modelStruct.Param.M12 = 0.250f; // FxaaFloat fxaaQualityEdgeThreshold'                          modelStruct.Param.M13 = 0.0833f; // FxaaFloat fxaaQualityEdgeThresholdMin'                          break;                      case FXAALevel.Medium:                          modelStruct.Param.M11 = 0.50f;                          modelStruct.Param.M12 = 0.166f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.High:                          modelStruct.Param.M11 = 0.75f;                          modelStruct.Param.M12 = 0.125f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.Ultra:                          modelStruct.Param.M11 = 1.00f;                          modelStruct.Param.M12 = 0.063f;                          modelStruct.Param.M13 = 0.0312f;                          break;                  }
Magic Number,Core,PostEffectFXAA,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectFXAA.cs,OnUpdatePerModelStruct,The following statement contains a magic number: switch (FXAALevel)                  {                      case FXAALevel.Low:                          modelStruct.Param.M11 = 0.25f; //fxaaQualitySubpix                          modelStruct.Param.M12 = 0.250f; // FxaaFloat fxaaQualityEdgeThreshold'                          modelStruct.Param.M13 = 0.0833f; // FxaaFloat fxaaQualityEdgeThresholdMin'                          break;                      case FXAALevel.Medium:                          modelStruct.Param.M11 = 0.50f;                          modelStruct.Param.M12 = 0.166f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.High:                          modelStruct.Param.M11 = 0.75f;                          modelStruct.Param.M12 = 0.125f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.Ultra:                          modelStruct.Param.M11 = 1.00f;                          modelStruct.Param.M12 = 0.063f;                          modelStruct.Param.M13 = 0.0312f;                          break;                  }
Magic Number,Core,PostEffectFXAA,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectFXAA.cs,OnUpdatePerModelStruct,The following statement contains a magic number: switch (FXAALevel)                  {                      case FXAALevel.Low:                          modelStruct.Param.M11 = 0.25f; //fxaaQualitySubpix                          modelStruct.Param.M12 = 0.250f; // FxaaFloat fxaaQualityEdgeThreshold'                          modelStruct.Param.M13 = 0.0833f; // FxaaFloat fxaaQualityEdgeThresholdMin'                          break;                      case FXAALevel.Medium:                          modelStruct.Param.M11 = 0.50f;                          modelStruct.Param.M12 = 0.166f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.High:                          modelStruct.Param.M11 = 0.75f;                          modelStruct.Param.M12 = 0.125f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.Ultra:                          modelStruct.Param.M11 = 1.00f;                          modelStruct.Param.M12 = 0.063f;                          modelStruct.Param.M13 = 0.0312f;                          break;                  }
Magic Number,Core,PostEffectFXAA,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectFXAA.cs,OnUpdatePerModelStruct,The following statement contains a magic number: switch (FXAALevel)                  {                      case FXAALevel.Low:                          modelStruct.Param.M11 = 0.25f; //fxaaQualitySubpix                          modelStruct.Param.M12 = 0.250f; // FxaaFloat fxaaQualityEdgeThreshold'                          modelStruct.Param.M13 = 0.0833f; // FxaaFloat fxaaQualityEdgeThresholdMin'                          break;                      case FXAALevel.Medium:                          modelStruct.Param.M11 = 0.50f;                          modelStruct.Param.M12 = 0.166f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.High:                          modelStruct.Param.M11 = 0.75f;                          modelStruct.Param.M12 = 0.125f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.Ultra:                          modelStruct.Param.M11 = 1.00f;                          modelStruct.Param.M12 = 0.063f;                          modelStruct.Param.M13 = 0.0312f;                          break;                  }
Magic Number,Core,PostEffectFXAA,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectFXAA.cs,OnUpdatePerModelStruct,The following statement contains a magic number: switch (FXAALevel)                  {                      case FXAALevel.Low:                          modelStruct.Param.M11 = 0.25f; //fxaaQualitySubpix                          modelStruct.Param.M12 = 0.250f; // FxaaFloat fxaaQualityEdgeThreshold'                          modelStruct.Param.M13 = 0.0833f; // FxaaFloat fxaaQualityEdgeThresholdMin'                          break;                      case FXAALevel.Medium:                          modelStruct.Param.M11 = 0.50f;                          modelStruct.Param.M12 = 0.166f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.High:                          modelStruct.Param.M11 = 0.75f;                          modelStruct.Param.M12 = 0.125f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.Ultra:                          modelStruct.Param.M11 = 1.00f;                          modelStruct.Param.M12 = 0.063f;                          modelStruct.Param.M13 = 0.0312f;                          break;                  }
Magic Number,Core,PostEffectMeshOutlineBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshOutlineBlurCore.cs,DrawOutline,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,PostEffectMeshOutlineBlurCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectMeshOutlineBlurCore.cs,DrawOutline,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,Render,The following statement contains a magic number: int left = (int)(context.ActualWidth * Math.Abs(modelStruct.TopLeft.X + 1) / 2);
Magic Number,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,Render,The following statement contains a magic number: int top = (int)(context.ActualHeight * Math.Abs(modelStruct.TopLeft.Y - 1) / 2);
Magic Number,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,Render,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,DrawCursor,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,GetVertexBound,The following statement contains a magic number: var ndcCloneW = (2.0f * cloneRatio) / viewportRatio;
Magic Number,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,GetVertexBound,The following statement contains a magic number: bound.X = -1 + (2 - ndcCloneW)/2.0f;
Magic Number,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,GetVertexBound,The following statement contains a magic number: bound.X = -1 + (2 - ndcCloneW)/2.0f;
Magic Number,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,GetCursorVertexBound,The following statement contains a magic number: var centerX = cloneRectangle.Width != 0 ? (cloneRectangle.Left + cloneWidth / 2) : cloneWidth / 2;
Magic Number,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,GetCursorVertexBound,The following statement contains a magic number: var centerX = cloneRectangle.Width != 0 ? (cloneRectangle.Left + cloneWidth / 2) : cloneWidth / 2;
Magic Number,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,GetCursorVertexBound,The following statement contains a magic number: var centerY = cloneRectangle.Height != 0 ? (cloneRectangle.Top + cloneHeight / 2) : cloneHeight / 2;
Magic Number,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,GetCursorVertexBound,The following statement contains a magic number: var centerY = cloneRectangle.Height != 0 ? (cloneRectangle.Top + cloneHeight / 2) : cloneHeight / 2;
Magic Number,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,GetCursorVertexBound,The following statement contains a magic number: var viewportCenterX = viewportWidth / 2;
Magic Number,Core,ScreenCloneRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,GetCursorVertexBound,The following statement contains a magic number: var viewportCenterY = viewportHeight / 2;
Magic Number,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessMonoMask,The following statement contains a magic number: info.ShapeInfo.Height /= 2;
Magic Number,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessMonoMask,The following statement contains a magic number: info.ShapeInfo.Height *= 2;
Magic Number,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessMonoMask,The following statement contains a magic number: Mask = (byte)(Mask >> (byte)(skipX % 8));
Magic Number,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessMonoMask,The following statement contains a magic number: byte AndMask = (byte)(info.PtrShapeBuffer[((col + skipX) / 8) + ((row + skipY) * (info.ShapeInfo.Pitch))] & Mask);
Magic Number,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessMonoMask,The following statement contains a magic number: byte XorMask = (byte)(info.PtrShapeBuffer[((col + skipX) / 8) + ((row + skipY + (info.ShapeInfo.Height / 2))                                               * (info.ShapeInfo.Pitch))] & Mask);
Magic Number,Core,FrameProcessing,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenCloneRenderCore.cs,ProcessMonoMask,The following statement contains a magic number: byte XorMask = (byte)(info.PtrShapeBuffer[((col + skipX) / 8) + ((row + skipY + (info.ShapeInfo.Height / 2))                                               * (info.ShapeInfo.Pitch))] & Mask);
Magic Number,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,OnCreateProjectionMatrix,The following statement contains a magic number: projectionMatrix = CreateProjectionMatrix(IsPerspective' IsRightHand' scale' Fov' 0.001f' 100f' CameraDistance' CameraDistance);
Magic Number,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,OnCreateProjectionMatrix,The following statement contains a magic number: projectionMatrix = CreateProjectionMatrix(IsPerspective' IsRightHand' scale' Fov' 0.001f' 100f' CameraDistance' CameraDistance);
Magic Number,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,RenderRelativeScreenSpaced,The following statement contains a magic number: offX = (int)(Width / 2 * (1 + RelativeScreenLocationX) - viewportSize / 2);
Magic Number,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,RenderRelativeScreenSpaced,The following statement contains a magic number: offX = (int)(Width / 2 * (1 + RelativeScreenLocationX) - viewportSize / 2);
Magic Number,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,RenderRelativeScreenSpaced,The following statement contains a magic number: offY = (int)(Height / 2 * (1 - RelativeScreenLocationY) - viewportSize / 2);
Magic Number,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,RenderRelativeScreenSpaced,The following statement contains a magic number: offY = (int)(Height / 2 * (1 - RelativeScreenLocationY) - viewportSize / 2);
Magic Number,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,RenderAbsolutePositionPerspective,The following statement contains a magic number: float distance = Size / 2 / SizeScale;
Magic Number,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,RenderAbsolutePositionPerspective,The following statement contains a magic number: globalTrans.Projection = CreateProjectionMatrix(context.IsPerspective' IsRightHand' 1'                      globalTrans.Frustum.X' 0.01f' 500 / SizeScale' w' h);
Magic Number,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,RenderAbsolutePositionPerspective,The following statement contains a magic number: globalTrans.Projection = CreateProjectionMatrix(context.IsPerspective' IsRightHand' 1'                      globalTrans.Frustum.X' 0.01f' 500 / SizeScale' w' h);
Magic Number,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,RenderAbsolutePositionOrtho,The following statement contains a magic number: offX = (screenPoint.X - viewportSize / 2);
Magic Number,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,RenderAbsolutePositionOrtho,The following statement contains a magic number: offY = (screenPoint.Y - viewportSize / 2);
Magic Number,Core,ShadowMapCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ShadowMapCore.cs,ShadowMapCore,The following statement contains a magic number: Bias = 0.0015f;
Magic Number,Core,ShadowMapCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ShadowMapCore.cs,ShadowMapCore,The following statement contains a magic number: Intensity = 0.5f;
Magic Number,Core,ShadowMapCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ShadowMapCore.cs,ShadowMapCore,The following statement contains a magic number: Width = Height = 1024;
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,Render,The following statement contains a magic number: ssaoParam.NoiseScale = new Vector2(w / 4f' h / 4f);
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,Render,The following statement contains a magic number: ssaoParam.NoiseScale = new Vector2(w / 4f' h / 4f);
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,Render,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,Render,The following statement contains a magic number: deviceContext.Draw(4' 0);
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,EnsureTextureResources,The following statement contains a magic number: width > 10 && height > 10
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,EnsureTextureResources,The following statement contains a magic number: width > 10 && height > 10
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,InitialParameters,The following statement contains a magic number: double thres = Math.Cos(Math.PI / 2 - Math.PI / 12);
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,InitialParameters,The following statement contains a magic number: double thres = Math.Cos(Math.PI / 2 - Math.PI / 12);
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,InitialParameters,The following statement contains a magic number: float z = rnd.NextFloat(1e-3f' 1);
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,InitialParameters,The following statement contains a magic number: float scale = i / 32f;
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,InitialParameters,The following statement contains a magic number: scale = 0.1f + 0.9f * scale;
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,InitialParameters,The following statement contains a magic number: scale = 0.1f + 0.9f * scale;
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,InitialParameters,The following statement contains a magic number: i < 32
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,InitialParameters,The following statement contains a magic number: Vector3[] noise = new Vector3[4 * 4];
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,InitialParameters,The following statement contains a magic number: Vector3[] noise = new Vector3[4 * 4];
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,InitialParameters,The following statement contains a magic number: i < 16
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,InitialParameters,The following statement contains a magic number: ssaoNoise = Collect(ShaderResourceViewProxy                      .CreateView(Device' noise' 4' 4' global::SharpDX.DXGI.Format.R32G32B32_Float' true' false));
Magic Number,Core,SSAOCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\SSAOCore.cs,InitialParameters,The following statement contains a magic number: ssaoNoise = Collect(ShaderResourceViewProxy                      .CreateView(Device' noise' 4' 4' global::SharpDX.DXGI.Format.R32G32B32_Float' true' false));
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,VolumeRenderCore,The following statement contains a magic number: BoxMesh = new MeshGeometry3D()                  {                      Positions = new Vector3Collection()                      {                           new Vector3(-0.5f' -0.5f' -0.5f)'                           new Vector3(0.5f' -0.5f' -0.5f)'                           new Vector3(-0.5f' 0.5f' -0.5f)'                           new Vector3(0.5f' 0.5f' -0.5f)'                           new Vector3(-0.5f' -0.5f' 0.5f)'                           new Vector3(0.5f' -0.5f' 0.5f)'                           new Vector3(-0.5f' 0.5f' 0.5f)'                           new Vector3(0.5f' 0.5f' 0.5f)'                      }'                      Indices = new IntCollection()                      {                          0'2'3'                          3'1'0'                          4'5'7'                          7'6'4'                          0'1'5'                          5'4'0'                          1'3'7'                          7'5'1'                          3'2'6'                          6'7'3'                          2'0'4'                          4'6'2                      }                  };
Magic Number,Core,VolumeRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs,Render,The following statement contains a magic number: !materialVariables.UpdateMaterialStruct(deviceContext' ref modelMatrices' Matrix.SizeInBytes * 2)
Magic Number,Animations,KeyFrameUpdater,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Animations\KeyFrameUpdater.cs,Update,The following statement contains a magic number: var endNext = timeRange[Math.Min(CurrentRangeIndex + 2' timeRange.Count - 1)];
Magic Number,Utilities,ConstantBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ConstantBufferProxy.cs,ConstantBufferProxy,The following statement contains a magic number: structSize % 16 != 0
Magic Number,Utilities,ConstantBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ConstantBufferProxy.cs,ConstantBufferProxy,The following statement contains a magic number: description.StructSize % 16 != 0
Magic Number,Utilities,ConstantBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Buffers\ConstantBufferProxy.cs,ResizeBuffer,The following statement contains a magic number: structSize % 16 != 0
Magic Number,Utilities,FrameStatistics,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\FrameStatistics.cs,Push,The following statement contains a magic number: latency > 1000 || latency < 0
Magic Number,Utilities,FrameStatistics,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\FrameStatistics.cs,Push,The following statement contains a magic number: movingAverage = Math.Min(1000' Math.Max(0' movingAverage));
Magic Number,Utilities,RenderStatistics,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\FrameStatistics.cs,GetFPS,The following statement contains a magic number: return $"FPS:{Math.Round(FPSStatistics.AverageFrequency' 2)}" + LineBreak;
Magic Number,Utilities,RenderStatistics,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\FrameStatistics.cs,GetStatistics,The following statement contains a magic number: return $"Render(ms): {Math.Round(LatencyStatistics.AverageValue' 4)}\n" +                      $"NumModel3D: {NumModel3D}\n" +                      $"NumCore3D: {NumCore3D}\n" +                      $"NumDrawCalls: {NumDrawCalls}"                      + LineBreak;
Magic Number,Utilities,StaticLineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticLineGeometryOctree.cs,GetObjects,The following statement contains a magic number: var objects = new KeyValuePair<int' BoundingBox>[Indices.Count / 2];
Magic Number,Utilities,StaticLineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticLineGeometryOctree.cs,GetObjects,The following statement contains a magic number: i < Indices.Count / 2
Magic Number,Utilities,StaticLineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticLineGeometryOctree.cs,GetBoundingBox,The following statement contains a magic number: var actual = triangleIndex * 2;
Magic Number,Utilities,StaticLineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticLineGeometryOctree.cs,HitTestCurrentNodeExcludeChild,The following statement contains a magic number: var idx = Objects[i].Key * 2;
Magic Number,Utilities,StaticLineGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticLineGeometryOctree.cs,FindNearestPointBySphereExcludeChild,The following statement contains a magic number: var idx = Objects[i].Key * 3;
Magic Number,Utilities,StaticMeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticMeshGeometryOctree.cs,GetObjects,The following statement contains a magic number: var objects = new KeyValuePair<int' BoundingBox>[Indices.Count / 3];
Magic Number,Utilities,StaticMeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticMeshGeometryOctree.cs,GetObjects,The following statement contains a magic number: i < Indices.Count / 3
Magic Number,Utilities,StaticMeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticMeshGeometryOctree.cs,GetBoundingBox,The following statement contains a magic number: var actual = triangleIndex * 3;
Magic Number,Utilities,StaticMeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticMeshGeometryOctree.cs,HitTestCurrentNodeExcludeChild,The following statement contains a magic number: var idx = Objects[i].Key * 3;
Magic Number,Utilities,StaticMeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticMeshGeometryOctree.cs,HitTestCurrentNodeExcludeChild,The following statement contains a magic number: var t3 = Indices[idx + 2];
Magic Number,Utilities,StaticMeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticMeshGeometryOctree.cs,FindNearestPointBySphereExcludeChild,The following statement contains a magic number: var idx = Objects[i].Key * 3;
Magic Number,Utilities,StaticMeshGeometryOctree,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticMeshGeometryOctree.cs,FindNearestPointBySphereExcludeChild,The following statement contains a magic number: var t3 = Indices[idx + 2];
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,BuildTree,The following statement contains a magic number: Console.WriteLine($"Build static tree time ={(double)tick / Stopwatch.Frequency * 1000}; Total = {octants.Count}");
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctants,The following statement contains a magic number: Vector3 half = dimensions / 2.0f;
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,FindNearestPointFromPoint,The following statement contains a magic number: heuristicSearchFactor = Math.Min(1.0f' Math.Max(0.1f' heuristicSearchFactor));
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: Vector3[] verts = new Vector3[8];
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[2] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Minimum.Z);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[3] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Minimum.Z);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[7] = box.Maximum;
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[4] = new Vector3(box.Maximum.X' box.Maximum.Y' box.Minimum.Z);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[5] = new Vector3(box.Maximum.X' box.Minimum.Y' box.Maximum.Z);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: verts[6] = new Vector3(box.Minimum.X' box.Maximum.Y' box.Maximum.Z);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[0]' verts[2]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[0]' verts[3]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[4]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[4]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[5]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[5]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[6]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[7]' verts[6]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[1]' verts[6]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[1]' verts[5]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[4]' verts[2]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[4]' verts[2]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[4]' verts[3]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[4]' verts[3]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[2]' verts[6]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[2]' verts[6]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[3]' verts[5]);
Magic Number,Utilities,StaticOctree<T>,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,CreateOctreeLineModel,The following statement contains a magic number: builder.AddLine(verts[3]' verts[5]);
Magic Number,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,GetChildIndex,The following statement contains a magic number: switch (index)                      {                          case 0: return c0;                          case 1: return c1;                          case 2: return c2;                          case 3: return c3;                          case 4: return c4;                          case 5: return c5;                          case 6: return c6;                          case 7: return c7;                          default:                              return -1;                      }
Magic Number,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,GetChildIndex,The following statement contains a magic number: switch (index)                      {                          case 0: return c0;                          case 1: return c1;                          case 2: return c2;                          case 3: return c3;                          case 4: return c4;                          case 5: return c5;                          case 6: return c6;                          case 7: return c7;                          default:                              return -1;                      }
Magic Number,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,GetChildIndex,The following statement contains a magic number: switch (index)                      {                          case 0: return c0;                          case 1: return c1;                          case 2: return c2;                          case 3: return c3;                          case 4: return c4;                          case 5: return c5;                          case 6: return c6;                          case 7: return c7;                          default:                              return -1;                      }
Magic Number,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,GetChildIndex,The following statement contains a magic number: switch (index)                      {                          case 0: return c0;                          case 1: return c1;                          case 2: return c2;                          case 3: return c3;                          case 4: return c4;                          case 5: return c5;                          case 6: return c6;                          case 7: return c7;                          default:                              return -1;                      }
Magic Number,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,GetChildIndex,The following statement contains a magic number: switch (index)                      {                          case 0: return c0;                          case 1: return c1;                          case 2: return c2;                          case 3: return c3;                          case 4: return c4;                          case 5: return c5;                          case 6: return c6;                          case 7: return c7;                          default:                              return -1;                      }
Magic Number,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,GetChildIndex,The following statement contains a magic number: switch (index)                      {                          case 0: return c0;                          case 1: return c1;                          case 2: return c2;                          case 3: return c3;                          case 4: return c4;                          case 5: return c5;                          case 6: return c6;                          case 7: return c7;                          default:                              return -1;                      }
Magic Number,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,SetChildIndex,The following statement contains a magic number: switch (index)                      {                          case 0: c0 = value; break;                          case 1: c1 = value; break;                          case 2: c2 = value; break;                          case 3: c3 = value; break;                          case 4: c4 = value; break;                          case 5: c5 = value; break;                          case 6: c6 = value; break;                          case 7: c7 = value; break;                      }
Magic Number,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,SetChildIndex,The following statement contains a magic number: switch (index)                      {                          case 0: c0 = value; break;                          case 1: c1 = value; break;                          case 2: c2 = value; break;                          case 3: c3 = value; break;                          case 4: c4 = value; break;                          case 5: c5 = value; break;                          case 6: c6 = value; break;                          case 7: c7 = value; break;                      }
Magic Number,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,SetChildIndex,The following statement contains a magic number: switch (index)                      {                          case 0: c0 = value; break;                          case 1: c1 = value; break;                          case 2: c2 = value; break;                          case 3: c3 = value; break;                          case 4: c4 = value; break;                          case 5: c5 = value; break;                          case 6: c6 = value; break;                          case 7: c7 = value; break;                      }
Magic Number,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,SetChildIndex,The following statement contains a magic number: switch (index)                      {                          case 0: c0 = value; break;                          case 1: c1 = value; break;                          case 2: c2 = value; break;                          case 3: c3 = value; break;                          case 4: c4 = value; break;                          case 5: c5 = value; break;                          case 6: c6 = value; break;                          case 7: c7 = value; break;                      }
Magic Number,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,SetChildIndex,The following statement contains a magic number: switch (index)                      {                          case 0: c0 = value; break;                          case 1: c1 = value; break;                          case 2: c2 = value; break;                          case 3: c3 = value; break;                          case 4: c4 = value; break;                          case 5: c5 = value; break;                          case 6: c6 = value; break;                          case 7: c7 = value; break;                      }
Magic Number,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,SetChildIndex,The following statement contains a magic number: switch (index)                      {                          case 0: c0 = value; break;                          case 1: c1 = value; break;                          case 2: c2 = value; break;                          case 3: c3 = value; break;                          case 4: c4 = value; break;                          case 5: c5 = value; break;                          case 6: c6 = value; break;                          case 7: c7 = value; break;                      }
Magic Number,Utilities,OctantArray,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,Add,The following statement contains a magic number: var newSize = array.Length * 2;
Magic Number,Utilities,OctantArray,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,Add,The following statement contains a magic number: newSize > int.MaxValue / 4
Magic Number,Utilities,OctantArray,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,Add,The following statement contains a magic number: var newArray = new Octant[array.Length * 2];
Magic Number,Utilities,ScreenCapture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ScreenCapture.cs,CopyTextureToWICStream,The following statement contains a magic number: frame.SetResolution(72' 72);
Magic Number,Utilities,ScreenCapture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ScreenCapture.cs,CopyTextureToWICStream,The following statement contains a magic number: frame.SetResolution(72' 72);
Magic Number,Utilities,VolumeDataHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\VolumeDataHelper.cs,GenerateGradients,The following statement contains a magic number: Parallel.For(0' depth' new ParallelOptions() { MaxDegreeOfParallelism = 4 }' (z) =>                  {                      int index = z * width * height;                      for (int y = 0; y < height; y++)                      {                          for (int x = 0; x < width; x++' ++index)                          {                              Vector3 s1' s2;                              s1.X = SampleVolume(data' width' height' depth' x - n' y' z);                              s2.X = SampleVolume(data' width' height' depth' x + n' y' z);                              s1.Y = SampleVolume(data' width' height' depth' x' y - n' z);                              s2.Y = SampleVolume(data' width' height' depth' x' y + n' z);                              s1.Z = SampleVolume(data' width' height' depth' x' y' z - n);                              s2.Z = SampleVolume(data' width' height' depth' x' y' z + n);                              var v = Vector3.Normalize(s2 - s1);                              var sample = SampleVolume(data' width' height' depth' x' y' z);                              gradients[index] = new Half4(v.X' v.Y' v.Z' sample);                              if (float.IsNaN(gradients[index].X))                              {                                  gradients[index] = new Half4(0' 0' 0' sample);                              }                          }                      }                  });
Magic Number,Utilities,VolumeDataHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\VolumeDataHelper.cs,SampleNxNxN,The following statement contains a magic number: n = (n - 1) / 2;
Magic Number,Cameras,CameraCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\Camera.cs,OnTimeStep,The following statement contains a magic number: var ellapsed = (float)(ticks - prevTicks) / System.Diagnostics.Stopwatch.Frequency * 1000;
Magic Number,Cameras,OrthographicCameraCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\Camera.cs,CreateProjectionMatrix,The following statement contains a magic number: return this.CreateLeftHandSystem ? Matrix.OrthoLH(                          this.Width'                          (float)(this.Width / aspectRatio)'                          this.NearPlaneDistance'                          Math.Min(1e15f' this.FarPlaneDistance))                          : Matrix.OrthoRH(                          this.Width'                          (float)(this.Width / aspectRatio)'                          this.NearPlaneDistance'                          Math.Min(1e15f' this.FarPlaneDistance));
Magic Number,Cameras,OrthographicCameraCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\Camera.cs,CreateProjectionMatrix,The following statement contains a magic number: return this.CreateLeftHandSystem ? Matrix.OrthoLH(                          this.Width'                          (float)(this.Width / aspectRatio)'                          this.NearPlaneDistance'                          Math.Min(1e15f' this.FarPlaneDistance))                          : Matrix.OrthoRH(                          this.Width'                          (float)(this.Width / aspectRatio)'                          this.NearPlaneDistance'                          Math.Min(1e15f' this.FarPlaneDistance));
Magic Number,Cameras,PerspectiveCameraCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\Camera.cs,CreateProjectionMatrix,The following statement contains a magic number: var fov = this.FieldOfView * Math.PI / 180;
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,RotateTrackball,The following statement contains a magic number: axis.LengthSquared() < 1e-8
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,RotateTrackball,The following statement contains a magic number: var rotate = Matrix.RotationAxis(Vector3.Normalize(axis)' -angle * sensitivity * 5);
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,ProjectToTrackball,The following statement contains a magic number: double r = Math.Sqrt((w * w) + (h * h)) / 2;
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,ProjectToTrackball,The following statement contains a magic number: double x = (point.X - (w / 2)) / r;
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,ProjectToTrackball,The following statement contains a magic number: double y = ((h / 2) - point.Y) / r;
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,RotateTurnball,The following statement contains a magic number: d = 0.2f;
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,RotateTurnball,The following statement contains a magic number: var q1 = Quaternion.RotationAxis(rotationAxisX' d * invertFactor * delta.X / 180 * (float)Math.PI);
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,RotateTurnball,The following statement contains a magic number: var q2 = Quaternion.RotationAxis(rotationAxisY' d * delta.Y / 180 * (float)Math.PI);
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,RotateTurnball,The following statement contains a magic number: (newUpDirection - modUpDir).Length() > 1e-8
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,InitTurnballRotationAxes,The following statement contains a magic number: fx > 0.8
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,InitTurnballRotationAxes,The following statement contains a magic number: fx < 0.2
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,RotateTurntable,The following statement contains a magic number: float d = -0.5f;
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,RotateTurntable,The following statement contains a magic number: d *= -0.2f;
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,RotateTurntable,The following statement contains a magic number: var q1 = Quaternion.RotationAxis(up' d * invertFactor * delta.X / 180 * (float)Math.PI);
Magic Number,Cameras,CameraMath,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Camera\CameraMath.cs,RotateTurntable,The following statement contains a magic number: var q2 = Quaternion.RotationAxis(right' d * delta.Y / 180 * (float)Math.PI);
Magic Number,Model,DefaultEffectAttributeParser,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\EffectAttributes.cs,Parse,The following statement contains a magic number: token.Length == 2
Magic Number,Model,VolumeTextureRawDataMaterialCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\VolumeTextureMaterial.cs,LoadRAWFile,The following statement contains a magic number: switch (bytePerPixel)                      {                          case 1:                              format = global::SharpDX.DXGI.Format.R8_UNorm;                              break;                          case 2:                              format = global::SharpDX.DXGI.Format.R16_UNorm;                              break;                          case 4:                              format = global::SharpDX.DXGI.Format.R32_Float;                              break;                      }
Magic Number,Model,VolumeTextureRawDataMaterialCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\VolumeTextureMaterial.cs,LoadRAWFile,The following statement contains a magic number: switch (bytePerPixel)                      {                          case 1:                              format = global::SharpDX.DXGI.Format.R8_UNorm;                              break;                          case 2:                              format = global::SharpDX.DXGI.Format.R16_UNorm;                              break;                          case 4:                              format = global::SharpDX.DXGI.Format.R32_Float;                              break;                      }
Magic Number,Model,Entry,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Metadata.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,Model,Entry,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Metadata.cs,GetHashCode,The following statement contains a magic number: hash = (hash * 31) + Data.GetHashCode();
Magic Number,Model,Entry,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Metadata.cs,GetHashCode,The following statement contains a magic number: hash = (hash * 31) + ((Data == null) ? 0 : Data.GetHashCode());
Magic Number,Model.Scene,BatchedMeshNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\BatchedMeshNode.cs,CreateRasterState,The following statement contains a magic number: return new RasterizerStateDescription()                  {                      FillMode = FillMode'                      CullMode = CullMode'                      DepthBias = DepthBias'                      DepthBiasClamp = -1000'                      SlopeScaledDepthBias = (float)SlopeScaledDepthBias'                      IsDepthClipEnabled = IsDepthClipEnabled'                      IsFrontCounterClockwise = FrontCCW'                      IsMultisampleEnabled = IsMSAAEnabled'                      IsScissorEnabled = IsThrowingShadow ? false : IsScissorEnabled'                  };
Magic Number,Model.Scene,AxisPlaneGridNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\AxisPlaneGridNode.cs,AxisPlaneGridNode,The following statement contains a magic number: RenderOrder = 1000;
Magic Number,Model.Scene,BillboardNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\BillboardNode.cs,CreateRasterState,The following statement contains a magic number: return new RasterizerStateDescription()                  {                      FillMode = FillMode.Solid'                      CullMode = CullMode.None'                      DepthBias = DepthBias'                      DepthBiasClamp = -1000'                      SlopeScaledDepthBias = (float)SlopeScaledDepthBias'                      IsDepthClipEnabled = true'                      IsFrontCounterClockwise = false'                        IsMultisampleEnabled = false'                      //IsAntialiasedLineEnabled = true'                                          IsScissorEnabled = IsThrowingShadow ? false : IsScissorEnabled'                  };
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateModel,The following statement contains a magic number: builder.AddArrow(Vector3.Zero' new Vector3(arrowSize' 0' 0)' arrowWidth' arrowHead' 8);
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateModel,The following statement contains a magic number: builder.AddArrow(Vector3.Zero' new Vector3(0' arrowSize' 0)' arrowWidth' arrowHead' 8);
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateModel,The following statement contains a magic number: builder.AddArrow(Vector3.Zero' new Vector3(0' 0' arrowSize)' arrowWidth' arrowHead' 8);
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateModel,The following statement contains a magic number: UpdateAxisColor(arrowMeshModel.Geometry' 2' AxisZColor' LabelZ' LabelColor);
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)                  {                      case 0:                          label = LabelX;                          break;                        case 1:                          label = LabelY;                          break;                        case 2:                          label = LabelZ;                          break;                  }
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisLabel,The following statement contains a magic number: switch (which)                  {                      case 0:                          color = AxisXColor;                          break;                        case 1:                          color = AxisYColor;                          break;                        case 2:                          color = AxisZColor;                          break;                  }
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateLabelColor,The following statement contains a magic number: UpdateAxisColor(arrowMeshModel.Geometry' 2' AxisZColor' LabelZ' LabelColor);
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)                  {                      case 0:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(arrowSize + 1.5f' 0' 0)) { Foreground = labelColor' Scale = 0.5f };                                         break;                        case 1:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' arrowSize + 1.5f' 0)) { Foreground = labelColor' Scale = 0.5f };                          break;                        case 2:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' 0' arrowSize + 1.5f)) { Foreground = labelColor' Scale = 0.5f };                          break;                  }
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)                  {                      case 0:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(arrowSize + 1.5f' 0' 0)) { Foreground = labelColor' Scale = 0.5f };                                         break;                        case 1:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' arrowSize + 1.5f' 0)) { Foreground = labelColor' Scale = 0.5f };                          break;                        case 2:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' 0' arrowSize + 1.5f)) { Foreground = labelColor' Scale = 0.5f };                          break;                  }
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)                  {                      case 0:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(arrowSize + 1.5f' 0' 0)) { Foreground = labelColor' Scale = 0.5f };                                         break;                        case 1:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' arrowSize + 1.5f' 0)) { Foreground = labelColor' Scale = 0.5f };                          break;                        case 2:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' 0' arrowSize + 1.5f)) { Foreground = labelColor' Scale = 0.5f };                          break;                  }
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)                  {                      case 0:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(arrowSize + 1.5f' 0' 0)) { Foreground = labelColor' Scale = 0.5f };                                         break;                        case 1:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' arrowSize + 1.5f' 0)) { Foreground = labelColor' Scale = 0.5f };                          break;                        case 2:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' 0' arrowSize + 1.5f)) { Foreground = labelColor' Scale = 0.5f };                          break;                  }
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)                  {                      case 0:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(arrowSize + 1.5f' 0' 0)) { Foreground = labelColor' Scale = 0.5f };                                         break;                        case 1:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' arrowSize + 1.5f' 0)) { Foreground = labelColor' Scale = 0.5f };                          break;                        case 2:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' 0' arrowSize + 1.5f)) { Foreground = labelColor' Scale = 0.5f };                          break;                  }
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)                  {                      case 0:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(arrowSize + 1.5f' 0' 0)) { Foreground = labelColor' Scale = 0.5f };                                         break;                        case 1:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' arrowSize + 1.5f' 0)) { Foreground = labelColor' Scale = 0.5f };                          break;                        case 2:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' 0' arrowSize + 1.5f)) { Foreground = labelColor' Scale = 0.5f };                          break;                  }
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The following statement contains a magic number: switch (which)                  {                      case 0:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(arrowSize + 1.5f' 0' 0)) { Foreground = labelColor' Scale = 0.5f };                                         break;                        case 1:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' arrowSize + 1.5f' 0)) { Foreground = labelColor' Scale = 0.5f };                          break;                        case 2:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' 0' arrowSize + 1.5f)) { Foreground = labelColor' Scale = 0.5f };                          break;                  }
Magic Number,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The following statement contains a magic number: int segment = mesh.Positions.Count / 3;
Magic Number,Model.Scene,EnvironmentMapNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\EnvironmentMapNode.cs,EnvironmentMapNode,The following statement contains a magic number: RenderOrder = 1000;
Magic Number,Model.Scene,EnvironmentMapNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\EnvironmentMapNode.cs,EnvironmentMapNode,The following statement contains a magic number: RenderOrder = 1000;
Magic Number,Model.Scene,LineNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\LineNode.cs,CreateRasterState,The following statement contains a magic number: return new RasterizerStateDescription()                  {                      FillMode = FillMode'                      CullMode = CullMode.None'                      DepthBias = DepthBias'                      DepthBiasClamp = -1000'                      SlopeScaledDepthBias = (float)SlopeScaledDepthBias'                      IsDepthClipEnabled = IsDepthClipEnabled'                      IsFrontCounterClockwise = true'                        IsMultisampleEnabled = IsMSAAEnabled'                      //IsAntialiasedLineEnabled = true' // Intel HD 3000 doesn't like this (#10051) and it's not needed                      IsScissorEnabled = IsThrowingShadow ? false : IsScissorEnabled                  };
Magic Number,Model.Scene,MeshNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\MeshNode.cs,CreateRasterState,The following statement contains a magic number: return new RasterizerStateDescription()                  {                      FillMode = FillMode'                      CullMode = CullMode'                      DepthBias = DepthBias'                      DepthBiasClamp = -1000'                      SlopeScaledDepthBias = (float)SlopeScaledDepthBias'                      IsDepthClipEnabled = IsDepthClipEnabled'                      IsFrontCounterClockwise = FrontCCW'                      IsMultisampleEnabled = IsMSAAEnabled'                      IsScissorEnabled = IsThrowingShadow ? false : IsScissorEnabled'                  };
Magic Number,Model.Scene,PointNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\PointNode.cs,CreateRasterState,The following statement contains a magic number: return new RasterizerStateDescription()                  {                      FillMode = FillMode'                      CullMode = CullMode.None'                      DepthBias = DepthBias'                      DepthBiasClamp = -1000'                      SlopeScaledDepthBias = (float)SlopeScaledDepthBias'                      IsDepthClipEnabled = IsDepthClipEnabled'                      IsFrontCounterClockwise = true'                      IsMultisampleEnabled = false'                      IsScissorEnabled = IsThrowingShadow ? false : IsScissorEnabled                  };
Magic Number,Model.Scene,ScreenSpacedNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ScreenSpacedNode.cs,CreateRelativeScreenModeRay,The following statement contains a magic number: float offx = (float)(context.ActualWidth / 2 * (1 + screenSpaceCore.RelativeScreenLocationX) - viewportSize / 2);
Magic Number,Model.Scene,ScreenSpacedNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ScreenSpacedNode.cs,CreateRelativeScreenModeRay,The following statement contains a magic number: float offx = (float)(context.ActualWidth / 2 * (1 + screenSpaceCore.RelativeScreenLocationX) - viewportSize / 2);
Magic Number,Model.Scene,ScreenSpacedNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ScreenSpacedNode.cs,CreateRelativeScreenModeRay,The following statement contains a magic number: float offy = (float)(context.ActualHeight / 2 * (1 - screenSpaceCore.RelativeScreenLocationY) - viewportSize / 2);
Magic Number,Model.Scene,ScreenSpacedNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ScreenSpacedNode.cs,CreateRelativeScreenModeRay,The following statement contains a magic number: float offy = (float)(context.ActualHeight / 2 * (1 - screenSpaceCore.RelativeScreenLocationY) - viewportSize / 2);
Magic Number,Model.Scene,ScreenSpacedNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ScreenSpacedNode.cs,CreateRelativeScreenModeRay,The following statement contains a magic number: newRay = RayExtensions.UnProject(new Vector2(px' py)' ref viewMatrix' ref projMatrix'                      0.01f' viewportSize' viewportSize' screenSpaceCore.IsPerspective);
Magic Number,Model.Scene,SortingGroupNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\SortingGroupNode.cs,UpdateNotRender,The following statement contains a magic number: long currTime = Stopwatch.GetTimestamp() * 1000 / Stopwatch.Frequency;
Magic Number,Model.Scene,SortingGroupNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\SortingGroupNode.cs,GetDistance,The following statement contains a magic number: switch (SortingMethod)                  {                      case SortingMethod.BoundingBoxCenter:                          var center = (node.BoundsWithTransform.Maximum + node.BoundsWithTransform.Minimum) / 2;                          return (cameraPos - center).LengthSquared();                      case SortingMethod.BoundingBoxCorners:                          var bound = node.BoundsWithTransform;                          //https://github.com/sharpdx/SharpDX/blob/master/Source/SharpDX.Mathematics/Collision.cs                          float distance = 0f;                          if (cameraPos.X < bound.Minimum.X)                              distance += (bound.Minimum.X - cameraPos.X) * (bound.Minimum.X - cameraPos.X);                          if (cameraPos.X > bound.Maximum.X)                              distance += (cameraPos.X - bound.Maximum.X) * (cameraPos.X - bound.Maximum.X);                            if (cameraPos.Y < bound.Minimum.Y)                              distance += (bound.Minimum.Y - cameraPos.Y) * (bound.Minimum.Y - cameraPos.Y);                          if (cameraPos.Y > bound.Maximum.Y)                              distance += (cameraPos.Y - bound.Maximum.Y) * (cameraPos.Y - bound.Maximum.Y);                            if (cameraPos.Z < bound.Minimum.Z)                              distance += (bound.Minimum.Z - cameraPos.Z) * (bound.Minimum.Z - cameraPos.Z);                          if (cameraPos.Z > bound.Maximum.Z)                              distance += (cameraPos.Z - bound.Maximum.Z) * (cameraPos.Z - bound.Maximum.Z);                          return distance;                      case SortingMethod.BoundingSphereSurface:                          float distS = (node.BoundsSphereWithTransform.Center - cameraPos).Length() - node.BoundsSphereWithTransform.Radius;                          return Math.Max(distS' 0f);                      default:                          return 0;                  }
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,ViewBoxNode,The following statement contains a magic number: float cornerSize = size / 5;
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,ViewBoxNode,The following statement contains a magic number: float halfSize = size / 2;
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,ViewBoxNode,The following statement contains a magic number: float edgeSize = halfSize * 1.5f;
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,ViewBoxNode,The following statement contains a magic number: cornerInstances[i] = Matrix.Translation(cornerPoints[i] * size / 2 * 0.95f);
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,ViewBoxNode,The following statement contains a magic number: cornerInstances[i] = Matrix.Translation(cornerPoints[i] * size / 2 * 0.95f);
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,ViewBoxNode,The following statement contains a magic number: edgeInstances = new Matrix[count * 3];
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,ViewBoxNode,The following statement contains a magic number: edgeInstances[i] = Matrix.RotationZ((float)Math.PI / 2) * Matrix.Translation(xAligned[i] * halfSize * 0.95f);
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,ViewBoxNode,The following statement contains a magic number: edgeInstances[i] = Matrix.RotationZ((float)Math.PI / 2) * Matrix.Translation(xAligned[i] * halfSize * 0.95f);
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,ViewBoxNode,The following statement contains a magic number: edgeInstances[i] = Matrix.Translation(yAligned[i % count] * halfSize * 0.95f);
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,ViewBoxNode,The following statement contains a magic number: i < count * 2
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,ViewBoxNode,The following statement contains a magic number: edgeInstances[i] = Matrix.RotationX((float)Math.PI / 2) * Matrix.Translation(zAligned[i % count] * halfSize * 0.95f);
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,ViewBoxNode,The following statement contains a magic number: edgeInstances[i] = Matrix.RotationX((float)Math.PI / 2) * Matrix.Translation(zAligned[i % count] * halfSize * 0.95f);
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,ViewBoxNode,The following statement contains a magic number: i < count * 3
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,ViewBoxNode,The following statement contains a magic number: RelativeScreenLocationX = 0.8f;
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,UpdateModel,The following statement contains a magic number: var center = up * -size / 2 * 1.1f;
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,UpdateModel,The following statement contains a magic number: var center = up * -size / 2 * 1.1f;
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,UpdateModel,The following statement contains a magic number: int phi = 24;
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,UpdateModel,The following statement contains a magic number: double angle = 0 + (360 * i / (phi - 1));
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,UpdateModel,The following statement contains a magic number: double angleRad = angle / 180 * Math.PI;
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,UpdateModel,The following statement contains a magic number: pts.Add(center + (dir * (size - 0.75f)));
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,UpdateModel,The following statement contains a magic number: pts.Add(center + (dir * (size + 1.1f)));
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,CreateTextureCoordinates,The following statement contains a magic number: int faces = 6;
Magic Number,Model.Scene,ViewBoxNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ViewBoxNode.cs,CreateTextureCoordinates,The following statement contains a magic number: int segment = 4;
Magic Number,Render,DefaultRenderHost,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\DefaultRenderHostPartial_Properties.cs,PreRender,The following statement contains a magic number: getTriangleCountTask = Task.Factory.StartNew(() =>                      {                          int count = 0;                          foreach (var core in opaqueNodesInFrustum.Select(x => x.RenderCore))                          {                              if (core is IGeometryRenderCore c)                              {                                  if (c.GeometryBuffer is IGeometryBufferModel geo && geo.Geometry != null && geo.Geometry.Indices != null)                                      count += geo.Geometry.Indices.Count / 3;                              }                          }                          foreach (var core in transparentNodesInFrustum.Select(x => x.RenderCore))                          {                              if (core is IGeometryRenderCore c)                              {                                  if (c.GeometryBuffer is IGeometryBufferModel geo && geo.Geometry != null && geo.Geometry.Indices != null)                                      count += geo.Geometry.Indices.Count / 3;                              }                          }                          renderStatistics.NumTriangles = count;                      });
Magic Number,Render,DefaultRenderHost,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\DefaultRenderHostPartial_Properties.cs,PreRender,The following statement contains a magic number: getTriangleCountTask = Task.Factory.StartNew(() =>                      {                          int count = 0;                          foreach (var core in opaqueNodesInFrustum.Select(x => x.RenderCore))                          {                              if (core is IGeometryRenderCore c)                              {                                  if (c.GeometryBuffer is IGeometryBufferModel geo && geo.Geometry != null && geo.Geometry.Indices != null)                                      count += geo.Geometry.Indices.Count / 3;                              }                          }                          foreach (var core in transparentNodesInFrustum.Select(x => x.RenderCore))                          {                              if (core is IGeometryRenderCore c)                              {                                  if (c.GeometryBuffer is IGeometryBufferModel geo && geo.Geometry != null && geo.Geometry.Indices != null)                                      count += geo.Geometry.Indices.Count / 3;                              }                          }                          renderStatistics.NumTriangles = count;                      });
Magic Number,Render,DefaultRenderHost,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\DefaultRenderHostPartial_Properties.cs,CollectPostEffectNodes,The following statement contains a magic number: opaqueNodesInFrustum.Count + transparentNodesInFrustum.Count > 50
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: halfResDepthStencilPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 2)'                      Height = Math.Max(2' height / 2)'                      ArraySize = 1'                      BindFlags = BindFlags.DepthStencil'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: halfResDepthStencilPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 2)'                      Height = Math.Max(2' height / 2)'                      ArraySize = 1'                      BindFlags = BindFlags.DepthStencil'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: halfResDepthStencilPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 2)'                      Height = Math.Max(2' height / 2)'                      ArraySize = 1'                      BindFlags = BindFlags.DepthStencil'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: halfResDepthStencilPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 2)'                      Height = Math.Max(2' height / 2)'                      ArraySize = 1'                      BindFlags = BindFlags.DepthStencil'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: halfResRenderTargetPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 2)'                      Height = Math.Max(2' height / 2)'                      BindFlags = BindFlags.RenderTarget | BindFlags.ShaderResource'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      ArraySize = 1'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: halfResRenderTargetPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 2)'                      Height = Math.Max(2' height / 2)'                      BindFlags = BindFlags.RenderTarget | BindFlags.ShaderResource'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      ArraySize = 1'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: halfResRenderTargetPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 2)'                      Height = Math.Max(2' height / 2)'                      BindFlags = BindFlags.RenderTarget | BindFlags.ShaderResource'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      ArraySize = 1'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: halfResRenderTargetPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 2)'                      Height = Math.Max(2' height / 2)'                      BindFlags = BindFlags.RenderTarget | BindFlags.ShaderResource'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      ArraySize = 1'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: quarterResDepthStencilPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 4)'                      Height = Math.Max(2' height / 4)'                      ArraySize = 1'                      BindFlags = BindFlags.DepthStencil'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: quarterResDepthStencilPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 4)'                      Height = Math.Max(2' height / 4)'                      ArraySize = 1'                      BindFlags = BindFlags.DepthStencil'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: quarterResDepthStencilPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 4)'                      Height = Math.Max(2' height / 4)'                      ArraySize = 1'                      BindFlags = BindFlags.DepthStencil'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: quarterResDepthStencilPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 4)'                      Height = Math.Max(2' height / 4)'                      ArraySize = 1'                      BindFlags = BindFlags.DepthStencil'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: quarterResRenderTargetPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 4)'                      Height = Math.Max(2' height / 4)'                      BindFlags = BindFlags.RenderTarget | BindFlags.ShaderResource'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      ArraySize = 1'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: quarterResRenderTargetPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 4)'                      Height = Math.Max(2' height / 4)'                      BindFlags = BindFlags.RenderTarget | BindFlags.ShaderResource'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      ArraySize = 1'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: quarterResRenderTargetPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 4)'                      Height = Math.Max(2' height / 4)'                      BindFlags = BindFlags.RenderTarget | BindFlags.ShaderResource'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      ArraySize = 1'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,InitializeTexturePools,The following statement contains a magic number: quarterResRenderTargetPool = Collect(new TexturePool(this.DeviceResources' new Texture2DDescription()                  {                      Width = Math.Max(2' width / 4)'                      Height = Math.Max(2' height / 4)'                      BindFlags = BindFlags.RenderTarget | BindFlags.ShaderResource'                      CpuAccessFlags = CpuAccessFlags.None'                      Usage = ResourceUsage.Default'                      ArraySize = 1'                      MipLevels = 1'                      OptionFlags = ResourceOptionFlags.None'                      SampleDescription = new SampleDescription(1' 0)                  }));
Magic Number,Render,DX11RenderBufferProxyBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11RenderBufferBase.cs,GetMSAASampleDescription,The following statement contains a magic number: var newSampleCount = sampleCount * 2;
Magic Number,Render,DX11SwapChainCompositionRenderBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11SwapChainCompositionRenderBufferProxy.cs,CreateSwapChainDescription,The following statement contains a magic number: var desc = new SwapChainDescription1()                  {                      Width = Math.Max(1' TargetWidth)'                      Height = Math.Max(1' TargetHeight)'                      // B8G8R8A8_UNorm gives us better performance                       Format = Format'                      Stereo = false'                      SampleDescription = new SampleDescription(sampleCount' sampleQuality)'                      Usage = Usage.RenderTargetOutput'                      BufferCount = 2'                      SwapEffect = SwapEffect.FlipSequential'                      Scaling = Scaling.Stretch'                      Flags = SwapChainFlags.None                  };
Magic Number,Render,DX11SwapChainRenderBufferProxy,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderBuffers\DX11SwapChainRenderBufferProxy.cs,CreateSwapChainDescription,The following statement contains a magic number: var desc = new SwapChainDescription1()                  {                      Width = Math.Max(1' TargetWidth)'                      Height = Math.Max(1' TargetHeight)'                      // B8G8R8A8_UNorm gives us better performance                       Format = Format'                      Stereo = false'                      SampleDescription = new SampleDescription(sampleCount' sampleQuality)'                      Usage = Usage.RenderTargetOutput'                      BufferCount = 2'                      SwapEffect = SwapEffect.FlipSequential'                      Scaling = Scaling.Stretch'                      Flags = SwapChainFlags.AllowModeSwitch                  };
Magic Number,Render,DX11RenderHostBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\RenderHostBase.cs,CanRender,The following statement contains a magic number: return IsInitialized && IsRendering && (UpdateRequested || updateCounter < RenderConfiguration.MinimumUpdateCount)                      && viewport != null && viewport.CameraCore != null && ActualWidth > 10 && ActualHeight > 10;
Magic Number,Render,DX11RenderHostBase,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\RenderHostBase.cs,CanRender,The following statement contains a magic number: return IsInitialized && IsRendering && (UpdateRequested || updateCounter < RenderConfiguration.MinimumUpdateCount)                      && viewport != null && viewport.CameraCore != null && ActualWidth > 10 && ActualHeight > 10;
Magic Number,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,Arrange,The following statement contains a magic number: layoutOffset.X = (clientSize.X - clippedArrangeResultSize.X) / 2.0f;
Magic Number,Model.Scene2D,SceneNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\Abstract\SceneNode2D.cs,Arrange,The following statement contains a magic number: layoutOffset.Y = (clientSize.Y - clippedArrangeResultSize.Y) / 2.0f;
Magic Number,Model.Scene2D,BorderNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\BorderNode2D.cs,MeasureOverride,The following statement contains a magic number: var margin = new Size2F((BorderThickness.Left / 2 + Padding.Left + BorderThickness.Right / 2 + Padding.Right)'                          (BorderThickness.Top / 2 + Padding.Top + BorderThickness.Bottom / 2 + Padding.Bottom));
Magic Number,Model.Scene2D,BorderNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\BorderNode2D.cs,MeasureOverride,The following statement contains a magic number: var margin = new Size2F((BorderThickness.Left / 2 + Padding.Left + BorderThickness.Right / 2 + Padding.Right)'                          (BorderThickness.Top / 2 + Padding.Top + BorderThickness.Bottom / 2 + Padding.Bottom));
Magic Number,Model.Scene2D,BorderNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\BorderNode2D.cs,MeasureOverride,The following statement contains a magic number: var margin = new Size2F((BorderThickness.Left / 2 + Padding.Left + BorderThickness.Right / 2 + Padding.Right)'                          (BorderThickness.Top / 2 + Padding.Top + BorderThickness.Bottom / 2 + Padding.Bottom));
Magic Number,Model.Scene2D,BorderNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\BorderNode2D.cs,MeasureOverride,The following statement contains a magic number: var margin = new Size2F((BorderThickness.Left / 2 + Padding.Left + BorderThickness.Right / 2 + Padding.Right)'                          (BorderThickness.Top / 2 + Padding.Top + BorderThickness.Bottom / 2 + Padding.Bottom));
Magic Number,Model.Scene2D,BorderNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\BorderNode2D.cs,ArrangeOverride,The following statement contains a magic number: contentRect.Left += (float)(BorderThickness.Left / 2 + Padding.Left);
Magic Number,Model.Scene2D,BorderNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\BorderNode2D.cs,ArrangeOverride,The following statement contains a magic number: contentRect.Right -= (float)(BorderThickness.Right / 2 + Padding.Right);
Magic Number,Model.Scene2D,BorderNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\BorderNode2D.cs,ArrangeOverride,The following statement contains a magic number: contentRect.Top += (float)(BorderThickness.Top / 2 + Padding.Top);
Magic Number,Model.Scene2D,BorderNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\BorderNode2D.cs,ArrangeOverride,The following statement contains a magic number: contentRect.Bottom -= (float)(BorderThickness.Bottom / 2 + Padding.Bottom);
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following statement contains a magic number: switch (headerDX10.ResourceDimension)                  {                      case ResourceDimension.Texture1D:                            // D3DX writes 1D textures with a fixed Height of 1                          if ((header.Flags & DDS.HeaderFlags.Height) != 0 && header.Height != 1)                              throw new InvalidOperationException("Unexpected Height != 1 from DDS HeaderDX10 ");                            description.Width = header.Width;                          description.Height = 1;                          description.Depth = 1;                          description.Dimension = TextureDimension.Texture1D;                          break;                        case ResourceDimension.Texture2D:                          if ((headerDX10.MiscFlags & ResourceOptionFlags.TextureCube) != 0)                          {                              description.ArraySize *= 6;                              description.Dimension = TextureDimension.TextureCube;                          }                          else                          {                              description.Dimension = TextureDimension.Texture2D;                          }                            description.Width = header.Width;                          description.Height = header.Height;                          description.Depth = 1;                          break;                        case ResourceDimension.Texture3D:                          if ((header.Flags & DDS.HeaderFlags.Volume) == 0)                              throw new InvalidOperationException("Texture3D missing HeaderFlags.Volume from DDS HeaderDX10");                            if (description.ArraySize > 1)                              throw new InvalidOperationException("Unexpected ArraySize > 1 for Texture3D from DDS HeaderDX10");                            description.Width = header.Width;                          description.Height = header.Height;                          description.Depth = header.Depth;                          description.Dimension = TextureDimension.Texture3D;                          break;                        default:                          throw new InvalidOperationException(string.Format("Unexpected dimension [{0}] from DDS HeaderDX10"' headerDX10.ResourceDimension));                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: (description.ArraySize != 6) || (description.Dimension != TextureDimension.Texture2D) || (description.Dimension != TextureDimension.TextureCube)
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: ext->ArraySize = description.ArraySize / 6;
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LoadFromDDSMemory,The following statement contains a magic number: offset += (256 * sizeof (uint));
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,NewCube,The following statement contains a magic number: return new Image(CreateDescription(TextureDimension.TextureCube' width' width' 1' mipMapCount' format' 6)' dataPointer' 0' null' false);
Magic Number,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Load,The following statement contains a magic number: size > (85 * 1024)
Magic Number,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Load,The following statement contains a magic number: size > (85 * 1024)
Magic Number,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The following statement contains a magic number: switch (description.Dimension)              {                  case TextureDimension.Texture1D:                      if (description.Width <= 0 || description.Height != 1 || description.Depth != 1 || description.ArraySize == 0)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 1D");                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' 1' description.MipLevels);                      break;                    case TextureDimension.Texture2D:                  case TextureDimension.TextureCube:                      if (description.Width <= 0 || description.Height <= 0 || description.Depth != 1 || description.ArraySize == 0)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 2D");                        if (description.Dimension == TextureDimension.TextureCube)                      {                          if ((description.ArraySize % 6) != 0)                              throw new InvalidOperationException("TextureCube must have an arraysize = 6");                      }                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.MipLevels);                      break;                    case TextureDimension.Texture3D:                      if (description.Width <= 0 || description.Height <= 0 || description.Depth <= 0 || description.ArraySize != 1)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 3D");                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.Depth' description.MipLevels);                      break;              }
Magic Number,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;
Magic Number,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;
Magic Number,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: widthCount = Math.Max(1' (width + 3) / 4);
Magic Number,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: widthCount = Math.Max(1' (width + 3) / 4);
Magic Number,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: heightCount = Math.Max(1' (height + 3) / 4);
Magic Number,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: heightCount = Math.Max(1' (height + 3) / 4);
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Width;
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Height;
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Depth;
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ ArraySize;
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ MipLevels;
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Format.GetHashCode();
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.Height;
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.WidthPacked;
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.HeightPacked;
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.Depth;
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.RowStride;
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.MipmapSize;
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.DepthStride;
Magic Number,SharpDX.Toolkit.Graphics,RenderTargetCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTargetCube.cs,NewRenderTargetDescription,The following statement contains a magic number: var desc = Texture2DBase.NewDescription(size' size' format' flags' mipCount' 6' ResourceUsage.Default);
Magic Number,SharpDX.Toolkit.Graphics,Texture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,CalculateMipMapCount,The following statement contains a magic number: int maxMipMap = 1 + (int)Math.Log(size' 2);
Magic Number,SharpDX.Toolkit.Graphics,Texture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetViewCount,The following statement contains a magic number: return GetViewIndex((ViewType)4' arrayOrDepthSize' this.Description.MipLevels);
Magic Number,SharpDX.Toolkit.Graphics,TextureViewKey,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ (int)ViewType;
Magic Number,SharpDX.Toolkit.Graphics,TextureViewKey,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ ArrayOrDepthSlice;
Magic Number,SharpDX.Toolkit.Graphics,TextureViewKey,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ MipIndex;
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: textureData.Length != 6
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin(textureData[2]' ptr => dataBox3 = GetDataBox(format' size' size' 1' textureData[0]' ptr));
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin(textureData[3]' ptr => dataBox4 = GetDataBox(format' size' size' 1' textureData[0]' ptr));
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin(textureData[4]' ptr => dataBox5 = GetDataBox(format' size' size' 1' textureData[0]' ptr));
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin(textureData[5]' ptr => dataBox6 = GetDataBox(format' size' size' 1' textureData[0]' ptr));
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: textureData.Length != 6
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,NewTextureCubeDescription,The following statement contains a magic number: var desc = NewDescription(size' size' format' flags' mipCount' 6' usage);
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Width;
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Height;
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Depth;
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ ArraySize;
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ MipLevels;
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Format.GetHashCode();
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ Usage.GetHashCode();
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: frame.SetResolution(72' 72);
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: frame.SetResolution(72' 72);
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: palette.Initialize(source' 256' true);
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: int rowPitch = (image.Width * bpp + 7) / 8;
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: int rowPitch = (image.Width * bpp + 7) / 8;
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeMultiframe,The following statement contains a magic number: images.Length < 2
Magic Number,Utilities.ImagePacker,ArevaloRectanglePacker,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImagePacker\ArevaloRectanglePacker.cs,SelectAnchorRecursive,The following statement contains a magic number: return SelectAnchorRecursive(rectangleWidth' rectangleHeight' testedPackingAreaWidth' Math.Min(testedPackingAreaHeight*2' PackingAreaHeight));
Magic Number,Utilities.ImagePacker,ArevaloRectanglePacker,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImagePacker\ArevaloRectanglePacker.cs,SelectAnchorRecursive,The following statement contains a magic number: return SelectAnchorRecursive(rectangleWidth' rectangleHeight' Math.Min(testedPackingAreaWidth*2' PackingAreaWidth)' testedPackingAreaHeight);
Magic Number,Utilities.ImagePacker,MiscHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImagePacker\MiscHelper.cs,FindNextPowerOfTwo,The following statement contains a magic number: i < sizeof(int) * 8
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: n < 3
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: int count = 2 * nv;
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: count = 2 * nv;
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: nv > 2
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Area,The following statement contains a magic number: return area * 0.5f;
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,InsideTriangle,The following statement contains a magic number: const double EPSILON = -1e-10;
Duplicate Code,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The method contains a code clone-set at the following line numbers (starting from the method definition): ((140' 164)' (732' 756))
Duplicate Code,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The method contains a code clone-set at the following line numbers (starting from the method definition): ((222' 279)' (778' 835))
Duplicate Code,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The method contains a code clone-set at the following line numbers (starting from the method definition): ((281' 312)' (837' 868))
Duplicate Code,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1653' 1673)' (1709' 1729))
Duplicate Code,HelixToolkit.SharpDX.Core,DefaultEffectsManager,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\ShaderManager\DefaultEffectsManager.cs,LoadTechniqueDescriptions,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1687' 1707)' (1743' 1763))
Duplicate Code,Render,DefaultRenderHost,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\DefaultRenderHostPartial_Properties.cs,SeparateRenderables,The method contains a code clone-set at the following line numbers (starting from the method definition): ((22' 41)' (100' 119))
Missing Default,HelixToolkit.SharpDX.Core.Controls,RotateHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\RotateHandler.cs,Rotate,The following switch statement is missing a default case: switch (this.Controller.CameraRotationMode)              {                  case CameraRotationMode.Trackball:                      CameraMath.RotateTrackball(CameraMode' ref p0' ref p1' ref rotateAround' (float)RotationSensitivity'                          Controller.Width' Controller.Height' Camera' inv' out newPos' out newLook' out newUp);                      break;                  case CameraRotationMode.Turntable:                      var p = p1 - p0;                      CameraMath.RotateTurntable(CameraMode' ref p' ref rotateAround' (float)RotationSensitivity'                          Controller.Width' Controller.Height' Camera' inv' ModelUpDirection' out newPos' out newLook' out newUp);                      break;                  case CameraRotationMode.Turnball:                      CameraMath.RotateTurnball(CameraMode' ref p0' ref p1' ref rotateAround' (float)RotationSensitivity'                          Controller.Width' Controller.Height' Camera' inv' out newPos' out newLook' out newUp);                      break;              }
Missing Default,HelixToolkit.SharpDX.Core.Controls,RotateHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\RotateHandler.cs,Started,The following switch statement is missing a default case: switch (this.CameraRotationMode)              {                  case CameraRotationMode.Trackball:                      break;                  case CameraRotationMode.Turntable:                      break;                  case CameraRotationMode.Turnball:                      CameraMath.InitTurnballRotationAxes(e' (int)Controller.Width' (int)Controller.Height' Camera'                          out rotationAxisX' out rotationAxisY);                      break;              }
Missing Default,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,Zoom,The following switch statement is missing a default case: switch (CameraMode)                      {                          case CameraMode.Inspect:                              ChangeCameraDistance(ref delta' zoomAround);                              break;                          case CameraMode.WalkAround:                              Camera.Position -= Camera.LookDirection * (float)delta;                              break;                      }
Missing Default,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,MoveCameraPosition,The following switch statement is missing a default case: switch (CameraMode)              {                  case CameraMode.Inspect:                  case CameraMode.WalkAround:                      Camera.Position += (x * delta.X) + (y * delta.Y) + (z * delta.Z);                      break;              }
Missing Default,HelixToolkit.SharpDX.Core.Controls,ZoomHandler,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Core\Controls\ZoomHandler.cs,ZoomByChangingCameraWidth,The following switch statement is missing a default case: switch (CameraMode)              {                  case CameraMode.WalkAround:                  case CameraMode.Inspect:                  case CameraMode.FixedPosition:                      if (ChangeCameraDistance(ref delta' zoomAround))                      {                          // Modify the camera width                          if (Camera is OrthographicCameraCore ocamera)                          {                              ocamera.Width *= (float)Math.Pow(2.5f' delta);                          }                      }                      break;              }
Missing Default,HelixToolkit.SharpDX.Core,BitmapExtensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BitmapExtensions.cs,ToWICImageFormat,The following switch statement is missing a default case: switch (format)              {                  case Direct2DImageFormat.Bmp:                      return ContainerFormatGuids.Bmp;                  case Direct2DImageFormat.Ico:                      return ContainerFormatGuids.Ico;                  case Direct2DImageFormat.Gif:                      return ContainerFormatGuids.Gif;                  case Direct2DImageFormat.Jpeg:                      return ContainerFormatGuids.Jpeg;                  case Direct2DImageFormat.Png:                      return ContainerFormatGuids.Png;                  case Direct2DImageFormat.Tiff:                      return ContainerFormatGuids.Tiff;                  case Direct2DImageFormat.Wmp:                      return ContainerFormatGuids.Wmp;              }
Missing Default,HelixToolkit.SharpDX.Core,Color4Extensions,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Color4Extensions.cs,ToColor4,The following switch statement is missing a default case: switch (values.Length)                          {                              case 1:                                  obj = FromArgb(values[0]);                                  break;                                case 3:                                  obj = FromArgb(values[0]' values[1]' values[2]);                                  break;                                case 4:                                  obj = FromArgb(values[0]' values[1]' values[2]' values[3]);                                  break;                          }
Missing Default,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,Read,The following switch statement is missing a default case: switch (keyword.ToLower())                          {                              // Vertex data                              case "v": // geometric vertices                                  this.AddVertex(values);                                  break;                              case "vt": // texture vertices                                  this.AddTexCoord(values);                                  break;                              case "vn": // vertex normals                                  this.AddNormal(values);                                  break;                              case "vp": // parameter space vertices                              case "cstype": // rational or non-rational forms of curve or surface type: basis matrix' Bezier' B-spline' Cardinal' Taylor                              case "degree": // degree                              case "bmat": // basis matrix                              case "step": // step size                                  // not supported                                  break;                                // Elements                              case "f": // face                                  this.AddFace(values);                                  break;                              case "p": // point                              case "l": // line                              case "curv": // curve                              case "curv2": // 2D curve                              case "surf": // surface                                  // not supported                                  break;                                // Free-form curve/surface body statements                              case "parm": // parameter name                              case "trim": // outer trimming loop (trim)                              case "hole": // inner trimming loop (hole)                              case "scrv": // special curve (scrv)                              case "sp":  // special point (sp)                              case "end": // end statement (end)                                  // not supported                                  break;                                // Connectivity between free-form surfaces                              case "con": // connect                                  // not supported                                  break;                                // Grouping                              case "g": // group name                                  this.AddGroup(values);                                  break;                              case "s": // smoothing group                                  this.SetSmoothingGroup(values);                                  break;                              case "mg": // merging group                                  break;                              case "o": // object name                                  // not supported                                  break;                                // Display/render attributes                              case "mtllib": // material library                                  this.LoadMaterialLib(values);                                  break;                              case "usemtl": // material name                                  this.EnsureNewMesh();                                    this.SetMaterial(values);                                  break;                              case "usemap": // texture map name                                  this.EnsureNewMesh();                                    break;                              case "bevel": // bevel interpolation                              case "c_interp": // color interpolation                              case "d_interp": // dissolve interpolation                              case "lod": // level of detail                              case "shadow_obj": // shadow casting                              case "trace_obj": // ray tracing                              case "ctech": // curve approximation technique                              case "stech": // surface approximation technique                                  // not supported                                  break;                          }
Missing Default,HelixToolkit.SharpDX.Core,ObjReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs,LoadMaterialLib,The following switch statement is missing a default case: switch (keyword.ToLower())                          {                              case "newmtl":                                  if (value != null)                                  {                                      if (this.Materials.ContainsKey(value))                                      {                                          currentMaterial = null;                                      }                                      else                                      {                                          currentMaterial = new MaterialDefinition();                                          this.Materials.Add(value' currentMaterial);                                      }                                  }                                    break;                              case "ka":                                  if (currentMaterial != null && value != null)                                  {                                      currentMaterial.Ambient = ColorParse(value);                                  }                                    break;                              case "kd":                                  if (currentMaterial != null && value != null)                                  {                                      currentMaterial.Diffuse = ColorParse(value);                                  }                                    break;                              case "ks":                                  if (currentMaterial != null && value != null)                                  {                                      currentMaterial.Specular = ColorParse(value);                                  }                                    break;                              case "ns":                                  if (currentMaterial != null && value != null)                                  {                                      currentMaterial.SpecularCoefficient = DoubleParse(value);                                  }                                    break;                              case "d":                                  if (currentMaterial != null && value != null)                                  {                                      currentMaterial.Dissolved = DoubleParse(value);                                  }                                    break;                              case "tr":                                  if (!this.SkipTransparencyValues && currentMaterial != null && value != null)                                  {                                      currentMaterial.Dissolved = DoubleParse(value);                                  }                                    break;                              case "illum":                                  if (currentMaterial != null && value != null)                                  {                                      currentMaterial.Illumination = int.Parse(value);                                  }                                    break;                              case "map_ka":                                  if (currentMaterial != null)                                  {                                      currentMaterial.AmbientMap = value;                                  }                                    break;                              case "map_kd":                                  if (currentMaterial != null)                                  {                                      currentMaterial.DiffuseMap = value;                                  }                                    break;                              case "map_ks":                                  if (currentMaterial != null)                                  {                                      currentMaterial.SpecularMap = value;                                  }                                    break;                              case "map_d":                                  if (currentMaterial != null)                                  {                                      currentMaterial.AlphaMap = value;                                  }                                    break;                              case "map_bump":                              case "bump":                                  if (currentMaterial != null)                                  {                                      currentMaterial.BumpMap = value;                                  }                                    break;                          }
Missing Default,HelixToolkit.SharpDX.Core,StLReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StLReader.cs,TryReadAscii,The following switch statement is missing a default case: switch (id)                  {                      case "solid":                          this.Header = values.Trim();                          break;                      case "facet":                          this.ReadFacet(reader' values);                          break;                      case "endsolid":                          break;                  }
Missing Default,HelixToolkit.SharpDX.Core,StudioReader,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\StudioReader.cs,ReadPercent,The following switch statement is missing a default case: switch (type)              {                  case ChunkID.PERCENTW:                      percent = reader.ReadUInt16();                      break;                  case ChunkID.PERCENTF:                      percent = reader.ReadSingle();                      break;                  case ChunkID.PERCENTD:                      reader.ReadBytes(size);                      break;              }
Missing Default,HelixToolkit.SharpDX.Core,SweepLinePolygonTriangulator,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,CalculateDiagonals,The following switch statement is missing a default case: switch (evClass)                  {                      case PolygonPointClass.Start:                          // Just add the left Edge (depending on the sweeping direction)                          statusAndHelper.Add(new StatusHelperElement(sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));                          break;                      case PolygonPointClass.Stop:                          // Just remove the left Edge (depending on the sweeping direction)                          statusAndHelper.Remove(sweepDown ? ev.EdgeOne : ev.EdgeTwo);                          break;                      case PolygonPointClass.Regular:                          // If the Polygon is positioned on the right Side of this Event                          if (ev.Last > ev.Next)                          {                              // Replace the corresponding (old) StatusHelperElement with the new one                              statusAndHelper.Remove(sweepDown ? ev.EdgeOne : ev.EdgeTwo);                              statusAndHelper.Add(new StatusHelperElement(sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));                          }                          else                          {                              // Search Edge left of the Event and set Event as it's Helper                              she = statusAndHelper.SearchLeft(ev);                              if (she != null)                                  she.Helper = ev;                          }                          break;                      case PolygonPointClass.Merge:                          // Just remove the left Edge (depending on the sweeping direction)                          statusAndHelper.Remove(sweepDown ? ev.EdgeOne : ev.EdgeTwo);                          // Search Edge left of the Event and set Event as it's Helper                          she = statusAndHelper.SearchLeft(ev);                          if (she != null)                              she.Helper = ev;                          break;                      case PolygonPointClass.Split:                          // Search Edge left of the Event                          she = statusAndHelper.SearchLeft(ev);                          if (she != null)                          {                              // Chose diagonal from Helper of Edge to Event.                              var minP = Math.Min(she.Helper.Index' ev.Index);                              var maxP = Math.Max(she.Helper.Index' ev.Index);                              var diagonal = new Tuple<int' int>(minP' maxP);                              diagonals.Add(diagonal);                                // Replace the Helper of the StatusHelperElement by Event                              she.Helper = ev;                              // Insert the right Edge from Event                              statusAndHelper.Add(new StatusHelperElement(sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));                          }                          break;                  }
Missing Default,Core,DefaultMeshGeometryBufferModel,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\MeshBufferModel.cs,OnCreateVertexBuffer,The following switch statement is missing a default case: switch (bufferIndex)                      {                          case 0:                              // -- set geometry if given                              if (geometry.Positions != null && geometry.Positions.Count > 0)                              {                                  // --- get geometry                                  var data = BuildVertexArray(mesh);                                  buffer.UploadDataToBuffer(context' data' geometry.Positions.Count' 0' geometry.PreDefinedVertexCount);                              }                              else                              {                                  //buffer.DisposeAndClear();                                  buffer.UploadDataToBuffer(context' emptyVerts' 0);                              }                              break;                          case 1:                              if(mesh.TextureCoordinates != null && mesh.TextureCoordinates.Count > 0)                              {                                  buffer.UploadDataToBuffer(context' mesh.TextureCoordinates' mesh.TextureCoordinates.Count' 0' geometry.PreDefinedVertexCount);                              }                              else                              {                                  buffer.UploadDataToBuffer(context' emptyTextureArray' 0);                              }                              break;                          case 2:                              if (geometry.Colors != null && geometry.Colors.Count > 0)                              {                                  buffer.UploadDataToBuffer(context' geometry.Colors' geometry.Colors.Count' 0' geometry.PreDefinedVertexCount);                              }                              else                              {                                  buffer.UploadDataToBuffer(context' emptyColorArray' 0);                              }                              break;                      }
Missing Default,Core,PostEffectFXAA,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\PostEffects\PostEffectFXAA.cs,OnUpdatePerModelStruct,The following switch statement is missing a default case: switch (FXAALevel)                  {                      case FXAALevel.Low:                          modelStruct.Param.M11 = 0.25f; //fxaaQualitySubpix                          modelStruct.Param.M12 = 0.250f; // FxaaFloat fxaaQualityEdgeThreshold'                          modelStruct.Param.M13 = 0.0833f; // FxaaFloat fxaaQualityEdgeThresholdMin'                          break;                      case FXAALevel.Medium:                          modelStruct.Param.M11 = 0.50f;                          modelStruct.Param.M12 = 0.166f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.High:                          modelStruct.Param.M11 = 0.75f;                          modelStruct.Param.M12 = 0.125f;                          modelStruct.Param.M13 = 0.0625f;                          break;                      case FXAALevel.Ultra:                          modelStruct.Param.M11 = 1.00f;                          modelStruct.Param.M12 = 0.063f;                          modelStruct.Param.M13 = 0.0312f;                          break;                  }
Missing Default,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,SetScreenSpacedCoordinates,The following switch statement is missing a default case: switch (mode)                  {                      case ScreenSpacedMode.RelativeScreenSpaced:                          RenderRelativeScreenSpaced(context' deviceContext);                          break;                      case ScreenSpacedMode.AbsolutePosition3D:                          switch (context.IsPerspective)                          {                              case true:                                  RenderAbsolutePositionPerspective(context' deviceContext);                                  break;                              case false:                                  RenderAbsolutePositionOrtho(context' deviceContext);                                  break;                          }                          break;                  }
Missing Default,Core,ScreenSpacedMeshRenderCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Core\ScreenSpacedMeshRenderCore.cs,SetScreenSpacedCoordinates,The following switch statement is missing a default case: switch (context.IsPerspective)                          {                              case true:                                  RenderAbsolutePositionPerspective(context' deviceContext);                                  break;                              case false:                                  RenderAbsolutePositionOrtho(context' deviceContext);                                  break;                          }
Missing Default,Shaders,ShaderPass,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Shaders\ShaderPass.cs,ShaderPass,The following switch statement is missing a default case: switch (shader.ShaderType)                          {                              case ShaderStage.Vertex:                                  VertexShader = s as VertexShader;                                  break;                              case ShaderStage.Domain:                                  DomainShader = s as DomainShader;                                  break;                              case ShaderStage.Hull:                                  HullShader = s as HullShader;                                  break;                              case ShaderStage.Geometry:                                  GeometryShader = s as GeometryShader;                                  break;                              case ShaderStage.Pixel:                                  PixelShader = s as PixelShader;                                  break;                              case ShaderStage.Compute:                                  ComputeShader = s as ComputeShader;                                  break;                                                      }
Missing Default,Shaders,ShaderPass,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Shaders\ShaderPass.cs,SetShader,The following switch statement is missing a default case: switch (shader.ShaderType)                  {                      case ShaderStage.Vertex:                          VertexShader = shader as VertexShader;                          break;                      case ShaderStage.Pixel:                          PixelShader = shader as PixelShader;                          break;                      case ShaderStage.Compute:                          ComputeShader = shader as ComputeShader;                          break;                      case ShaderStage.Hull:                          HullShader = shader as HullShader;                          break;                      case ShaderStage.Domain:                          DomainShader = shader as DomainShader;                          break;                      case ShaderStage.Geometry:                          GeometryShader = shader as GeometryShader;                          break;                  }
Missing Default,Shaders,ShaderReflector,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Shaders\ShaderReflector.cs,Parse,The following switch statement is missing a default case: switch (res.Type)                          {                              case ShaderInputType.ConstantBuffer:                                  var cb = reflection.GetConstantBuffer(res.Name);                                  var cbDesc = new ConstantBufferDescription(cb) { Stage = stage' Slot = res.BindPoint };                                  ConstantBufferMappings.Add(res.Name' cbDesc.CreateMapping(res.BindPoint));                                  break;                              case ShaderInputType.Texture:                                  var tDescT = new TextureDescription(res.Name' stage' TextureType.Texture);                                  TextureMappings.Add(res.Name' tDescT.CreateMapping(res.BindPoint));                                  break;                              case ShaderInputType.Structured:                                  var tDescStr = new TextureDescription(res.Name' stage' TextureType.Structured);                                  TextureMappings.Add(res.Name' tDescStr.CreateMapping(res.BindPoint));                                  break;                              case ShaderInputType.TextureBuffer:                                  var tDescTB = new TextureDescription(res.Name' stage' TextureType.TextureBuffer);                                  TextureMappings.Add(res.Name' tDescTB.CreateMapping(res.BindPoint));                                  break;                              case ShaderInputType.UnorderedAccessViewAppendStructured:                                  var uDescAppend = new UAVDescription(res.Name' stage' UnorderedAccessViewType.AppendStructured);                                  UAVMappings.Add(res.Name' uDescAppend.CreateMapping(res.BindPoint));                                  break;                              case ShaderInputType.UnorderedAccessViewConsumeStructured:                                  var uDescConsume = new UAVDescription(res.Name' stage' UnorderedAccessViewType.ConsumeStructured);                                  UAVMappings.Add(res.Name' uDescConsume.CreateMapping(res.BindPoint));                                  break;                              case ShaderInputType.UnorderedAccessViewRWByteAddress:                                  var uDescByte = new UAVDescription(res.Name' stage' UnorderedAccessViewType.RWByteAddress);                                  UAVMappings.Add(res.Name' uDescByte.CreateMapping(res.BindPoint));                                  break;                              case ShaderInputType.UnorderedAccessViewRWStructuredWithCounter:                                  var uDescStr = new UAVDescription(res.Name' stage' UnorderedAccessViewType.RWStructuredWithCounter);                                  UAVMappings.Add(res.Name' uDescStr.CreateMapping(res.BindPoint));                                  break;                              case ShaderInputType.UnorderedAccessViewRWTyped:                                  var uDescTyped = new UAVDescription(res.Name' stage' UnorderedAccessViewType.RWTyped);                                  UAVMappings.Add(res.Name' uDescTyped.CreateMapping(res.BindPoint));                                  break;                              case ShaderInputType.Sampler:                                  SamplerMappings.Add(res.Name' new SamplerMapping(res.BindPoint' res.Name' stage));                                  break;                          }
Missing Default,Animations,KeyFrameUpdater,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Animations\KeyFrameUpdater.cs,Update,The following switch statement is missing a default case: switch (RepeatMode)                      {                          case AnimationRepeatMode.PlayOnce:                              return;                          case AnimationRepeatMode.PlayOnceHold:                              OutputBones(boneNode);                              return;                      }
Missing Default,Animations,NodeAnimationUpdater,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Animations\KeyFrameUpdater.cs,Update,The following switch statement is missing a default case: switch (RepeatMode)                      {                          case AnimationRepeatMode.PlayOnce:                              UpdateBoneSkinMesh();                              SetToStart();                              return;                          case AnimationRepeatMode.PlayOnceHold:                                                         return;                      }
Missing Default,Utilities,Octant,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\Octrees\StaticOctrees\StaticOctree.cs,SetChildIndex,The following switch statement is missing a default case: switch (index)                      {                          case 0: c0 = value; break;                          case 1: c1 = value; break;                          case 2: c2 = value; break;                          case 3: c3 = value; break;                          case 4: c4 = value; break;                          case 5: c5 = value; break;                          case 6: c6 = value; break;                          case 7: c7 = value; break;                      }
Missing Default,Model,GenericMaterialVariable,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\Variables\GenericMaterialVariable.cs,MaterialCore_UpdatingResource,The following switch statement is missing a default case: switch (e.Type)                  {                      case ResourceType.Sampler:                          SetSampler(e.Name' materialCore.GetSampler(e.Name));                          break;                      case ResourceType.Texture:                          SetTexture(e.Name' materialCore.GetTexture(e.Name));                          break;                      case ResourceType.Float:                          WriteValue(e.Name' materialCore.FloatDict[e.Name]);                          break;                      case ResourceType.Vector2:                          WriteValue(e.Name' materialCore.Vector2Dict[e.Name]);                          break;                      case ResourceType.Vector3:                          WriteValue(e.Name' materialCore.Vector3Dict[e.Name]);                          break;                      case ResourceType.Vector4:                          WriteValue(e.Name' materialCore.Vector4Dict[e.Name]);                          break;                      case ResourceType.Matrix:                          WriteValue(e.Name' materialCore.MatrixDict[e.Name]);                          break;                  }
Missing Default,Model,VolumeTextureRawDataMaterialCore,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Material\VolumeTextureMaterial.cs,LoadRAWFile,The following switch statement is missing a default case: switch (bytePerPixel)                      {                          case 1:                              format = global::SharpDX.DXGI.Format.R8_UNorm;                              break;                          case 2:                              format = global::SharpDX.DXGI.Format.R16_UNorm;                              break;                          case 4:                              format = global::SharpDX.DXGI.Format.R32_Float;                              break;                      }
Missing Default,Model,Entry,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Metadata.cs,DataAs,The following switch statement is missing a default case: switch (DataType)                      {                          case MetaDataType.Bool:                              dataTypeType = typeof(bool);                              break;                          case MetaDataType.Float:                              dataTypeType = typeof(float);                              break;                          case MetaDataType.Double:                              dataTypeType = typeof(double);                              break;                          case MetaDataType.Int32:                              dataTypeType = typeof(int);                              break;                          case MetaDataType.String:                              dataTypeType = typeof(String);                              break;                          case MetaDataType.UInt64:                              dataTypeType = typeof(UInt64);                              break;                          case MetaDataType.Vector3D:                              dataTypeType = typeof(Vector3);                              break;                      }
Missing Default,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The following switch statement is missing a default case: switch (which)                  {                      case 0:                          label = LabelX;                          break;                        case 1:                          label = LabelY;                          break;                        case 2:                          label = LabelZ;                          break;                  }
Missing Default,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisLabel,The following switch statement is missing a default case: switch (which)                  {                      case 0:                          color = AxisXColor;                          break;                        case 1:                          color = AxisYColor;                          break;                        case 2:                          color = AxisZColor;                          break;                  }
Missing Default,Model.Scene,CoordinateSystemNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\CoordinateSystemNode.cs,UpdateAxisColor,The following switch statement is missing a default case: switch (which)                  {                      case 0:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(arrowSize + 1.5f' 0' 0)) { Foreground = labelColor' Scale = 0.5f };                                         break;                        case 1:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' arrowSize + 1.5f' 0)) { Foreground = labelColor' Scale = 0.5f };                          break;                        case 2:                          labelText.TextInfo[which] = new TextInfo(label' new Vector3(0' 0' arrowSize + 1.5f)) { Foreground = labelColor' Scale = 0.5f };                          break;                  }
Missing Default,Model.Scene,ScreenSpacedNode,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene\ScreenSpacedNode.cs,OnHitTest,The following switch statement is missing a default case: switch (Mode)                  {                      case ScreenSpacedMode.RelativeScreenSpaced:                          preHit = CreateRelativeScreenModeRay(context' ref totalModelMatrix' ref ray' out newRay);                          break;                      case ScreenSpacedMode.AbsolutePosition3D:                          preHit = CreateAbsoluteModeRay(context' ref totalModelMatrix' ref ray' out newRay);                          break;                  }
Missing Default,Render,DefaultRenderHost,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Render\RenderHost\DefaultRenderHostPartial_Properties.cs,SeparateRenderables,The following switch statement is missing a default case: switch (type)                          {                              case RenderType.Opaque:                                  opaqueNodes.Add(renderable.Value);                                  break;                              case RenderType.Light:                                  lightNodes.Add(renderable.Value);                                  break;                              case RenderType.Transparent:                                  transparentNodes.Add(renderable.Value);                                  break;                              case RenderType.Particle:                                  particleNodes.Add(renderable.Value);                                  break;                              case RenderType.PreProc:                                  preProcNodes.Add(renderable.Value);                                  break;                              case RenderType.PostProc:                                  postProcNodes.Add(renderable.Value);                                  break;                              case RenderType.ScreenSpaced:                                  screenSpacedNodes.Add(renderable.Value);                                  break;                          }
Missing Default,Model.Scene2D,StackPanelNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\StackPanelNode2D.cs,MeasureOverride,The following switch statement is missing a default case: switch (Orientation)                  {                      case Orientation.Horizontal:                          availableSize.Width = float.PositiveInfinity;                          break;                        case Orientation.Vertical:                          availableSize.Height = float.PositiveInfinity;                          break;                  }
Missing Default,Model.Scene2D,StackPanelNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\StackPanelNode2D.cs,MeasureOverride,The following switch statement is missing a default case: switch (Orientation)                          {                              case Orientation.Horizontal:                                  size.Width += c.DesiredSize.X;                                  size.Height = Math.Max(size.Height' c.DesiredSize.Y);                                  break;                                case Orientation.Vertical:                                  size.Width = Math.Max(c.DesiredSize.X' size.Width);                                  size.Height += c.DesiredSize.Y;                                  break;                          }
Missing Default,Model.Scene2D,StackPanelNode2D,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Model\Scene2D\StackPanelNode2D.cs,ArrangeOverride,The following switch statement is missing a default case: switch (Orientation)                          {                              case Orientation.Horizontal:                                  totalSize.Left += lastSize;                                  lastSize = c.DesiredSize.X;                                  totalSize.Right = totalSize.Left + lastSize;                                  //totalSize.Bottom = totalSize.Top + Math.Min(finalSize.Height' c.DesiredSize.Y);                                  break;                                case Orientation.Vertical:                                  totalSize.Top += lastSize;                                  lastSize = c.DesiredSize.Y;                                  //totalSize.Right = totalSize.Left + Math.Min(finalSize.Width' c.DesiredSize.X);                                  totalSize.Bottom = totalSize.Top + lastSize;                                  break;                          }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following switch statement is missing a default case: switch ((DXGI.Format) description.Format)                  {                      case Format.B8G8R8A8_UNorm:                          description.Format = Format.R8G8B8A8_UNorm;                          convFlags |= ConversionFlags.Swizzle;                          break;                        case Format.B8G8R8X8_UNorm:                          description.Format = Format.R8G8B8A8_UNorm;                          convFlags |= ConversionFlags.Swizzle | ConversionFlags.NoAlpha;                          break;                        case Format.B8G8R8A8_Typeless:                          description.Format = Format.R8G8B8A8_Typeless;                          convFlags |= ConversionFlags.Swizzle;                          break;                        case Format.B8G8R8A8_UNorm_SRgb:                          description.Format = Format.R8G8B8A8_UNorm_SRgb;                          convFlags |= ConversionFlags.Swizzle;                          break;                        case Format.B8G8R8X8_Typeless:                          description.Format = Format.R8G8B8A8_Typeless;                          convFlags |= ConversionFlags.Swizzle | ConversionFlags.NoAlpha;                          break;                        case Format.B8G8R8X8_UNorm_SRgb:                          description.Format = Format.R8G8B8A8_UNorm_SRgb;                          convFlags |= ConversionFlags.Swizzle | ConversionFlags.NoAlpha;                          break;                  }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following switch statement is missing a default case: switch ((DXGI.Format) description.Format)                  {                      case Format.B5G6R5_UNorm:                      case Format.B5G5R5A1_UNorm:  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:  #endif                          description.Format = Format.R8G8B8A8_UNorm;                          convFlags |= ConversionFlags.Expand;                          if (description.Format == Format.B5G6R5_UNorm)                              convFlags |= ConversionFlags.NoAlpha;                          break;                  }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following switch statement is missing a default case: switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following switch statement is missing a default case: switch (description.Dimension)              {                  case TextureDimension.Texture1D:                      header->Height = description.Height;                      header->Width = header->Depth = 1;                      break;                    case TextureDimension.Texture2D:                  case TextureDimension.TextureCube:                      header->Height = description.Height;                      header->Width = description.Width;                      header->Depth = 1;                        if (description.Dimension == TextureDimension.TextureCube)                      {                          header->SurfaceFlags |= DDS.SurfaceFlags.Cubemap;                          header->CubemapFlags |= DDS.CubemapFlags.AllFaces;                      }                      break;                    case TextureDimension.Texture3D:                        header->Flags |= DDS.HeaderFlags.Volume;                      header->CubemapFlags |= DDS.CubemapFlags.Volume;                      header->Height = description.Height;                      header->Width = description.Width;                      header->Depth = description.Depth;                      break;              }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following switch statement is missing a default case: switch (description.Dimension)                  {                      case TextureDimension.Texture1D:                          ext->ResourceDimension = ResourceDimension.Texture1D;                          break;                      case TextureDimension.Texture2D:                      case TextureDimension.TextureCube:                          ext->ResourceDimension = ResourceDimension.Texture2D;                          break;                      case TextureDimension.Texture3D:                          ext->ResourceDimension = ResourceDimension.Texture3D;                          break;                    }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following switch statement is missing a default case: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following switch statement is missing a default case: switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following switch statement is missing a default case: switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following switch statement is missing a default case: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following switch statement is missing a default case: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following switch statement is missing a default case: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Missing Default,SharpDX.Toolkit.Graphics,DepthStencilBuffer,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,ComputeViewFormat,The following switch statement is missing a default case: switch (format)              {                  case SharpDX.DXGI.Format.D16_UNorm:                  case DXGI.Format.R16_Float:                  case DXGI.Format.R16_Typeless:                      return DepthFormat.Depth16;                    case SharpDX.DXGI.Format.D32_Float:                  case DXGI.Format.R32_Float:                  case DXGI.Format.R32_Typeless:                      return DepthFormat.Depth32;                    case SharpDX.DXGI.Format.D24_UNorm_S8_UInt:                  case SharpDX.DXGI.Format.R24_UNorm_X8_Typeless:                      return DepthFormat.Depth24Stencil8;                    case SharpDX.DXGI.Format.D32_Float_S8X24_UInt:                  case SharpDX.DXGI.Format.R32_Float_X8X24_Typeless:                      return DepthFormat.Depth32Stencil8X24;              }
Missing Default,SharpDX.Toolkit.Graphics,GraphicsResource,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\GraphicsResource.cs,GetCpuAccessFlagsFromUsage,The following switch statement is missing a default case: switch (usage)              {                  case ResourceUsage.Dynamic:                      return CpuAccessFlags.Write;                  case ResourceUsage.Staging:                      return CpuAccessFlags.Read | CpuAccessFlags.Write;              }
Missing Default,SharpDX.Toolkit.Graphics,Image,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The following switch statement is missing a default case: switch (description.Dimension)              {                  case TextureDimension.Texture1D:                      if (description.Width <= 0 || description.Height != 1 || description.Depth != 1 || description.ArraySize == 0)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 1D");                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' 1' description.MipLevels);                      break;                    case TextureDimension.Texture2D:                  case TextureDimension.TextureCube:                      if (description.Width <= 0 || description.Height <= 0 || description.Depth != 1 || description.ArraySize == 0)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 2D");                        if (description.Dimension == TextureDimension.TextureCube)                      {                          if ((description.ArraySize % 6) != 0)                              throw new InvalidOperationException("TextureCube must have an arraysize = 6");                      }                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.MipLevels);                      break;                    case TextureDimension.Texture3D:                      if (description.Width <= 0 || description.Height <= 0 || description.Depth <= 0 || description.ArraySize != 1)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 3D");                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.Depth' description.MipLevels);                      break;              }
Missing Default,SharpDX.Toolkit.Graphics,Texture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,New,The following switch statement is missing a default case: switch (description.Dimension)                  {                      case TextureDimension.Texture1D:                          return RenderTarget1D.New(graphicsDevice' description);                      case TextureDimension.Texture2D:                          return RenderTarget2D.New(graphicsDevice' description);                      case TextureDimension.Texture3D:                          return RenderTarget3D.New(graphicsDevice' description);                      case TextureDimension.TextureCube:                          return RenderTargetCube.New(graphicsDevice' description);                  }
Missing Default,SharpDX.Toolkit.Graphics,Texture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,New,The following switch statement is missing a default case: switch (description.Dimension)                  {                      case TextureDimension.Texture1D:                          return Texture1D.New(graphicsDevice' description);                      case TextureDimension.Texture2D:                          return Texture2D.New(graphicsDevice' description);                      case TextureDimension.Texture3D:                          return Texture3D.New(graphicsDevice' description);                      case TextureDimension.TextureCube:                          return TextureCube.New(graphicsDevice' description);                  }
Missing Default,SharpDX.Toolkit.Graphics,Texture,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,Load,The following switch statement is missing a default case: switch (image.Description.Dimension)                  {                      case TextureDimension.Texture1D:                          return Texture1D.New(device' image' flags' usage);                      case TextureDimension.Texture2D:                          return Texture2D.New(device' image' flags' usage);                      case TextureDimension.Texture3D:                          return Texture3D.New(device' image' flags' usage);                      case TextureDimension.TextureCube:                          return TextureCube.New(device' image' flags' usage);                  }
Missing Default,SharpDX.Toolkit.Graphics,WICHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,ToWIC,The following switch statement is missing a default case: switch (format)              {                  case SharpDX.DXGI.Format.R8G8B8A8_UNorm_SRgb:                      guid = SharpDX.WIC.PixelFormat.Format32bppRGBA;                      return true;                    case SharpDX.DXGI.Format.D32_Float:                      guid = SharpDX.WIC.PixelFormat.Format32bppGrayFloat;                      return true;                    case SharpDX.DXGI.Format.D16_UNorm:                      guid = SharpDX.WIC.PixelFormat.Format16bppGray;                      return true;                    case SharpDX.DXGI.Format.B8G8R8A8_UNorm_SRgb:                      guid = SharpDX.WIC.PixelFormat.Format32bppBGRA;                      return true;                    case SharpDX.DXGI.Format.B8G8R8X8_UNorm_SRgb:                      guid = SharpDX.WIC.PixelFormat.Format32bppBGR;                      return true;              }
Missing Default,SharpDX.Toolkit.Graphics,WICHelper,D:\research\architectureSmells\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,DetermineFormat,The following switch statement is missing a default case: switch (format)              {                  case DXGI.Format.B8G8R8A8_UNorm: // BGRA                  case DXGI.Format.B8G8R8X8_UNorm: // BGRX                      if ((flags & WICFlags.ForceRgb) != 0)                      {                          format = DXGI.Format.R8G8B8A8_UNorm;                          pixelFormatOut = WIC.PixelFormat.Format32bppRGBA;                      }                      break;                    case DXGI.Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & WICFlags.NoX2Bias) != 0)                      {                          format = DXGI.Format.R10G10B10A2_UNorm;                          pixelFormatOut = WIC.PixelFormat.Format32bppRGBA1010102;                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                  case DXGI.Format.B5G6R5_UNorm:                      if ((flags & WICFlags.No16Bpp) != 0)                      {                          format = DXGI.Format.R8G8B8A8_UNorm;                          pixelFormatOut = WIC.PixelFormat.Format32bppRGBA;                      }                      break;                    case DXGI.Format.R1_UNorm:                      if ((flags & WICFlags.FlagsAllowMono) == 0)                      {                          // By default we want to promote a black & white to greyscale since R1 is not a generally supported D3D format                          format = DXGI.Format.R8_UNorm;                          pixelFormatOut = WIC.PixelFormat.Format8bppGray;                      }                      break;              }
