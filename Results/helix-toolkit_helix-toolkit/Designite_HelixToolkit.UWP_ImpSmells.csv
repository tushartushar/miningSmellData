Implementation smell,Namespace,Class,File,Method,Description
Long Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The method has 110 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The method has 202 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 109 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The method has 108 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The method has 131 lines of code.
Long Method,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,The method has 125 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The method has 157 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The method has 211 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The method has 163 lines of code.
Long Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The method has 206 lines of code.
Complex Method,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddLoftedGeometry,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,Cyclomatic complexity of the method is 9
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangles,Cyclomatic complexity of the method is 13
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,Cyclomatic complexity of the method is 14
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,Cyclomatic complexity of the method is 15
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Append,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Simplify,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,Cyclomatic complexity of the method is 11
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,Cyclomatic complexity of the method is 13
Complex Method,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,Cyclomatic complexity of the method is 21
Complex Method,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,Cyclomatic complexity of the method is 26
Complex Method,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,Cyclomatic complexity of the method is 10
Complex Method,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,Cyclomatic complexity of the method is 8
Complex Method,HelixToolkit.Wpf.SharpDX,BoundingBoxExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BoundingBoxExtensions.cs,Transform,Cyclomatic complexity of the method is 10
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,GetDXGIFormat,Cyclomatic complexity of the method is 8
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,Cyclomatic complexity of the method is 16
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,Cyclomatic complexity of the method is 15
Complex Method,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,Cyclomatic complexity of the method is 12
Complex Method,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,CalculateImageArray,Cyclomatic complexity of the method is 8
Complex Method,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,OnPropertyChanged,Cyclomatic complexity of the method is 12
Complex Method,HelixToolkit.Wpf.SharpDX.Utilities,TokenizerHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TokenizerHelper.cs,NextToken,Cyclomatic complexity of the method is 9
Long Parameter List,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,InsideTriangle,The method has 8 parameters. Parameters: Ax' Ay' Bx' By' Cx' Cy' Px' Py
Long Parameter List,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Snip,The method has 6 parameters. Parameters: contour' u' v' w' n' V
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The method has 6 parameters. Parameters: positions' normals' textureCoordinates' triangleIndices' tangents' bitangents
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The method has 6 parameters. Parameters: positions' normals' textureCoordinates' indices' tangents' bitangents
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddArrow,The method has 5 parameters. Parameters: point1' point2' diameter' headLength' thetaDiv
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBox,The method has 5 parameters. Parameters: center' xlength' ylength' zlength' faces
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddBox,The method has 7 parameters. Parameters: center' x' y' xlength' ylength' zlength' faces
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCone,The method has 8 parameters. Parameters: origin' direction' baseRadius' topRadius' height' baseCap' topCap' thetaDiv
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCone,The method has 5 parameters. Parameters: origin' apex' baseRadius' baseCap' thetaDiv
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The method has 6 parameters. Parameters: center' normal' up' dist' width' height
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The method has 6 parameters. Parameters: p1' p2' radius' thetaDiv' cap1' cap2
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The method has 6 parameters. Parameters: center' radiusx' radiusy' radiusz' thetaDiv' phiDiv
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The method has 5 parameters. Parameters: center' forward' up' sideLength' height
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The method has 5 parameters. Parameters: point1' point2' innerDiameter' diameter' thetaDiv
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The method has 6 parameters. Parameters: center' forward' up' sideLength' height' closeBase
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The method has 8 parameters. Parameters: p0' p1' p2' p3' uv0' uv1' uv2' uv3
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The method has 8 parameters. Parameters: plane' columns' rows' width' height' flipTriangles' flipTexCoordsUAxis' flipTexCoordsVAxis
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndices,The method has 5 parameters. Parameters: index0' rows' columns' rowsClosed' columnsClosed
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The method has 5 parameters. Parameters: points' textureValues' origin' direction' thetaDiv
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The method has 6 parameters. Parameters: origin' axis' section' sectionIndices' thetaDiv' textureValues
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The method has 6 parameters. Parameters: p0' p1' p2' uv0' uv1' uv2
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 7 parameters. Parameters: path' values' diameters' thetaDiv' isTubeClosed' frontCap' backCap
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 6 parameters. Parameters: path' diameter' thetaDiv' isTubeClosed' frontCap' backCap
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 8 parameters. Parameters: path' values' diameters' section' isTubeClosed' isSectionClosed' frontCap' backCap
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The method has 10 parameters. Parameters: path' angles' values' diameters' section' sectionXAxis' isTubeClosed' isSectionClosed' frontCap' backCap
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,The method has 8 parameters. Parameters: vertices' triangles' texture' normals' verticesOut' trianglesOut' textureOut' normalOut
Long Parameter List,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The method has 6 parameters. Parameters: p' i0' i1' v0' v1' deleted
Long Parameter List,HelixToolkit.Wpf.SharpDX,SymmetricMatrix,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,SymmetricMatrix,The method has 10 parameters. Parameters: m11' m12' m13' m14' m22' m23' m24' m33' m34' m44
Long Parameter List,HelixToolkit.Wpf.SharpDX,SymmetricMatrix,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,det,The method has 9 parameters. Parameters: a11' a12' a13' a21' a22' a23' a31' a32' a33
Long Parameter List,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourFacet,The method has 7 parameters. Parameters: index0' index1' index2' newPositions' newNormals' newTextureCoordinates' triangleIndices
Long Parameter List,SharpDX.Toolkit.Graphics,PixelFormat,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDS.cs,PixelFormat,The method has 7 parameters. Parameters: flags' fourCC' rgbBitCount' rBitMask' gBitMask' bBitMask' aBitMask
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The method has 5 parameters. Parameters: headerPtr' size' flags' description' convFlags
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The method has 5 parameters. Parameters: description' flags' pDestination' maxsize' required
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The method has 8 parameters. Parameters: pDestination' outSize' outFormat' pSource' inSize' inFormat' pal8' flags
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The method has 8 parameters. Parameters: pDDS' offset' size' metadata' cpFlags' convFlags' pal8' handle
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SaveToDDSStream,The method has 5 parameters. Parameters: pixelBuffers' count' metadata' flags' stream
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The method has 6 parameters. Parameters: pDestination' outSize' pSource' inSize' inFormat' flags
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The method has 6 parameters. Parameters: pDestination' outSize' pSource' inSize' format' flags
Long Parameter List,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The method has 6 parameters. Parameters: pDestination' outSize' pSource' inSize' format' flags
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Image,The method has 6 parameters. Parameters: description' dataPointer' offset' handle' bufferIsDisposable' pitchFlags
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New2D,The method has 5 parameters. Parameters: width' height' mipMapCount' format' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New3D,The method has 5 parameters. Parameters: width' height' depth' mipMapCount' format
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New1D,The method has 5 parameters. Parameters: width' mipMapCount' format' arraySize' dataPointer
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New2D,The method has 6 parameters. Parameters: width' height' mipMapCount' format' arraySize' dataPointer
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New3D,The method has 6 parameters. Parameters: width' height' depth' mipMapCount' format' dataPointer
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The method has 6 parameters. Parameters: description' dataPointer' offset' handle' bufferIsDisposable' pitchFlags
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,CreateDescription,The method has 7 parameters. Parameters: dimension' width' height' depth' mipMapCount' format' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The method has 8 parameters. Parameters: fmt' width' height' rowPitch' slicePitch' widthCount' heightCount' flags
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,SetupImageArray,The method has 5 parameters. Parameters: buffer' pixelSize' imageDesc' pitchFlags' output
Long Parameter List,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Save,The method has 5 parameters. Parameters: pixelBuffers' count' description' imageStream' fileType
Long Parameter List,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,MipMapDescription,The method has 7 parameters. Parameters: width' height' depth' rowStride' depthStride' widthPacked' heightPacked
Long Parameter List,SharpDX.Toolkit.Graphics,PixelBuffer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs,PixelBuffer,The method has 6 parameters. Parameters: width' height' format' rowStride' bufferStride' dataPointer
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,New,The method has 5 parameters. Parameters: device' width' format' flags' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,New,The method has 6 parameters. Parameters: device' width' mipCount' format' flags' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,NewRenderTargetDescription,The method has 5 parameters. Parameters: width' format' textureFlags' mipCount' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,New,The method has 7 parameters. Parameters: device' width' height' depth' format' flags' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,New,The method has 8 parameters. Parameters: device' width' height' depth' mipCount' format' flags' arraySize
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTarget3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,NewRenderTargetDescription,The method has 6 parameters. Parameters: width' height' depth' format' textureFlags' mipCount
Long Parameter List,SharpDX.Toolkit.Graphics,RenderTargetCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTargetCube.cs,New,The method has 5 parameters. Parameters: device' size' mipCount' format' flags
Long Parameter List,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetDataBox,The method has 6 parameters. Parameters: format' width' height' depth' textureData' fixedPointer
Long Parameter List,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetViewSliceBounds,The method has 5 parameters. Parameters: viewType' arrayOrDepthIndex' mipIndex' arrayOrDepthCount' mipCount
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The method has 6 parameters. Parameters: device' width' format' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The method has 7 parameters. Parameters: device' width' mipCount' format' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The method has 6 parameters. Parameters: device' width' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture1DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1DBase.cs,NewDescription,The method has 6 parameters. Parameters: width' format' textureFlags' mipCount' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 7 parameters. Parameters: device' width' height' format' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 8 parameters. Parameters: device' width' height' mipCount' format' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 7 parameters. Parameters: device' width' height' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The method has 9 parameters. Parameters: device' width' height' mipCount' format' textureData' flags' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture2DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,NewDescription,The method has 7 parameters. Parameters: width' height' format' textureFlags' mipCount' arraySize' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 7 parameters. Parameters: device' width' height' depth' format' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 8 parameters. Parameters: device' width' height' depth' mipCount' format' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 8 parameters. Parameters: device' width' height' depth' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The method has 9 parameters. Parameters: device' width' height' depth' mipCount' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,Texture3DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3DBase.cs,NewDescription,The method has 7 parameters. Parameters: width' height' depth' format' textureFlags' mipCount' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 5 parameters. Parameters: device' size' format' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 6 parameters. Parameters: device' size' mipCount' format' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 6 parameters. Parameters: device' size' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The method has 6 parameters. Parameters: device' size' format' textureData' flags' usage
Long Parameter List,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,NewTextureCubeDescription,The method has 5 parameters. Parameters: size' format' flags' mipCount' usage
Long Parameter List,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeMultiframe,The method has 5 parameters. Parameters: images' count' flags' guidContainerFormat' stream
Long Parameter List,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,SaveToWICMemory,The method has 5 parameters. Parameters: pixelBuffer' count' flags' fileType' stream
Long Identifier,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,,The length of the parameter AllCurvesShouldHaveTheSameNumberOfPoints is 40.
Long Identifier,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,,The length of the parameter SourceMeshNormalsShouldNotBeNull is 32.
Long Identifier,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,,The length of the parameter SourceMeshTextureCoordinatesShouldNotBeNull is 43.
Long Identifier,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,,The length of the parameter WrongNumberOfTextureCoordinates is 31.
Long Statement,HelixToolkit.UWP.CommonDX,DeviceManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\DeviceManager.cs,CreateDeviceIndependentResources,The length of the statement  "            d2dFactory = Collect(new global::SharpDX.Direct2D1.Factory1(global::SharpDX.Direct2D1.FactoryType.SingleThreaded' debugLevel)); " is 127.
Long Statement,HelixToolkit.UWP.CommonDX,DeviceManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\DeviceManager.cs,CreateDeviceResources,The length of the statement  "            var creationFlags = global::SharpDX.Direct3D11.DeviceCreationFlags.VideoSupport | global::SharpDX.Direct3D11.DeviceCreationFlags.BgraSupport; " is 141.
Long Statement,HelixToolkit.UWP.CommonDX,DeviceManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\DeviceManager.cs,CreateDeviceResources,The length of the statement  "            // Decomment this line to have Debug. Unfortunately' debug is sometimes crashing applications' so it is disable by default " is 122.
Long Statement,HelixToolkit.UWP.CommonDX,DeviceManager,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\DeviceManager.cs,CreateDeviceResources,The length of the statement  "            d2dContext = Collect(new global::SharpDX.Direct2D1.DeviceContext(d2dDevice' global::SharpDX.Direct2D1.DeviceContextOptions.None)); " is 130.
Long Statement,HelixToolkit.UWP.CommonDX,SurfaceImageSourceTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SurfaceImageSourceTarget.cs,RenderAll,The length of the statement  "                        viewData.RenderTargetView = Collect(new global::SharpDX.Direct3D11.RenderTargetView(DeviceManager.DeviceDirect3D' viewData.BackBuffer)); " is 136.
Long Statement,HelixToolkit.UWP.CommonDX,SurfaceImageSourceTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SurfaceImageSourceTarget.cs,RenderAll,The length of the statement  "                    using (var depthBuffer = new global::SharpDX.Direct3D11.Texture2D(DeviceManager.DeviceDirect3D' new global::SharpDX.Direct3D11.Texture2DDescription() " is 149.
Long Statement,HelixToolkit.UWP.CommonDX,SurfaceImageSourceTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SurfaceImageSourceTarget.cs,RenderAll,The length of the statement  "                        viewData.DepthStencilView = Collect(new global::SharpDX.Direct3D11.DepthStencilView(DeviceManager.DeviceDirect3D' depthBuffer' new global::SharpDX.Direct3D11.DepthStencilViewDescription() { Dimension = global::SharpDX.Direct3D11.DepthStencilViewDimension.Texture2D })); " is 269.
Long Statement,HelixToolkit.UWP.CommonDX,SurfaceImageSourceTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SurfaceImageSourceTarget.cs,RenderAll,The length of the statement  "                    viewData.BitmapTarget = Collect(new global::SharpDX.Direct2D1.Bitmap1(DeviceManager.ContextDirect2D' surface' bitmapProperties)); " is 129.
Long Statement,HelixToolkit.UWP.CommonDX,SurfaceImageSourceTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SurfaceImageSourceTarget.cs,RenderAll,The length of the statement  "                    viewData.Viewport = new global::SharpDX.ViewportF(position.X' position.Y' (float)viewData.RenderTargetSize.Width - position.X' (float)viewData.RenderTargetSize.Height - position.Y' 0.0f' 1.0f); " is 193.
Long Statement,HelixToolkit.UWP.CommonDX,SurfaceImageSourceTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SurfaceImageSourceTarget.cs,RenderAll,The length of the statement  "                RenderTargetBounds = new Rect(viewData.Viewport.X' viewData.Viewport.Y' viewData.Viewport.Width' viewData.Viewport.Height); " is 123.
Long Statement,HelixToolkit.UWP.CommonDX,SwapChainTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SwapChainTarget.cs,Initialize,The length of the statement  "            // We have to take into account pixel scaling; Windows Phone 8.1 uses virtual resolutions smaller than the physical screen size. " is 128.
Long Statement,HelixToolkit.UWP.CommonDX,SwapChainTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SwapChainTarget.cs,Initialize,The length of the statement  "            using (global::SharpDX.DXGI.Device3 dxgiDevice3 = deviceManager.DeviceDirect3D.QueryInterface<global::SharpDX.DXGI.Device3>()) " is 126.
Long Statement,HelixToolkit.UWP.CommonDX,SwapChainTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SwapChainTarget.cs,Initialize,The length of the statement  "                    using (global::SharpDX.DXGI.SwapChain1 swapChain1 = new global::SharpDX.DXGI.SwapChain1(dxgiFactory3' deviceManager.DeviceDirect3D' ref swapChainDescription)) " is 158.
Long Statement,HelixToolkit.UWP.CommonDX,SwapChainTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SwapChainTarget.cs,Initialize,The length of the statement  "            using (global::SharpDX.DXGI.ISwapChainPanelNative nativeObject = global::SharpDX.ComObject.As<global::SharpDX.DXGI.ISwapChainPanelNative>(this.swapChainPanel)) " is 159.
Long Statement,HelixToolkit.UWP.CommonDX,SwapChainTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SwapChainTarget.cs,Initialize,The length of the statement  "            using (var depthBuffer = new global::SharpDX.Direct3D11.Texture2D(DeviceManager.DeviceDirect3D' new global::SharpDX.Direct3D11.Texture2DDescription() " is 149.
Long Statement,HelixToolkit.UWP.CommonDX,SwapChainTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SwapChainTarget.cs,Initialize,The length of the statement  "            this.depthStencilView = Collect(new global::SharpDX.Direct3D11.DepthStencilView(DeviceManager.DeviceDirect3D' depthBuffer' new global::SharpDX.Direct3D11.DepthStencilViewDescription() { Dimension = global::SharpDX.Direct3D11.DepthStencilViewDimension.Texture2D })); " is 265.
Long Statement,HelixToolkit.UWP.CommonDX,SwapChainTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SwapChainTarget.cs,Initialize,The length of the statement  "            this.backBuffer = global::SharpDX.Direct3D11.Texture2D.FromSwapChain<global::SharpDX.Direct3D11.Texture2D>(this.swapChain' 0); " is 126.
Long Statement,HelixToolkit.UWP.CommonDX,SwapChainTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SwapChainTarget.cs,Initialize,The length of the statement  "            var viewport = new global::SharpDX.ViewportF(0' 0' (float)swapChainDescription.Width' (float)swapChainDescription.Height' 0.0f' 1.0f); " is 134.
Long Statement,HelixToolkit.UWP,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\Controls\Viewport3DX.cs,Viewport3DXLoaded,The length of the statement  "            // Use CoreWindowTarget as the rendering target (Initialize SwapChain' RenderTargetView' DepthStencilView' BitmapTarget) " is 120.
Long Statement,HelixToolkit.UWP,ExampleCube3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\Model\ExampleCube3D.cs,Render,The length of the statement  "            var view = global::SharpDX.Matrix.LookAtLH(new global::SharpDX.Vector3(0' 0' -5)' new global::SharpDX.Vector3(0' 0' 0)' global::SharpDX.Vector3.UnitY); " is 151.
Long Statement,HelixToolkit.UWP,ExampleCube3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\Model\ExampleCube3D.cs,Render,The length of the statement  "            context.ClearDepthStencilView(render.DepthStencilView' global::SharpDX.Direct3D11.DepthStencilClearFlags.Depth' 1.0f' 0); " is 121.
Long Statement,HelixToolkit.UWP,ExampleCube3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\Model\ExampleCube3D.cs,Render,The length of the statement  "                var worldViewProj = global::SharpDX.Matrix.Scaling((float)this.Scale) * global::SharpDX.Matrix.RotationX((float)this.RotationSpeed * time) " is 138.
Long Statement,HelixToolkit.UWP,ExampleCube3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\Model\ExampleCube3D.cs,Render,The length of the statement  "                                    * global::SharpDX.Matrix.RotationY((float)this.RotationSpeed * time * 2.0f) * global::SharpDX.Matrix.RotationZ((float)this.RotationSpeed * time * .7f) " is 150.
Long Statement,HelixToolkit.UWP,ExampleCube3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\Model\ExampleCube3D.cs,Initialize,The length of the statement  "            this.pixelShader = new global::SharpDX.Direct3D11.PixelShader(d3dDevice' global::SharpDX.IO.NativeFile.ReadAllBytes(path + "\\MiniCube_PS.fxo")); " is 145.
Long Statement,HelixToolkit.UWP,ExampleCube3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\Model\ExampleCube3D.cs,Initialize,The length of the statement  "            this.vertexBufferBinding = new global::SharpDX.Direct3D11.VertexBufferBinding(vertices' global::SharpDX.Utilities.SizeOf<global::SharpDX.Vector4>() * 2' 0); " is 156.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormals,The length of the statement  "            //Cannot use normals[i].normalize() if using Media3D.Vector3DCollection. Does not change the internal value in Vector3DCollection. " is 130.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "            var radiusSphere = 0.25f * (DoubleOrSingle)Math.Sqrt(3) * (1 + (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength; " is 122.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "                var newPoint = new Point3D(radiusSphere * (DoubleOrSingle)Math.Cos(gamma)' 0' radiusSphere * (DoubleOrSingle)Math.Sin(gamma)); " is 126.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "                var newPoint = new Point3D(radiusSphere * (DoubleOrSingle)Math.Cos(gamma)' 0' radiusSphere * (DoubleOrSingle)Math.Sin(gamma)); " is 126.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The length of the statement  "                    var u = (DoubleOrSingle)Math.Atan2(SharedFunctions.DotProduct(ref planeCTP' ref forward)' SharedFunctions.DotProduct(ref planeCTP' ref right)); " is 143.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The length of the statement  "                    var p = new Point3D(center.X + (DoubleOrSingle)(radiusx * x)' center.Y + (DoubleOrSingle)(radiusy * y)' center.Z + (DoubleOrSingle)(radiusz * z)); " is 146.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The length of the statement  "                        this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues[j])); " is 163.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The length of the statement  "                        this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues[j + 1])); " is 173.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The length of the statement  "                        this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues[j])); " is 163.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                    var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25)))); " is 132.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList(); " is 188.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                    var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList(); " is 246.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                        var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList(); " is 246.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The length of the statement  "                        var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0); " is 177.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Scale,The length of the statement  "                    this.Positions[i].X * (DoubleOrSingle)scaleX' this.Positions[i].Y * (DoubleOrSingle)scaleY' this.Positions[i].Z * (DoubleOrSingle)scaleZ); " is 138.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Scale,The length of the statement  "                        this.Normals[i].X * (DoubleOrSingle)scaleX' this.Normals[i].Y * (DoubleOrSingle)scaleY' this.Normals[i].Z * (DoubleOrSingle)scaleZ); " is 132.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The length of the statement  "            return new MeshGeometry3D { Positions = p' TriangleIndices = new SharpDX.Core.IntCollection(ti)' Normals = n' TextureCoordinates = tc }; " is 136.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The length of the statement  "                contourHelper.ContourFacet(index0' index1' index2' out positions' out normals' out textureCoordinates' out triangleIndices); " is 124.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,The length of the statement  "            RemoveIsolatedVertices(mesh.Positions' mesh.TriangleIndices' mesh.TextureCoordinates' mesh.Normals' out vertNew' out triNew' out textureNew' out normalNew); " is 156.
Long Statement,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,RemoveIsolatedVertices,The length of the statement  "            var newMesh = new MeshGeometry3D() { Positions = vertNew' TriangleIndices = triNew' TextureCoordinates = textureNew' Normals = normalNew }; " is 139.
Long Statement,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,Flatten,The length of the statement  "            var m = new Matrix3D(backward.X' right.X' up.X' 0' backward.Y' right.Y' up.Y' 0' backward.Z' right.Z' up.Z' 0' 0' 0' 0' 1); " is 123.
Long Statement,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,The length of the statement  "                //if (!(leftChain.Contains(top) && leftChain.Contains(newPoint) || rightChain.Contains(top) && rightChain.Contains(newPoint))) " is 126.
Long Statement,HelixToolkit.Wpf.SharpDX,BoundingSphereExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\BoundingSphereExtensions.cs,FromPoints,The length of the statement  "                throw new ArgumentOutOfRangeException("start"' start' string.Format("Must be in the range [0' {0}]"' points.Count - 1)); " is 120.
Long Statement,HelixToolkit.Wpf.SharpDX,TextureLoader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TextureLoader.cs,FromFileAsShaderResourceView,The length of the statement  "                if (!disableAutoGenMipMap && texture.Description.MipLevels == 1)// Check if it already has mipmaps or not' if loaded DDS file' it may already has precompiled mipmaps' don't need to generate again " is 195.
Long Statement,HelixToolkit.Wpf.SharpDX,TextureLoader,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Utilities\TextureLoader.cs,FromMemoryAsShaderResourceView,The length of the statement  "                if (!disableAutoGenMipMap && texture.Description.MipLevels == 1)// Check if it already has mipmaps or not' if loaded DDS file' it may already has precompiled mipmaps' don't need to generate again " is 195.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The length of the statement  "            if ((header.PixelFormat.Flags & DDS.PixelFormatFlags.FourCC) != 0 && (new FourCC('D'' 'X'' '1'' '0') == header.PixelFormat.FourCC)) " is 131.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The length of the statement  "                        throw new InvalidOperationException(string.Format("Unexpected dimension [{0}] from DDS HeaderDX10"' headerDX10.ResourceDimension)); " is 131.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The length of the statement  "                if ((description.ArraySize != 6) || (description.Dimension != TextureDimension.Texture2D) || (description.Dimension != TextureDimension.TextureCube)) " is 149.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The length of the statement  "            Image.ComputePitch(description.Format' description.Width' description.Height' out rowPitch' out slicePitch' out newWidth' out newHeight); " is 137.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LoadFromDDSMemory,The length of the statement  "            var image = CreateImageFromDDS(pSource' offset' size - offset' mdata' (flags & DDSFlags.LegacyDword) != 0 ? Image.PitchFlags.LegacyDword : Image.PitchFlags.None' convFlags' pal8' handle); " is 187.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The length of the statement  "                else if ((convFlags & (ConversionFlags.Format565 | ConversionFlags.Format5551 | ConversionFlags.Format4444 | ConversionFlags.Format8332 | ConversionFlags.FormatA8P8)) != 0) " is 172.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The length of the statement  "            var isCopyNeeded = (convFlags & (ConversionFlags.Expand | ConversionFlags.CopyMemory)) != 0 || ((cpFlags & Image.PitchFlags.LegacyDword) != 0); " is 143.
Long Statement,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CreateImageFromDDS,The length of the statement  "                                        ExpandScanline(pDest' dpitch' pSrc' spitch' (convFlags & ConversionFlags.Format565) != 0 ? DXGI.Format.B5G6R5_UNorm : DXGI.Format.B5G5R5A1_UNorm' tflags); " is 154.
Long Statement,SharpDX.Toolkit.Graphics,DepthStencilBuffer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,GetDepthStencilView,The length of the statement  "                        dsvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? DepthStencilViewDimension.Texture2DMultisampledArray : DepthStencilViewDimension.Texture2DArray; " is 170.
Long Statement,SharpDX.Toolkit.Graphics,DepthStencilBuffer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,GetDepthStencilView,The length of the statement  "                        dsvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? DepthStencilViewDimension.Texture2DMultisampled : DepthStencilViewDimension.Texture2D; " is 160.
Long Statement,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New1D,The length of the statement  "            return new Image(CreateDescription(TextureDimension.Texture1D' width' 1' 1' mipMapCount' format' arraySize)' dataPointer' 0' null' false); " is 138.
Long Statement,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New2D,The length of the statement  "            return new Image(CreateDescription(TextureDimension.Texture2D' width' height' 1' mipMapCount' format' arraySize)' dataPointer' 0' null' false); " is 143.
Long Statement,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,NewCube,The length of the statement  "            return new Image(CreateDescription(TextureDimension.TextureCube' width' width' 1' mipMapCount' format' 6)' dataPointer' 0' null' false); " is 136.
Long Statement,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,New3D,The length of the statement  "            return new Image(CreateDescription(TextureDimension.Texture3D' width' width' depth' mipMapCount' format' 1)' dataPointer' 0' null' false); " is 138.
Long Statement,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The length of the statement  "                    description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.Depth' description.MipLevels); " is 132.
Long Statement,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,Equals,The length of the statement  "            return Dimension.Equals(other.Dimension) && Width == other.Width && Height == other.Height && Depth == other.Depth && ArraySize == other.ArraySize && MipLevels == other.MipLevels && Format.Equals(other.Format); " is 210.
Long Statement,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,ToString,The length of the statement  "            return string.Format("Dimension: {0}' Width: {1}' Height: {2}' Depth: {3}' Format: {4}' ArraySize: {5}' MipLevels: {6}"' Dimension' Width' Height' Depth' Format' ArraySize' MipLevels); " is 184.
Long Statement,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,Equals,The length of the statement  "            return this.Width == other.Width && this.Height == other.Height && this.WidthPacked == other.WidthPacked && this.HeightPacked == other.HeightPacked && this.Depth == other.Depth && this.RowStride == other.RowStride && this.MipmapSize == other.MipmapSize && this.DepthStride == other.DepthStride; " is 294.
Long Statement,SharpDX.Toolkit.Graphics,PixelBuffer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs,CopyTo,The length of the statement  "                throw new ArgumentException("Invalid destination pixelBufferArray. Mush have same Width' Height and Format"' "pixelBuffer"); " is 124.
Long Statement,SharpDX.Toolkit.Graphics,PixelBuffer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs,GetPixels,The length of the statement  "                throw new ArgumentException(string.Format("Invalid sizeof(T)' not a multiple of current size [{0}]in bytes "' totalSize)); " is 122.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget1D.cs,New,The length of the statement  "            return new RenderTarget1D(device' NewRenderTargetDescription(width' format' flags | TextureFlags.RenderTarget' mipCount' arraySize)); " is 133.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget2D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget2D.cs,GetRenderTargetView,The length of the statement  "                        rtvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? RenderTargetViewDimension.Texture2DMultisampledArray : RenderTargetViewDimension.Texture2DArray; " is 170.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget2D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget2D.cs,GetRenderTargetView,The length of the statement  "                        rtvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? RenderTargetViewDimension.Texture2DMultisampled : RenderTargetViewDimension.Texture2D; " is 160.
Long Statement,SharpDX.Toolkit.Graphics,RenderTarget3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTarget3D.cs,New,The length of the statement  "            return new RenderTarget3D(device' NewRenderTargetDescription(width' height' depth' format' flags | TextureFlags.RenderTarget' mipCount)); " is 137.
Long Statement,SharpDX.Toolkit.Graphics,RenderTargetCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTargetCube.cs,New,The length of the statement  "            return new RenderTargetCube(device' NewRenderTargetDescription(size' format' flags | TextureFlags.RenderTarget' mipCount)); " is 123.
Long Statement,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,CalculatePixelDataCount,The length of the statement  "            return CalculateWidth<TData>(mipLevel) * CalculateMipSize(Description.Height' mipLevel) * CalculateMipSize(Description.Depth' mipLevel); " is 136.
Long Statement,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,OnPropertyChanged,The length of the statement  "                            if (shaderResourceView != null) shaderResourceView.View.DebugName = Name == null ? null : String.Format("{0} SRV[{1}]"' i' Name); " is 129.
Long Statement,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,OnPropertyChanged,The length of the statement  "                            if (renderTargetView != null) renderTargetView.View.DebugName = Name == null ? null : String.Format("{0} RTV[{1}]"' i' Name); " is 125.
Long Statement,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,OnPropertyChanged,The length of the statement  "                            if (unorderedAccessView != null) unorderedAccessView.DebugName = Name == null ? null : String.Format("{0} UAV[{1}]"' i' Name); " is 126.
Long Statement,SharpDX.Toolkit.Graphics,TextureViewKey,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,Equals,The length of the statement  "                return ViewFormat == other.ViewFormat && ViewType == other.ViewType && ArrayOrDepthSlice == other.ArrayOrDepthSlice && MipIndex == other.MipIndex; " is 146.
Long Statement,SharpDX.Toolkit.Graphics,Texture1D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs,New,The length of the statement  "                texture = new Texture1D(device' NewDescription(width' format' flags' 1' 1' usage)' GetDataBox(format' width' 1' 1' textureData' ptr)); " is 134.
Long Statement,SharpDX.Toolkit.Graphics,Texture1DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1DBase.cs,GetUnorderedAccessView,The length of the statement  "                        Dimension = this.Description.ArraySize > 1 ? UnorderedAccessViewDimension.Texture1DArray : UnorderedAccessViewDimension.Texture1D " is 129.
Long Statement,SharpDX.Toolkit.Graphics,Texture1DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1DBase.cs,NewDescription,The length of the statement  "            if ((desc.BindFlags & BindFlags.RenderTarget) != 0 && (desc.BindFlags & BindFlags.ShaderResource) != 0 && desc.MipLevels > 1) " is 125.
Long Statement,SharpDX.Toolkit.Graphics,Texture2D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs,New,The length of the statement  "                texture = New(device' width' height' 1' format' new[] { GetDataBox(format' width' height' 1' textureData' ptr) }' flags' 1' usage); " is 131.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,GetShaderResourceView,The length of the statement  "                            srvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? ShaderResourceViewDimension.Texture2DMultisampledArray : ShaderResourceViewDimension.Texture2DArray; " is 174.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,GetShaderResourceView,The length of the statement  "                        srvDescription.Dimension = this.Description.SampleDescription.Count > 1 ? ShaderResourceViewDimension.Texture2DMultisampled : ShaderResourceViewDimension.Texture2D; " is 164.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,GetUnorderedAccessView,The length of the statement  "                        Dimension = this.Description.ArraySize > 1 ? UnorderedAccessViewDimension.Texture2DArray : UnorderedAccessViewDimension.Texture2D " is 129.
Long Statement,SharpDX.Toolkit.Graphics,Texture2DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2DBase.cs,NewDescription,The length of the statement  "            if ((desc.BindFlags & BindFlags.RenderTarget) != 0 && (desc.BindFlags & BindFlags.ShaderResource) != 0 && desc.MipLevels > 1) " is 125.
Long Statement,SharpDX.Toolkit.Graphics,Texture3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs,New,The length of the statement  "                texture = New(device' width' height' depth' 1' format' new[] { GetDataBox(format' width' height' depth' textureData' ptr) }' flags' usage); " is 139.
Long Statement,SharpDX.Toolkit.Graphics,Texture3DBase,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3DBase.cs,NewDescription,The length of the statement  "            if ((desc.BindFlags & BindFlags.RenderTarget) != 0 && (desc.BindFlags & BindFlags.ShaderResource) != 0 && desc.MipLevels > 1) " is 125.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "            return new TextureCube(device' NewTextureCubeDescription(size' format' flags | TextureFlags.ShaderResource' mipCount' usage)); " is 126.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "            return new TextureCube(device' NewTextureCubeDescription(size' format' flags | TextureFlags.ShaderResource' 1' usage)' dataBox1' dataBox2' dataBox3' dataBox4' dataBox5' dataBox6); " is 179.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "            return new TextureCube(device' NewTextureCubeDescription(size' format' flags | TextureFlags.ShaderResource' 1' usage)' textureData); " is 132.
Long Statement,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The length of the statement  "            return new TextureCube(device' CreateTextureDescriptionFromImage(image' flags | TextureFlags.ShaderResource' usage)' image.ToDataBox()); " is 136.
Long Statement,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,ToStagingDescription,The length of the statement  "            copy.OptionFlags = copy.Dimension == TextureDimension.TextureCube ? ResourceOptionFlags.TextureCube : ResourceOptionFlags.None; " is 127.
Long Statement,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,Equals,The length of the statement  "            return Dimension.Equals(other.Dimension) && Width == other.Width && Height == other.Height && Depth == other.Depth && ArraySize == other.ArraySize && MipLevels == other.MipLevels && Format.Equals(other.Format) && SampleDescription.Equals(other.SampleDescription) && Usage.Equals(other.Usage) && BindFlags.Equals(other.BindFlags) && CpuAccessFlags.Equals(other.CpuAccessFlags) && OptionFlags.Equals(other.OptionFlags); " is 417.
Long Statement,SharpDX.Toolkit.Graphics,TextureView,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureView.cs,Initialize,The length of the statement  "                        throw new ArgumentException("Expecting argument to be a ShaderResourceView' RenderTargetView or DepthStencilView"' "view"); " is 123.
Long Statement,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The length of the statement  "                using (var source = new Bitmap(Factory' image.Width' image.Height' pfGuid' new DataRectangle(image.DataPointer' image.RowStride)' image.BufferStride)) " is 150.
Complex Conditional,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,GetCircle,The conditional expression  "(!closed && !CircleCache.Value.TryGetValue(thetaDiv' out circle)) ||                  (closed && !ClosedCircleCache.Value.TryGetValue(thetaDiv' out circle))"  is complex.
Complex Conditional,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The conditional expression  "selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1))"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,GetDXGIFormat,The conditional expression  "pixelFormat.RBitMask == entry.PixelFormat.RBitMask                              && pixelFormat.GBitMask == entry.PixelFormat.GBitMask                              && pixelFormat.BBitMask == entry.PixelFormat.BBitMask                              && pixelFormat.ABitMask == entry.PixelFormat.ABitMask"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The conditional expression  "description.Width <= 0 || description.Height != 1 || description.Depth != 1 || description.ArraySize == 0"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The conditional expression  "description.Width <= 0 || description.Height <= 0 || description.Depth != 1 || description.ArraySize == 0"  is complex.
Complex Conditional,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The conditional expression  "description.Width <= 0 || description.Height <= 0 || description.Depth <= 0 || description.ArraySize != 1"  is complex.
Empty Catch Block,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Load,The method has an empty catch block.
Empty Catch Block,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeSingleFrame,The method has an empty catch block.
Magic Number,HelixToolkit.UWP.CommonDX,SwapChainTarget,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\CommonDX\SwapChainTarget.cs,Initialize,The following statement contains a magic number: global::SharpDX.DXGI.SwapChainDescription1 swapChainDescription = new global::SharpDX.DXGI.SwapChainDescription1()              {                  // No transparency.                  AlphaMode = global::SharpDX.DXGI.AlphaMode.Ignore'                  // Double buffer.                  BufferCount = 2'                  // BGRA 32bit pixel format.                  Format = global::SharpDX.DXGI.Format.B8G8R8A8_UNorm'                  // Unlike in CoreWindow swap chains' the dimensions must be set.                  Height = (int)(this.swapChainPanel.RenderSize.Height * pixelScale)'                  Width = (int)(this.swapChainPanel.RenderSize.Width * pixelScale)'                  // Default multisampling.                  SampleDescription = new global::SharpDX.DXGI.SampleDescription(1' 0)'                  // In case the control is resized' stretch the swap chain accordingly.                  Scaling = global::SharpDX.DXGI.Scaling.Stretch'                  // No support for stereo display.                  Stereo = false'                  // Sequential displaying for double buffering.                  SwapEffect = global::SharpDX.DXGI.SwapEffect.FlipSequential'                  // This swapchain is going to be used as the back buffer.                  Usage = global::SharpDX.DXGI.Usage.BackBuffer | global::SharpDX.DXGI.Usage.RenderTargetOutput'              };
Magic Number,HelixToolkit.UWP,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\Controls\Viewport3DX.cs,Viewport3DXLoaded,The following statement contains a magic number: int pixelWidth = (int)(this.ActualWidth * logicalDpi / 96.0);
Magic Number,HelixToolkit.UWP,Viewport3DX,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\Controls\Viewport3DX.cs,Viewport3DXLoaded,The following statement contains a magic number: int pixelHeight = (int)(this.ActualHeight * logicalDpi / 96.0);
Magic Number,HelixToolkit.UWP,ExampleCube3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\Model\ExampleCube3D.cs,Render,The following statement contains a magic number: var view = global::SharpDX.Matrix.LookAtLH(new global::SharpDX.Vector3(0' 0' -5)' new global::SharpDX.Vector3(0' 0' 0)' global::SharpDX.Vector3.UnitY);
Magic Number,HelixToolkit.UWP,ExampleCube3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\Model\ExampleCube3D.cs,Render,The following statement contains a magic number: var time = (float)(this.clock.ElapsedMilliseconds / 1000.0);
Magic Number,HelixToolkit.UWP,ExampleCube3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\Model\ExampleCube3D.cs,Render,The following statement contains a magic number: if (this.ShowCube)              {                  // Calculate WorldViewProj                  var worldViewProj = global::SharpDX.Matrix.Scaling((float)this.Scale) * global::SharpDX.Matrix.RotationX((float)this.RotationSpeed * time)                                      * global::SharpDX.Matrix.RotationY((float)this.RotationSpeed * time * 2.0f) * global::SharpDX.Matrix.RotationZ((float)this.RotationSpeed * time * .7f)                                      * viewProj;                  worldViewProj.Transpose();                    // Setup the pipeline                  context.InputAssembler.SetVertexBuffers(0' this.vertexBufferBinding);                  context.InputAssembler.InputLayout = this.layout;                  context.InputAssembler.PrimitiveTopology = global::SharpDX.Direct3D.PrimitiveTopology.TriangleList;                  context.VertexShader.SetConstantBuffer(0' this.constantBuffer);                  context.VertexShader.Set(this.vertexShader);                  context.PixelShader.Set(this.pixelShader);                    // Update Constant Buffer                  context.UpdateSubresource(ref worldViewProj' this.constantBuffer' 0);                    // Draw the cube                  context.Draw(36' 0);              }
Magic Number,HelixToolkit.UWP,ExampleCube3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\Model\ExampleCube3D.cs,Initialize,The following statement contains a magic number: this.layout = new global::SharpDX.Direct3D11.InputLayout(                  d3dDevice'                  vertexShaderByteCode'                  new[]                      {                          new global::SharpDX.Direct3D11.InputElement("POSITION"' 0' global::SharpDX.DXGI.Format.R32G32B32A32_Float' 0' 0)'                          new global::SharpDX.Direct3D11.InputElement("COLOR"' 0' global::SharpDX.DXGI.Format.R32G32B32A32_Float' 16' 0)                      });
Magic Number,HelixToolkit.UWP,ExampleCube3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.UWP\Model\ExampleCube3D.cs,Initialize,The following statement contains a magic number: this.vertexBufferBinding = new global::SharpDX.Direct3D11.VertexBufferBinding(vertices' global::SharpDX.Utilities.SizeOf<global::SharpDX.Vector4>() * 2' 0);
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: if (n < 3)              {                  return null;              }
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: int count = 2 * nv;
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: for (int v = nv - 1; nv > 2;)              {                  // if we loop' it is probably a non-simple polygon                  if (0 >= (count--))                  {                      // ERROR - probable bad polygon!                      return null;                  }                    // three consecutive vertices in current polygon' <u'v'w>                  int u = v;                  if (nv <= u)                  {                      u = 0; // previous                  }                    v = u + 1;                  if (nv <= v)                  {                      v = 0; // new v                  }                    int w = v + 1;                  if (nv <= w)                  {                      w = 0; // next                  }                    if (Snip(contour' u' v' w' nv' V))                  {                      int s' t;                        // true names of the vertices                      int a = V[u];                      int b = V[v];                      int c = V[w];                        // output Triangle                      result.Add(a);                      result.Add(b);                      result.Add(c);                        // remove v from remaining polygon                      for (s = v' t = v + 1; t < nv; s++' t++)                      {                          V[s] = V[t];                      }                        nv--;                        // resest error detection counter                      count = 2 * nv;                  }              }
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,Triangulate,The following statement contains a magic number: for (int v = nv - 1; nv > 2;)              {                  // if we loop' it is probably a non-simple polygon                  if (0 >= (count--))                  {                      // ERROR - probable bad polygon!                      return null;                  }                    // three consecutive vertices in current polygon' <u'v'w>                  int u = v;                  if (nv <= u)                  {                      u = 0; // previous                  }                    v = u + 1;                  if (nv <= v)                  {                      v = 0; // new v                  }                    int w = v + 1;                  if (nv <= w)                  {                      w = 0; // next                  }                    if (Snip(contour' u' v' w' nv' V))                  {                      int s' t;                        // true names of the vertices                      int a = V[u];                      int b = V[v];                      int c = V[w];                        // output Triangle                      result.Add(a);                      result.Add(b);                      result.Add(c);                        // remove v from remaining polygon                      for (s = v' t = v + 1; t < nv; s++' t++)                      {                          V[s] = V[t];                      }                        nv--;                        // resest error detection counter                      count = 2 * nv;                  }              }
Magic Number,HelixToolkit.Wpf,CuttingEarsTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\CuttingEarsTriangulator.cs,InsideTriangle,The following statement contains a magic number: const double EPSILON = -1e-10;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,GetCircle,The following statement contains a magic number: if ((!closed && !CircleCache.Value.TryGetValue(thetaDiv' out circle)) ||                  (closed && !ClosedCircleCache.Value.TryGetValue(thetaDiv' out circle)))              {                  circle = new PointCollection();                  // Add to the cache                  if (!closed)                  {                      CircleCache.Value.Add(thetaDiv' circle);                  }                  else                  {                      ClosedCircleCache.Value.Add(thetaDiv' circle);                  }                  // Determine the angle steps                  var num = closed ? thetaDiv : thetaDiv - 1;                  for (int i = 0; i < thetaDiv; i++)                  {                      var theta = (DoubleOrSingle)Math.PI * 2 * ((DoubleOrSingle)i / num);                      circle.Add(new Point((DoubleOrSingle)Math.Cos(theta)' -(DoubleOrSingle)Math.Sin(theta)));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormals,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3)              {                  var i1 = triangleIndices[t];                  var i2 = triangleIndices[t + 1];                  var i3 = triangleIndices[t + 2];                  var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                  var p1 = v2 - v1;                  var p2 = v3 - v1;                  var n = SharedFunctions.CrossProduct(ref p1' ref p2);                  // angle                  p1.Normalize();                  p2.Normalize();                  var a = (float)Math.Acos(SharedFunctions.DotProduct(ref p1' ref p2));                  n.Normalize();                  normals[i1] += (a * n);                  normals[i2] += (a * n);                  normals[i3] += (a * n);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeNormals,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3)              {                  var i1 = triangleIndices[t];                  var i2 = triangleIndices[t + 1];                  var i3 = triangleIndices[t + 2];                  var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                  var p1 = v2 - v1;                  var p2 = v3 - v1;                  var n = SharedFunctions.CrossProduct(ref p1' ref p2);                  // angle                  p1.Normalize();                  p2.Normalize();                  var a = (float)Math.Acos(SharedFunctions.DotProduct(ref p1' ref p2));                  n.Normalize();                  normals[i1] += (a * n);                  normals[i2] += (a * n);                  normals[i3] += (a * n);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3)              {                  var i1 = triangleIndices[t];                  var i2 = triangleIndices[t + 1];                  var i3 = triangleIndices[t + 2];                  var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                  var w1 = textureCoordinates[i1];                  var w2 = textureCoordinates[i2];                  var w3 = textureCoordinates[i3];                  var x1 = v2.X - v1.X;                  var x2 = v3.X - v1.X;                  var y1 = v2.Y - v1.Y;                  var y2 = v3.Y - v1.Y;                  var z1 = v2.Z - v1.Z;                  var z2 = v3.Z - v1.Z;                  var s1 = w2.X - w1.X;                  var s2 = w3.X - w1.X;                  var t1 = w2.Y - w1.Y;                  var t2 = w3.Y - w1.Y;                  var r = 1.0f / (s1 * t2 - s2 * t1);                  var udir = new Vector3D((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);                  tan1[i1] += udir;                  tan1[i2] += udir;                  tan1[i3] += udir;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangents,The following statement contains a magic number: for (int t = 0; t < triangleIndices.Count; t += 3)              {                  var i1 = triangleIndices[t];                  var i2 = triangleIndices[t + 1];                  var i3 = triangleIndices[t + 2];                  var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                  var w1 = textureCoordinates[i1];                  var w2 = textureCoordinates[i2];                  var w3 = textureCoordinates[i3];                  var x1 = v2.X - v1.X;                  var x2 = v3.X - v1.X;                  var y1 = v2.Y - v1.Y;                  var y2 = v3.Y - v1.Y;                  var z1 = v2.Z - v1.Z;                  var z2 = v3.Z - v1.Z;                  var s1 = w2.X - w1.X;                  var s2 = w3.X - w1.X;                  var t1 = w2.Y - w1.Y;                  var t2 = w3.Y - w1.Y;                  var r = 1.0f / (s1 * t2 - s2 * t1);                  var udir = new Vector3D((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);                  tan1[i1] += udir;                  tan1[i2] += udir;                  tan1[i3] += udir;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: for (int t = 0; t < indices.Count; t += 4)              {                  var i1 = indices[t];                  var i2 = indices[t + 1];                  var i3 = indices[t + 2];                  var i4 = indices[t + 3];                  var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                  var v4 = positions[i4];                  var w1 = textureCoordinates[i1];                  var w2 = textureCoordinates[i2];                  var w3 = textureCoordinates[i3];                  var w4 = textureCoordinates[i4];                  var x1 = v2.X - v1.X;                  var x2 = v4.X - v1.X;                  var y1 = v2.Y - v1.Y;                  var y2 = v4.Y - v1.Y;                  var z1 = v2.Z - v1.Z;                  var z2 = v4.Z - v1.Z;                  var s1 = w2.X - w1.X;                  var s2 = w4.X - w1.X;                  var t1 = w2.Y - w1.Y;                  var t2 = w4.Y - w1.Y;                  var r = 1.0f / (s1 * t2 - s2 * t1);                  var udir = new Vector3D((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);                  tan1[i1] += udir;                  tan1[i2] += udir;                  tan1[i3] += udir;                  tan1[i4] += udir;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: for (int t = 0; t < indices.Count; t += 4)              {                  var i1 = indices[t];                  var i2 = indices[t + 1];                  var i3 = indices[t + 2];                  var i4 = indices[t + 3];                  var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                  var v4 = positions[i4];                  var w1 = textureCoordinates[i1];                  var w2 = textureCoordinates[i2];                  var w3 = textureCoordinates[i3];                  var w4 = textureCoordinates[i4];                  var x1 = v2.X - v1.X;                  var x2 = v4.X - v1.X;                  var y1 = v2.Y - v1.Y;                  var y2 = v4.Y - v1.Y;                  var z1 = v2.Z - v1.Z;                  var z2 = v4.Z - v1.Z;                  var s1 = w2.X - w1.X;                  var s2 = w4.X - w1.X;                  var t1 = w2.Y - w1.Y;                  var t2 = w4.Y - w1.Y;                  var r = 1.0f / (s1 * t2 - s2 * t1);                  var udir = new Vector3D((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);                  tan1[i1] += udir;                  tan1[i2] += udir;                  tan1[i3] += udir;                  tan1[i4] += udir;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ComputeTangentsQuads,The following statement contains a magic number: for (int t = 0; t < indices.Count; t += 4)              {                  var i1 = indices[t];                  var i2 = indices[t + 1];                  var i3 = indices[t + 2];                  var i4 = indices[t + 3];                  var v1 = positions[i1];                  var v2 = positions[i2];                  var v3 = positions[i3];                  var v4 = positions[i4];                  var w1 = textureCoordinates[i1];                  var w2 = textureCoordinates[i2];                  var w3 = textureCoordinates[i3];                  var w4 = textureCoordinates[i4];                  var x1 = v2.X - v1.X;                  var x2 = v4.X - v1.X;                  var y1 = v2.Y - v1.Y;                  var y2 = v4.Y - v1.Y;                  var z1 = v2.Z - v1.Z;                  var z2 = v4.Z - v1.Z;                  var s1 = w2.X - w1.X;                  var s2 = w4.X - w1.X;                  var t1 = w2.Y - w1.Y;                  var t2 = w4.Y - w1.Y;                  var r = 1.0f / (s1 * t2 - s2 * t1);                  var udir = new Vector3D((t2 * x1 - t1 * x2) * r' (t2 * y1 - t1 * y2) * r' (t2 * z1 - t1 * z2) * r);                  tan1[i1] += udir;                  tan1[i2] += udir;                  tan1[i3] += udir;                  tan1[i4] += udir;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddArrow,The following statement contains a magic number: var r = (DoubleOrSingle)diameter / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddArrow,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' 0)'                      new Point(0' r)'                      new Point(length - (DoubleOrSingle)(diameter * headLength)' r)'                      new Point(length - (DoubleOrSingle)(diameter * headLength)' r * 2)'                      new Point(length' 0)                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: var n = normal * (DoubleOrSingle)dist / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: up *= (DoubleOrSingle)height / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: right *= (DoubleOrSingle)width / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add(i0 + 3);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCubeFace,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The following statement contains a magic number: this.AddCone(p1' n' diameter / 2' diameter / 2' l' false' false' thetaDiv);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddCylinder,The following statement contains a magic number: this.AddCone(p1' n' diameter / 2' diameter / 2' l' false' false' thetaDiv);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusSphere = 0.25f * (DoubleOrSingle)Math.Sqrt(3) * (1 + (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusSphere = 0.25f * (DoubleOrSingle)Math.Sqrt(3) * (1 + (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusFace = 0.1f * (DoubleOrSingle)Math.Sqrt(50 + 10 * (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusFace = 0.1f * (DoubleOrSingle)Math.Sqrt(50 + 10 * (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var radiusFace = 0.1f * (DoubleOrSingle)Math.Sqrt(50 + 10 * (DoubleOrSingle)Math.Sqrt(5)) * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var pentagonPoints = GetCircle(5' true);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: var gamma = (DoubleOrSingle)Math.Acos(1 - (sideLength * sideLength / (2 * radiusSphere * radiusSphere)));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation(this.positions.Skip(positionsCount).Take(5).Select((p' i) => i).ToList());
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation(this.positions.Skip(positionsCount + 15).Select((p' i) => 15 + i).ToList());
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: this.AddPolygonByTriangulation(this.positions.Skip(positionsCount + 15).Select((p' i) => 15 + i).ToList());
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddDodecahedron,The following statement contains a magic number: for (int i = 0; i < 5; i++)              {                  // Polygon one                  var pIndices = new List<int>() {                      (i + 1) % 5 + positionsCount'                      i' i + 5 + positionsCount'                      (5 - i + 2) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 5 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);                    // Polygon two                  pIndices = new List<int>() {                      i + 15 + positionsCount'                      i + 10 + positionsCount'                      (5 - i + 2) % 5 + 5 + positionsCount'                      (i + 1) % 5 + 10 + positionsCount'                      (i + 1) % 5 + 15 + positionsCount                  };                  this.AddPolygonByTriangulation(pIndices);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEdges,The following statement contains a magic number: for (int i = 0; i < edges.Count - 1; i += 2)              {                  this.AddCylinder(points[edges[i]]' points[edges[i + 1]]' diameter' thetaDiv);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The following statement contains a magic number: var dt = 2 * (DoubleOrSingle)Math.PI / thetaDiv;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddEllipsoid,The following statement contains a magic number: for (int pi = 0; pi <= phiDiv; pi++)              {                  var phi = pi * dp;                    for (int ti = 0; ti <= thetaDiv; ti++)                  {                      // we want to start the mesh on the x axis                      var theta = ti * dt;                        // Spherical coordinates                      // http://mathworld.wolfram.com/SphericalCoordinates.html                      var x = (DoubleOrSingle)Math.Cos(theta) * (DoubleOrSingle)Math.Sin(phi);                      var y = (DoubleOrSingle)Math.Sin(theta) * (DoubleOrSingle)Math.Sin(phi);                      var z = (DoubleOrSingle)Math.Cos(phi);                        var p = new Point3D(center.X + (DoubleOrSingle)(radiusx * x)' center.Y + (DoubleOrSingle)(radiusy * y)' center.Z + (DoubleOrSingle)(radiusz * z));                      this.positions.Add(p);                        if (this.normals != null)                      {                          var n = new Vector3D(x' y' z);                          this.normals.Add(n);                      }                        if (this.textureCoordinates != null)                      {                          var uv = new Point(theta / (2 * (DoubleOrSingle)Math.PI)' phi / (DoubleOrSingle)Math.PI);                          this.textureCoordinates.Add(uv);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedGeometry,The following statement contains a magic number: int np = 2 * points.Count;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedGeometry,The following statement contains a magic number: foreach (var p in points)              {                  var v = (xaxis * p.X) + (ydirection * p.Y);                  this.positions.Add(p0 + v);                  this.positions.Add(p1 + v);                  v.Normalize();                  if (this.normals != null)                  {                      this.normals.Add(v);                      this.normals.Add(v);                  }                    if (this.textureCoordinates != null)                  {                      this.textureCoordinates.Add(new Point(0' 0));                      this.textureCoordinates.Add(new Point(1' 0));                  }                    int i1 = index0 + 1;                  int i2 = (index0 + 2) % np;                  int i3 = ((index0 + 2) % np) + 1;                    this.triangleIndices.Add(i1);                  this.triangleIndices.Add(i2);                  this.triangleIndices.Add(index0);                    this.triangleIndices.Add(i1);                  this.triangleIndices.Add(i3);                  this.triangleIndices.Add(i2);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedGeometry,The following statement contains a magic number: foreach (var p in points)              {                  var v = (xaxis * p.X) + (ydirection * p.Y);                  this.positions.Add(p0 + v);                  this.positions.Add(p1 + v);                  v.Normalize();                  if (this.normals != null)                  {                      this.normals.Add(v);                      this.normals.Add(v);                  }                    if (this.textureCoordinates != null)                  {                      this.textureCoordinates.Add(new Point(0' 0));                      this.textureCoordinates.Add(new Point(1' 0));                  }                    int i1 = index0 + 1;                  int i2 = (index0 + 2) % np;                  int i3 = ((index0 + 2) % np) + 1;                    this.triangleIndices.Add(i1);                  this.triangleIndices.Add(i2);                  this.triangleIndices.Add(index0);                    this.triangleIndices.Add(i1);                  this.triangleIndices.Add(i3);                  this.triangleIndices.Add(i2);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNZ,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNX,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFacePY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddFaceNY,The following statement contains a magic number: var indices = new int[]              {                  i0+0'i0+3'i0+2'                  i0+0'i0+2'i0+1'              };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: if (points.Count % 2 != 0)              {                  throw new InvalidOperationException("The number of points should be even.");              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  int i0 = index0 + (i * 2);                  int i1 = i0 + 1;                  int i2 = i0 + 3;                  int i3 = i0 + 2;                    this.triangleIndices.Add(i0);                  this.triangleIndices.Add(i1);                  this.triangleIndices.Add(i2);                    this.triangleIndices.Add(i2);                  this.triangleIndices.Add(i3);                  this.triangleIndices.Add(i0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  int i0 = index0 + (i * 2);                  int i1 = i0 + 1;                  int i2 = i0 + 3;                  int i3 = i0 + 2;                    this.triangleIndices.Add(i0);                  this.triangleIndices.Add(i1);                  this.triangleIndices.Add(i2);                    this.triangleIndices.Add(i2);                  this.triangleIndices.Add(i3);                  this.triangleIndices.Add(i0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddExtrudedSegments,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  int i0 = index0 + (i * 2);                  int i1 = i0 + 1;                  int i2 = i0 + 3;                  int i3 = i0 + 2;                    this.triangleIndices.Add(i0);                  this.triangleIndices.Add(i1);                  this.triangleIndices.Add(i2);                    this.triangleIndices.Add(i2);                  this.triangleIndices.Add(i3);                  this.triangleIndices.Add(i0);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The following statement contains a magic number: var n = forward * (DoubleOrSingle)sideLength / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The following statement contains a magic number: up *= (DoubleOrSingle)height / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddOctahedron,The following statement contains a magic number: right *= (DoubleOrSingle)sideLength / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' (DoubleOrSingle)innerDiameter / 2)'                      new Point(0' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)innerDiameter / 2)                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' (DoubleOrSingle)innerDiameter / 2)'                      new Point(0' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)innerDiameter / 2)                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' (DoubleOrSingle)innerDiameter / 2)'                      new Point(0' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)innerDiameter / 2)                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: var pc = new PointCollection                  {                      new Point(0' (DoubleOrSingle)innerDiameter / 2)'                      new Point(0' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)diameter / 2)'                      new Point(height' (DoubleOrSingle)innerDiameter / 2)                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipe,The following statement contains a magic number: if (innerDiameter > 0)              {                  // Add the inner surface                  pc.Add(new Point(0' (DoubleOrSingle)innerDiameter / 2));                  tc.Add(1);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPipes,The following statement contains a magic number: for (int i = 0; i < edges.Count - 1; i += 2)              {                  this.AddCylinder((Point3D)points[edges[i]]' (Point3D)points[edges[i + 1]]' diameter' thetaDiv);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: switch (points.Count)              {                  case 3:                      this.AddTriangle(points[0]' points[1]' points[2]);                      break;                  case 4:                      this.AddQuad(points[0]' points[1]' points[2]' points[3]);                      break;                  default:                      this.AddTriangleFan(points);                      break;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: for (int i = 0; i + 2 < n; i++)              {                  this.triangleIndices.Add(vertexIndices[0]);                  this.triangleIndices.Add(vertexIndices[i + 1]);                  this.triangleIndices.Add(vertexIndices[i + 2]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPolygon,The following statement contains a magic number: for (int i = 0; i + 2 < n; i++)              {                  this.triangleIndices.Add(vertexIndices[0]);                  this.triangleIndices.Add(vertexIndices[i + 1]);                  this.triangleIndices.Add(vertexIndices[i + 2]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: var n = forward * (DoubleOrSingle)sideLength / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: right *= (DoubleOrSingle)sideLength / 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: var down = -up * 1f / 3;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddPyramid,The following statement contains a magic number: var realup = up * 2f / 3;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  this.triangleIndices.Add(vertexIndices[i]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuad,The following statement contains a magic number: this.triangleIndices.Add(i0 + 3);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: Debug.Assert(quadPositions.Count > 0 && quadPositions.Count % 4 == 0' "Wrong number of positions.");
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    this.triangleIndices.Add(i + 2);                  this.triangleIndices.Add(i + 3);                  this.triangleIndices.Add(i);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    this.triangleIndices.Add(i + 2);                  this.triangleIndices.Add(i + 3);                  this.triangleIndices.Add(i);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    this.triangleIndices.Add(i + 2);                  this.triangleIndices.Add(i + 3);                  this.triangleIndices.Add(i);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddQuads,The following statement contains a magic number: for (int i = index0; i + 3 < indexEnd; i++)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    this.triangleIndices.Add(i + 2);                  this.triangleIndices.Add(i + 3);                  this.triangleIndices.Add(i);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The following statement contains a magic number: if (columns < 2 || rows < 2)              {                  throw new ArgumentNullException("columns or rows too small");              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMesh,The following statement contains a magic number: if (columns < 2 || rows < 2)              {                  throw new ArgumentNullException("columns or rows too small");              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndices,The following statement contains a magic number: for (int i = 0; i < rows - 1; i++)              {                  for (int j = 0; j < columns - 1; j++)                  {                      int ij = (i * columns) + j;                      if (!isSpherical || i > 0)                      {                          this.triangleIndices.Add(index0 + ij);                          this.triangleIndices.Add(index0 + ij + 1 + columns);                          this.triangleIndices.Add(index0 + ij + 1);                      }                        if (!isSpherical || i < rows - 2)                      {                          this.triangleIndices.Add(index0 + ij + 1 + columns);                          this.triangleIndices.Add(index0 + ij);                          this.triangleIndices.Add(index0 + ij + columns);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRectangularMeshTriangleIndicesFlipped,The following statement contains a magic number: for (int i = 0; i < rows - 1; i++)              {                  for (int j = 0; j < columns - 1; j++)                  {                      int ij = (i * columns) + j;                      if (!isSpherical || i > 0)                      {                          this.triangleIndices.Add(index0 + ij);                          this.triangleIndices.Add(index0 + ij + 1);                          this.triangleIndices.Add(index0 + ij + 1 + columns);                      }                        if (!isSpherical || i < rows - 2)                      {                          this.triangleIndices.Add(index0 + ij + 1 + columns);                          this.triangleIndices.Add(index0 + ij + columns);                          this.triangleIndices.Add(index0 + ij);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var a = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 + Math.Sqrt(5.0)));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var a = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 + Math.Sqrt(5.0)));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var a = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 + Math.Sqrt(5.0)));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var b = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 - Math.Sqrt(5.0)));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var b = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 - Math.Sqrt(5.0)));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var b = (DoubleOrSingle)Math.Sqrt(2.0 / (5.0 - Math.Sqrt(5.0)));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: var icosahedronIndices = new[]                  {                      1' 4' 0' 4' 9' 0' 4' 5' 9' 8' 5' 4' 1' 8' 4' 1' 10' 8' 10' 3' 8' 8' 3' 5' 3' 2' 5' 3' 7' 2' 3' 10' 7'                      10' 6' 7' 6' 11' 7' 6' 0' 11' 6' 1' 0' 10' 1' 6' 11' 0' 9' 2' 11' 9' 5' 2' 9' 11' 2' 7                  };
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: if (shareVertices)              {                  int index0 = this.positions.Count;                  foreach (var v in icosahedronVertices)                  {                      this.positions.Add(center + (v * (DoubleOrSingle)radius));                  }                    foreach (int i in icosahedronIndices)                  {                      this.triangleIndices.Add(index0 + i);                  }              }              else              {                  for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3)                  {                      this.AddTriangle(                          center + (icosahedronVertices[icosahedronIndices[i]] * (DoubleOrSingle)radius)'                          center + (icosahedronVertices[icosahedronIndices[i + 1]] * (DoubleOrSingle)radius)'                          center + (icosahedronVertices[icosahedronIndices[i + 2]] * (DoubleOrSingle)radius));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: if (shareVertices)              {                  int index0 = this.positions.Count;                  foreach (var v in icosahedronVertices)                  {                      this.positions.Add(center + (v * (DoubleOrSingle)radius));                  }                    foreach (int i in icosahedronIndices)                  {                      this.triangleIndices.Add(index0 + i);                  }              }              else              {                  for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3)                  {                      this.AddTriangle(                          center + (icosahedronVertices[icosahedronIndices[i]] * (DoubleOrSingle)radius)'                          center + (icosahedronVertices[icosahedronIndices[i + 1]] * (DoubleOrSingle)radius)'                          center + (icosahedronVertices[icosahedronIndices[i + 2]] * (DoubleOrSingle)radius));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRegularIcosahedron,The following statement contains a magic number: if (shareVertices)              {                  int index0 = this.positions.Count;                  foreach (var v in icosahedronVertices)                  {                      this.positions.Add(center + (v * (DoubleOrSingle)radius));                  }                    foreach (int i in icosahedronIndices)                  {                      this.triangleIndices.Add(index0 + i);                  }              }              else              {                  for (int i = 0; i + 2 < icosahedronIndices.Length; i += 3)                  {                      this.AddTriangle(                          center + (icosahedronVertices[icosahedronIndices[i]] * (DoubleOrSingle)radius)'                          center + (icosahedronVertices[icosahedronIndices[i + 1]] * (DoubleOrSingle)radius)'                          center + (icosahedronVertices[icosahedronIndices[i + 2]] * (DoubleOrSingle)radius));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: int totalNodes = (points.Count - 1) * 2 * thetaDiv;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: int rowNodes = (points.Count - 1) * 2;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++)              {                  var w = (v * circle[i].X) + (u * circle[i].Y);                    for (int j = 0; j + 1 < n; j++)                  {                      // Add segment                      var q1 = origin + (direction * points[j].X) + (w * points[j].Y);                      var q2 = origin + (direction * points[j + 1].X) + (w * points[j + 1].Y);                        // TODO: should not add segment if q1==q2 (corner point)                      // const double eps = 1e-6;                      // if (Point3D.Subtract(q1' q2).LengthSquared < eps)                      // continue;                      this.positions.Add(q1);                      this.positions.Add(q2);                        if (this.normals != null)                      {                          var tx = points[j + 1].X - points[j].X;                          var ty = points[j + 1].Y - points[j].Y;                          var normal = (-direction * ty) + (w * tx);                          normal.Normalize();                          this.normals.Add(normal);                          this.normals.Add(normal);                      }                        if (this.textureCoordinates != null)                      {                          this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues[j]));                          this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues[j + 1]));                      }                        int i0 = index0 + (i * rowNodes) + (j * 2);                      int i1 = i0 + 1;                      int i2 = index0 + ((((i + 1) * rowNodes) + (j * 2)) % totalNodes);                      int i3 = i2 + 1;                        this.triangleIndices.Add(i1);                      this.triangleIndices.Add(i0);                      this.triangleIndices.Add(i2);                        this.triangleIndices.Add(i1);                      this.triangleIndices.Add(i2);                      this.triangleIndices.Add(i3);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddRevolvedGeometry,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++)              {                  var w = (v * circle[i].X) + (u * circle[i].Y);                    for (int j = 0; j + 1 < n; j++)                  {                      // Add segment                      var q1 = origin + (direction * points[j].X) + (w * points[j].Y);                      var q2 = origin + (direction * points[j + 1].X) + (w * points[j + 1].Y);                        // TODO: should not add segment if q1==q2 (corner point)                      // const double eps = 1e-6;                      // if (Point3D.Subtract(q1' q2).LengthSquared < eps)                      // continue;                      this.positions.Add(q1);                      this.positions.Add(q2);                        if (this.normals != null)                      {                          var tx = points[j + 1].X - points[j].X;                          var ty = points[j + 1].Y - points[j].Y;                          var normal = (-direction * ty) + (w * tx);                          normal.Normalize();                          this.normals.Add(normal);                          this.normals.Add(normal);                      }                        if (this.textureCoordinates != null)                      {                          this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)j / (n - 1) : (DoubleOrSingle)textureValues[j]));                          this.textureCoordinates.Add(new Point((DoubleOrSingle)i / (thetaDiv - 1)' textureValues == null ? (DoubleOrSingle)(j + 1) / (n - 1) : (DoubleOrSingle)textureValues[j + 1]));                      }                        int i0 = index0 + (i * rowNodes) + (j * 2);                      int i1 = i0 + 1;                      int i2 = index0 + ((((i + 1) * rowNodes) + (j * 2)) % totalNodes);                      int i3 = i2 + 1;                        this.triangleIndices.Add(i1);                      this.triangleIndices.Add(i0);                      this.triangleIndices.Add(i2);                        this.triangleIndices.Add(i1);                      this.triangleIndices.Add(i2);                      this.triangleIndices.Add(i3);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddSurfaceOfRevolution,The following statement contains a magic number: for (int i = 0; i < thetaDiv; i++)              {                  var ii = (i + 1) % thetaDiv;                  for (int j = 0; j + 1 < sectionIndices.Count; j += 2)                  {                      var j0 = sectionIndices[j];                      var j1 = sectionIndices[j + 1];                        int i0 = index0 + (i * n) + j0;                      int i1 = index0 + (ii * n) + j0;                      int i2 = index0 + (i * n) + j1;                      int i3 = index0 + (ii * n) + j1;                        this.triangleIndices.Add(i0);                      this.triangleIndices.Add(i1);                      this.triangleIndices.Add(i3);                        this.triangleIndices.Add(i3);                      this.triangleIndices.Add(i2);                      this.triangleIndices.Add(i0);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var heightSphere = (DoubleOrSingle)Math.Sqrt(6) / 3 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var heightSphere = (DoubleOrSingle)Math.Sqrt(6) / 3 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var radiusSphere = (DoubleOrSingle)Math.Sqrt(6) / 4 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var radiusSphere = (DoubleOrSingle)Math.Sqrt(6) / 4 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var heightFace = (DoubleOrSingle)Math.Sqrt(3) / 2 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var heightFace = (DoubleOrSingle)Math.Sqrt(3) / 2 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var radiusFace = (DoubleOrSingle)Math.Sqrt(3) / 3 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTetrahedron,The following statement contains a magic number: var radiusFace = (DoubleOrSingle)Math.Sqrt(3) / 3 * (DoubleOrSingle)sideLength;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTorus,The following statement contains a magic number: if (torusDiameter == 0.0)              {                  this.AddSphere(new Point3D()' tubeDiameter' thetaDiv' phiDiv);              }              // If the second Diameter is zero' we can't build out torus              else if (tubeDiameter == 0.0)                  throw new HelixToolkitException("Torus must have a Diameter bigger than 0");              // Values result in a Torus              else              {                  // Points of the Cross-Section of the torus "tube"                  IList<Point> crossSectionPoints;                  // Self-intersecting Torus' if the "Tube" Diameter is bigger than the Torus Diameter                  var selfIntersecting = tubeDiameter > torusDiameter;                  if (selfIntersecting)                  {                      // Angle-Calculations for Circle Segment https://de.wikipedia.org/wiki/Gleichschenkliges_Dreieck                      var angleIcoTriangle = (DoubleOrSingle)Math.Acos(1 - ((torusDiameter * torusDiameter) / (2 * (tubeDiameter * tubeDiameter * .25))));                      var circleAngle = (DoubleOrSingle)Math.PI + angleIcoTriangle;                      var offset = -circleAngle / 2;                      // The Cross-Section is defined by only a Segment of a Circle                      crossSectionPoints = GetCircleSegment(phiDiv' circleAngle' offset);                  }                  // "normal" Torus (with a Circle as Cross-Section of the Torus                  else                  {                      crossSectionPoints = GetCircle(phiDiv' true);                  }                  // Transform Crosssection to real Size                  crossSectionPoints = crossSectionPoints.Select(p => new Point((DoubleOrSingle)p.X * (DoubleOrSingle)tubeDiameter * .5f' (DoubleOrSingle)p.Y * (DoubleOrSingle)tubeDiameter * .5f)).ToList();                  // Transform the Cross-Section Points to 3D Space                  var crossSection3DPoints = crossSectionPoints.Select(p => new Point3D(p.X' 0' p.Y)).ToList();                    // Add the needed Vertex-Positions of the Torus                  for (int i = 0; i < thetaDiv; i++)                  {                      // Angle of the current Cross-Section in the XY-Plane                      var angle = Math.PI * 2 * ((double)i / thetaDiv);                      // Rotate the Cross-Section around the Origin by using the angle and the defined torusDiameter                      var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                      for (int j = 0; j < phiDiv; j++)                      {                          // If selfintersecting Torus' skip the first and last Point of the Cross-Sections' when not the first Cross Section.                          // We only need the first and last Point of the first Cross-Section once!                          if (selfIntersecting && i > 0 && (j == 0 || j == (phiDiv - 1)))                              continue;                          // Add the Position                          this.positions.Add(rotatedPoints[j]);                      }                  }                  // Add all Normals' if they need to be calculated                  if (this.normals != null)                  {                      for (int i = 0; i < thetaDiv; i++)                      {                          // Transform the Cross-Section as well as the Origin of the Cross-Section                          var angle = Math.PI * 2 * ((double)i / thetaDiv);                          var rotatedPoints = crossSection3DPoints.Select(p3D => new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)(p3D.X + torusDiameter * .5f)' p3D.Z)).ToList();                          // We don't need the first and last Point of the rotated Points' if we are not in the first Cross-Section                          if (selfIntersecting && i > 0)                          {                              rotatedPoints.RemoveAt(0);                              rotatedPoints.RemoveAt(rotatedPoints.Count - 1);                          }                          // Transform the Center of the Cross-Section                          var rotatedOrigin = new Point3D((DoubleOrSingle)Math.Cos(angle) * (DoubleOrSingle)torusDiameter * .5f' (DoubleOrSingle)Math.Sin(angle) * (DoubleOrSingle)torusDiameter * .5f' 0);                          // Add the Normal of the Vertex                          for (int j = 0; j < rotatedPoints.Count; j++)                          {                              // The default Normal has the same Direction as the Vector from the Center to the Vertex                              var normal = rotatedPoints[j] - rotatedOrigin;                              normal.Normalize();                              // If self-intersecting Torus and first Point of first Cross-Section'                              // modify Normal                              if (selfIntersecting && i == 0 && j == 0)                              {                                  normal = new Vector3D(0' 0' -1);                              }                              // If self-intersecting Torus and last Point of first Cross-Section                              // modify Normal                              else if (selfIntersecting && i == 0 && j == (phiDiv - 1))                              {                                  normal = new Vector3D(0' 0' 1);                              }                              // Add the Normal                              this.normals.Add(normal);                          }                      }                  }                  // Add all Texture Coordinates' if they need to be calculated                  if (this.textureCoordinates != null)                  {                      // For all Points' calculate a simple uv Coordinate                      for (int i = 0; i < thetaDiv; i++)                      {                          // Determine the Number of Vertices of this Cross-Section present in the positions Collection                          var numCS = (selfIntersecting && i > 0) ? phiDiv - 2 : phiDiv;                          for (int j = 0; j < numCS; j++)                          {                              // Calculate u- and v- Coordinates for the Points                              var u = (DoubleOrSingle)i / thetaDiv;                              DoubleOrSingle v = 0;                              if (i > 0 && selfIntersecting)                                  v = (DoubleOrSingle)(j + 1) / phiDiv;                              else                                  v = (DoubleOrSingle)j / phiDiv;                              // Add the Texture-Coordinate                              this.textureCoordinates.Add(new Point(u' v));                          }                      }                  }                  // Add Triangle-Indices                  for (int i = 0; i < thetaDiv; i++)                  {                      // Normal non-selfintersecting Torus                      // Just add Triangle-Strips between all neighboring Cross-Sections                      if (!selfIntersecting)                      {                          var firstPointIdx = i * phiDiv;                          var firstPointIdxNextCircle = ((i + 1) % thetaDiv) * phiDiv;                          for (int j = 0; j < phiDiv; j++)                          {                              var jNext = (j + 1) % phiDiv;                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + jNext + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + jNext + positionsCount);                          }                      }                      // Selfintersecting Torus                      else                      {                          // Add intermediate Triangles like for the non-selfintersecting Torus                          // Skip the first and last Triangles' the "Caps" will be added later                          // Determine the Index of the first Point of the first Cross-Section                          var firstPointIdx = i * (phiDiv - 2) + 1;                          firstPointIdx += i > 0 ? 1 : 0;                          // Determine the Index of the first Point of the next Cross-Section                          var firstPointIdxNextCircle = phiDiv + firstPointIdx - 1;                          firstPointIdxNextCircle -= i > 0 ? 1 : 0;                          if (firstPointIdxNextCircle >= this.positions.Count)                          {                              firstPointIdxNextCircle %= this.positions.Count;                              firstPointIdxNextCircle++;                          }                          // Add Triangles between the "middle" Parts of the neighboring Cross-Sections                          for (int j = 1; j < phiDiv - 2; j++)                          {                              this.triangleIndices.Add(firstPointIdx + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                                this.triangleIndices.Add(firstPointIdxNextCircle + j - 1 + positionsCount);                              this.triangleIndices.Add(firstPointIdxNextCircle + j + positionsCount);                              this.triangleIndices.Add(firstPointIdx + j + positionsCount);                          }                      }                  }                  // For selfintersecting Tori                  if (selfIntersecting)                  {                      // Add bottom Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      var verts = new List<int>();                      verts.Add(0);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(1 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + (i - 1) * (phiDiv - 2) + positionsCount);                          }                      }                      verts.Add(1 + positionsCount);                      verts.Reverse();                      AddTriangleFan(verts);                        // Add top Cap by creating a List of Vertex-Indices                      // and using them to create a Triangle-Fan                      verts = new List<int>();                      verts.Add(phiDiv - 1 + positionsCount);                      for (int i = 0; i < thetaDiv; i++)                      {                          if (i == 0)                          {                              verts.Add(phiDiv - 2 + positionsCount);                          }                          else                          {                              verts.Add(phiDiv + i * (phiDiv - 2) - 1 + positionsCount);                          }                      }                      verts.Add(phiDiv - 2 + positionsCount);                      AddTriangleFan(verts);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  this.triangleIndices.Add(vertexIndices[i]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangle,The following statement contains a magic number: this.triangleIndices.Add(i0 + 2);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = 0; i + 2 < vertices.Count; i++)              {                  this.triangleIndices.Add(vertices[0]);                  this.triangleIndices.Add(vertices[i + 1]);                  this.triangleIndices.Add(vertices[i + 2]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = 0; i + 2 < vertices.Count; i++)              {                  this.triangleIndices.Add(vertices[0]);                  this.triangleIndices.Add(vertices[i + 1]);                  this.triangleIndices.Add(vertices[i + 2]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i++)              {                  this.triangleIndices.Add(index0);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleFan,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i++)              {                  this.triangleIndices.Add(index0);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangles,The following statement contains a magic number: if (trianglePositions.Count % 3 != 0)              {                  throw new InvalidOperationException(WrongNumberOfPositions);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    if (i + 3 < indexEnd)                  {                      this.triangleIndices.Add(i + 1);                      this.triangleIndices.Add(i + 3);                      this.triangleIndices.Add(i + 2);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    if (i + 3 < indexEnd)                  {                      this.triangleIndices.Add(i + 1);                      this.triangleIndices.Add(i + 3);                      this.triangleIndices.Add(i + 2);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    if (i + 3 < indexEnd)                  {                      this.triangleIndices.Add(i + 1);                      this.triangleIndices.Add(i + 3);                      this.triangleIndices.Add(i + 2);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    if (i + 3 < indexEnd)                  {                      this.triangleIndices.Add(i + 1);                      this.triangleIndices.Add(i + 3);                      this.triangleIndices.Add(i + 2);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    if (i + 3 < indexEnd)                  {                      this.triangleIndices.Add(i + 1);                      this.triangleIndices.Add(i + 3);                      this.triangleIndices.Add(i + 2);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTriangleStrip,The following statement contains a magic number: for (int i = index0; i + 2 < indexEnd; i += 2)              {                  this.triangleIndices.Add(i);                  this.triangleIndices.Add(i + 1);                  this.triangleIndices.Add(i + 2);                    if (i + 3 < indexEnd)                  {                      this.triangleIndices.Add(i + 1);                      this.triangleIndices.Add(i + 3);                      this.triangleIndices.Add(i + 2);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2)              {                  return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2)              {                  return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: for (int i = 0; i < pathLength; i++)              {                  var r = diameters != null ? (DoubleOrSingle)diameters[i % diametersCount] / 2 : 1;                  int i0 = i > 0 ? i - 1 : i;                  int i1 = i + 1 < pathLength ? i + 1 : i;                  var forward = path[i1] - path[i0];                  var right = SharedFunctions.CrossProduct(ref up' ref forward);                    up = SharedFunctions.CrossProduct(ref forward' ref right);                  up.Normalize();                  right.Normalize();                  var u = right;                  var v = up;                    //*******************************                  //*** PROPOSED SOLUTION *********                  // ** I think this will work because if path[n-1] is same point'                   // ** it is always a reflection of the current move                  // ** so reversing the last move vector should work?                  //*******************************                  if (u.IsUndefined() || v.IsUndefined())                  {                      forward = lastForward;                      forward *= -1;                      up = lastUp;                      //** Please verify that negation of "up" is correct here                      up *= -1;                      right = SharedFunctions.CrossProduct(ref up' ref forward);                      up.Normalize();                      right.Normalize();                      u = right;                      v = up;                  }                  lastForward = forward;                  lastUp = up;                    //*** PROPOSED SOLUTION *********                  //*******************************                  for (int j = 0; j < sectionLength; j++)                  {                      var w = (section[j].X * u * r) + (section[j].Y * v * r);                      var q = path[i] + w;                      this.positions.Add(q);                      if (this.normals != null)                      {                          w.Normalize();                          this.normals.Add(w);                      }                        if (this.textureCoordinates != null)                      {                          this.textureCoordinates.Add(                              values != null                                  ? new Point((DoubleOrSingle)values[i % valuesCount]' (DoubleOrSingle)j / (sectionLength - 1))                                  : new Point());                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (frontCap || backCap && path.Count > 1)              {                  var normals = new Vector3D[section.Count];                  var fanTextures = new Point[section.Count];                  var count = path.Count;                  if (backCap)                  {                      var circleBack = Positions.Skip(Positions.Count - section.Count).Take(section.Count).Reverse().ToArray();                      var normal = path[count - 1] - path[count - 2];                      normal.Normalize();                      for (int i = 0; i < normals.Length; ++i)                      {                          normals[i] = normal;                      }                      this.AddTriangleFan(circleBack' normals' fanTextures);                  }                  if (frontCap)                  {                      var circleFront = Positions.Take(section.Count).ToArray();                      var normal = path[0] - path[1];                      normal.Normalize();                        for (int i = 0; i < normals.Length; ++i)                      {                          normals[i] = normal;                      }                      this.AddTriangleFan(circleFront' normals' fanTextures);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2)              {                  return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (pathLength < 2 || sectionLength < 2)              {                  return;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: for (int i = 0; i < pathLength; i++)              {                  var radius = diameters != null ? (DoubleOrSingle)diameters[i % diametersCount] / 2 : 1;                  var theta = angles != null ? (DoubleOrSingle)angles[i % anglesCount] : 0.0;                    var ct = (DoubleOrSingle)Math.Cos(theta);                  var st = (DoubleOrSingle)Math.Sin(theta);                    int i0 = i > 0 ? i - 1 : i;                  int i1 = i + 1 < pathLength ? i + 1 : i;                    forward = path[i1] - path[i0];                  right = SharedFunctions.CrossProduct(ref up' ref forward);                  if (SharedFunctions.LengthSquared(ref right) > 1e-6f)                  {                      up = SharedFunctions.CrossProduct(ref forward' ref right);                  }                    up.Normalize();                  right.Normalize();                  for (int j = 0; j < sectionLength; j++)                  {                      var x = (section[j].X * ct) - (section[j].Y * st);                      var y = (section[j].X * st) + (section[j].Y * ct);                        var w = (x * right * radius) + (y * up * radius);                      var q = path[i] + w;                      this.positions.Add(q);                      if (this.normals != null)                      {                          w.Normalize();                          this.normals.Add(w);                      }                        if (this.textureCoordinates != null)                      {                          this.textureCoordinates.Add(                              values != null                                  ? new Point((DoubleOrSingle)values[i % valuesCount]' (DoubleOrSingle)j / (sectionLength - 1))                                  : new Point());                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,AddTube,The following statement contains a magic number: if (frontCap || backCap && path.Count > 1)              {                  var normals = new Vector3D[section.Count];                  var fanTextures = new Point[section.Count];                  var count = path.Count;                  if (backCap)                  {                      var circleBack = Positions.Skip(Positions.Count - section.Count).Take(section.Count).Reverse().ToArray();                      var normal = path[count - 1] - path[count - 2];                      normal.Normalize();                      for (int i = 0; i < normals.Length; ++i)                      {                          normals[i] = normal;                      }                      this.AddTriangleFan(circleBack' normals' fanTextures);                  }                  if (frontCap)                  {                      var circleFront = Positions.Take(section.Count).ToArray();                      var normal = path[0] - path[1];                      normal.Normalize();                        for (int i = 0; i < normals.Length; ++i)                      {                          normals[i] = normal;                      }                      this.AddTriangleFan(circleFront' normals' fanTextures);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  var p0 = this.positions[this.triangleIndices[i0]];                  var p1 = this.positions[this.triangleIndices[i1]];                  var p2 = this.positions[this.triangleIndices[i2]];                  var pp0 = p - p0;                  var pp1 = p - p1;                  var pp2 = p - p2;                  var d0 = SharedFunctions.LengthSquared(ref pp0);                  var d1 = SharedFunctions.LengthSquared(ref pp1);                  var d2 = SharedFunctions.LengthSquared(ref pp2);                  var mind = Math.Min(d0' Math.Min(d1' d2));                  if (mind > eps)                  {                      continue;                  }                    if (d1 < eps)                  {                      i0 = i + 1;                      i1 = i + 2;                      i2 = i;                  }                    if (d2 < eps)                  {                      i0 = i + 2;                      i1 = i;                      i2 = i + 1;                  }                    p0 = this.positions[this.triangleIndices[i0]];                  p1 = this.positions[this.triangleIndices[i1]];                  p2 = this.positions[this.triangleIndices[i2]];                    // origin is the corner vertex (at index i0)                  // find the intersections between the chamfer plane and the two edges connected to the corner                  var p01 = plane.LineIntersection(p0' p1);                  var p02 = plane.LineIntersection(p0' p2);                    if (p01 == null)                  {                      continue;                  }                    if (p02 == null)                  {                      continue;                  }                    if (chamferPoints != null)                  {                      // add the chamfered points                      if (!chamferPoints.Contains(p01.Value))                      {                          chamferPoints.Add(p01.Value);                      }                        if (!chamferPoints.Contains(p02.Value))                      {                          chamferPoints.Add(p02.Value);                      }                  }                    int i01 = i0;                    // change the original triangle to use the first chamfer point                  this.positions[this.triangleIndices[i01]] = p01.Value;                    int i02 = this.positions.Count;                  this.positions.Add(p02.Value);                    // add a new triangle for the other chamfer point                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i2);                  this.triangleIndices.Add(i02);                    // add a triangle connecting the chamfer points and the new corner point                  this.triangleIndices.Add(index0);                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i02);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  var p0 = this.positions[this.triangleIndices[i0]];                  var p1 = this.positions[this.triangleIndices[i1]];                  var p2 = this.positions[this.triangleIndices[i2]];                  var pp0 = p - p0;                  var pp1 = p - p1;                  var pp2 = p - p2;                  var d0 = SharedFunctions.LengthSquared(ref pp0);                  var d1 = SharedFunctions.LengthSquared(ref pp1);                  var d2 = SharedFunctions.LengthSquared(ref pp2);                  var mind = Math.Min(d0' Math.Min(d1' d2));                  if (mind > eps)                  {                      continue;                  }                    if (d1 < eps)                  {                      i0 = i + 1;                      i1 = i + 2;                      i2 = i;                  }                    if (d2 < eps)                  {                      i0 = i + 2;                      i1 = i;                      i2 = i + 1;                  }                    p0 = this.positions[this.triangleIndices[i0]];                  p1 = this.positions[this.triangleIndices[i1]];                  p2 = this.positions[this.triangleIndices[i2]];                    // origin is the corner vertex (at index i0)                  // find the intersections between the chamfer plane and the two edges connected to the corner                  var p01 = plane.LineIntersection(p0' p1);                  var p02 = plane.LineIntersection(p0' p2);                    if (p01 == null)                  {                      continue;                  }                    if (p02 == null)                  {                      continue;                  }                    if (chamferPoints != null)                  {                      // add the chamfered points                      if (!chamferPoints.Contains(p01.Value))                      {                          chamferPoints.Add(p01.Value);                      }                        if (!chamferPoints.Contains(p02.Value))                      {                          chamferPoints.Add(p02.Value);                      }                  }                    int i01 = i0;                    // change the original triangle to use the first chamfer point                  this.positions[this.triangleIndices[i01]] = p01.Value;                    int i02 = this.positions.Count;                  this.positions.Add(p02.Value);                    // add a new triangle for the other chamfer point                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i2);                  this.triangleIndices.Add(i02);                    // add a triangle connecting the chamfer points and the new corner point                  this.triangleIndices.Add(index0);                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i02);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  var p0 = this.positions[this.triangleIndices[i0]];                  var p1 = this.positions[this.triangleIndices[i1]];                  var p2 = this.positions[this.triangleIndices[i2]];                  var pp0 = p - p0;                  var pp1 = p - p1;                  var pp2 = p - p2;                  var d0 = SharedFunctions.LengthSquared(ref pp0);                  var d1 = SharedFunctions.LengthSquared(ref pp1);                  var d2 = SharedFunctions.LengthSquared(ref pp2);                  var mind = Math.Min(d0' Math.Min(d1' d2));                  if (mind > eps)                  {                      continue;                  }                    if (d1 < eps)                  {                      i0 = i + 1;                      i1 = i + 2;                      i2 = i;                  }                    if (d2 < eps)                  {                      i0 = i + 2;                      i1 = i;                      i2 = i + 1;                  }                    p0 = this.positions[this.triangleIndices[i0]];                  p1 = this.positions[this.triangleIndices[i1]];                  p2 = this.positions[this.triangleIndices[i2]];                    // origin is the corner vertex (at index i0)                  // find the intersections between the chamfer plane and the two edges connected to the corner                  var p01 = plane.LineIntersection(p0' p1);                  var p02 = plane.LineIntersection(p0' p2);                    if (p01 == null)                  {                      continue;                  }                    if (p02 == null)                  {                      continue;                  }                    if (chamferPoints != null)                  {                      // add the chamfered points                      if (!chamferPoints.Contains(p01.Value))                      {                          chamferPoints.Add(p01.Value);                      }                        if (!chamferPoints.Contains(p02.Value))                      {                          chamferPoints.Add(p02.Value);                      }                  }                    int i01 = i0;                    // change the original triangle to use the first chamfer point                  this.positions[this.triangleIndices[i01]] = p01.Value;                    int i02 = this.positions.Count;                  this.positions.Add(p02.Value);                    // add a new triangle for the other chamfer point                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i2);                  this.triangleIndices.Add(i02);                    // add a triangle connecting the chamfer points and the new corner point                  this.triangleIndices.Add(index0);                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i02);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,ChamferCorner,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  var p0 = this.positions[this.triangleIndices[i0]];                  var p1 = this.positions[this.triangleIndices[i1]];                  var p2 = this.positions[this.triangleIndices[i2]];                  var pp0 = p - p0;                  var pp1 = p - p1;                  var pp2 = p - p2;                  var d0 = SharedFunctions.LengthSquared(ref pp0);                  var d1 = SharedFunctions.LengthSquared(ref pp1);                  var d2 = SharedFunctions.LengthSquared(ref pp2);                  var mind = Math.Min(d0' Math.Min(d1' d2));                  if (mind > eps)                  {                      continue;                  }                    if (d1 < eps)                  {                      i0 = i + 1;                      i1 = i + 2;                      i2 = i;                  }                    if (d2 < eps)                  {                      i0 = i + 2;                      i1 = i;                      i2 = i + 1;                  }                    p0 = this.positions[this.triangleIndices[i0]];                  p1 = this.positions[this.triangleIndices[i1]];                  p2 = this.positions[this.triangleIndices[i2]];                    // origin is the corner vertex (at index i0)                  // find the intersections between the chamfer plane and the two edges connected to the corner                  var p01 = plane.LineIntersection(p0' p1);                  var p02 = plane.LineIntersection(p0' p2);                    if (p01 == null)                  {                      continue;                  }                    if (p02 == null)                  {                      continue;                  }                    if (chamferPoints != null)                  {                      // add the chamfered points                      if (!chamferPoints.Contains(p01.Value))                      {                          chamferPoints.Add(p01.Value);                      }                        if (!chamferPoints.Contains(p02.Value))                      {                          chamferPoints.Add(p02.Value);                      }                  }                    int i01 = i0;                    // change the original triangle to use the first chamfer point                  this.positions[this.triangleIndices[i01]] = p01.Value;                    int i02 = this.positions.Count;                  this.positions.Add(p02.Value);                    // add a new triangle for the other chamfer point                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i2);                  this.triangleIndices.Add(i02);                    // add a triangle connecting the chamfer points and the new corner point                  this.triangleIndices.Add(index0);                  this.triangleIndices.Add(i01);                  this.triangleIndices.Add(i02);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,FindCornerNormal,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  var p0 = this.positions[this.triangleIndices[i0]];                  var p1 = this.positions[this.triangleIndices[i1]];                  var p2 = this.positions[this.triangleIndices[i2]];                    // check if any of the vertices are on the corner                  var pp0 = p - p0;                  var pp1 = p - p1;                  var pp2 = p - p2;                  var d0 = SharedFunctions.LengthSquared(ref pp0);                  var d1 = SharedFunctions.LengthSquared(ref pp1);                  var d2 = SharedFunctions.LengthSquared(ref pp2);                  var mind = Math.Min(d0' Math.Min(d1' d2));                  if (mind > eps)                  {                      continue;                  }                    // calculate the triangle normal and check if this face is already added                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var normal = SharedFunctions.CrossProduct(ref p10' ref p20);                  normal.Normalize();                    // todo: need to use the epsilon value to compare the normals?                  if (addedNormals.Contains(normal))                  {                      continue;                  }                    // todo: this does not work yet                  // double dp = 1;                  // foreach (var n in addedNormals)                  // {                  // dp = Math.Abs(Vector3D.DotProduct(n' normal) - 1);                  // if (dp < eps)                  // continue;                  // }                  // if (dp < eps)                  // {                  // continue;                  // }                  count++;                  sum += normal;                  addedNormals.Add(normal);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,FindCornerNormal,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  var p0 = this.positions[this.triangleIndices[i0]];                  var p1 = this.positions[this.triangleIndices[i1]];                  var p2 = this.positions[this.triangleIndices[i2]];                    // check if any of the vertices are on the corner                  var pp0 = p - p0;                  var pp1 = p - p1;                  var pp2 = p - p2;                  var d0 = SharedFunctions.LengthSquared(ref pp0);                  var d1 = SharedFunctions.LengthSquared(ref pp1);                  var d2 = SharedFunctions.LengthSquared(ref pp2);                  var mind = Math.Min(d0' Math.Min(d1' d2));                  if (mind > eps)                  {                      continue;                  }                    // calculate the triangle normal and check if this face is already added                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var normal = SharedFunctions.CrossProduct(ref p10' ref p20);                  normal.Normalize();                    // todo: need to use the epsilon value to compare the normals?                  if (addedNormals.Contains(normal))                  {                      continue;                  }                    // todo: this does not work yet                  // double dp = 1;                  // foreach (var n in addedNormals)                  // {                  // dp = Math.Abs(Vector3D.DotProduct(n' normal) - 1);                  // if (dp < eps)                  // continue;                  // }                  // if (dp < eps)                  // {                  // continue;                  // }                  count++;                  sum += normal;                  addedNormals.Add(normal);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  int index0 = this.triangleIndices[i0];                  int index1 = this.triangleIndices[i1];                  int index2 = this.triangleIndices[i2];                  var p0 = this.positions[index0];                  var p1 = this.positions[index1];                  var p2 = this.positions[index2];                  p.Add(p0);                  p.Add(p1);                  p.Add(p2);                  ti.Add(i0);                  ti.Add(i1);                  ti.Add(i2);                  if (n != null)                  {                      n.Add(this.normals[index0]);                      n.Add(this.normals[index1]);                      n.Add(this.normals[index2]);                  }                    if (tc != null)                  {                      tc.Add(this.textureCoordinates[index0]);                      tc.Add(this.textureCoordinates[index1]);                      tc.Add(this.textureCoordinates[index2]);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < this.triangleIndices.Count; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  int index0 = this.triangleIndices[i0];                  int index1 = this.triangleIndices[i1];                  int index2 = this.triangleIndices[i2];                  var p0 = this.positions[index0];                  var p1 = this.positions[index1];                  var p2 = this.positions[index2];                  p.Add(p0);                  p.Add(p1);                  p.Add(p2);                  ti.Add(i0);                  ti.Add(i1);                  ti.Add(i2);                  if (n != null)                  {                      n.Add(this.normals[index0]);                      n.Add(this.normals[index1]);                      n.Add(this.normals[index2]);                  }                    if (tc != null)                  {                      tc.Add(this.textureCoordinates[index0]);                      tc.Add(this.textureCoordinates[index1]);                      tc.Add(this.textureCoordinates[index2]);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                    int i01 = ip++;                  int i12 = ip++;                  int i20 = ip++;                    this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = i20;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i20);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                    int i01 = ip++;                  int i12 = ip++;                  int i20 = ip++;                    this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = i20;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i20);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                    int i01 = ip++;                  int i12 = ip++;                  int i20 = ip++;                    this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = i20;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i20);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,Subdivide4,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                    int i01 = ip++;                  int i12 = ip++;                  int i20 = ip++;                    this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = i20;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i20);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshBuilder,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs,SubdivideBarycentric,The following statement contains a magic number: for (int i = 0; i < ntri; i += 3)              {                  int i0 = this.TriangleIndices[i];                  int i1 = this.TriangleIndices[i + 1];                  int i2 = this.TriangleIndices[i + 2];                  var p0 = this.Positions[i0];                  var p1 = this.Positions[i1];                  var p2 = this.Positions[i2];                  var v01 = p1 - p0;                  var v12 = p2 - p1;                  var v20 = p0 - p2;                  var p01 = p0 + (v01 * 0.5f);                  var p12 = p1 + (v12 * 0.5f);                  var p20 = p2 + (v20 * 0.5f);                  var m = new Point3D((p0.X + p1.X + p2.X) / 3' (p0.Y + p1.Y + p2.Y) / 3' (p0.Z + p1.Z + p2.Z) / 3);                    int i01 = im + 1;                  int i12 = im + 2;                  int i20 = im + 3;                    this.Positions.Add(m);                  this.Positions.Add(p01);                  this.Positions.Add(p12);                  this.Positions.Add(p20);                    if (this.normals != null)                  {                      var n = this.Normals[i0];                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                      this.Normals.Add(n);                  }                    if (this.textureCoordinates != null)                  {                      var uv0 = this.TextureCoordinates[i0];                      var uv1 = this.TextureCoordinates[i0 + 1];                      var uv2 = this.TextureCoordinates[i0 + 2];                      var t01 = uv1 - uv0;                      var t12 = uv2 - uv1;                      var t20 = uv0 - uv2;                      var u01 = uv0 + (t01 * 0.5f);                      var u12 = uv1 + (t12 * 0.5f);                      var u20 = uv2 + (t20 * 0.5f);                      var uvm = new Point((uv0.X + uv1.X) * 0.5f' (uv0.Y + uv1.Y) * 0.5f);                      this.TextureCoordinates.Add(uvm);                      this.TextureCoordinates.Add(u01);                      this.TextureCoordinates.Add(u12);                      this.TextureCoordinates.Add(u20);                  }                    // TriangleIndices[i ] = i0;                  this.TriangleIndices[i + 1] = i01;                  this.TriangleIndices[i + 2] = im;                    this.TriangleIndices.Add(i01);                  this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i1);                  this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i12);                  this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i2);                  this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(im);                    this.TriangleIndices.Add(i20);                  this.TriangleIndices.Add(i0);                  this.TriangleIndices.Add(im);                    im += 4;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < triangleIndices.Count; i += 3)              {                  int index0 = triangleIndices[i];                  int index1 = triangleIndices[i + 1];                  int index2 = triangleIndices[i + 2];                  var p0 = positions[index0];                  var p1 = positions[index1];                  var p2 = positions[index2];                  Vector3D u = p1 - p0;                  Vector3D v = p2 - p0;                  Vector3D w = SharedFunctions.CrossProduct(ref u' ref v);                  w.Normalize();                  normals[index0] += w;                  normals[index1] += w;                  normals[index2] += w;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < triangleIndices.Count; i += 3)              {                  int index0 = triangleIndices[i];                  int index1 = triangleIndices[i + 1];                  int index2 = triangleIndices[i + 2];                  var p0 = positions[index0];                  var p1 = positions[index1];                  var p2 = positions[index2];                  Vector3D u = p1 - p0;                  Vector3D v = p2 - p0;                  Vector3D w = SharedFunctions.CrossProduct(ref u' ref v);                  w.Normalize();                  normals[index0] += w;                  normals[index1] += w;                  normals[index2] += w;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (dict.ContainsKey(key))                      {                          dict[key] = dict[key] + 1;                      }                      else                      {                          dict.Add(key' 1);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (dict.ContainsKey(key))                      {                          dict[key] = dict[key] + 1;                      }                      else                      {                          dict.Add(key' 1);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (dict.ContainsKey(key))                      {                          dict[key] = dict[key] + 1;                      }                      else                      {                          dict.Add(key' 1);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindBorderEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (dict.ContainsKey(key))                      {                          dict[key] = dict[key] + 1;                      }                      else                      {                          dict.Add(key' 1);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (!dict.Contains(key))                      {                          edges.Add(minIndex);                          edges.Add(maxIndex);                          dict.Add(key);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (!dict.Contains(key))                      {                          edges.Add(minIndex);                          edges.Add(maxIndex);                          dict.Add(key);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (!dict.Contains(key))                      {                          edges.Add(minIndex);                          edges.Add(maxIndex);                          dict.Add(key);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index1' index0);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      if (!dict.Contains(key))                      {                          edges.Add(minIndex);                          edges.Add(maxIndex);                          dict.Add(key);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  var p0 = mesh.Positions[mesh.TriangleIndices[i0]];                  var p1 = mesh.Positions[mesh.TriangleIndices[i0 + 1]];                  var p2 = mesh.Positions[mesh.TriangleIndices[i0 + 2]];                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var n = SharedFunctions.CrossProduct(ref p10' ref p20);                  n.Normalize();                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index0' index1);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      Vector3D value;                      if (edgeNormals.TryGetValue(key' out value))                      {                          var n2 = value;                          n2.Normalize();                          var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos(SharedFunctions.DotProduct(ref n' ref n2));                          if (angle > minimumAngle)                          {                              edgeIndices.Add(minIndex);                              edgeIndices.Add(maxIndex);                          }                      }                      else                      {                          edgeNormals.Add(key' n);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  var p0 = mesh.Positions[mesh.TriangleIndices[i0]];                  var p1 = mesh.Positions[mesh.TriangleIndices[i0 + 1]];                  var p2 = mesh.Positions[mesh.TriangleIndices[i0 + 2]];                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var n = SharedFunctions.CrossProduct(ref p10' ref p20);                  n.Normalize();                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index0' index1);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      Vector3D value;                      if (edgeNormals.TryGetValue(key' out value))                      {                          var n2 = value;                          n2.Normalize();                          var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos(SharedFunctions.DotProduct(ref n' ref n2));                          if (angle > minimumAngle)                          {                              edgeIndices.Add(minIndex);                              edgeIndices.Add(maxIndex);                          }                      }                      else                      {                          edgeNormals.Add(key' n);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  var p0 = mesh.Positions[mesh.TriangleIndices[i0]];                  var p1 = mesh.Positions[mesh.TriangleIndices[i0 + 1]];                  var p2 = mesh.Positions[mesh.TriangleIndices[i0 + 2]];                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var n = SharedFunctions.CrossProduct(ref p10' ref p20);                  n.Normalize();                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index0' index1);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      Vector3D value;                      if (edgeNormals.TryGetValue(key' out value))                      {                          var n2 = value;                          n2.Normalize();                          var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos(SharedFunctions.DotProduct(ref n' ref n2));                          if (angle > minimumAngle)                          {                              edgeIndices.Add(minIndex);                              edgeIndices.Add(maxIndex);                          }                      }                      else                      {                          edgeNormals.Add(key' n);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  var p0 = mesh.Positions[mesh.TriangleIndices[i0]];                  var p1 = mesh.Positions[mesh.TriangleIndices[i0 + 1]];                  var p2 = mesh.Positions[mesh.TriangleIndices[i0 + 2]];                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var n = SharedFunctions.CrossProduct(ref p10' ref p20);                  n.Normalize();                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index0' index1);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      Vector3D value;                      if (edgeNormals.TryGetValue(key' out value))                      {                          var n2 = value;                          n2.Normalize();                          var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos(SharedFunctions.DotProduct(ref n' ref n2));                          if (angle > minimumAngle)                          {                              edgeIndices.Add(minIndex);                              edgeIndices.Add(maxIndex);                          }                      }                      else                      {                          edgeNormals.Add(key' n);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  var p0 = mesh.Positions[mesh.TriangleIndices[i0]];                  var p1 = mesh.Positions[mesh.TriangleIndices[i0 + 1]];                  var p2 = mesh.Positions[mesh.TriangleIndices[i0 + 2]];                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var n = SharedFunctions.CrossProduct(ref p10' ref p20);                  n.Normalize();                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index0' index1);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      Vector3D value;                      if (edgeNormals.TryGetValue(key' out value))                      {                          var n2 = value;                          n2.Normalize();                          var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos(SharedFunctions.DotProduct(ref n' ref n2));                          if (angle > minimumAngle)                          {                              edgeIndices.Add(minIndex);                              edgeIndices.Add(maxIndex);                          }                      }                      else                      {                          edgeNormals.Add(key' n);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,FindSharpEdges,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count / 3; i++)              {                  int i0 = i * 3;                  var p0 = mesh.Positions[mesh.TriangleIndices[i0]];                  var p1 = mesh.Positions[mesh.TriangleIndices[i0 + 1]];                  var p2 = mesh.Positions[mesh.TriangleIndices[i0 + 2]];                  var p10 = p1 - p0;                  var p20 = p2 - p0;                  var n = SharedFunctions.CrossProduct(ref p10' ref p20);                  n.Normalize();                  for (int j = 0; j < 3; j++)                  {                      int index0 = mesh.TriangleIndices[i0 + j];                      int index1 = mesh.TriangleIndices[i0 + ((j + 1) % 3)];                      int minIndex = Math.Min(index0' index1);                      int maxIndex = Math.Max(index0' index1);                      ulong key = CreateKey((uint)minIndex' (uint)maxIndex);                      Vector3D value;                      if (edgeNormals.TryGetValue(key' out value))                      {                          var n2 = value;                          n2.Normalize();                          var angle = 180 / (DoubleOrSingle)Math.PI * (DoubleOrSingle)Math.Acos(SharedFunctions.DotProduct(ref n' ref n2));                          if (angle > minimumAngle)                          {                              edgeIndices.Add(minIndex);                              edgeIndices.Add(maxIndex);                          }                      }                      else                      {                          edgeNormals.Add(key' n);                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < input.TriangleIndices.Count; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  int index0 = input.TriangleIndices[i0];                  int index1 = input.TriangleIndices[i1];                  int index2 = input.TriangleIndices[i2];                  var p0 = input.Positions[index0];                  var p1 = input.Positions[index1];                  var p2 = input.Positions[index2];                  p.Add(p0);                  p.Add(p1);                  p.Add(p2);                  ti.Add(i0);                  ti.Add(i1);                  ti.Add(i2);                  if (n != null)                  {                      n.Add(input.Normals[index0]);                      n.Add(input.Normals[index1]);                      n.Add(input.Normals[index2]);                  }                    if (tc != null)                  {                      tc.Add(input.TextureCoordinates[index0]);                      tc.Add(input.TextureCoordinates[index1]);                      tc.Add(input.TextureCoordinates[index2]);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,NoSharedVertices,The following statement contains a magic number: for (int i = 0; i < input.TriangleIndices.Count; i += 3)              {                  int i0 = i;                  int i1 = i + 1;                  int i2 = i + 2;                  int index0 = input.TriangleIndices[i0];                  int index1 = input.TriangleIndices[i1];                  int index2 = input.TriangleIndices[i2];                  var p0 = input.Positions[index0];                  var p1 = input.Positions[index1];                  var p2 = input.Positions[index2];                  p.Add(p0);                  p.Add(p1);                  p.Add(p2);                  ti.Add(i0);                  ti.Add(i1);                  ti.Add(i2);                  if (n != null)                  {                      n.Add(input.Normals[index0]);                      n.Add(input.Normals[index1]);                      n.Add(input.Normals[index2]);                  }                    if (tc != null)                  {                      tc.Add(input.TextureCoordinates[index0]);                      tc.Add(input.TextureCoordinates[index1]);                      tc.Add(input.TextureCoordinates[index2]);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: if (mesh.TriangleIndices.Count % 3 != 0)              {                  sb.AppendLine("TriangleIndices not complete");              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i++)              {                  int index = mesh.TriangleIndices[i];                  if (index < 0 || index >= mesh.Positions.Count)                  {                      sb.AppendFormat("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);                      sb.AppendLine();                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Validate,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i++)              {                  int index = mesh.TriangleIndices[i];                  if (index < 0 || index >= mesh.Positions.Count)                  {                      sb.AppendFormat("Wrong index {0} in triangle {1} vertex {2}"' index' i / 3' i % 3);                      sb.AppendLine();                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The following statement contains a magic number: for (var i = 0; i < mesh.TriangleIndices.Count; i += 3)              {                  var index0 = mesh.TriangleIndices[i];                  var index1 = mesh.TriangleIndices[i + 1];                  var index2 = mesh.TriangleIndices[i + 2];                    Point3D[] positions;                  Vector3D[] normals;                  Point[] textureCoordinates;                  int[] triangleIndices;                    contourHelper.ContourFacet(index0' index1' index2' out positions' out normals' out textureCoordinates' out triangleIndices);                    foreach (var p in positions)                  {                      meshBuilder.Positions.Add(p);                  }                    foreach (var tc in textureCoordinates)                  {                      meshBuilder.TextureCoordinates.Add(tc);                  }                    foreach (var n in normals)                  {                      meshBuilder.Normals.Add(n);                  }                    foreach (var ti in triangleIndices)                  {                      meshBuilder.TriangleIndices.Add(ti);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,Cut,The following statement contains a magic number: for (var i = 0; i < mesh.TriangleIndices.Count; i += 3)              {                  var index0 = mesh.TriangleIndices[i];                  var index1 = mesh.TriangleIndices[i + 1];                  var index2 = mesh.TriangleIndices[i + 2];                    Point3D[] positions;                  Vector3D[] normals;                  Point[] textureCoordinates;                  int[] triangleIndices;                    contourHelper.ContourFacet(index0' index1' index2' out positions' out normals' out textureCoordinates' out triangleIndices);                    foreach (var p in positions)                  {                      meshBuilder.Positions.Add(p);                  }                    foreach (var tc in textureCoordinates)                  {                      meshBuilder.TextureCoordinates.Add(tc);                  }                    foreach (var n in normals)                  {                      meshBuilder.Normals.Add(n);                  }                    foreach (var ti in triangleIndices)                  {                      meshBuilder.TriangleIndices.Add(ti);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3)              {                  Point3D[] positions;                  Vector3D[] normals;                  Point[] textureCoordinates;                  int[] triangleIndices;                    contourHelper.ContourFacet(                      mesh.TriangleIndices[i]'                      mesh.TriangleIndices[i + 1]'                      mesh.TriangleIndices[i + 2]'                      out positions'                      out normals'                      out textureCoordinates'                      out triangleIndices);                  segments.AddRange(positions);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,GetContourSegments,The following statement contains a magic number: for (int i = 0; i < mesh.TriangleIndices.Count; i += 3)              {                  Point3D[] positions;                  Vector3D[] normals;                  Point[] textureCoordinates;                  int[] triangleIndices;                    contourHelper.ContourFacet(                      mesh.TriangleIndices[i]'                      mesh.TriangleIndices[i + 1]'                      mesh.TriangleIndices[i + 2]'                      out positions'                      out normals'                      out textureCoordinates'                      out triangleIndices);                  segments.AddRange(positions);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0)              {                  if (curveCount > 0)                  {                      // Find a segment that is connected to the head of the contour                      segment1 = FindConnectedSegment(segments' curve[0]' eps);                      if (segment1 >= 0)                      {                          if (segment1 % 2 == 1)                          {                              curve.Insert(0' segments[segment1 - 1]);                              segments.RemoveAt(segment1 - 1);                              segments.RemoveAt(segment1 - 1);                          }                          else                          {                              curve.Insert(0' segments[segment1 + 1]);                              segments.RemoveAt(segment1);                              segments.RemoveAt(segment1);                          }                            curveCount++;                          segmentCount -= 2;                      }                        // Find a segment that is connected to the tail of the contour                      segment2 = FindConnectedSegment(segments' curve[curveCount - 1]' eps);                      if (segment2 >= 0)                      {                          if (segment2 % 2 == 1)                          {                              curve.Add(segments[segment2 - 1]);                              segments.RemoveAt(segment2 - 1);                              segments.RemoveAt(segment2 - 1);                          }                          else                          {                              curve.Add(segments[segment2 + 1]);                              segments.RemoveAt(segment2);                              segments.RemoveAt(segment2);                          }                            curveCount++;                          segmentCount -= 2;                      }                  }                    if ((segment1 < 0 && segment2 < 0) || segmentCount == 0)                  {                      if (curveCount > 0)                      {                          yield return curve;                          curve = new List<Point3D>();                          curveCount = 0;                      }                        if (segmentCount > 0)                      {                          curve.Add(segments[0]);                          curve.Add(segments[1]);                          curveCount += 2;                          segments.RemoveAt(0);                          segments.RemoveAt(0);                          segmentCount -= 2;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0)              {                  if (curveCount > 0)                  {                      // Find a segment that is connected to the head of the contour                      segment1 = FindConnectedSegment(segments' curve[0]' eps);                      if (segment1 >= 0)                      {                          if (segment1 % 2 == 1)                          {                              curve.Insert(0' segments[segment1 - 1]);                              segments.RemoveAt(segment1 - 1);                              segments.RemoveAt(segment1 - 1);                          }                          else                          {                              curve.Insert(0' segments[segment1 + 1]);                              segments.RemoveAt(segment1);                              segments.RemoveAt(segment1);                          }                            curveCount++;                          segmentCount -= 2;                      }                        // Find a segment that is connected to the tail of the contour                      segment2 = FindConnectedSegment(segments' curve[curveCount - 1]' eps);                      if (segment2 >= 0)                      {                          if (segment2 % 2 == 1)                          {                              curve.Add(segments[segment2 - 1]);                              segments.RemoveAt(segment2 - 1);                              segments.RemoveAt(segment2 - 1);                          }                          else                          {                              curve.Add(segments[segment2 + 1]);                              segments.RemoveAt(segment2);                              segments.RemoveAt(segment2);                          }                            curveCount++;                          segmentCount -= 2;                      }                  }                    if ((segment1 < 0 && segment2 < 0) || segmentCount == 0)                  {                      if (curveCount > 0)                      {                          yield return curve;                          curve = new List<Point3D>();                          curveCount = 0;                      }                        if (segmentCount > 0)                      {                          curve.Add(segments[0]);                          curve.Add(segments[1]);                          curveCount += 2;                          segments.RemoveAt(0);                          segments.RemoveAt(0);                          segmentCount -= 2;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0)              {                  if (curveCount > 0)                  {                      // Find a segment that is connected to the head of the contour                      segment1 = FindConnectedSegment(segments' curve[0]' eps);                      if (segment1 >= 0)                      {                          if (segment1 % 2 == 1)                          {                              curve.Insert(0' segments[segment1 - 1]);                              segments.RemoveAt(segment1 - 1);                              segments.RemoveAt(segment1 - 1);                          }                          else                          {                              curve.Insert(0' segments[segment1 + 1]);                              segments.RemoveAt(segment1);                              segments.RemoveAt(segment1);                          }                            curveCount++;                          segmentCount -= 2;                      }                        // Find a segment that is connected to the tail of the contour                      segment2 = FindConnectedSegment(segments' curve[curveCount - 1]' eps);                      if (segment2 >= 0)                      {                          if (segment2 % 2 == 1)                          {                              curve.Add(segments[segment2 - 1]);                              segments.RemoveAt(segment2 - 1);                              segments.RemoveAt(segment2 - 1);                          }                          else                          {                              curve.Add(segments[segment2 + 1]);                              segments.RemoveAt(segment2);                              segments.RemoveAt(segment2);                          }                            curveCount++;                          segmentCount -= 2;                      }                  }                    if ((segment1 < 0 && segment2 < 0) || segmentCount == 0)                  {                      if (curveCount > 0)                      {                          yield return curve;                          curve = new List<Point3D>();                          curveCount = 0;                      }                        if (segmentCount > 0)                      {                          curve.Add(segments[0]);                          curve.Add(segments[1]);                          curveCount += 2;                          segments.RemoveAt(0);                          segments.RemoveAt(0);                          segmentCount -= 2;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0)              {                  if (curveCount > 0)                  {                      // Find a segment that is connected to the head of the contour                      segment1 = FindConnectedSegment(segments' curve[0]' eps);                      if (segment1 >= 0)                      {                          if (segment1 % 2 == 1)                          {                              curve.Insert(0' segments[segment1 - 1]);                              segments.RemoveAt(segment1 - 1);                              segments.RemoveAt(segment1 - 1);                          }                          else                          {                              curve.Insert(0' segments[segment1 + 1]);                              segments.RemoveAt(segment1);                              segments.RemoveAt(segment1);                          }                            curveCount++;                          segmentCount -= 2;                      }                        // Find a segment that is connected to the tail of the contour                      segment2 = FindConnectedSegment(segments' curve[curveCount - 1]' eps);                      if (segment2 >= 0)                      {                          if (segment2 % 2 == 1)                          {                              curve.Add(segments[segment2 - 1]);                              segments.RemoveAt(segment2 - 1);                              segments.RemoveAt(segment2 - 1);                          }                          else                          {                              curve.Add(segments[segment2 + 1]);                              segments.RemoveAt(segment2);                              segments.RemoveAt(segment2);                          }                            curveCount++;                          segmentCount -= 2;                      }                  }                    if ((segment1 < 0 && segment2 < 0) || segmentCount == 0)                  {                      if (curveCount > 0)                      {                          yield return curve;                          curve = new List<Point3D>();                          curveCount = 0;                      }                        if (segmentCount > 0)                      {                          curve.Add(segments[0]);                          curve.Add(segments[1]);                          curveCount += 2;                          segments.RemoveAt(0);                          segments.RemoveAt(0);                          segmentCount -= 2;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0)              {                  if (curveCount > 0)                  {                      // Find a segment that is connected to the head of the contour                      segment1 = FindConnectedSegment(segments' curve[0]' eps);                      if (segment1 >= 0)                      {                          if (segment1 % 2 == 1)                          {                              curve.Insert(0' segments[segment1 - 1]);                              segments.RemoveAt(segment1 - 1);                              segments.RemoveAt(segment1 - 1);                          }                          else                          {                              curve.Insert(0' segments[segment1 + 1]);                              segments.RemoveAt(segment1);                              segments.RemoveAt(segment1);                          }                            curveCount++;                          segmentCount -= 2;                      }                        // Find a segment that is connected to the tail of the contour                      segment2 = FindConnectedSegment(segments' curve[curveCount - 1]' eps);                      if (segment2 >= 0)                      {                          if (segment2 % 2 == 1)                          {                              curve.Add(segments[segment2 - 1]);                              segments.RemoveAt(segment2 - 1);                              segments.RemoveAt(segment2 - 1);                          }                          else                          {                              curve.Add(segments[segment2 + 1]);                              segments.RemoveAt(segment2);                              segments.RemoveAt(segment2);                          }                            curveCount++;                          segmentCount -= 2;                      }                  }                    if ((segment1 < 0 && segment2 < 0) || segmentCount == 0)                  {                      if (curveCount > 0)                      {                          yield return curve;                          curve = new List<Point3D>();                          curveCount = 0;                      }                        if (segmentCount > 0)                      {                          curve.Add(segments[0]);                          curve.Add(segments[1]);                          curveCount += 2;                          segments.RemoveAt(0);                          segments.RemoveAt(0);                          segmentCount -= 2;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CombineSegments,The following statement contains a magic number: while (segmentCount > 0)              {                  if (curveCount > 0)                  {                      // Find a segment that is connected to the head of the contour                      segment1 = FindConnectedSegment(segments' curve[0]' eps);                      if (segment1 >= 0)                      {                          if (segment1 % 2 == 1)                          {                              curve.Insert(0' segments[segment1 - 1]);                              segments.RemoveAt(segment1 - 1);                              segments.RemoveAt(segment1 - 1);                          }                          else                          {                              curve.Insert(0' segments[segment1 + 1]);                              segments.RemoveAt(segment1);                              segments.RemoveAt(segment1);                          }                            curveCount++;                          segmentCount -= 2;                      }                        // Find a segment that is connected to the tail of the contour                      segment2 = FindConnectedSegment(segments' curve[curveCount - 1]' eps);                      if (segment2 >= 0)                      {                          if (segment2 % 2 == 1)                          {                              curve.Add(segments[segment2 - 1]);                              segments.RemoveAt(segment2 - 1);                              segments.RemoveAt(segment2 - 1);                          }                          else                          {                              curve.Add(segments[segment2 + 1]);                              segments.RemoveAt(segment2);                              segments.RemoveAt(segment2);                          }                            curveCount++;                          segmentCount -= 2;                      }                  }                    if ((segment1 < 0 && segment2 < 0) || segmentCount == 0)                  {                      if (curveCount > 0)                      {                          yield return curve;                          curve = new List<Point3D>();                          curveCount = 0;                      }                        if (segmentCount > 0)                      {                          curve.Add(segments[0]);                          curve.Add(segments[1]);                          curveCount += 2;                          segments.RemoveAt(0);                          segments.RemoveAt(0);                          segmentCount -= 2;                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,CreateKey,The following statement contains a magic number: return ((ulong)i0 << 32) + i1;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i0 = (uint)(key >> 32);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i1 = (uint)((key << 32) >> 32);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshGeometryHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs,ReverseKey,The following statement contains a magic number: i1 = (uint)((key << 32) >> 32);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,MeshSimplification,The following statement contains a magic number: triangles = new List<Triangle>(Enumerable.Range(0' model.TriangleIndices.Count / 3).Select(x=>new Triangle()));
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,MeshSimplification,The following statement contains a magic number: foreach(var tri in triangles)              {                  tri.v[0] = model.TriangleIndices[i++];                  tri.v[1] = model.TriangleIndices[i++];                  tri.v[2] = model.TriangleIndices[i++];              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: return Simplify(int.MaxValue' 7' verbose' true);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: int maxIteration = 9999;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: if (!lossless)              {                  maxIteration = 100;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: for (int iteration = 0; iteration < maxIteration; ++iteration)              {                  if (!lossless && triCount - deletedTris <= targetCount)                  {                      break;                  }                  if (lossless || iteration % 5 == 0)                  {                      UpdateMesh(iteration);                  }                    foreach (var tri in triangles)                  {                      tri.dirty = false;                  }                  //                  // All triangles with edges below the threshold will be removed                  //                  // The following numbers works well for most models.                  // If it does not' try to adjust the 3 parameters                  //                  double threshold = 0.001;                  if(!lossless)                      threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);                  if (verbose)                  {                      Debug.WriteLine($"Iteration: {iteration}; Triangles: {triCount - deletedTris}; Threshold: {threshold};");                  }                    foreach (var tri in triangles)                  {                      if (tri.err[3] > threshold || tri.deleted || tri.dirty) { continue; }                        for (int j = 0; j < 3; ++j)                      {                          if (tri.err[j] < threshold)                          {                              int i0 = tri.v[j];                              var v0 = vertices[i0];                              int i1 = tri.v[(j + 1) % 3];                              var v1 = vertices[i1];                              //border check                              if (v0.border != v1.border)                              {                                  continue;                              }                              //Compute vertex to collapse to                              Vector3D p;                              CalculateError(i0' i1' out p);                              deleted0.Clear();                              deleted1.Clear();                              deleted0.AddRange(Enumerable.Repeat(false' v0.tCount));                              deleted1.AddRange(Enumerable.Repeat(false' v1.tCount));                                if (Flipped(ref p' i0' i1' ref v0' ref v1' deleted0)                                  || Flipped(ref p' i1' i0' ref v1' ref v0' deleted1))                              { continue; }                              v0.p = p;                              v0.q = v1.q + v0.q;                                int tStart = refs.Count;                              UpdateTriangles(i0' ref v0' deleted0' ref deletedTris);                              UpdateTriangles(i0' ref v1' deleted1' ref deletedTris);                                int tcount = refs.Count - tStart;                              if (tcount <= v0.tCount)                              {                                  if (tcount > 0)                                  {                                      for (int k = 0; k < tcount; ++k)                                      {                                          refs[v0.tStart + k] = refs[tStart + k];                                      }                                  }                              }                              else                              {                                  v0.tStart = tStart;                              }                                v0.tCount = tcount;                              break;                          }                        }                      if (!lossless && triCount - deletedTris <= targetCount)                      {                          break;                      }                  }                  if (lossless)                  {                      if (deletedTris <= 0)                      {                          break;                      }                      deletedTris = 0;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: for (int iteration = 0; iteration < maxIteration; ++iteration)              {                  if (!lossless && triCount - deletedTris <= targetCount)                  {                      break;                  }                  if (lossless || iteration % 5 == 0)                  {                      UpdateMesh(iteration);                  }                    foreach (var tri in triangles)                  {                      tri.dirty = false;                  }                  //                  // All triangles with edges below the threshold will be removed                  //                  // The following numbers works well for most models.                  // If it does not' try to adjust the 3 parameters                  //                  double threshold = 0.001;                  if(!lossless)                      threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);                  if (verbose)                  {                      Debug.WriteLine($"Iteration: {iteration}; Triangles: {triCount - deletedTris}; Threshold: {threshold};");                  }                    foreach (var tri in triangles)                  {                      if (tri.err[3] > threshold || tri.deleted || tri.dirty) { continue; }                        for (int j = 0; j < 3; ++j)                      {                          if (tri.err[j] < threshold)                          {                              int i0 = tri.v[j];                              var v0 = vertices[i0];                              int i1 = tri.v[(j + 1) % 3];                              var v1 = vertices[i1];                              //border check                              if (v0.border != v1.border)                              {                                  continue;                              }                              //Compute vertex to collapse to                              Vector3D p;                              CalculateError(i0' i1' out p);                              deleted0.Clear();                              deleted1.Clear();                              deleted0.AddRange(Enumerable.Repeat(false' v0.tCount));                              deleted1.AddRange(Enumerable.Repeat(false' v1.tCount));                                if (Flipped(ref p' i0' i1' ref v0' ref v1' deleted0)                                  || Flipped(ref p' i1' i0' ref v1' ref v0' deleted1))                              { continue; }                              v0.p = p;                              v0.q = v1.q + v0.q;                                int tStart = refs.Count;                              UpdateTriangles(i0' ref v0' deleted0' ref deletedTris);                              UpdateTriangles(i0' ref v1' deleted1' ref deletedTris);                                int tcount = refs.Count - tStart;                              if (tcount <= v0.tCount)                              {                                  if (tcount > 0)                                  {                                      for (int k = 0; k < tcount; ++k)                                      {                                          refs[v0.tStart + k] = refs[tStart + k];                                      }                                  }                              }                              else                              {                                  v0.tStart = tStart;                              }                                v0.tCount = tcount;                              break;                          }                        }                      if (!lossless && triCount - deletedTris <= targetCount)                      {                          break;                      }                  }                  if (lossless)                  {                      if (deletedTris <= 0)                      {                          break;                      }                      deletedTris = 0;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: for (int iteration = 0; iteration < maxIteration; ++iteration)              {                  if (!lossless && triCount - deletedTris <= targetCount)                  {                      break;                  }                  if (lossless || iteration % 5 == 0)                  {                      UpdateMesh(iteration);                  }                    foreach (var tri in triangles)                  {                      tri.dirty = false;                  }                  //                  // All triangles with edges below the threshold will be removed                  //                  // The following numbers works well for most models.                  // If it does not' try to adjust the 3 parameters                  //                  double threshold = 0.001;                  if(!lossless)                      threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);                  if (verbose)                  {                      Debug.WriteLine($"Iteration: {iteration}; Triangles: {triCount - deletedTris}; Threshold: {threshold};");                  }                    foreach (var tri in triangles)                  {                      if (tri.err[3] > threshold || tri.deleted || tri.dirty) { continue; }                        for (int j = 0; j < 3; ++j)                      {                          if (tri.err[j] < threshold)                          {                              int i0 = tri.v[j];                              var v0 = vertices[i0];                              int i1 = tri.v[(j + 1) % 3];                              var v1 = vertices[i1];                              //border check                              if (v0.border != v1.border)                              {                                  continue;                              }                              //Compute vertex to collapse to                              Vector3D p;                              CalculateError(i0' i1' out p);                              deleted0.Clear();                              deleted1.Clear();                              deleted0.AddRange(Enumerable.Repeat(false' v0.tCount));                              deleted1.AddRange(Enumerable.Repeat(false' v1.tCount));                                if (Flipped(ref p' i0' i1' ref v0' ref v1' deleted0)                                  || Flipped(ref p' i1' i0' ref v1' ref v0' deleted1))                              { continue; }                              v0.p = p;                              v0.q = v1.q + v0.q;                                int tStart = refs.Count;                              UpdateTriangles(i0' ref v0' deleted0' ref deletedTris);                              UpdateTriangles(i0' ref v1' deleted1' ref deletedTris);                                int tcount = refs.Count - tStart;                              if (tcount <= v0.tCount)                              {                                  if (tcount > 0)                                  {                                      for (int k = 0; k < tcount; ++k)                                      {                                          refs[v0.tStart + k] = refs[tStart + k];                                      }                                  }                              }                              else                              {                                  v0.tStart = tStart;                              }                                v0.tCount = tcount;                              break;                          }                        }                      if (!lossless && triCount - deletedTris <= targetCount)                      {                          break;                      }                  }                  if (lossless)                  {                      if (deletedTris <= 0)                      {                          break;                      }                      deletedTris = 0;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: for (int iteration = 0; iteration < maxIteration; ++iteration)              {                  if (!lossless && triCount - deletedTris <= targetCount)                  {                      break;                  }                  if (lossless || iteration % 5 == 0)                  {                      UpdateMesh(iteration);                  }                    foreach (var tri in triangles)                  {                      tri.dirty = false;                  }                  //                  // All triangles with edges below the threshold will be removed                  //                  // The following numbers works well for most models.                  // If it does not' try to adjust the 3 parameters                  //                  double threshold = 0.001;                  if(!lossless)                      threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);                  if (verbose)                  {                      Debug.WriteLine($"Iteration: {iteration}; Triangles: {triCount - deletedTris}; Threshold: {threshold};");                  }                    foreach (var tri in triangles)                  {                      if (tri.err[3] > threshold || tri.deleted || tri.dirty) { continue; }                        for (int j = 0; j < 3; ++j)                      {                          if (tri.err[j] < threshold)                          {                              int i0 = tri.v[j];                              var v0 = vertices[i0];                              int i1 = tri.v[(j + 1) % 3];                              var v1 = vertices[i1];                              //border check                              if (v0.border != v1.border)                              {                                  continue;                              }                              //Compute vertex to collapse to                              Vector3D p;                              CalculateError(i0' i1' out p);                              deleted0.Clear();                              deleted1.Clear();                              deleted0.AddRange(Enumerable.Repeat(false' v0.tCount));                              deleted1.AddRange(Enumerable.Repeat(false' v1.tCount));                                if (Flipped(ref p' i0' i1' ref v0' ref v1' deleted0)                                  || Flipped(ref p' i1' i0' ref v1' ref v0' deleted1))                              { continue; }                              v0.p = p;                              v0.q = v1.q + v0.q;                                int tStart = refs.Count;                              UpdateTriangles(i0' ref v0' deleted0' ref deletedTris);                              UpdateTriangles(i0' ref v1' deleted1' ref deletedTris);                                int tcount = refs.Count - tStart;                              if (tcount <= v0.tCount)                              {                                  if (tcount > 0)                                  {                                      for (int k = 0; k < tcount; ++k)                                      {                                          refs[v0.tStart + k] = refs[tStart + k];                                      }                                  }                              }                              else                              {                                  v0.tStart = tStart;                              }                                v0.tCount = tcount;                              break;                          }                        }                      if (!lossless && triCount - deletedTris <= targetCount)                      {                          break;                      }                  }                  if (lossless)                  {                      if (deletedTris <= 0)                      {                          break;                      }                      deletedTris = 0;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: for (int iteration = 0; iteration < maxIteration; ++iteration)              {                  if (!lossless && triCount - deletedTris <= targetCount)                  {                      break;                  }                  if (lossless || iteration % 5 == 0)                  {                      UpdateMesh(iteration);                  }                    foreach (var tri in triangles)                  {                      tri.dirty = false;                  }                  //                  // All triangles with edges below the threshold will be removed                  //                  // The following numbers works well for most models.                  // If it does not' try to adjust the 3 parameters                  //                  double threshold = 0.001;                  if(!lossless)                      threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);                  if (verbose)                  {                      Debug.WriteLine($"Iteration: {iteration}; Triangles: {triCount - deletedTris}; Threshold: {threshold};");                  }                    foreach (var tri in triangles)                  {                      if (tri.err[3] > threshold || tri.deleted || tri.dirty) { continue; }                        for (int j = 0; j < 3; ++j)                      {                          if (tri.err[j] < threshold)                          {                              int i0 = tri.v[j];                              var v0 = vertices[i0];                              int i1 = tri.v[(j + 1) % 3];                              var v1 = vertices[i1];                              //border check                              if (v0.border != v1.border)                              {                                  continue;                              }                              //Compute vertex to collapse to                              Vector3D p;                              CalculateError(i0' i1' out p);                              deleted0.Clear();                              deleted1.Clear();                              deleted0.AddRange(Enumerable.Repeat(false' v0.tCount));                              deleted1.AddRange(Enumerable.Repeat(false' v1.tCount));                                if (Flipped(ref p' i0' i1' ref v0' ref v1' deleted0)                                  || Flipped(ref p' i1' i0' ref v1' ref v0' deleted1))                              { continue; }                              v0.p = p;                              v0.q = v1.q + v0.q;                                int tStart = refs.Count;                              UpdateTriangles(i0' ref v0' deleted0' ref deletedTris);                              UpdateTriangles(i0' ref v1' deleted1' ref deletedTris);                                int tcount = refs.Count - tStart;                              if (tcount <= v0.tCount)                              {                                  if (tcount > 0)                                  {                                      for (int k = 0; k < tcount; ++k)                                      {                                          refs[v0.tStart + k] = refs[tStart + k];                                      }                                  }                              }                              else                              {                                  v0.tStart = tStart;                              }                                v0.tCount = tcount;                              break;                          }                        }                      if (!lossless && triCount - deletedTris <= targetCount)                      {                          break;                      }                  }                  if (lossless)                  {                      if (deletedTris <= 0)                      {                          break;                      }                      deletedTris = 0;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: for (int iteration = 0; iteration < maxIteration; ++iteration)              {                  if (!lossless && triCount - deletedTris <= targetCount)                  {                      break;                  }                  if (lossless || iteration % 5 == 0)                  {                      UpdateMesh(iteration);                  }                    foreach (var tri in triangles)                  {                      tri.dirty = false;                  }                  //                  // All triangles with edges below the threshold will be removed                  //                  // The following numbers works well for most models.                  // If it does not' try to adjust the 3 parameters                  //                  double threshold = 0.001;                  if(!lossless)                      threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);                  if (verbose)                  {                      Debug.WriteLine($"Iteration: {iteration}; Triangles: {triCount - deletedTris}; Threshold: {threshold};");                  }                    foreach (var tri in triangles)                  {                      if (tri.err[3] > threshold || tri.deleted || tri.dirty) { continue; }                        for (int j = 0; j < 3; ++j)                      {                          if (tri.err[j] < threshold)                          {                              int i0 = tri.v[j];                              var v0 = vertices[i0];                              int i1 = tri.v[(j + 1) % 3];                              var v1 = vertices[i1];                              //border check                              if (v0.border != v1.border)                              {                                  continue;                              }                              //Compute vertex to collapse to                              Vector3D p;                              CalculateError(i0' i1' out p);                              deleted0.Clear();                              deleted1.Clear();                              deleted0.AddRange(Enumerable.Repeat(false' v0.tCount));                              deleted1.AddRange(Enumerable.Repeat(false' v1.tCount));                                if (Flipped(ref p' i0' i1' ref v0' ref v1' deleted0)                                  || Flipped(ref p' i1' i0' ref v1' ref v0' deleted1))                              { continue; }                              v0.p = p;                              v0.q = v1.q + v0.q;                                int tStart = refs.Count;                              UpdateTriangles(i0' ref v0' deleted0' ref deletedTris);                              UpdateTriangles(i0' ref v1' deleted1' ref deletedTris);                                int tcount = refs.Count - tStart;                              if (tcount <= v0.tCount)                              {                                  if (tcount > 0)                                  {                                      for (int k = 0; k < tcount; ++k)                                      {                                          refs[v0.tStart + k] = refs[tStart + k];                                      }                                  }                              }                              else                              {                                  v0.tStart = tStart;                              }                                v0.tCount = tcount;                              break;                          }                        }                      if (!lossless && triCount - deletedTris <= targetCount)                      {                          break;                      }                  }                  if (lossless)                  {                      if (deletedTris <= 0)                      {                          break;                      }                      deletedTris = 0;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Simplify,The following statement contains a magic number: for (int iteration = 0; iteration < maxIteration; ++iteration)              {                  if (!lossless && triCount - deletedTris <= targetCount)                  {                      break;                  }                  if (lossless || iteration % 5 == 0)                  {                      UpdateMesh(iteration);                  }                    foreach (var tri in triangles)                  {                      tri.dirty = false;                  }                  //                  // All triangles with edges below the threshold will be removed                  //                  // The following numbers works well for most models.                  // If it does not' try to adjust the 3 parameters                  //                  double threshold = 0.001;                  if(!lossless)                      threshold = 0.000000001 * Math.Pow(iteration + 3.0' aggressive);                  if (verbose)                  {                      Debug.WriteLine($"Iteration: {iteration}; Triangles: {triCount - deletedTris}; Threshold: {threshold};");                  }                    foreach (var tri in triangles)                  {                      if (tri.err[3] > threshold || tri.deleted || tri.dirty) { continue; }                        for (int j = 0; j < 3; ++j)                      {                          if (tri.err[j] < threshold)                          {                              int i0 = tri.v[j];                              var v0 = vertices[i0];                              int i1 = tri.v[(j + 1) % 3];                              var v1 = vertices[i1];                              //border check                              if (v0.border != v1.border)                              {                                  continue;                              }                              //Compute vertex to collapse to                              Vector3D p;                              CalculateError(i0' i1' out p);                              deleted0.Clear();                              deleted1.Clear();                              deleted0.AddRange(Enumerable.Repeat(false' v0.tCount));                              deleted1.AddRange(Enumerable.Repeat(false' v1.tCount));                                if (Flipped(ref p' i0' i1' ref v0' ref v1' deleted0)                                  || Flipped(ref p' i1' i0' ref v1' ref v0' deleted1))                              { continue; }                              v0.p = p;                              v0.q = v1.q + v0.q;                                int tStart = refs.Count;                              UpdateTriangles(i0' ref v0' deleted0' ref deletedTris);                              UpdateTriangles(i0' ref v1' deleted1' ref deletedTris);                                int tcount = refs.Count - tStart;                              if (tcount <= v0.tCount)                              {                                  if (tcount > 0)                                  {                                      for (int k = 0; k < tcount; ++k)                                      {                                          refs[v0.tStart + k] = refs[tStart + k];                                      }                                  }                              }                              else                              {                                  v0.tStart = tStart;                              }                                v0.tCount = tcount;                              break;                          }                        }                      if (!lossless && triCount - deletedTris <= targetCount)                      {                          break;                      }                  }                  if (lossless)                  {                      if (deletedTris <= 0)                      {                          break;                      }                      deletedTris = 0;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,GetMesh,The following statement contains a magic number: var tris = new Int32Collection(triangles.Count*3);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,GetMesh,The following statement contains a magic number: foreach (var tri in triangles)              {                  tris.Add(tri.v[0]);                  tris.Add(tri.v[1]);                  tris.Add(tri.v[2]);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: for (int i = 0; i < v0.tCount; ++i)              {                  var t = triangles[refs[v0.tStart + i].tid];                  if (t.deleted) { continue; }                  int s = refs[v0.tStart + i].tvertex;                  int id1 = t.v[(s + 1) % 3];                  int id2 = t.v[(s + 2) % 3];                  if (id1 == i1 || id2 == i1)                  {                      deleted[i] = true;                      continue;                  }                    Vector3D d1 = vertices[id1].p - p;                  d1.Normalize();                  Vector3D d2 = vertices[id2].p - p;                  d2.Normalize();                  if (SharedFunctions.DotProduct(ref d1' ref d2) > 0.999)                  {                      return true;                  }                  var n = SharedFunctions.CrossProduct(ref d1' ref d2);                  n.Normalize();                  deleted[i] = false;                  if (SharedFunctions.DotProduct(ref n' ref t.normal) < 0.2)                  {                      return true;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: for (int i = 0; i < v0.tCount; ++i)              {                  var t = triangles[refs[v0.tStart + i].tid];                  if (t.deleted) { continue; }                  int s = refs[v0.tStart + i].tvertex;                  int id1 = t.v[(s + 1) % 3];                  int id2 = t.v[(s + 2) % 3];                  if (id1 == i1 || id2 == i1)                  {                      deleted[i] = true;                      continue;                  }                    Vector3D d1 = vertices[id1].p - p;                  d1.Normalize();                  Vector3D d2 = vertices[id2].p - p;                  d2.Normalize();                  if (SharedFunctions.DotProduct(ref d1' ref d2) > 0.999)                  {                      return true;                  }                  var n = SharedFunctions.CrossProduct(ref d1' ref d2);                  n.Normalize();                  deleted[i] = false;                  if (SharedFunctions.DotProduct(ref n' ref t.normal) < 0.2)                  {                      return true;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: for (int i = 0; i < v0.tCount; ++i)              {                  var t = triangles[refs[v0.tStart + i].tid];                  if (t.deleted) { continue; }                  int s = refs[v0.tStart + i].tvertex;                  int id1 = t.v[(s + 1) % 3];                  int id2 = t.v[(s + 2) % 3];                  if (id1 == i1 || id2 == i1)                  {                      deleted[i] = true;                      continue;                  }                    Vector3D d1 = vertices[id1].p - p;                  d1.Normalize();                  Vector3D d2 = vertices[id2].p - p;                  d2.Normalize();                  if (SharedFunctions.DotProduct(ref d1' ref d2) > 0.999)                  {                      return true;                  }                  var n = SharedFunctions.CrossProduct(ref d1' ref d2);                  n.Normalize();                  deleted[i] = false;                  if (SharedFunctions.DotProduct(ref n' ref t.normal) < 0.2)                  {                      return true;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: for (int i = 0; i < v0.tCount; ++i)              {                  var t = triangles[refs[v0.tStart + i].tid];                  if (t.deleted) { continue; }                  int s = refs[v0.tStart + i].tvertex;                  int id1 = t.v[(s + 1) % 3];                  int id2 = t.v[(s + 2) % 3];                  if (id1 == i1 || id2 == i1)                  {                      deleted[i] = true;                      continue;                  }                    Vector3D d1 = vertices[id1].p - p;                  d1.Normalize();                  Vector3D d2 = vertices[id2].p - p;                  d2.Normalize();                  if (SharedFunctions.DotProduct(ref d1' ref d2) > 0.999)                  {                      return true;                  }                  var n = SharedFunctions.CrossProduct(ref d1' ref d2);                  n.Normalize();                  deleted[i] = false;                  if (SharedFunctions.DotProduct(ref n' ref t.normal) < 0.2)                  {                      return true;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Flipped,The following statement contains a magic number: for (int i = 0; i < v0.tCount; ++i)              {                  var t = triangles[refs[v0.tStart + i].tid];                  if (t.deleted) { continue; }                  int s = refs[v0.tStart + i].tvertex;                  int id1 = t.v[(s + 1) % 3];                  int id2 = t.v[(s + 2) % 3];                  if (id1 == i1 || id2 == i1)                  {                      deleted[i] = true;                      continue;                  }                    Vector3D d1 = vertices[id1].p - p;                  d1.Normalize();                  Vector3D d2 = vertices[id2].p - p;                  d2.Normalize();                  if (SharedFunctions.DotProduct(ref d1' ref d2) > 0.999)                  {                      return true;                  }                  var n = SharedFunctions.CrossProduct(ref d1' ref d2);                  n.Normalize();                  deleted[i] = false;                  if (SharedFunctions.DotProduct(ref n' ref t.normal) < 0.2)                  {                      return true;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: for (int i = 0; i < v.tCount; ++i)              {                  var r = refs[v.tStart + i];                  var t = triangles[r.tid];                  if (t.deleted) { continue; }                  if (deleted[i])                  {                      t.deleted = true;                      deletedTriangles++;                      continue;                  }                    t.v[r.tvertex] = i0;                  t.dirty = true;                  t.err[0] = CalculateError(t.v[0]' t.v[1]' out p);                  t.err[1] = CalculateError(t.v[1]' t.v[2]' out p);                  t.err[2] = CalculateError(t.v[2]' t.v[0]' out p);                  t.err[3] = Math.Min(t.err[0]' Math.Min(t.err[1]' t.err[2]));                  refs.Add(r);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: for (int i = 0; i < v.tCount; ++i)              {                  var r = refs[v.tStart + i];                  var t = triangles[r.tid];                  if (t.deleted) { continue; }                  if (deleted[i])                  {                      t.deleted = true;                      deletedTriangles++;                      continue;                  }                    t.v[r.tvertex] = i0;                  t.dirty = true;                  t.err[0] = CalculateError(t.v[0]' t.v[1]' out p);                  t.err[1] = CalculateError(t.v[1]' t.v[2]' out p);                  t.err[2] = CalculateError(t.v[2]' t.v[0]' out p);                  t.err[3] = Math.Min(t.err[0]' Math.Min(t.err[1]' t.err[2]));                  refs.Add(r);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: for (int i = 0; i < v.tCount; ++i)              {                  var r = refs[v.tStart + i];                  var t = triangles[r.tid];                  if (t.deleted) { continue; }                  if (deleted[i])                  {                      t.deleted = true;                      deletedTriangles++;                      continue;                  }                    t.v[r.tvertex] = i0;                  t.dirty = true;                  t.err[0] = CalculateError(t.v[0]' t.v[1]' out p);                  t.err[1] = CalculateError(t.v[1]' t.v[2]' out p);                  t.err[2] = CalculateError(t.v[2]' t.v[0]' out p);                  t.err[3] = Math.Min(t.err[0]' Math.Min(t.err[1]' t.err[2]));                  refs.Add(r);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: for (int i = 0; i < v.tCount; ++i)              {                  var r = refs[v.tStart + i];                  var t = triangles[r.tid];                  if (t.deleted) { continue; }                  if (deleted[i])                  {                      t.deleted = true;                      deletedTriangles++;                      continue;                  }                    t.v[r.tvertex] = i0;                  t.dirty = true;                  t.err[0] = CalculateError(t.v[0]' t.v[1]' out p);                  t.err[1] = CalculateError(t.v[1]' t.v[2]' out p);                  t.err[2] = CalculateError(t.v[2]' t.v[0]' out p);                  t.err[3] = Math.Min(t.err[0]' Math.Min(t.err[1]' t.err[2]));                  refs.Add(r);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateTriangles,The following statement contains a magic number: for (int i = 0; i < v.tCount; ++i)              {                  var r = refs[v.tStart + i];                  var t = triangles[r.tid];                  if (t.deleted) { continue; }                  if (deleted[i])                  {                      t.deleted = true;                      deletedTriangles++;                      continue;                  }                    t.v[r.tvertex] = i0;                  t.dirty = true;                  t.err[0] = CalculateError(t.v[0]' t.v[1]' out p);                  t.err[1] = CalculateError(t.v[1]' t.v[2]' out p);                  t.err[2] = CalculateError(t.v[2]' t.v[0]' out p);                  t.err[3] = Math.Min(t.err[0]' Math.Min(t.err[1]' t.err[2]));                  refs.Add(r);              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: double det = q.det(0' 1' 2' 1' 4' 5' 2' 5' 7);
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CalculateError,The following statement contains a magic number: if (det != 0 && !border)              {                  // q_delta is invertible                  p_result.X = (float)(-1 / det * (q.det(1' 2' 3' 4' 5' 6' 5' 7' 8))); // vx = A41/det(q_delta)                  p_result.Y = (float)(1 / det * (q.det(0' 2' 3' 1' 5' 6' 2' 7' 8)));  // vy = A42/det(q_delta)                  p_result.Z = (float)(-1 / det * (q.det(0' 1' 3' 1' 4' 6' 2' 5' 8))); // vz = A43/det(q_delta)                    error = VertexError(ref q' p_result.X' p_result.Y' p_result.Z);              }              else              {                  // det = 0 -> try to find best result                  var p1 = vertices[id_v1].p;                  var p2 = vertices[id_v2].p;                  var p3 = (p1 + p2) / 2;                  double error1 = VertexError(ref q' p1.X' p1.Y' p1.Z);                  double error2 = VertexError(ref q' p2.X' p2.Y' p2.Z);                  double error3 = VertexError(ref q' p3.X' p3.Y' p3.Z);                  error = Math.Min(error1' Math.Min(error2' error3));                  if (error1 == error) p_result = p1;                  if (error2 == error) p_result = p2;                  if (error3 == error) p_result = p3;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,VertexError,The following statement contains a magic number: return q.M11 * x * x + 2 * q.M12 * x * y + 2 * q.M13 * x * z + 2 * q.M14 * x + q.M22 * y * y                   + 2 * q.M23 * y * z + 2 * q.M24 * y + q.M33 * z * z + 2 * q.M34 * z + q.M44;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: if (iteration == 0)              {                  foreach (var vert in vertices)                  {                      vert.q.SetAll(0);                  }                    foreach (var tri in triangles)                  {                      var p0 = vertices[tri.v[0]].p;                      var p1 = vertices[tri.v[1]].p;                      var p2 = vertices[tri.v[2]].p;                      var n = SharedFunctions.CrossProduct(p1 - p0' p2 - p0);                      n.Normalize();                      tri.normal = n;                      for (int j = 0; j < 3; ++j)                      {                          vertices[tri.v[j]].q += new SymmetricMatrix(n.X' n.Y' n.Z' -SharedFunctions.DotProduct(ref n' ref p0));                      }                  }                  Vector3D p;                  foreach (var tri in triangles)                  {                      for (int i = 0; i < 3; ++i)                      {                                                 tri.err[i] = CalculateError(tri.v[i]' tri.v[(i + 1) % 3]' out p);                      }                      tri.err[3] = Math.Min(tri.err[0]' Math.Min(tri.err[1]' tri.err[2]));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: if (iteration == 0)              {                  foreach (var vert in vertices)                  {                      vert.q.SetAll(0);                  }                    foreach (var tri in triangles)                  {                      var p0 = vertices[tri.v[0]].p;                      var p1 = vertices[tri.v[1]].p;                      var p2 = vertices[tri.v[2]].p;                      var n = SharedFunctions.CrossProduct(p1 - p0' p2 - p0);                      n.Normalize();                      tri.normal = n;                      for (int j = 0; j < 3; ++j)                      {                          vertices[tri.v[j]].q += new SymmetricMatrix(n.X' n.Y' n.Z' -SharedFunctions.DotProduct(ref n' ref p0));                      }                  }                  Vector3D p;                  foreach (var tri in triangles)                  {                      for (int i = 0; i < 3; ++i)                      {                                                 tri.err[i] = CalculateError(tri.v[i]' tri.v[(i + 1) % 3]' out p);                      }                      tri.err[3] = Math.Min(tri.err[0]' Math.Min(tri.err[1]' tri.err[2]));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: if (iteration == 0)              {                  foreach (var vert in vertices)                  {                      vert.q.SetAll(0);                  }                    foreach (var tri in triangles)                  {                      var p0 = vertices[tri.v[0]].p;                      var p1 = vertices[tri.v[1]].p;                      var p2 = vertices[tri.v[2]].p;                      var n = SharedFunctions.CrossProduct(p1 - p0' p2 - p0);                      n.Normalize();                      tri.normal = n;                      for (int j = 0; j < 3; ++j)                      {                          vertices[tri.v[j]].q += new SymmetricMatrix(n.X' n.Y' n.Z' -SharedFunctions.DotProduct(ref n' ref p0));                      }                  }                  Vector3D p;                  foreach (var tri in triangles)                  {                      for (int i = 0; i < 3; ++i)                      {                                                 tri.err[i] = CalculateError(tri.v[i]' tri.v[(i + 1) % 3]' out p);                      }                      tri.err[3] = Math.Min(tri.err[0]' Math.Min(tri.err[1]' tri.err[2]));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: if (iteration == 0)              {                  foreach (var vert in vertices)                  {                      vert.q.SetAll(0);                  }                    foreach (var tri in triangles)                  {                      var p0 = vertices[tri.v[0]].p;                      var p1 = vertices[tri.v[1]].p;                      var p2 = vertices[tri.v[2]].p;                      var n = SharedFunctions.CrossProduct(p1 - p0' p2 - p0);                      n.Normalize();                      tri.normal = n;                      for (int j = 0; j < 3; ++j)                      {                          vertices[tri.v[j]].q += new SymmetricMatrix(n.X' n.Y' n.Z' -SharedFunctions.DotProduct(ref n' ref p0));                      }                  }                  Vector3D p;                  foreach (var tri in triangles)                  {                      for (int i = 0; i < 3; ++i)                      {                                                 tri.err[i] = CalculateError(tri.v[i]' tri.v[(i + 1) % 3]' out p);                      }                      tri.err[3] = Math.Min(tri.err[0]' Math.Min(tri.err[1]' tri.err[2]));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: if (iteration == 0)              {                  foreach (var vert in vertices)                  {                      vert.q.SetAll(0);                  }                    foreach (var tri in triangles)                  {                      var p0 = vertices[tri.v[0]].p;                      var p1 = vertices[tri.v[1]].p;                      var p2 = vertices[tri.v[2]].p;                      var n = SharedFunctions.CrossProduct(p1 - p0' p2 - p0);                      n.Normalize();                      tri.normal = n;                      for (int j = 0; j < 3; ++j)                      {                          vertices[tri.v[j]].q += new SymmetricMatrix(n.X' n.Y' n.Z' -SharedFunctions.DotProduct(ref n' ref p0));                      }                  }                  Vector3D p;                  foreach (var tri in triangles)                  {                      for (int i = 0; i < 3; ++i)                      {                                                 tri.err[i] = CalculateError(tri.v[i]' tri.v[(i + 1) % 3]' out p);                      }                      tri.err[3] = Math.Min(tri.err[0]' Math.Min(tri.err[1]' tri.err[2]));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: if (iteration == 0)              {                  foreach (var vert in vertices)                  {                      vert.q.SetAll(0);                  }                    foreach (var tri in triangles)                  {                      var p0 = vertices[tri.v[0]].p;                      var p1 = vertices[tri.v[1]].p;                      var p2 = vertices[tri.v[2]].p;                      var n = SharedFunctions.CrossProduct(p1 - p0' p2 - p0);                      n.Normalize();                      tri.normal = n;                      for (int j = 0; j < 3; ++j)                      {                          vertices[tri.v[j]].q += new SymmetricMatrix(n.X' n.Y' n.Z' -SharedFunctions.DotProduct(ref n' ref p0));                      }                  }                  Vector3D p;                  foreach (var tri in triangles)                  {                      for (int i = 0; i < 3; ++i)                      {                                                 tri.err[i] = CalculateError(tri.v[i]' tri.v[(i + 1) % 3]' out p);                      }                      tri.err[3] = Math.Min(tri.err[0]' Math.Min(tri.err[1]' tri.err[2]));                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: foreach (var tri in triangles)              {                  vertices[tri.v[0]].tCount++;                  vertices[tri.v[1]].tCount++;                  vertices[tri.v[2]].tCount++;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: int totalTris = triangles.Count * 3;
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: foreach (var tri in triangles)              {                  for (int j = 0; j < 3; ++j)                  {                      var v = vertices[tri.v[j]];                      var r = refs[v.tStart + v.tCount];                      r.tid = count;                      r.tvertex = j;                      refs[v.tStart + v.tCount] = r;                      v.tCount++;                                        }                  ++count;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,UpdateMesh,The following statement contains a magic number: if (iteration == 0)              {                  var vCount = new List<int>();                  var vids = new List<int>();                  foreach (var vert in vertices)                  {                      vert.border = false;                  }                    foreach (var vert in vertices)                  {                      vCount.Clear();                      vids.Clear();                      for (int j = 0; j < vert.tCount; ++j)                      {                          var t = triangles[refs[vert.tStart + j].tid];                          for (int k = 0; k < 3; ++k)                          {                              int ofs = 0;                              int id = t.v[k];                              while (ofs < vCount.Count)                              {                                  if (vids[ofs] == id) { break; }                                  ++ofs;                              }                              if (ofs == vCount.Count)                              {                                  vCount.Add(1);                                  vids.Add(id);                              }                              else                              {                                  vCount[ofs]++;                              }                          }                      }                        for (int j = 0; j < vCount.Count; ++j)                      {                          if (vCount[j] == 1)                          {                              vertices[vids[j]].border = true;                          }                      }                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CompactMesh,The following statement contains a magic number: for (int i = 0; i < triangles.Count; ++i)              {                  if (!triangles[i].deleted)                  {                      triangles[dst++] = triangles[i];                      vertices[triangles[i].v[0]].tCount = 1;                      vertices[triangles[i].v[1]].tCount = 1;                      vertices[triangles[i].v[2]].tCount = 1;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CompactMesh,The following statement contains a magic number: foreach (var tri in triangles)              {                  tri.v[0] = vertices[tri.v[0]].tStart;                  tri.v[1] = vertices[tri.v[1]].tStart;                  tri.v[2] = vertices[tri.v[2]].tStart;              }
Magic Number,HelixToolkit.Wpf.SharpDX,MeshSimplification,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,CompactMesh,The following statement contains a magic number: foreach (var tri in triangles)              {                  tri.v[0] = vertices[tri.v[0]].tStart;                  tri.v[1] = vertices[tri.v[1]].tStart;                  tri.v[2] = vertices[tri.v[2]].tStart;              }
Magic Number,HelixToolkit.Wpf.SharpDX,Triangle,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Clone,The following statement contains a magic number: t.v[2] = this.v[2];
Magic Number,HelixToolkit.Wpf.SharpDX,Triangle,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Clone,The following statement contains a magic number: t.v[2] = this.v[2];
Magic Number,HelixToolkit.Wpf.SharpDX,Triangle,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Clone,The following statement contains a magic number: t.err[2] = this.err[2];
Magic Number,HelixToolkit.Wpf.SharpDX,Triangle,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Clone,The following statement contains a magic number: t.err[2] = this.err[2];
Magic Number,HelixToolkit.Wpf.SharpDX,Triangle,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Clone,The following statement contains a magic number: t.err[3] = this.err[3];
Magic Number,HelixToolkit.Wpf.SharpDX,Triangle,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\MeshSimplification.cs,Clone,The following statement contains a magic number: t.err[3] = this.err[3];
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: if (this.Points.Count < 3)              {                  throw new InvalidOperationException("At least three points required in the polygon to find a normal.");              }
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++)              {  #if SHARPDX                  var n = Vector3D.Cross(v1' this.Points[i] - this.Points[0]);                    if (n.LengthSquared() > 1e-10)  #else                  var n = Vector3D.CrossProduct(v1' this.Points[i] - this.Points[0]);                    if (n.LengthSquared > 1e-10)  #endif                  {                      n.Normalize();                      return n;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++)              {  #if SHARPDX                  var n = Vector3D.Cross(v1' this.Points[i] - this.Points[0]);                    if (n.LengthSquared() > 1e-10)  #else                  var n = Vector3D.CrossProduct(v1' this.Points[i] - this.Points[0]);                    if (n.LengthSquared > 1e-10)  #endif                  {                      n.Normalize();                      return n;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,GetNormal,The following statement contains a magic number: Vector3D result = Vector3D.Cross(v1' this.Points[2] - this.Points[0]);
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,IsPlanar,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++)              {  #if SHARPDX                  var n = Vector3D.Cross(v1' this.Points[i] - this.Points[0]);  #else                  var n = Vector3D.CrossProduct(v1' this.Points[i] - this.Points[0]);  #endif                  n.Normalize();                  if (i == 2)                  {                      normal = n;                  }  #if SHARPDX                  else if (Math.Abs(Vector3D.Dot(n' normal) - 1) > 1e-8)  #else                  else if (Math.Abs(Vector3D.DotProduct(n' normal) - 1) > 1e-8)  #endif                  {                      return false;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,IsPlanar,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++)              {  #if SHARPDX                  var n = Vector3D.Cross(v1' this.Points[i] - this.Points[0]);  #else                  var n = Vector3D.CrossProduct(v1' this.Points[i] - this.Points[0]);  #endif                  n.Normalize();                  if (i == 2)                  {                      normal = n;                  }  #if SHARPDX                  else if (Math.Abs(Vector3D.Dot(n' normal) - 1) > 1e-8)  #else                  else if (Math.Abs(Vector3D.DotProduct(n' normal) - 1) > 1e-8)  #endif                  {                      return false;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,Polygon3D,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\Polygon3D.cs,IsPlanar,The following statement contains a magic number: for (int i = 2; i < this.Points.Count; i++)              {  #if SHARPDX                  var n = Vector3D.Cross(v1' this.Points[i] - this.Points[0]);  #else                  var n = Vector3D.CrossProduct(v1' this.Points[i] - this.Points[0]);  #endif                  n.Normalize();                  if (i == 2)                  {                      normal = n;                  }  #if SHARPDX                  else if (Math.Abs(Vector3D.Dot(n' normal) - 1) > 1e-8)  #else                  else if (Math.Abs(Vector3D.DotProduct(n' normal) - 1) > 1e-8)  #endif                  {                      return false;                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)                  return null;              else if (count == 3)              {                  if (!didReverse)                  {                      return new Int32Collection { 0' 1' 2 };                  }                  else                  {                      return new Int32Collection { 2' 1' 1 };                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)                  return null;              else if (count == 3)              {                  if (!didReverse)                  {                      return new Int32Collection { 0' 1' 2 };                  }                  else                  {                      return new Int32Collection { 2' 1' 1 };                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)                  return null;              else if (count == 3)              {                  if (!didReverse)                  {                      return new Int32Collection { 0' 1' 2 };                  }                  else                  {                      return new Int32Collection { 2' 1' 1 };                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,Triangulate,The following statement contains a magic number: if (count < 3)                  return null;              else if (count == 3)              {                  if (!didReverse)                  {                      return new Int32Collection { 0' 1' 2 };                  }                  else                  {                      return new Int32Collection { 2' 1' 1 };                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,TriangulateMonotone,The following statement contains a magic number: for (int i = 2; i < pointCnt; i++)              {                  // The current Point                  var newPoint = events[i];                  var top = pointStack.Peek();                  // If the new Point is not on the same side as the last Point on the Stack                  //if (!(leftChain.Contains(top) && leftChain.Contains(newPoint) || rightChain.Contains(top) && rightChain.Contains(newPoint)))                  if (!(top.Last == newPoint || top.Next == newPoint))                  {                      // Determine this Point's Chain (left or right)                      if (left.Next == newPoint)                      {                          left = newPoint;                      }                      else if (right.Last == newPoint)                      {                          right = newPoint;                      }                        // Third triangle Point                      var p2 = top;                      // While there is a Point on the Stack                      while (pointStack.Count != 0)                      {                          // Pop and set the third Point                          top = pointStack.Pop();                          p2 = top;                          if (pointStack.Count != 0)                          {                              // Pop again                              top = pointStack.Pop();                                // Add to the result. The Order is depending on the Side                              if (left == newPoint)                              {                                  result.Add(newPoint.Index);                                  result.Add(p2.Index);                                  result.Add(top.Index);                              }                              else                              {                                  result.Add(newPoint.Index);                                  result.Add(top.Index);                                  result.Add(p2.Index);                              }                          }                          // If more Points are on the Stack'                          // Push the Point back again' to be able to form the Triangles                          if (pointStack.Count != 0)                              pointStack.Push(top);                      }                      // Push the last to Points on the Stack                      pointStack.Push(events[i - 1]);                      pointStack.Push(newPoint);                  }                  // If the newPoint is on the same Side (i.e. Chain)                  else                  {                      // Get to Point on the Stack                      top = pointStack.Pop();                      var p2 = top;                        // Determine this Point's Chain (left or right)                      if (left.Next == newPoint && right.Last == newPoint)                      {                          if (top.Last == newPoint)                              right = newPoint;                          else if (top.Next == newPoint)                              left = newPoint;                          else                              throw new Exception("Triangulation error");                      }                      else if (left.Next == newPoint)                      {                          left = newPoint;                      }                      else if (right.Last == newPoint)                      {                          right = newPoint;                      }                        while (pointStack.Count != 0)                      {                          // If the Triangle is possible' add it to the result (Point Order depends on the Side)                          if (right == newPoint && IsCCW(new List<Point> { newPoint.Point' p2.Point' pointStack.Peek().Point }))                          {                              top = pointStack.Pop();                              result.Add(newPoint.Index);                              result.Add(p2.Index);                              result.Add(top.Index);                              p2 = top;                          }                          else if (left == newPoint && !IsCCW(new List<Point> { newPoint.Point' p2.Point' pointStack.Peek().Point }))                          {                              top = pointStack.Pop();                              result.Add(newPoint.Index);                              result.Add(top.Index);                              result.Add(p2.Index);                              p2 = top;                          }                          // No Triangle possible' just leave the Loop                          else                              break;                      }                      // Push the last two Points on the Stack                      pointStack.Push(p2);                      pointStack.Push(newPoint);                  }              }
Magic Number,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,BestEdge,The following statement contains a magic number: var bestAngle = (float)Math.PI * 2;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourHelper,The following statement contains a magic number: this.normals = hasNormals ? new Vector3D[3] : null;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,ContourHelper,The following statement contains a magic number: this.textures = hasTextureCoordinates ? new Point[3] : null;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,GetContourFacet,The following statement contains a magic number: if (this.IsSideAlone(2))              {                  return this.sides[2] > 0 ? ContourFacetResult.TwoOnly : ContourFacetResult.ZeroAndOne;              }
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,GetContourFacet,The following statement contains a magic number: if (this.IsSideAlone(2))              {                  return this.sides[2] > 0 ? ContourFacetResult.TwoOnly : ContourFacetResult.ZeroAndOne;              }
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.indices[2] = index2;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.points[2] = this.meshPositions[index2];
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: if (this.normals != null)              {                  this.normals[0] = this.meshNormals[index0];                  this.normals[1] = this.meshNormals[index1];                  this.normals[2] = this.meshNormals[index2];              }
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: if (this.textures != null)              {                  this.textures[0] = this.meshTextureCoordinates[index0];                  this.textures[1] = this.meshTextureCoordinates[index1];                  this.textures[2] = this.meshTextureCoordinates[index2];              }
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides[2] = (this.a * this.points[2].X) + (this.b * this.points[2].Y) + (this.c * this.points[2].Z) + this.d;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides[2] = (this.a * this.points[2].X) + (this.b * this.points[2].Y) + (this.c * this.points[2].Z) + this.d;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides[2] = (this.a * this.points[2].X) + (this.b * this.points[2].Y) + (this.c * this.points[2].Z) + this.d;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,SetData,The following statement contains a magic number: this.sides[2] = (this.a * this.points[2].X) + (this.b * this.points[2].Y) + (this.c * this.points[2].Z) + this.d;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,IsSideAlone,The following statement contains a magic number: Func<int' int> getNext = i => i + 1 > 2 ? 0 : i + 1;
Magic Number,HelixToolkit.Wpf.SharpDX,ContourHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Helper\ContourHelper.cs,AllSidesBelowContour,The following statement contains a magic number: return this.sides[0] >= 0                  && this.sides[1] >= 0                  && this.sides[2] >= 0;
Magic Number,HelixToolkit.Wpf.SharpDX,VectorExtensions,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Extensions\Vector3DExtensions.cs,FindAnyPerpendicular,The following statement contains a magic number: if (u.LengthSquared() < 1e-3)              {                  u = Vector3.Cross(new Vector3(1' 0' 0)' n);              }
Magic Number,HelixToolkit.SharpDX.Helpers,PointerSizeHelpers,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\Helpers\PointerSizeHelpers.cs,ToUInt64,The following statement contains a magic number: if (UIntPtr.Size == 8)              {                  return (ulong)(long)ptr;              }              else              {                  return (uint)(int)ptr;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following statement contains a magic number: if ((header.PixelFormat.Flags & DDS.PixelFormatFlags.FourCC) != 0 && (new FourCC('D'' 'X'' '1'' '0') == header.PixelFormat.FourCC))              {                  // Buffer must be big enough for both headers and magic value                  if (size < (Utilities.SizeOf<DDS.Header>() + sizeof (uint) + Utilities.SizeOf<DDS.HeaderDXT10>()))                      return false;                    var headerDX10 = *(DDS.HeaderDXT10*) ((byte*) headerPtr + sizeof (int) + Utilities.SizeOf<DDS.Header>());                  convFlags |= ConversionFlags.DX10;                    description.ArraySize = headerDX10.ArraySize;                  if (description.ArraySize == 0)                      throw new InvalidOperationException("Unexpected ArraySize == 0 from DDS HeaderDX10 ");                    description.Format = headerDX10.DXGIFormat;                  if (!FormatHelper.IsValid(description.Format))                      throw new InvalidOperationException("Invalid Format from DDS HeaderDX10 ");                    switch (headerDX10.ResourceDimension)                  {                      case ResourceDimension.Texture1D:                            // D3DX writes 1D textures with a fixed Height of 1                          if ((header.Flags & DDS.HeaderFlags.Height) != 0 && header.Height != 1)                              throw new InvalidOperationException("Unexpected Height != 1 from DDS HeaderDX10 ");                            description.Width = header.Width;                          description.Height = 1;                          description.Depth = 1;                          description.Dimension = TextureDimension.Texture1D;                          break;                        case ResourceDimension.Texture2D:                          if ((headerDX10.MiscFlags & ResourceOptionFlags.TextureCube) != 0)                          {                              description.ArraySize *= 6;                              description.Dimension = TextureDimension.TextureCube;                          }                          else                          {                              description.Dimension = TextureDimension.Texture2D;                          }                            description.Width = header.Width;                          description.Height = header.Height;                          description.Depth = 1;                          break;                        case ResourceDimension.Texture3D:                          if ((header.Flags & DDS.HeaderFlags.Volume) == 0)                              throw new InvalidOperationException("Texture3D missing HeaderFlags.Volume from DDS HeaderDX10");                            if (description.ArraySize > 1)                              throw new InvalidOperationException("Unexpected ArraySize > 1 for Texture3D from DDS HeaderDX10");                            description.Width = header.Width;                          description.Height = header.Height;                          description.Depth = header.Depth;                          description.Dimension = TextureDimension.Texture3D;                          break;                        default:                          throw new InvalidOperationException(string.Format("Unexpected dimension [{0}] from DDS HeaderDX10"' headerDX10.ResourceDimension));                  }              }              else              {                  description.ArraySize = 1;                    if ((header.Flags & DDS.HeaderFlags.Volume) != 0)                  {                      description.Width = header.Width;                      description.Height = header.Height;                      description.Depth = header.Depth;                      description.Dimension = TextureDimension.Texture3D;                  }                  else                  {                      if ((header.CubemapFlags & DDS.CubemapFlags.CubeMap) != 0)                      {                          // We require all six faces to be defined                          if ((header.CubemapFlags & DDS.CubemapFlags.AllFaces) != DDS.CubemapFlags.AllFaces)                              throw new InvalidOperationException("Unexpected CubeMap' expecting all faces from DDS Header");                            description.ArraySize = 6;                          description.Dimension = TextureDimension.TextureCube;                      }                      else                      {                          description.Dimension = TextureDimension.Texture2D;                      }                        description.Width = header.Width;                      description.Height = header.Height;                      description.Depth = 1;                      // Note there's no way for a legacy Direct3D 9 DDS to express a '1D' texture                  }                    description.Format = GetDXGIFormat(ref header.PixelFormat' flags' out convFlags);                    if (description.Format == Format.Unknown)                      throw new InvalidOperationException("Unsupported PixelFormat from DDS Header");              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following statement contains a magic number: if ((header.PixelFormat.Flags & DDS.PixelFormatFlags.FourCC) != 0 && (new FourCC('D'' 'X'' '1'' '0') == header.PixelFormat.FourCC))              {                  // Buffer must be big enough for both headers and magic value                  if (size < (Utilities.SizeOf<DDS.Header>() + sizeof (uint) + Utilities.SizeOf<DDS.HeaderDXT10>()))                      return false;                    var headerDX10 = *(DDS.HeaderDXT10*) ((byte*) headerPtr + sizeof (int) + Utilities.SizeOf<DDS.Header>());                  convFlags |= ConversionFlags.DX10;                    description.ArraySize = headerDX10.ArraySize;                  if (description.ArraySize == 0)                      throw new InvalidOperationException("Unexpected ArraySize == 0 from DDS HeaderDX10 ");                    description.Format = headerDX10.DXGIFormat;                  if (!FormatHelper.IsValid(description.Format))                      throw new InvalidOperationException("Invalid Format from DDS HeaderDX10 ");                    switch (headerDX10.ResourceDimension)                  {                      case ResourceDimension.Texture1D:                            // D3DX writes 1D textures with a fixed Height of 1                          if ((header.Flags & DDS.HeaderFlags.Height) != 0 && header.Height != 1)                              throw new InvalidOperationException("Unexpected Height != 1 from DDS HeaderDX10 ");                            description.Width = header.Width;                          description.Height = 1;                          description.Depth = 1;                          description.Dimension = TextureDimension.Texture1D;                          break;                        case ResourceDimension.Texture2D:                          if ((headerDX10.MiscFlags & ResourceOptionFlags.TextureCube) != 0)                          {                              description.ArraySize *= 6;                              description.Dimension = TextureDimension.TextureCube;                          }                          else                          {                              description.Dimension = TextureDimension.Texture2D;                          }                            description.Width = header.Width;                          description.Height = header.Height;                          description.Depth = 1;                          break;                        case ResourceDimension.Texture3D:                          if ((header.Flags & DDS.HeaderFlags.Volume) == 0)                              throw new InvalidOperationException("Texture3D missing HeaderFlags.Volume from DDS HeaderDX10");                            if (description.ArraySize > 1)                              throw new InvalidOperationException("Unexpected ArraySize > 1 for Texture3D from DDS HeaderDX10");                            description.Width = header.Width;                          description.Height = header.Height;                          description.Depth = header.Depth;                          description.Dimension = TextureDimension.Texture3D;                          break;                        default:                          throw new InvalidOperationException(string.Format("Unexpected dimension [{0}] from DDS HeaderDX10"' headerDX10.ResourceDimension));                  }              }              else              {                  description.ArraySize = 1;                    if ((header.Flags & DDS.HeaderFlags.Volume) != 0)                  {                      description.Width = header.Width;                      description.Height = header.Height;                      description.Depth = header.Depth;                      description.Dimension = TextureDimension.Texture3D;                  }                  else                  {                      if ((header.CubemapFlags & DDS.CubemapFlags.CubeMap) != 0)                      {                          // We require all six faces to be defined                          if ((header.CubemapFlags & DDS.CubemapFlags.AllFaces) != DDS.CubemapFlags.AllFaces)                              throw new InvalidOperationException("Unexpected CubeMap' expecting all faces from DDS Header");                            description.ArraySize = 6;                          description.Dimension = TextureDimension.TextureCube;                      }                      else                      {                          description.Dimension = TextureDimension.Texture2D;                      }                        description.Width = header.Width;                      description.Height = header.Height;                      description.Depth = 1;                      // Note there's no way for a legacy Direct3D 9 DDS to express a '1D' texture                  }                    description.Format = GetDXGIFormat(ref header.PixelFormat' flags' out convFlags);                    if (description.Format == Format.Unknown)                      throw new InvalidOperationException("Unsupported PixelFormat from DDS Header");              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if (description.ArraySize > 1)              {                  if ((description.ArraySize != 6) || (description.Dimension != TextureDimension.Texture2D) || (description.Dimension != TextureDimension.TextureCube))                  {                      flags |= DDSFlags.ForceDX10Ext;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if ((flags & DDSFlags.ForceDX10Ext) == 0)              {                  switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following statement contains a magic number: if (ddpf.Size == 0)              {                  header->PixelFormat = DDS.PixelFormat.DX10;                    var ext = (DDS.HeaderDXT10*)((byte*)(header) + Utilities.SizeOf<DDS.Header>());                    Utilities.ClearMemory((IntPtr) ext' 0' Utilities.SizeOf<DDS.HeaderDXT10>());                    ext->DXGIFormat = description.Format;                  switch (description.Dimension)                  {                      case TextureDimension.Texture1D:                          ext->ResourceDimension = ResourceDimension.Texture1D;                          break;                      case TextureDimension.Texture2D:                      case TextureDimension.TextureCube:                          ext->ResourceDimension = ResourceDimension.Texture2D;                          break;                      case TextureDimension.Texture3D:                          ext->ResourceDimension = ResourceDimension.Texture3D;                          break;                    }                    if (description.Dimension == TextureDimension.TextureCube)                  {                      ext->MiscFlags |= ResourceOptionFlags.TextureCube;                      ext->ArraySize = description.ArraySize / 6;                  }                  else                  {                      ext->ArraySize = description.ArraySize;                  }              }              else              {                  header->PixelFormat = ddpf;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LoadFromDDSMemory,The following statement contains a magic number: if ((convFlags & ConversionFlags.Pal8) != 0)              {                  pal8 = (int*) ((byte*) (pSource) + offset);                  offset += (256 * sizeof (uint));              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following statement contains a magic number: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following statement contains a magic number: if ((flags & ScanlineFlags.SetAlpha) != 0)              {                  switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following statement contains a magic number: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,NewCube,The following statement contains a magic number: return new Image(CreateDescription(TextureDimension.TextureCube' width' width' 1' mipMapCount' format' 6)' dataPointer' 0' null' false);
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Load,The following statement contains a magic number: if (size > (85 * 1024))              {                  var handle = GCHandle.Alloc(buffer' GCHandleType.Pinned);                  return Load(handle.AddrOfPinnedObject()' size' false' handle);              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Load,The following statement contains a magic number: if (size > (85 * 1024))              {                  var handle = GCHandle.Alloc(buffer' GCHandleType.Pinned);                  return Load(handle.AddrOfPinnedObject()' size' false' handle);              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The following statement contains a magic number: switch (description.Dimension)              {                  case TextureDimension.Texture1D:                      if (description.Width <= 0 || description.Height != 1 || description.Depth != 1 || description.ArraySize == 0)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 1D");                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' 1' description.MipLevels);                      break;                    case TextureDimension.Texture2D:                  case TextureDimension.TextureCube:                      if (description.Width <= 0 || description.Height <= 0 || description.Depth != 1 || description.ArraySize == 0)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 2D");                        if (description.Dimension == TextureDimension.TextureCube)                      {                          if ((description.ArraySize % 6) != 0)                              throw new InvalidOperationException("TextureCube must have an arraysize = 6");                      }                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.MipLevels);                      break;                    case TextureDimension.Texture3D:                      if (description.Width <= 0 || description.Height <= 0 || description.Depth <= 0 || description.ArraySize != 1)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 3D");                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.Depth' description.MipLevels);                      break;              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,ComputePitch,The following statement contains a magic number: if (FormatHelper.IsCompressed(fmt))              {                  int bpb = (fmt == Format.BC1_Typeless                               || fmt == Format.BC1_UNorm                               || fmt == Format.BC1_UNorm_SRgb                               || fmt == Format.BC4_Typeless                               || fmt == Format.BC4_UNorm                               || fmt == Format.BC4_SNorm) ? 8 : 16;                  widthCount = Math.Max(1' (width + 3) / 4);                  heightCount = Math.Max(1' (height + 3) / 4);                  rowPitch = widthCount * bpb;                    slicePitch = rowPitch * heightCount;              }              else if (FormatHelper.IsPacked(fmt))              {                  rowPitch = ((width + 1) >> 1) * 4;                    slicePitch = rowPitch * height;              }              else              {                  int bpp;                    if ((flags & PitchFlags.Bpp24) != 0)                      bpp = 24;                  else if ((flags & PitchFlags.Bpp16) != 0)                      bpp = 16;                  else if ((flags & PitchFlags.Bpp8) != 0)                      bpp = 8;                  else                      bpp = FormatHelper.SizeOfInBits(fmt);                    if ((flags & PitchFlags.LegacyDword) != 0)                  {                      // Special computation for some incorrectly created DDS files based on                      // legacy DirectDraw assumptions about pitch alignment                      rowPitch = ((width * bpp + 31) / 32) * sizeof(int);                      slicePitch = rowPitch * height;                  }                  else                  {                      rowPitch = (width * bpp + 7) / 8;                      slicePitch = rowPitch * height;                  }              }
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,ImageDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = this.Width;                  hashCode = (hashCode * 397) ^ this.Height;                  hashCode = (hashCode * 397) ^ this.WidthPacked;                  hashCode = (hashCode * 397) ^ this.HeightPacked;                  hashCode = (hashCode * 397) ^ this.Depth;                  hashCode = (hashCode * 397) ^ this.RowStride;                  hashCode = (hashCode * 397) ^ this.MipmapSize;                  hashCode = (hashCode * 397) ^ this.DepthStride;                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = this.Width;                  hashCode = (hashCode * 397) ^ this.Height;                  hashCode = (hashCode * 397) ^ this.WidthPacked;                  hashCode = (hashCode * 397) ^ this.HeightPacked;                  hashCode = (hashCode * 397) ^ this.Depth;                  hashCode = (hashCode * 397) ^ this.RowStride;                  hashCode = (hashCode * 397) ^ this.MipmapSize;                  hashCode = (hashCode * 397) ^ this.DepthStride;                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = this.Width;                  hashCode = (hashCode * 397) ^ this.Height;                  hashCode = (hashCode * 397) ^ this.WidthPacked;                  hashCode = (hashCode * 397) ^ this.HeightPacked;                  hashCode = (hashCode * 397) ^ this.Depth;                  hashCode = (hashCode * 397) ^ this.RowStride;                  hashCode = (hashCode * 397) ^ this.MipmapSize;                  hashCode = (hashCode * 397) ^ this.DepthStride;                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = this.Width;                  hashCode = (hashCode * 397) ^ this.Height;                  hashCode = (hashCode * 397) ^ this.WidthPacked;                  hashCode = (hashCode * 397) ^ this.HeightPacked;                  hashCode = (hashCode * 397) ^ this.Depth;                  hashCode = (hashCode * 397) ^ this.RowStride;                  hashCode = (hashCode * 397) ^ this.MipmapSize;                  hashCode = (hashCode * 397) ^ this.DepthStride;                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = this.Width;                  hashCode = (hashCode * 397) ^ this.Height;                  hashCode = (hashCode * 397) ^ this.WidthPacked;                  hashCode = (hashCode * 397) ^ this.HeightPacked;                  hashCode = (hashCode * 397) ^ this.Depth;                  hashCode = (hashCode * 397) ^ this.RowStride;                  hashCode = (hashCode * 397) ^ this.MipmapSize;                  hashCode = (hashCode * 397) ^ this.DepthStride;                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = this.Width;                  hashCode = (hashCode * 397) ^ this.Height;                  hashCode = (hashCode * 397) ^ this.WidthPacked;                  hashCode = (hashCode * 397) ^ this.HeightPacked;                  hashCode = (hashCode * 397) ^ this.Depth;                  hashCode = (hashCode * 397) ^ this.RowStride;                  hashCode = (hashCode * 397) ^ this.MipmapSize;                  hashCode = (hashCode * 397) ^ this.DepthStride;                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,MipMapDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\MipMapDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = this.Width;                  hashCode = (hashCode * 397) ^ this.Height;                  hashCode = (hashCode * 397) ^ this.WidthPacked;                  hashCode = (hashCode * 397) ^ this.HeightPacked;                  hashCode = (hashCode * 397) ^ this.Depth;                  hashCode = (hashCode * 397) ^ this.RowStride;                  hashCode = (hashCode * 397) ^ this.MipmapSize;                  hashCode = (hashCode * 397) ^ this.DepthStride;                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,RenderTargetCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\RenderTargetCube.cs,NewRenderTargetDescription,The following statement contains a magic number: var desc = Texture2DBase.NewDescription(size' size' format' flags' mipCount' 6' ResourceUsage.Default);
Magic Number,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,CalculateMipMapCount,The following statement contains a magic number: int maxMipMap = 1 + (int)Math.Log(size' 2);
Magic Number,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetViewCount,The following statement contains a magic number: return GetViewIndex((ViewType)4' arrayOrDepthSize' this.Description.MipLevels);
Magic Number,SharpDX.Toolkit.Graphics,TextureViewKey,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      var hashCode = (int)ViewFormat;                      hashCode = (hashCode * 397) ^ (int)ViewType;                      hashCode = (hashCode * 397) ^ ArrayOrDepthSlice;                      hashCode = (hashCode * 397) ^ MipIndex;                      return hashCode;                  }
Magic Number,SharpDX.Toolkit.Graphics,TextureViewKey,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      var hashCode = (int)ViewFormat;                      hashCode = (hashCode * 397) ^ (int)ViewType;                      hashCode = (hashCode * 397) ^ ArrayOrDepthSlice;                      hashCode = (hashCode * 397) ^ MipIndex;                      return hashCode;                  }
Magic Number,SharpDX.Toolkit.Graphics,TextureViewKey,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      var hashCode = (int)ViewFormat;                      hashCode = (hashCode * 397) ^ (int)ViewType;                      hashCode = (hashCode * 397) ^ ArrayOrDepthSlice;                      hashCode = (hashCode * 397) ^ MipIndex;                      return hashCode;                  }
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: if (textureData.Length != 6)                  throw new ArgumentException("Invalid texture data. First dimension must be equal to 6"' "textureData");
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin(textureData[2]' ptr => dataBox3 = GetDataBox(format' size' size' 1' textureData[0]' ptr));
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin(textureData[3]' ptr => dataBox4 = GetDataBox(format' size' size' 1' textureData[0]' ptr));
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin(textureData[4]' ptr => dataBox5 = GetDataBox(format' size' size' 1' textureData[0]' ptr));
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: Utilities.Pin(textureData[5]' ptr => dataBox6 = GetDataBox(format' size' size' 1' textureData[0]' ptr));
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,New,The following statement contains a magic number: if (textureData.Length != 6)                  throw new ArgumentException("Invalid texture data. First dimension must be equal to 6"' "textureData");
Magic Number,SharpDX.Toolkit.Graphics,TextureCube,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs,NewTextureCubeDescription,The following statement contains a magic number: var desc = NewDescription(size' size' format' flags' mipCount' 6' usage);
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,TextureDescription,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureDescription.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = Dimension.GetHashCode();                  hashCode = (hashCode * 397) ^ Width;                  hashCode = (hashCode * 397) ^ Height;                  hashCode = (hashCode * 397) ^ Depth;                  hashCode = (hashCode * 397) ^ ArraySize;                  hashCode = (hashCode * 397) ^ MipLevels;                  hashCode = (hashCode * 397) ^ Format.GetHashCode();                  hashCode = (hashCode * 397) ^ SampleDescription.GetHashCode();                  hashCode = (hashCode * 397) ^ Usage.GetHashCode();                  hashCode = (hashCode * 397) ^ BindFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ CpuAccessFlags.GetHashCode();                  hashCode = (hashCode * 397) ^ OptionFlags.GetHashCode();                  return hashCode;              }
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: frame.SetResolution(72' 72);
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: frame.SetResolution(72' 72);
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: if (targetGuid != pfGuid)              {                  using (var source = new Bitmap(Factory' image.Width' image.Height' pfGuid' new DataRectangle(image.DataPointer' image.RowStride)' image.BufferStride))                  {                      using (var converter = new FormatConverter(Factory))                      {                          using (var palette = new Palette(Factory))                          {                              palette.Initialize(source' 256' true);                              converter.Initialize(source' targetGuid' GetWICDither(flags)' palette' 0' BitmapPaletteType.Custom);                                int bpp = GetBitsPerPixel(targetGuid);                              if (bpp == 0) throw new NotSupportedException("Unable to determine the Bpp for the target format");                                int rowPitch = (image.Width * bpp + 7) / 8;                              int slicePitch = rowPitch * image.Height;                                var temp = Utilities.AllocateMemory(slicePitch);                              try                              {                                  converter.CopyPixels(rowPitch' temp' slicePitch);                                  frame.Palette = palette;                                  frame.WritePixels(image.Height' temp' rowPitch' slicePitch);                              }                              finally                              {                                  Utilities.FreeMemory(temp);                              }                          }                      }                  }              }              else              {                  // No conversion required                  frame.WritePixels(image.Height' image.DataPointer' image.RowStride' image.BufferStride);              }
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: if (targetGuid != pfGuid)              {                  using (var source = new Bitmap(Factory' image.Width' image.Height' pfGuid' new DataRectangle(image.DataPointer' image.RowStride)' image.BufferStride))                  {                      using (var converter = new FormatConverter(Factory))                      {                          using (var palette = new Palette(Factory))                          {                              palette.Initialize(source' 256' true);                              converter.Initialize(source' targetGuid' GetWICDither(flags)' palette' 0' BitmapPaletteType.Custom);                                int bpp = GetBitsPerPixel(targetGuid);                              if (bpp == 0) throw new NotSupportedException("Unable to determine the Bpp for the target format");                                int rowPitch = (image.Width * bpp + 7) / 8;                              int slicePitch = rowPitch * image.Height;                                var temp = Utilities.AllocateMemory(slicePitch);                              try                              {                                  converter.CopyPixels(rowPitch' temp' slicePitch);                                  frame.Palette = palette;                                  frame.WritePixels(image.Height' temp' rowPitch' slicePitch);                              }                              finally                              {                                  Utilities.FreeMemory(temp);                              }                          }                      }                  }              }              else              {                  // No conversion required                  frame.WritePixels(image.Height' image.DataPointer' image.RowStride' image.BufferStride);              }
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeImage,The following statement contains a magic number: if (targetGuid != pfGuid)              {                  using (var source = new Bitmap(Factory' image.Width' image.Height' pfGuid' new DataRectangle(image.DataPointer' image.RowStride)' image.BufferStride))                  {                      using (var converter = new FormatConverter(Factory))                      {                          using (var palette = new Palette(Factory))                          {                              palette.Initialize(source' 256' true);                              converter.Initialize(source' targetGuid' GetWICDither(flags)' palette' 0' BitmapPaletteType.Custom);                                int bpp = GetBitsPerPixel(targetGuid);                              if (bpp == 0) throw new NotSupportedException("Unable to determine the Bpp for the target format");                                int rowPitch = (image.Width * bpp + 7) / 8;                              int slicePitch = rowPitch * image.Height;                                var temp = Utilities.AllocateMemory(slicePitch);                              try                              {                                  converter.CopyPixels(rowPitch' temp' slicePitch);                                  frame.Palette = palette;                                  frame.WritePixels(image.Height' temp' rowPitch' slicePitch);                              }                              finally                              {                                  Utilities.FreeMemory(temp);                              }                          }                      }                  }              }              else              {                  // No conversion required                  frame.WritePixels(image.Height' image.DataPointer' image.RowStride' image.BufferStride);              }
Magic Number,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,EncodeMultiframe,The following statement contains a magic number: if (images.Length < 2)                  throw new ArgumentException("Cannot encode to multiple frame. Image doesn't have multiple frame");
Missing Default,HelixToolkit.Wpf.SharpDX,SweepLinePolygonTriangulator,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.Shared\Geometry\SweepLinePolygonTriangulator.cs,CalculateDiagonals,The following switch statement is missing a default case: switch (evClass)                  {                      case PolygonPointClass.Start:                          // Just add the left Edge (depending on the sweeping direction)                          statusAndHelper.Add(new StatusHelperElement(sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));                          break;                      case PolygonPointClass.Stop:                          // Just remove the left Edge (depending on the sweeping direction)                          statusAndHelper.Remove(sweepDown ? ev.EdgeOne : ev.EdgeTwo);                          break;                      case PolygonPointClass.Regular:                          // If the Polygon is positioned on the right Side of this Event                          if (ev.Last > ev.Next)                          {                              // Replace the corresponding (old) StatusHelperElement with the new one                              statusAndHelper.Remove(sweepDown ? ev.EdgeOne : ev.EdgeTwo);                              statusAndHelper.Add(new StatusHelperElement(sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));                          }                          else                          {                              // Search Edge left of the Event and set Event as it's Helper                              she = statusAndHelper.SearchLeft(ev);                              she.Helper = ev;                          }                          break;                      case PolygonPointClass.Merge:                          // Just remove the left Edge (depending on the sweeping direction)                          statusAndHelper.Remove(sweepDown ? ev.EdgeOne : ev.EdgeTwo);                          // Search Edge left of the Event and set Event as it's Helper                          she = statusAndHelper.SearchLeft(ev);                          she.Helper = ev;                          break;                      case PolygonPointClass.Split:                          // Search Edge left of the Event                          she = statusAndHelper.SearchLeft(ev);                          // Chose diagonal from Helper of Edge to Event.                          var minP = Math.Min(she.Helper.Index' ev.Index);                          var maxP = Math.Max(she.Helper.Index' ev.Index);                          var diagonal = new Tuple<int' int>(minP' maxP);                          diagonals.Add(diagonal);                            // Replace the Helper of the StatusHelperElement by Event                          she.Helper = ev;                          // Insert the right Edge from Event                          statusAndHelper.Add(new StatusHelperElement(sweepDown ? ev.EdgeTwo : ev.EdgeOne' ev));                          break;                  }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following switch statement is missing a default case: switch ((DXGI.Format) description.Format)                  {                      case Format.B8G8R8A8_UNorm:                          description.Format = Format.R8G8B8A8_UNorm;                          convFlags |= ConversionFlags.Swizzle;                          break;                        case Format.B8G8R8X8_UNorm:                          description.Format = Format.R8G8B8A8_UNorm;                          convFlags |= ConversionFlags.Swizzle | ConversionFlags.NoAlpha;                          break;                        case Format.B8G8R8A8_Typeless:                          description.Format = Format.R8G8B8A8_Typeless;                          convFlags |= ConversionFlags.Swizzle;                          break;                        case Format.B8G8R8A8_UNorm_SRgb:                          description.Format = Format.R8G8B8A8_UNorm_SRgb;                          convFlags |= ConversionFlags.Swizzle;                          break;                        case Format.B8G8R8X8_Typeless:                          description.Format = Format.R8G8B8A8_Typeless;                          convFlags |= ConversionFlags.Swizzle | ConversionFlags.NoAlpha;                          break;                        case Format.B8G8R8X8_UNorm_SRgb:                          description.Format = Format.R8G8B8A8_UNorm_SRgb;                          convFlags |= ConversionFlags.Swizzle | ConversionFlags.NoAlpha;                          break;                  }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,DecodeDDSHeader,The following switch statement is missing a default case: switch ((DXGI.Format) description.Format)                  {                      case Format.B5G6R5_UNorm:                      case Format.B5G5R5A1_UNorm:  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:  #endif                          description.Format = Format.R8G8B8A8_UNorm;                          convFlags |= ConversionFlags.Expand;                          if (description.Format == Format.B5G6R5_UNorm)                              convFlags |= ConversionFlags.NoAlpha;                          break;                  }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following switch statement is missing a default case: switch (description.Format)                  {                      case Format.R8G8B8A8_UNorm:                          ddpf = DDS.PixelFormat.A8B8G8R8;                          break;                      case Format.R16G16_UNorm:                          ddpf = DDS.PixelFormat.G16R16;                          break;                      case Format.R8G8_UNorm:                          ddpf = DDS.PixelFormat.A8L8;                          break;                      case Format.R16_UNorm:                          ddpf = DDS.PixelFormat.L16;                          break;                      case Format.R8_UNorm:                          ddpf = DDS.PixelFormat.L8;                          break;                      case Format.A8_UNorm:                          ddpf = DDS.PixelFormat.A8;                          break;                      case Format.R8G8_B8G8_UNorm:                          ddpf = DDS.PixelFormat.R8G8_B8G8;                          break;                      case Format.G8R8_G8B8_UNorm:                          ddpf = DDS.PixelFormat.G8R8_G8B8;                          break;                      case Format.BC1_UNorm:                          ddpf = DDS.PixelFormat.DXT1;                          break;                      case Format.BC2_UNorm:                          ddpf = DDS.PixelFormat.DXT3;                          break;                      case Format.BC3_UNorm:                          ddpf = DDS.PixelFormat.DXT5;                          break;                      case Format.BC4_UNorm:                          ddpf = DDS.PixelFormat.BC4_UNorm;                          break;                      case Format.BC4_SNorm:                          ddpf = DDS.PixelFormat.BC4_SNorm;                          break;                      case Format.BC5_UNorm:                          ddpf = DDS.PixelFormat.BC5_UNorm;                          break;                      case Format.BC5_SNorm:                          ddpf = DDS.PixelFormat.BC5_SNorm;                          break;                      case Format.B5G6R5_UNorm:                          ddpf = DDS.PixelFormat.R5G6B5;                          break;                      case Format.B5G5R5A1_UNorm:                          ddpf = DDS.PixelFormat.A1R5G5B5;                          break;                      case Format.B8G8R8A8_UNorm:                          ddpf = DDS.PixelFormat.A8R8G8B8;                          break; // DXGI 1.1                      case Format.B8G8R8X8_UNorm:                          ddpf = DDS.PixelFormat.X8R8G8B8;                          break; // DXGI 1.1  #if DIRECTX11_1                      case Format.B4G4R4A4_UNorm:                          ddpf = DDS.PixelFormat.A4R4G4B4;                          break;  #endif                      // Legacy D3DX formats using D3DFMT enum value as FourCC                      case Format.R32G32B32A32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 116; // D3DFMT_A32B32G32R32F                          break;                      case Format.R16G16B16A16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 113; // D3DFMT_A16B16G16R16F                          break;                      case Format.R16G16B16A16_UNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 36; // D3DFMT_A16B16G16R16                          break;                      case Format.R16G16B16A16_SNorm:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 110; // D3DFMT_Q16W16V16U16                          break;                      case Format.R32G32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 115; // D3DFMT_G32R32F                          break;                      case Format.R16G16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 112; // D3DFMT_G16R16F                          break;                      case Format.R32_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 114; // D3DFMT_R32F                          break;                      case Format.R16_Float:                          ddpf.Size = Utilities.SizeOf<DDS.PixelFormat>();                          ddpf.Flags = DDS.PixelFormatFlags.FourCC;                          ddpf.FourCC = 111; // D3DFMT_R16F                          break;                  }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following switch statement is missing a default case: switch (description.Dimension)              {                  case TextureDimension.Texture1D:                      header->Height = description.Height;                      header->Width = header->Depth = 1;                      break;                    case TextureDimension.Texture2D:                  case TextureDimension.TextureCube:                      header->Height = description.Height;                      header->Width = description.Width;                      header->Depth = 1;                        if (description.Dimension == TextureDimension.TextureCube)                      {                          header->SurfaceFlags |= DDS.SurfaceFlags.Cubemap;                          header->CubemapFlags |= DDS.CubemapFlags.AllFaces;                      }                      break;                    case TextureDimension.Texture3D:                        header->Flags |= DDS.HeaderFlags.Volume;                      header->CubemapFlags |= DDS.CubemapFlags.Volume;                      header->Height = description.Height;                      header->Width = description.Width;                      header->Depth = description.Depth;                      break;              }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,EncodeDDSHeader,The following switch statement is missing a default case: switch (description.Dimension)                  {                      case TextureDimension.Texture1D:                          ext->ResourceDimension = ResourceDimension.Texture1D;                          break;                      case TextureDimension.Texture2D:                      case TextureDimension.TextureCube:                          ext->ResourceDimension = ResourceDimension.Texture2D;                          break;                      case TextureDimension.Texture3D:                          ext->ResourceDimension = ResourceDimension.Texture3D;                          break;                    }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following switch statement is missing a default case: switch (inFormat)              {                  case TEXP_LEGACY_FORMAT.R8G8B8:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_R8G8B8 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (byte*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 3' ocount += 4)                          {                              // 24bpp Direct3D 9 files are actually BGR' so need to swizzle as well                              int t1 = (*(sPtr) << 16);                              int t2 = (*(sPtr + 1) << 8);                              int t3 = *(sPtr + 2);                                *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                              sPtr += 3;                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.R3G3B2:                      switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }                      break;                    case TEXP_LEGACY_FORMAT.A8R3G3B2:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A8R3G3B2 -> Format.R8G8B8A8_UNorm                      {                          var sPtr = (short*) (pSource);                          var dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)((t & 0x00e0) | ((t & 0x00e0) >> 3) | ((t & 0x00c0) >> 6));                              uint t2 = (uint)(((t & 0x001c) << 11) | ((t & 0x001c) << 8) | ((t & 0x0018) << 5));                              uint t3 = (uint)(((t & 0x0003) << 22) | ((t & 0x0003) << 20) | ((t & 0x0003) << 18) | ((t & 0x0003) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_P8 -> Format.R8G8B8A8_UNorm                      {                          byte* sPtr = (byte*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                          {                              byte t = *(sPtr++);                                *(dPtr++) = pal8[t];                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A8P8:                      if ((outFormat != Format.R8G8B8A8_UNorm) || pal8 == null)                          return false;                        // D3DFMT_A8P8 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)pal8[t & 0xff];                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((t & 0xff00) << 16));                                *(dPtr++) = (int) (t1 | ta);                          }                      }                      return true;                    case TEXP_LEGACY_FORMAT.A4L4:                      switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }                      break;    #if !DIRECTX11_1                  case TEXP_LEGACY_FORMAT.B4G4R4A4:                      if (outFormat != Format.R8G8B8A8_UNorm)                          return false;                        // D3DFMT_A4R4G4B4 -> Format.R8G8B8A8_UNorm                      {                          short* sPtr = (short*) (pSource);                          int* dPtr = (int*) (pDestination);                            for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              short t = *(sPtr++);                                uint t1 = (uint)(((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint)(((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint)(((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = (int) (t1 | t2 | t3 | ta);                          }                      }                      return true;  #endif              }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following switch statement is missing a default case: switch (outFormat)                      {                          case Format.R8G8B8A8_UNorm:                              // D3DFMT_R3G3B2 -> Format.R8G8B8A8_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        int t1 = (t & 0xe0) | ((t & 0xe0) >> 3) | ((t & 0xc0) >> 6);                                      int t2 = ((t & 0x1c) << 11) | ((t & 0x1c) << 8) | ((t & 0x18) << 5);                                      int t3 = ((t & 0x03) << 22) | ((t & 0x03) << 20) | ((t & 0x03) << 18) | ((t & 0x03) << 16);                                        *(dPtr++) = (int) (t1 | t2 | t3 | 0xff000000);                                  }                              }                              return true;                            case Format.B5G6R5_UNorm:                              // D3DFMT_R3G3B2 -> Format.B5G6R5_UNorm                              {                                  var sPtr = (byte*) (pSource);                                  var dPtr = (short*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2)                                  {                                      byte t = *(sPtr++);                                        var t1 = (ushort) (((t & 0xe0) << 8) | ((t & 0xc0) << 5));                                      var t2 = (ushort) (((t & 0x1c) << 6) | ((t & 0x1c) << 3));                                      var t3 = (ushort) (((t & 0x03) << 3) | ((t & 0x03) << 1) | ((t & 0x02) >> 1));                                        *(dPtr++) = (short) (t1 | t2 | t3);                                  }                              }                              return true;                      }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,LegacyExpandScanline,The following switch statement is missing a default case: switch (outFormat)                      {  #if DIRECTX11_1                  case Format.B4G4R4A4_UNorm :                      // D3DFMT_A4L4 -> Format.B4G4R4A4_UNorm                       {                          byte * sPtr = (byte*)(pSource);                          short * dPtr = (short*)(pDestination);                            for( int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 2 )                          {                              byte t = *(sPtr++);                                short t1 = (short)(t & 0x0f);                              ushort ta = (flags & ScanlineFlags.SetAlpha ) != 0 ?  (ushort)0xf000 : (ushort)((t & 0xf0) << 8);                                *(dPtr++) = (short)(t1 | (t1 << 4) | (t1 << 8) | ta);                          }                      }                      return true;  #endif                              // DXGI_1_2_FORMATS                            case Format.R8G8B8A8_UNorm:                              // D3DFMT_A4L4 -> Format.R8G8B8A8_UNorm                              {                                  byte* sPtr = (byte*) (pSource);                                  int* dPtr = (int*) (pDestination);                                    for (int ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); ++icount' ocount += 4)                                  {                                      byte t = *(sPtr++);                                        uint t1 = (uint)(((t & 0x0f) << 4) | (t & 0x0f));                                      uint ta = ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) (((t & 0xf0) << 24) | ((t & 0xf0) << 20)));                                        *(dPtr++) = (int) (t1 | (t1 << 8) | (t1 << 16) | ta);                                  }                              }                              return true;                      }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,ExpandScanline,The following switch statement is missing a default case: switch (inFormat)              {                  case DXGI.Format.B5G6R5_UNorm:                      // DXGI.Format.B5G6R5_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0xf800) >> 8) | ((t & 0xe000) >> 13));                              uint t2 = (uint) (((t & 0x07e0) << 5) | ((t & 0x0600) >> 5));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                                *(dPtr++) = t1 | t2 | t3 | 0xff000000;                          }                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                      // DXGI.Format.B5G5R5A1_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x7c00) >> 7) | ((t & 0x7000) >> 12));                              uint t2 = (uint) (((t & 0x03e0) << 6) | ((t & 0x0380) << 1));                              uint t3 = (uint) (((t & 0x001f) << 19) | ((t & 0x001c) << 14));                              uint ta = (uint) ((flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (((t & 0x8000) != 0 ? 0xff000000 : 0)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;    #if DIRECTX11_1                  case DXGI.Format.B4G4R4A4_UNorm:                      // DXGI.Format.B4G4R4A4_UNorm -> DXGI.Format.R8G8B8A8_UNorm                      {                          var sPtr = (ushort*) (pSource);                          var dPtr = (uint*) (pDestination);                            for (uint ocount = 0' icount = 0; ((icount < inSize) && (ocount < outSize)); icount += 2' ocount += 4)                          {                              ushort t = *(sPtr++);                                uint t1 = (uint) (((t & 0x0f00) >> 4) | ((t & 0x0f00) >> 8));                              uint t2 = (uint) (((t & 0x00f0) << 8) | ((t & 0x00f0) << 4));                              uint t3 = (uint) (((t & 0x000f) << 20) | ((t & 0x000f) << 16));                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (uint) ((((t & 0xf000) << 16) | ((t & 0xf000) << 12)));                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      break;  #endif  // DXGI_1_2_FORMATS              }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,CopyScanline,The following switch statement is missing a default case: switch (format)                  {                      //-----------------------------------------------------------------------------                      case Format.R32G32B32A32_Typeless:                      case Format.R32G32B32A32_Float:                      case Format.R32G32B32A32_UInt:                      case Format.R32G32B32A32_SInt:                          {                              uint alpha;                              if (format == Format.R32G32B32A32_Float)                                  alpha = 0x3f800000;                              else if (format == Format.R32G32B32A32_SInt)                                  alpha = 0x7fffffff;                              else                                  alpha = 0xffffffff;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 16)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 16)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R16G16B16A16_Typeless:                      case Format.R16G16B16A16_Float:                      case Format.R16G16B16A16_UNorm:                      case Format.R16G16B16A16_UInt:                      case Format.R16G16B16A16_SNorm:                      case Format.R16G16B16A16_SInt:                          {                              ushort alpha;                              if (format == Format.R16G16B16A16_Float)                                  alpha = 0x3c00;                              else if (format == Format.R16G16B16A16_SNorm || format == Format.R16G16B16A16_SInt)                                  alpha = 0x7fff;                              else                                  alpha = 0xffff;                                if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 8)                                  {                                      dPtr += 3;                                      *(dPtr++) = alpha;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 8)                                  {                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = *(sPtr++);                                      *(dPtr++) = alpha;                                      sPtr++;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R10G10B10A2_Typeless:                      case Format.R10G10B10A2_UNorm:                      case Format.R10G10B10A2_UInt:                      case Format.R10G10B10_Xr_Bias_A2_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      *dPtr |= 0xC0000000;                                      ++dPtr;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      *(dPtr++) = *(sPtr++) | 0xC0000000;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.R8G8B8A8_Typeless:                      case Format.R8G8B8A8_UNorm:                      case Format.R8G8B8A8_UNorm_SRgb:                      case Format.R8G8B8A8_UInt:                      case Format.R8G8B8A8_SNorm:                      case Format.R8G8B8A8_SInt:                      case Format.B8G8R8A8_UNorm:                      case Format.B8G8R8A8_Typeless:                      case Format.B8G8R8A8_UNorm_SRgb:                          {                              uint alpha = (format == Format.R8G8B8A8_SNorm || format == Format.R8G8B8A8_SInt) ? 0x7f000000 : 0xff000000;                                if (pDestination == pSource)                              {                                  var dPtr = (uint*)(pDestination);                                  for (int count = 0; count < outSize; count += 4)                                  {                                      uint t = *dPtr & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                              else                              {                                  var sPtr = (uint*)(pSource);                                  var dPtr = (uint*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 4)                                  {                                      uint t = *(sPtr++) & 0xFFFFFF;                                      t |= alpha;                                      *(dPtr++) = t;                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.B5G5R5A1_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*)(pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0x8000;                                  }                              }                              else                              {                                  var sPtr = (ushort*)(pSource);                                  var dPtr = (ushort*)(pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort)(*(sPtr++) | 0x8000);                                  }                              }                          }                          return;                        //-----------------------------------------------------------------------------                      case Format.A8_UNorm:                          Utilities.ClearMemory(pDestination' 0xff' outSize);                          return;    #if DIRECTX11_1                      //-----------------------------------------------------------------------------                      case Format.B4G4R4A4_UNorm:                          {                              if (pDestination == pSource)                              {                                  var dPtr = (ushort*) (pDestination);                                  for (int count = 0; count < outSize; count += 2)                                  {                                      *(dPtr++) |= 0xF000;                                  }                              }                              else                              {                                  var sPtr = (ushort*) (pSource);                                  var dPtr = (ushort*) (pDestination);                                  int size = Math.Min(outSize' inSize);                                  for (int count = 0; count < size; count += 2)                                  {                                      *(dPtr++) = (ushort) (*(sPtr++) | 0xF000);                                  }                              }                          }                          return;  #endif                      // DXGI_1_2_FORMATS                  }
Missing Default,SharpDX.Toolkit.Graphics,DDSHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs,SwizzleScanline,The following switch statement is missing a default case: switch (format)              {                  //---------------------------------------------------------------------------------                  case Format.R10G10B10A2_Typeless:                  case Format.R10G10B10A2_UNorm:                  case Format.R10G10B10A2_UInt:                  case Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & ScanlineFlags.Legacy) != 0)                      {                          // Swap Red (R) and Blue (B) channel (used for D3DFMT_A2R10G10B10 legacy sources)                          if (pDestination == pSource)                          {                              var dPtr = (uint*)(pDestination);                              for (int count = 0; count < outSize; count += 4)                              {                                  uint t = *dPtr;                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          else                          {                              var sPtr = (uint*)(pSource);                              var dPtr = (uint*)(pDestination);                              int size = Math.Min(outSize' inSize);                              for (int count = 0; count < size; count += 4)                              {                                  uint t = *(sPtr++);                                    uint t1 = (t & 0x3ff00000) >> 20;                                  uint t2 = (t & 0x000003ff) << 20;                                  uint t3 = (t & 0x000ffc00);                                  uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xC0000000 : (t & 0xC0000000);                                    *(dPtr++) = t1 | t2 | t3 | ta;                              }                          }                          return;                      }                      break;                    //---------------------------------------------------------------------------------                  case Format.R8G8B8A8_Typeless:                  case Format.R8G8B8A8_UNorm:                  case Format.R8G8B8A8_UNorm_SRgb:                  case Format.B8G8R8A8_UNorm:                  case Format.B8G8R8X8_UNorm:                  case Format.B8G8R8A8_Typeless:                  case Format.B8G8R8A8_UNorm_SRgb:                  case Format.B8G8R8X8_Typeless:                  case Format.B8G8R8X8_UNorm_SRgb:                      // Swap Red (R) and Blue (B) channels (used to convert from DXGI 1.1 BGR formats to DXGI 1.0 RGB)                      if (pDestination == pSource)                      {                          var dPtr = (uint*)(pDestination);                          for (int count = 0; count < outSize; count += 4)                          {                              uint t = *dPtr;                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      else                      {                          var sPtr = (uint*)(pSource);                          var dPtr = (uint*)(pDestination);                          int size = Math.Min(outSize' inSize);                          for (int count = 0; count < size; count += 4)                          {                              uint t = *(sPtr++);                                uint t1 = (t & 0x00ff0000) >> 16;                              uint t2 = (t & 0x000000ff) << 16;                              uint t3 = (t & 0x0000ff00);                              uint ta = (flags & ScanlineFlags.SetAlpha) != 0 ? 0xff000000 : (t & 0xFF000000);                                *(dPtr++) = t1 | t2 | t3 | ta;                          }                      }                      return;              }
Missing Default,SharpDX.Toolkit.Graphics,DepthStencilBuffer,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs,ComputeViewFormat,The following switch statement is missing a default case: switch (format)              {                  case SharpDX.DXGI.Format.D16_UNorm:                  case DXGI.Format.R16_Float:                  case DXGI.Format.R16_Typeless:                      return DepthFormat.Depth16;                    case SharpDX.DXGI.Format.D32_Float:                  case DXGI.Format.R32_Float:                  case DXGI.Format.R32_Typeless:                      return DepthFormat.Depth32;                    case SharpDX.DXGI.Format.D24_UNorm_S8_UInt:                  case SharpDX.DXGI.Format.R24_UNorm_X8_Typeless:                      return DepthFormat.Depth24Stencil8;                    case SharpDX.DXGI.Format.D32_Float_S8X24_UInt:                  case SharpDX.DXGI.Format.R32_Float_X8X24_Typeless:                      return DepthFormat.Depth32Stencil8X24;              }
Missing Default,SharpDX.Toolkit.Graphics,GraphicsResource,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\GraphicsResource.cs,GetCpuAccessFlagsFromUsage,The following switch statement is missing a default case: switch (usage)              {                  case ResourceUsage.Dynamic:                      return CpuAccessFlags.Write;                  case ResourceUsage.Staging:                      return CpuAccessFlags.Read | CpuAccessFlags.Write;              }
Missing Default,SharpDX.Toolkit.Graphics,Image,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs,Initialize,The following switch statement is missing a default case: switch (description.Dimension)              {                  case TextureDimension.Texture1D:                      if (description.Width <= 0 || description.Height != 1 || description.Depth != 1 || description.ArraySize == 0)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 1D");                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' 1' description.MipLevels);                      break;                    case TextureDimension.Texture2D:                  case TextureDimension.TextureCube:                      if (description.Width <= 0 || description.Height <= 0 || description.Depth != 1 || description.ArraySize == 0)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 2D");                        if (description.Dimension == TextureDimension.TextureCube)                      {                          if ((description.ArraySize % 6) != 0)                              throw new InvalidOperationException("TextureCube must have an arraysize = 6");                      }                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.MipLevels);                      break;                    case TextureDimension.Texture3D:                      if (description.Width <= 0 || description.Height <= 0 || description.Depth <= 0 || description.ArraySize != 1)                          throw new InvalidOperationException("Invalid Width/Height/Depth/ArraySize for Image 3D");                        // Check that miplevels are fine                      description.MipLevels = Texture.CalculateMipLevels(description.Width' description.Height' description.Depth' description.MipLevels);                      break;              }
Missing Default,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,New,The following switch statement is missing a default case: switch (description.Dimension)                  {                      case TextureDimension.Texture1D:                          return RenderTarget1D.New(graphicsDevice' description);                      case TextureDimension.Texture2D:                          return RenderTarget2D.New(graphicsDevice' description);                      case TextureDimension.Texture3D:                          return RenderTarget3D.New(graphicsDevice' description);                      case TextureDimension.TextureCube:                          return RenderTargetCube.New(graphicsDevice' description);                  }
Missing Default,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,New,The following switch statement is missing a default case: switch (description.Dimension)                  {                      case TextureDimension.Texture1D:                          return Texture1D.New(graphicsDevice' description);                      case TextureDimension.Texture2D:                          return Texture2D.New(graphicsDevice' description);                      case TextureDimension.Texture3D:                          return Texture3D.New(graphicsDevice' description);                      case TextureDimension.TextureCube:                          return TextureCube.New(graphicsDevice' description);                  }
Missing Default,SharpDX.Toolkit.Graphics,Texture,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs,Load,The following switch statement is missing a default case: switch (image.Description.Dimension)                  {                      case TextureDimension.Texture1D:                          return Texture1D.New(device' image' flags' usage);                      case TextureDimension.Texture2D:                          return Texture2D.New(device' image' flags' usage);                      case TextureDimension.Texture3D:                          return Texture3D.New(device' image' flags' usage);                      case TextureDimension.TextureCube:                          return TextureCube.New(device' image' flags' usage);                  }
Missing Default,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,ToWIC,The following switch statement is missing a default case: switch (format)              {                  case SharpDX.DXGI.Format.R8G8B8A8_UNorm_SRgb:                      guid = SharpDX.WIC.PixelFormat.Format32bppRGBA;                      return true;                    case SharpDX.DXGI.Format.D32_Float:                      guid = SharpDX.WIC.PixelFormat.Format32bppGrayFloat;                      return true;                    case SharpDX.DXGI.Format.D16_UNorm:                      guid = SharpDX.WIC.PixelFormat.Format16bppGray;                      return true;                    case SharpDX.DXGI.Format.B8G8R8A8_UNorm_SRgb:                      guid = SharpDX.WIC.PixelFormat.Format32bppBGRA;                      return true;                    case SharpDX.DXGI.Format.B8G8R8X8_UNorm_SRgb:                      guid = SharpDX.WIC.PixelFormat.Format32bppBGR;                      return true;              }
Missing Default,SharpDX.Toolkit.Graphics,WICHelper,C:\repos\helix-toolkit_helix-toolkit\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\WICHelper.cs,DetermineFormat,The following switch statement is missing a default case: switch (format)              {                  case DXGI.Format.B8G8R8A8_UNorm: // BGRA                  case DXGI.Format.B8G8R8X8_UNorm: // BGRX                      if ((flags & WICFlags.ForceRgb) != 0)                      {                          format = DXGI.Format.R8G8B8A8_UNorm;                          pixelFormatOut = WIC.PixelFormat.Format32bppRGBA;                      }                      break;                    case DXGI.Format.R10G10B10_Xr_Bias_A2_UNorm:                      if ((flags & WICFlags.NoX2Bias) != 0)                      {                          format = DXGI.Format.R10G10B10A2_UNorm;                          pixelFormatOut = WIC.PixelFormat.Format32bppRGBA1010102;                      }                      break;                    case DXGI.Format.B5G5R5A1_UNorm:                  case DXGI.Format.B5G6R5_UNorm:                      if ((flags & WICFlags.No16Bpp) != 0)                      {                          format = DXGI.Format.R8G8B8A8_UNorm;                          pixelFormatOut = WIC.PixelFormat.Format32bppRGBA;                      }                      break;                    case DXGI.Format.R1_UNorm:                      if ((flags & WICFlags.FlagsAllowMono) == 0)                      {                          // By default we want to promote a black & white to greyscale since R1 is not a generally supported D3D format                          format = DXGI.Format.R8_UNorm;                          pixelFormatOut = WIC.PixelFormat.Format8bppGray;                      }                      break;              }
